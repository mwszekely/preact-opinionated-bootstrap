(function () {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

      return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
      var t = {};

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }

      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    }
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }

      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator(thisArg, body) {
      var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) {
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];

            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;

              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };

              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;

              case 7:
                op = _.ops.pop();

                _.trys.pop();

                continue;

              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }

                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }

                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }

                if (t && _.label < t[2]) {
                  _.label = t[2];

                  _.ops.push(op);

                  break;
                }

                if (t[2]) _.ops.pop();

                _.trys.pop();

                continue;
            }

            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    }

    var n,
        l$1,
        u$1,
        t$1,
        o$1,
        r$1,
        f$1,
        e$1 = {},
        c$1 = [],
        s$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function a$1(n, l) {
      for (var u in l) {
        n[u] = l[u];
      }

      return n;
    }

    function h$1(n) {
      var l = n.parentNode;
      l && l.removeChild(n);
    }

    function v$1(l, u, i) {
      var t,
          o,
          r,
          f = {};

      for (r in u) {
        "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
      }

      if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) {
        void 0 === f[r] && (f[r] = l.defaultProps[r]);
      }
      return y$1(l, f, t, o, null);
    }

    function y$1(n, i, t, o, r) {
      var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u$1 : r
      };
      return null != l$1.vnode && l$1.vnode(f), f;
    }

    function d$1(n) {
      return n.children;
    }

    function _$1(n, l) {
      this.props = n, this.context = l;
    }

    function k$1(n, l) {
      if (null == l) return n.__ ? k$1(n.__, n.__.__k.indexOf(n) + 1) : null;

      for (var u; l < n.__k.length; l++) {
        if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
      }

      return "function" == typeof n.type ? k$1(n) : null;
    }

    function b$1(n) {
      var l, u;

      if (null != (n = n.__) && null != n.__c) {
        for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {
          if (null != (u = n.__k[l]) && null != u.__e) {
            n.__e = n.__c.base = u.__e;
            break;
          }
        }

        return b$1(n);
      }
    }

    function m$1(n) {
      (!n.__d && (n.__d = !0) && t$1.push(n) && !g$2.__r++ || r$1 !== l$1.debounceRendering) && ((r$1 = l$1.debounceRendering) || o$1)(g$2);
    }

    function g$2() {
      for (var n; g$2.__r = t$1.length;) {
        n = t$1.sort(function (n, l) {
          return n.__v.__b - l.__v.__b;
        }), t$1 = [], n.some(function (n) {
          var l, u, i, t, o, r;
          n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = a$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? k$1(t) : o, t.__h), z(u, t), t.__e != o && b$1(t)));
        });
      }
    }

    function w$2(n, l, u, i, t, o, r, f, s, a) {
      var h,
          v,
          p,
          _,
          b,
          m,
          g,
          w = i && i.__k || c$1,
          A = w.length;

      for (u.__k = [], h = 0; h < l.length; h++) {
        if (null != (_ = u.__k[h] = null == (_ = l[h]) || "boolean" == typeof _ ? null : "string" == typeof _ || "number" == typeof _ || "bigint" == typeof _ ? y$1(null, _, null, null, _) : Array.isArray(_) ? y$1(d$1, {
          children: _
        }, null, null, null) : _.__b > 0 ? y$1(_.type, _.props, _.key, null, _.__v) : _)) {
          if (_.__ = u, _.__b = u.__b + 1, null === (p = w[h]) || p && _.key == p.key && _.type === p.type) w[h] = void 0;else for (v = 0; v < A; v++) {
            if ((p = w[v]) && _.key == p.key && _.type === p.type) {
              w[v] = void 0;
              break;
            }

            p = null;
          }
          j$2(n, _, p = p || e$1, t, o, r, f, s, a), b = _.__e, (v = _.ref) && p.ref != v && (g || (g = []), p.ref && g.push(p.ref, null, _), g.push(v, _.__c || b, _)), null != b ? (null == m && (m = b), "function" == typeof _.type && null != _.__k && _.__k === p.__k ? _.__d = s = x$2(_, s, n) : s = P$1(n, _, p, w, b, s), a || "option" !== u.type ? "function" == typeof u.type && (u.__d = s) : n.value = "") : s && p.__e == s && s.parentNode != n && (s = k$1(p));
        }
      }

      for (u.__e = m, h = A; h--;) {
        null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = k$1(i, h + 1)), N(w[h], w[h]));
      }

      if (g) for (h = 0; h < g.length; h++) {
        M$1(g[h], g[++h], g[++h]);
      }
    }

    function x$2(n, l, u) {
      var i, t;

      for (i = 0; i < n.__k.length; i++) {
        (t = n.__k[i]) && (t.__ = n, l = "function" == typeof t.type ? x$2(t, l, u) : P$1(u, t, t, n.__k, t.__e, l));
      }

      return l;
    }

    function A$2(n, l) {
      return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
        A$2(n, l);
      }) : l.push(n)), l;
    }

    function P$1(n, l, u, i, t, o) {
      var r, f, e;
      if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
        for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) {
          if (f == t) break n;
        }

        n.insertBefore(t, o), r = o;
      }
      return void 0 !== r ? r : t.nextSibling;
    }

    function C$1(n, l, u, i, t) {
      var o;

      for (o in u) {
        "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);
      }

      for (o in l) {
        t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
      }
    }

    function $$1(n, l, u) {
      "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || s$1.test(l) ? u : u + "px";
    }

    function H$1(n, l, u, i, t) {
      var o;

      n: if ("style" === l) {
        if ("string" == typeof u) n.style.cssText = u;else {
          if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) {
            u && l in u || $$1(n.style, l, "");
          }
          if (u) for (l in u) {
            i && u[l] === i[l] || $$1(n.style, l, u[l]);
          }
        }
      } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$1 : I$1, o) : n.removeEventListener(l, o ? T$1 : I$1, o);else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
          n[l] = null == u ? "" : u;
          break n;
        } catch (n) {}
        "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
      }
    }

    function I$1(n) {
      this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
    }

    function T$1(n) {
      this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
    }

    function j$2(n, u, i, t, o, r, f, e, c) {
      var s,
          h,
          v,
          y,
          p,
          k,
          b,
          m,
          g,
          x,
          A,
          P = u.type;
      if (void 0 !== u.constructor) return null;
      null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (s = l$1.__b) && s(u);

      try {
        n: if ("function" == typeof P) {
          if (m = u.props, g = (s = P.contextType) && t[s.__c], x = s ? g ? g.props.value : s.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in P && P.prototype.render ? u.__c = h = new P(m, x) : (u.__c = h = new _$1(m, x), h.constructor = P, h.render = O$1), g && g.sub(h), h.props = m, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != P.getDerivedStateFromProps && (h.__s == h.state && (h.__s = a$1({}, h.__s)), a$1(h.__s, P.getDerivedStateFromProps(m, h.__s))), y = h.props, p = h.state, v) null == P.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
            if (null == P.getDerivedStateFromProps && m !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(m, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(m, h.__s, x) || u.__v === i.__v) {
              h.props = m, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
                n && (n.__ = u);
              }), h.__h.length && f.push(h);
              break n;
            }

            null != h.componentWillUpdate && h.componentWillUpdate(m, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
              h.componentDidUpdate(y, p, k);
            });
          }
          h.context = x, h.props = m, h.state = h.__s, (s = l$1.__r) && s(u), h.__d = !1, h.__v = u, h.__P = n, s = h.render(h.props, h.state, h.context), h.state = h.__s, null != h.getChildContext && (t = a$1(a$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, p)), A = null != s && s.type === d$1 && null == s.key ? s.props.children : s, w$2(n, Array.isArray(A) ? A : [A], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);

        (s = l$1.diffed) && s(u);
      } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
      }
    }

    function z(n, u) {
      l$1.__c && l$1.__c(u, n), n.some(function (u) {
        try {
          n = u.__h, u.__h = [], n.some(function (n) {
            n.call(u);
          });
        } catch (n) {
          l$1.__e(n, u.__v);
        }
      });
    }

    function L$1(l, u, i, t, o, r, f, c) {
      var s,
          a,
          v,
          y = i.props,
          p = u.props,
          d = u.type,
          _ = 0;
      if ("svg" === d && (o = !0), null != r) for (; _ < r.length; _++) {
        if ((s = r[_]) && (s === l || (d ? s.localName == d : 3 == s.nodeType))) {
          l = s, r[_] = null;
          break;
        }
      }

      if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
      }

      if (null === d) y === p || c && l.data === p || (l.data = p);else {
        if (r = r && n.call(l.childNodes), a = (y = i.props || e$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
          if (null != r) for (y = {}, _ = 0; _ < l.attributes.length; _++) {
            y[l.attributes[_].name] = l.attributes[_].value;
          }
          (v || a) && (v && (a && v.__html == a.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }

        if (C$1(l, p, y, o, c), v) u.__k = [];else if (_ = u.props.children, w$2(l, Array.isArray(_) ? _ : [_], u, i, t, o && "foreignObject" !== d, r, f, r ? r[0] : i.__k && k$1(i, 0), c), null != r) for (_ = r.length; _--;) {
          null != r[_] && h$1(r[_]);
        }
        c || ("value" in p && void 0 !== (_ = p.value) && (_ !== l.value || "progress" === d && !_) && H$1(l, "value", _, y.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && H$1(l, "checked", _, y.checked, !1));
      }
      return l;
    }

    function M$1(n, u, i) {
      try {
        "function" == typeof n ? n(u) : n.current = u;
      } catch (n) {
        l$1.__e(n, i);
      }
    }

    function N(n, u, i) {
      var t, o;

      if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$1(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
          t.componentWillUnmount();
        } catch (n) {
          l$1.__e(n, u);
        }
        t.base = t.__P = null;
      }

      if (t = n.__k) for (o = 0; o < t.length; o++) {
        t[o] && N(t[o], u, "function" != typeof n.type);
      }
      i || null == n.__e || h$1(n.__e), n.__e = n.__d = void 0;
    }

    function O$1(n, l, u) {
      return this.constructor(n, u);
    }

    function S$1(u, i, t) {
      var o, r, f;
      l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, f = [], j$2(i, u = (!o && t || i).__k = v$1(d$1, null, [u]), r || e$1, e$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, f, !o && t ? t : r ? r.__e : i.firstChild, o), z(f, u);
    }

    function B(l, u, i) {
      var t,
          o,
          r,
          f = a$1({}, l.props);

      for (r in u) {
        "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
      }

      return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), y$1(l.type, f, t || l.key, o || l.ref, null);
    }

    function D$1(n, l) {
      var u = {
        __c: l = "__cC" + f$1++,
        __: n,
        Consumer: function (n, l) {
          return n.children(l);
        },
        Provider: function (n) {
          var u, i;
          return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
            return i;
          }, this.shouldComponentUpdate = function (n) {
            this.props.value !== n.value && u.some(m$1);
          }, this.sub = function (n) {
            u.push(n);
            var l = n.componentWillUnmount;

            n.componentWillUnmount = function () {
              u.splice(u.indexOf(n), 1), l && l.call(n);
            };
          }), n.children;
        }
      };
      return u.Provider.__ = u.Consumer.contextType = u;
    }

    n = c$1.slice, l$1 = {
      __e: function (n, l) {
        for (var u, i, t; l = l.__;) {
          if ((u = l.__c) && !u.__) try {
            if ((i = u.constructor) && null != i.getDerivedStateFromError && (u.setState(i.getDerivedStateFromError(n)), t = u.__d), null != u.componentDidCatch && (u.componentDidCatch(n), t = u.__d), t) return u.__E = u;
          } catch (l) {
            n = l;
          }
        }

        throw n;
      }
    }, u$1 = 0, _$1.prototype.setState = function (n, l) {
      var u;
      u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a$1({}, this.state), "function" == typeof n && (n = n(a$1({}, u), this.props)), n && a$1(u, n), null != n && this.__v && (l && this.__h.push(l), m$1(this));
    }, _$1.prototype.forceUpdate = function (n) {
      this.__v && (this.__e = !0, n && this.__h.push(n), m$1(this));
    }, _$1.prototype.render = d$1, t$1 = [], o$1 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g$2.__r = 0, f$1 = 0;

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);

        if (enumerableOnly) {
          symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }

        keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }

      return target;
    }

    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }

      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }

    function _asyncToGenerator(fn) {
      return function () {
        var self = this,
            args = arguments;
        return new Promise(function (resolve, reject) {
          var gen = fn.apply(self, args);

          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }

          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }

          _next(undefined);
        });
      };
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};

      var target = _objectWithoutPropertiesLoose(source, excluded);

      var key, i;

      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }

      return target;
    }

    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];

      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }

      return (hint === "string" ? String : Number)(input);
    }

    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");

      return typeof key === "symbol" ? key : String(key);
    }

    var t,
        u,
        r,
        o = 0,
        i = [],
        c = l$1.__b,
        f = l$1.__r,
        e = l$1.diffed,
        a = l$1.__c,
        v = l$1.unmount;

    function m(t, r) {
      l$1.__h && l$1.__h(u, t, o || r), o = 0;
      var i = u.__H || (u.__H = {
        __: [],
        __h: []
      });
      return t >= i.__.length && i.__.push({}), i.__[t];
    }

    function l(n) {
      return o = 1, p(w$1, n);
    }

    function p(n, r, o) {
      var i = m(t++, 2);
      return i.t = n, i.__c || (i.__ = [o ? o(r) : w$1(void 0, r), function (n) {
        var t = i.t(i.__[0], n);
        i.__[0] !== t && (i.__ = [t, i.__[1]], i.__c.setState({}));
      }], i.__c = u), i.__;
    }

    function y(r, o) {
      var i = m(t++, 3);
      !l$1.__s && k(i.__H, o) && (i.__ = r, i.__H = o, u.__H.__h.push(i));
    }

    function h(r, o) {
      var i = m(t++, 4);
      !l$1.__s && k(i.__H, o) && (i.__ = r, i.__H = o, u.__h.push(i));
    }

    function s(n) {
      return o = 5, d(function () {
        return {
          current: n
        };
      }, []);
    }

    function _(n, t, u) {
      o = 6, h(function () {
        "function" == typeof n ? n(t()) : n && (n.current = t());
      }, null == u ? u : u.concat(n));
    }

    function d(n, u) {
      var r = m(t++, 7);
      return k(r.__H, u) && (r.__ = n(), r.__H = u, r.__h = n), r.__;
    }

    function A$1(n, t) {
      return o = 8, d(function () {
        return n;
      }, t);
    }

    function F(n) {
      var r = u.context[n.__c],
          o = m(t++, 9);
      return o.c = n, r ? (null == o.__ && (o.__ = !0, r.sub(u)), r.props.value) : n.__;
    }

    function x$1() {
      i.forEach(function (t) {
        if (t.__P) try {
          t.__H.__h.forEach(g$1), t.__H.__h.forEach(j$1), t.__H.__h = [];
        } catch (u) {
          t.__H.__h = [], l$1.__e(u, t.__v);
        }
      }), i = [];
    }

    l$1.__b = function (n) {
      u = null, c && c(n);
    }, l$1.__r = function (n) {
      f && f(n), t = 0;
      var r = (u = n.__c).__H;
      r && (r.__h.forEach(g$1), r.__h.forEach(j$1), r.__h = []);
    }, l$1.diffed = function (t) {
      e && e(t);
      var o = t.__c;
      o && o.__H && o.__H.__h.length && (1 !== i.push(o) && r === l$1.requestAnimationFrame || ((r = l$1.requestAnimationFrame) || function (n) {
        var t,
            u = function () {
          clearTimeout(r), b && cancelAnimationFrame(t), setTimeout(n);
        },
            r = setTimeout(u, 100);

        b && (t = requestAnimationFrame(u));
      })(x$1)), u = void 0;
    }, l$1.__c = function (t, u) {
      u.some(function (t) {
        try {
          t.__h.forEach(g$1), t.__h = t.__h.filter(function (n) {
            return !n.__ || j$1(n);
          });
        } catch (r) {
          u.some(function (n) {
            n.__h && (n.__h = []);
          }), u = [], l$1.__e(r, t.__v);
        }
      }), a && a(t, u);
    }, l$1.unmount = function (t) {
      v && v(t);
      var u = t.__c;
      if (u && u.__H) try {
        u.__H.__.forEach(g$1);
      } catch (t) {
        l$1.__e(t, u.__v);
      }
    };
    var b = "function" == typeof requestAnimationFrame;

    function g$1(n) {
      var t = u;
      "function" == typeof n.__c && n.__c(), u = t;
    }

    function j$1(n) {
      var t = u;
      n.__c = n.__(), u = t;
    }

    function k(n, t) {
      return !n || n.length !== t.length || t.some(function (t, u) {
        return t !== n[u];
      });
    }

    function w$1(n, t) {
      return "function" == typeof t ? t(n) : t;
    }

    function useMergedChildren(lhsProps, rhsProps) {
      var lhs = lhsProps === null || lhsProps === void 0 ? void 0 : lhsProps.children;
      var rhs = rhsProps === null || rhsProps === void 0 ? void 0 : rhsProps.children;

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        var ret = v$1(d$1, {}, lhs, rhs);
        return ret;
      }
    }

    function toVal(mix) {
      var k,
          y,
          str = '';

      if (typeof mix === 'string' || typeof mix === 'number') {
        str += mix;
      } else if (typeof mix === 'object') {
        if (Array.isArray(mix)) {
          for (k = 0; k < mix.length; k++) {
            if (mix[k]) {
              if (y = toVal(mix[k])) {
                str && (str += ' ');
                str += y;
              }
            }
          }
        } else {
          for (k in mix) {
            if (mix[k]) {
              str && (str += ' ');
              str += k;
            }
          }
        }
      }

      return str;
    }

    function clsx () {
      var i = 0,
          tmp,
          x,
          str = '';

      while (i < arguments.length) {
        if (tmp = arguments[i++]) {
          if (x = toVal(tmp)) {
            str && (str += ' ');
            str += x;
          }
        }
      }

      return str;
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */

    function useMergedClasses(lhs, rhs) {
      // Note: For the sake of forward compatibility, this function is labelled as
      // a hook, but as it uses no other hooks it technically isn't one.
      return mergeClasses(lhs, rhs);
    }

    function mergeClasses(lhs, rhs) {
      var lhsClass = lhs === null || lhs === void 0 ? void 0 : lhs.class;
      var lhsClassName = lhs === null || lhs === void 0 ? void 0 : lhs.className;
      var rhsClass = rhs === null || rhs === void 0 ? void 0 : rhs.class;
      var rhsClassName = rhs === null || rhs === void 0 ? void 0 : rhs.className;

      if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
        var lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
        var rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
        var allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
        return Array.from(allClasses).join(" ");
      } else {
        return undefined;
      }
    }

    function processRef(instance, ref) {
      if (typeof ref === "function") {
        ref(instance);
      } else if (ref != null) {
        ref.current = instance;
      }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */


    function useMergedRefs() {
      return function (lhsProps, rhsProps) {
        var lhs = lhsProps === null || lhsProps === void 0 ? void 0 : lhsProps.ref;
        var rhs = rhsProps === null || rhsProps === void 0 ? void 0 : rhsProps.ref;

        if (lhs == null && rhs == null) {
          return undefined;
        } else if (lhs == null) {
          return rhs;
        } else if (rhs == null) {
          return lhs;
        } else {
          var ret = A$1(current => {
            processRef(current, lhs);
            processRef(current, rhs);
          }, [lhs, rhs]);
          return ret;
        }
      };
    }
    /*
    function typetest<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const ref: RefObject<HTMLInputElement> = useRef<HTMLInputElement>(null);

        function acceptsRef(ref: Ref<any>) { }
        function acceptsOptionalRef(ref: Ref<any> | undefined) { }

        const c = [
            useMergedRefs<HTMLInputElement>()(undefined, undefined),
            useMergedRefs<HTMLInputElement>()({}, undefined),
            useMergedRefs<HTMLInputElement>()(props, undefined),
            useMergedRefs<HTMLInputElement>()(undefined, props),
            useMergedRefs<HTMLInputElement>()(props, props),
            useMergedRefs<HTMLInputElement>()({ ref }, props),
            useMergedRefs<HTMLInputElement>()({ ref }, { ref: undefined }),
            useMergedRefs<HTMLInputElement>()({ ref: undefined }, { ref }),
            useMergedRefs<HTMLInputElement>()({ ref }, { ref }),
        ] as const;

        /// @ts-expect-error
        acceptsRef(c[0]);
        /// @ts-expect-error
        acceptsRef(c[1]);

        acceptsOptionalRef(c[2]);
        acceptsOptionalRef(c[3]);
        acceptsOptionalRef(c[4]);

        /// @ts-expect-error TODO
        acceptsRef(c[5]);
        acceptsRef(c[6]);
        acceptsRef(c[7]);
        acceptsRef(c[8]);
    }
    */

    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */
    function useMergedStyles(lhs, rhs) {
      var _lhs$style, _rhs$style2;

      // Easy case, when there are no styles to merge return nothing.
      if (!(lhs !== null && lhs !== void 0 && lhs.style) && !(rhs !== null && rhs !== void 0 && rhs.style)) return undefined;

      if (typeof lhs != typeof rhs) {
        // Easy cases, when one is null and the other isn't.
        if (lhs !== null && lhs !== void 0 && lhs.style && !(rhs !== null && rhs !== void 0 && rhs.style)) return lhs.style;
        if (!(lhs !== null && lhs !== void 0 && lhs.style) && rhs !== null && rhs !== void 0 && rhs.style) return rhs.style; // They're both non-null but different types.
        // Convert the string type to an object bag type and run it again.

        if (lhs !== null && lhs !== void 0 && lhs.style && rhs !== null && rhs !== void 0 && rhs.style) {
          if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") return useMergedStyles({
            style: Object.fromEntries(lhs === null || lhs === void 0 ? void 0 : lhs.style.split(";").map(statement => statement.split(":")))
          }, rhs);
          if (typeof (rhs === null || rhs === void 0 ? void 0 : rhs.style) == "string") return useMergedStyles(lhs === null || lhs === void 0 ? void 0 : lhs.style, {
            style: Object.fromEntries(lhs === null || lhs === void 0 ? void 0 : lhs.style.split(";").map(statement => statement.split(":")))
          });
        } // Logic???


        return undefined;
      } // They're both strings, just concatenate them.


      if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") {
        var _rhs$style;

        return "".concat(lhs.style, ";").concat((_rhs$style = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style !== void 0 ? _rhs$style : "");
      } // They're both objects, just merge them.


      return _objectSpread2(_objectSpread2({}, (_lhs$style = lhs === null || lhs === void 0 ? void 0 : lhs.style) !== null && _lhs$style !== void 0 ? _lhs$style : {}), (_rhs$style2 = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style2 !== void 0 ? _rhs$style2 : {});
    }

    var _excluded$J = ["children", "class", "className", "style", "ref"],
        _excluded2$g = ["children", "class", "className", "style", "ref"];

    var log = str => {
      debugger;
      /* Intentional */
    };
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */

    function useMergedProps() {
      return function (lhs2, rhs2) {
        // First, put in all the properties that are easy to reason about
        // and all lhs props. We're going to merge in rhs just after.
        var lhs = _objectWithoutProperties(lhs2, _excluded$J);

        var rhs = _objectWithoutProperties(rhs2, _excluded2$g);

        var ret = _objectSpread2(_objectSpread2({}, lhs), {}, {
          ref: useMergedRefs()(lhs2, rhs2),
          style: useMergedStyles(lhs2, rhs2),
          className: useMergedClasses(lhs2, rhs2),
          children: useMergedChildren(lhs2, rhs2)
        });

        if (ret.ref === undefined) delete ret.ref;
        if (ret.style === undefined) delete ret.style;
        if (ret.className === undefined) delete ret.className;
        if (ret.children === undefined) delete ret.children; // Now, do *everything* else
        // Merge every remaining existing entry in lhs with what we've already put in ret.
        //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];

        var rhsEntries = Object.entries(rhs);

        for (var [rhsKey, rhsValue] of rhsEntries) {
          var lhsValue = lhs[rhsKey];

          if (typeof lhsValue === "function" || typeof rhsValue === "function") {
            // They're both functions that can be merged (or one's a function and the other's null).
            // Not an *easy* case, but a well-defined one.
            var merged = mergeFunctions(lhsValue, rhsValue);
            ret[rhsKey] = merged;
          } else {
            // Uh...we're here because one of them's null, right?
            if (lhsValue == null && rhsValue == null) {
              if (rhsValue === null && lhsValue === undefined) ret[rhsKey] = rhsValue;else ret[rhsKey] = lhsValue;
            }

            if (lhsValue == null) ret[rhsKey] = rhsValue;else if (rhsValue == null) ret[rhsKey] = lhsValue;else if (rhsValue == lhsValue) ; else {
              var _log;

              // Ugh.
              // No good strategies here, just log it if requested
              (_log = log) === null || _log === void 0 ? void 0 : _log("Could not merge incompatible prop \"".concat(rhsKey, "\" (type: ").concat(typeof rhsValue, ", values: [").concat(lhsValue, ", ").concat(rhsValue, "])"));
              ret[rhsKey] = rhsValue;
            }
          }
        }

        return ret;
      };
    }

    function mergeFunctions(lhs, rhs) {
      if (!lhs) return rhs;
      if (!rhs) return lhs;
      return (...args) => {
        var lv = lhs === null || lhs === void 0 ? void 0 : lhs(...args);
        var rv = rhs === null || rhs === void 0 ? void 0 : rhs(...args);
        if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
      };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */

    function useState(initialState) {
      // We keep both
      var [state, setState] = l(initialState);
      var ref = s(state); // Hijack the normal setter function 
      // to also set our ref to the new value

      var set = A$1(value => {
        if (typeof value === "function") {
          var callback = value;
          setState(prevValue => {
            var nextValue = callback(prevValue);
            ref.current = nextValue;
            return nextValue;
          });
        } else {
          ref.current = value;
          setState(value);
        }
      }, []);

      var get = () => {
        return ref.current;
      };

      console.assert(ref.current === state);
      return [state, set, get];
    }

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */

    function useRefElement() {
      // Let us store the actual (reference to) the element we capture
      var [element, setElement, getElement] = useState(null); // Create a RefCallback that's fired when mounted 
      // and that notifies us of our element when we have it

      var myRef = A$1(e => {
        if (e) setElement(() => e);
      }, []);
      var useRefElementProps = A$1(props => useMergedProps()({
        ref: myRef
      }, props), []); // Return both the element and the hook that modifies 
      // the props and allows us to actually find the element

      return {
        useRefElementProps,
        element,
        getElement
      };
    }

    function useElementSize({
      observeBox
    } = {}) {
      var {
        element,
        useRefElementProps
      } = useRefElement();
      var [size, setSize, getSize] = useState(null);
      y(() => {
        if (element) {
          var handleUpdate = () => {
            var {
              clientWidth,
              scrollWidth,
              offsetWidth,
              clientHeight,
              scrollHeight,
              offsetHeight,
              clientLeft,
              scrollLeft,
              offsetLeft,
              clientTop,
              scrollTop,
              offsetTop
            } = element;
            setSize({
              clientWidth,
              scrollWidth,
              offsetWidth,
              clientHeight,
              scrollHeight,
              offsetHeight,
              clientLeft,
              scrollLeft,
              offsetLeft,
              clientTop,
              scrollTop,
              offsetTop
            });
          };

          if (!("ResizeObserver" in window)) {
            document.addEventListener("resize", handleUpdate, {
              passive: true
            });
            return () => document.removeEventListener("resize", handleUpdate);
          } else {
            var observer = new ResizeObserver(entries => {
              handleUpdate();
            });
            observer.observe(element, {
              box: observeBox
            });
            return () => observer.disconnect();
          }
        }
      }, [element, observeBox]);
      return {
        element,
        elementSize: size,
        getElementSize: getSize,
        useElementSizeProps: useRefElementProps
      };
    }

    function capitalize(str) {
      return str[0].toUpperCase() + str.substr(1);
    }
    /**
     * Inspects the element's style and determines the logical direction that text flows.
     *
     * Certain CSS properties, like `block-size`, respect the current writing mode and text direction.
     * But `transform`, `clip`, etc. don't.
     *
     * This is provided so that CSS properties can consistently use those logical properties.
     *
     * See https://drafts.csswg.org/css-writing-modes/#logical-to-physical
     *
     * @returns An object containing the following functions:
     * * `getLogicalDirection`: retrieves a `LogicalDirectionInfo` representing the current state of the element. (Function is constant between renders)
     * * `convertElementSize`: When used in conjunction with `useElementSize`, allows you to retrieve the logical size of an element instead of the physical size.
     * * `convertToLogicalOrientation`: Based on the current direction, converts "horizontal" or "vertical" to "inline" or "block".
     * * `convertToPhysicalOrientation`:  Based on the current direction, converts "inline" or "block" to "horizontal" or "vertical".
     */


    function useLogicalDirection(element) {
      var [writingMode, setWritingMode] = l(null);
      var [direction, setDirection] = l(null);
      var [textOrientation, setTextOrientation] = l(null);
      var writingModeRef = s(writingMode);
      var directionRef = s(direction);
      var textOrientationRef = s(textOrientation);
      h(() => {
        writingModeRef.current = writingMode;
      }, [writingMode]);
      h(() => {
        directionRef.current = direction;
      }, [direction]);
      h(() => {
        textOrientationRef.current = textOrientation;
      }, [textOrientation]);
      h(() => {
        if (element) {
          var computedStyles = window.getComputedStyle(element);
          var w = computedStyles.writingMode;
          var t = computedStyles.textOrientation;
          var d = computedStyles.direction;
          setWritingMode(w || "horizontal-tb");
          setDirection(d || "rtl");
          setTextOrientation(t || "mixed");
        }
      });
      var getLogicalDirection = A$1(() => {
        var _direction;

        var writingMode = writingModeRef.current;
        var direction = directionRef.current;
        var textOrientation = textOrientationRef.current;
        if (!writingMode || !direction || !textOrientation) return null;
        if (textOrientation == "upright") direction = "ltr";
        return _objectSpread2({}, WritingModes[writingMode !== null && writingMode !== void 0 ? writingMode : "horizontal-tb"][(_direction = direction) !== null && _direction !== void 0 ? _direction : "ltr"]);
      }, [writingModeRef, directionRef, textOrientationRef]);
      var convertToLogicalOrientation = A$1((elementOrientation, direction) => {
        var _direction2, _direction3;

        (_direction2 = direction) !== null && _direction2 !== void 0 ? _direction2 : direction = getLogicalDirection();
        if (((_direction3 = direction) === null || _direction3 === void 0 ? void 0 : _direction3.inlineOrientation) === elementOrientation) return "inline";
        return "block";
      }, [getLogicalDirection]);
      var convertToPhysicalOrientation = A$1((elementOrientation, direction) => {
        var _direction4;

        (_direction4 = direction) !== null && _direction4 !== void 0 ? _direction4 : direction = getLogicalDirection();

        if (elementOrientation == "inline") {
          var _direction5;

          if (((_direction5 = direction) === null || _direction5 === void 0 ? void 0 : _direction5.inlineOrientation) == "horizontal") return "horizontal";
          return "vertical";
        } else {
          var _direction6;

          if (((_direction6 = direction) === null || _direction6 === void 0 ? void 0 : _direction6.blockOrientation) == "vertical") return "vertical";
          return "horizontal";
        }
      }, [getLogicalDirection]);
      var convertElementSize = A$1((elementSize, direction) => {
        var _direction7;

        (_direction7 = direction) !== null && _direction7 !== void 0 ? _direction7 : direction = getLogicalDirection();

        if (direction) {
          var {
            inlineSize,
            blockSize,
            inlineDirection,
            blockDirection
          } = direction; // Size is relatively simple

          var clientInlineSize = elementSize["client".concat(capitalize(inlineSize))];
          var clientBlockSize = elementSize["client".concat(capitalize(blockSize))];
          var offsetInlineSize = elementSize["offset".concat(capitalize(inlineSize))];
          var offsetBlockSize = elementSize["offset".concat(capitalize(blockSize))];
          var scrollInlineSize = elementSize["scroll".concat(capitalize(inlineSize))];
          var scrollBlockSize = elementSize["scroll".concat(capitalize(blockSize))]; // Position requires us to sometimes use one property (like `left`)
          // or sometimes two (like `left` + `width`)

          function getPhysicalLeftTop(dir) {
            if (dir === "ltr" || dir == "rtl") return "left";
            return "top";
          }

          function getPhysicalRightBottom(dir) {
            if (dir === "rtl") return "width";
            if (dir === "btt") return "height";
            return null;
          }

          var f1 = getPhysicalLeftTop(inlineDirection);
          var f2 = getPhysicalRightBottom(inlineDirection);
          var f3 = getPhysicalLeftTop(blockDirection);
          var f4 = getPhysicalRightBottom(blockDirection);
          var clientInlineInset = elementSize["client".concat(capitalize(f1))] + (!f2 ? 0 : elementSize["client".concat(capitalize(f2))]);
          var scrollInlineInset = elementSize["scroll".concat(capitalize(f1))] + (!f2 ? 0 : elementSize["scroll".concat(capitalize(f2))]);
          var offsetInlineInset = elementSize["offset".concat(capitalize(f1))] + (!f2 ? 0 : elementSize["offset".concat(capitalize(f2))]);
          var clientBlockInset = elementSize["client".concat(capitalize(f3))] + (!f4 ? 0 : elementSize["client".concat(capitalize(f4))]);
          var scrollBlockInset = elementSize["scroll".concat(capitalize(f3))] + (!f4 ? 0 : elementSize["scroll".concat(capitalize(f4))]);
          var offsetBlockInset = elementSize["offset".concat(capitalize(f3))] + (!f4 ? 0 : elementSize["offset".concat(capitalize(f4))]);
          return {
            clientInlineSize,
            scrollInlineSize,
            offsetInlineSize,
            clientBlockSize,
            scrollBlockSize,
            offsetBlockSize,
            clientInlineInset,
            scrollInlineInset,
            offsetInlineInset,
            clientBlockInset,
            scrollBlockInset,
            offsetBlockInset
          };
        }

        return null;
      }, [getLogicalDirection]);
      return {
        getLogicalDirection,
        convertElementSize,
        convertToLogicalOrientation,
        convertToPhysicalOrientation
      };
    }
    var HorizontalTbLtr = {
      inlineDirection: "ltr",
      blockDirection: "ttb",
      inlineOrientation: "horizontal",
      blockOrientation: "vertical",
      inlineSize: "width",
      blockSize: "height",
      leftRightDirection: "ltr",
      overUnderDirection: "ttb"
    };

    var HorizontalTbRtl = _objectSpread2(_objectSpread2({}, HorizontalTbLtr), {}, {
      inlineDirection: "rtl"
    });

    var VerticalRlLtr = {
      inlineDirection: "ttb",
      blockDirection: "rtl",
      inlineOrientation: "vertical",
      blockOrientation: "horizontal",
      inlineSize: "height",
      blockSize: "width",
      leftRightDirection: "ttb",
      overUnderDirection: "rtl"
    };

    var VerticalRlRtl = _objectSpread2(_objectSpread2({}, VerticalRlLtr), {}, {
      inlineDirection: "btt"
    });

    var SidewaysRlLtr = _objectSpread2({}, VerticalRlLtr);

    var SidewaysRlRtl = _objectSpread2({}, VerticalRlRtl);

    var VerticalLrLtr = _objectSpread2(_objectSpread2({}, VerticalRlLtr), {}, {
      blockDirection: "ltr"
    });

    var VerticalLrRtl = _objectSpread2(_objectSpread2({}, VerticalRlRtl), {}, {
      blockDirection: "ltr"
    });

    var SidewaysLtLtr = _objectSpread2(_objectSpread2({}, VerticalLrLtr), {}, {
      inlineDirection: "btt",
      leftRightDirection: "btt",
      overUnderDirection: "ltr"
    });

    var SidewaysLtRtl = _objectSpread2(_objectSpread2({}, SidewaysLtLtr), {}, {
      inlineDirection: "ttb"
    });

    var HorizontalTb = {
      ltr: HorizontalTbLtr,
      rtl: HorizontalTbRtl
    };
    var VerticalRl = {
      ltr: VerticalRlLtr,
      rtl: VerticalRlRtl
    };
    var VerticalLr = {
      ltr: VerticalLrLtr,
      rtl: VerticalLrRtl
    };
    var SidewaysRl = {
      ltr: SidewaysRlLtr,
      rtl: SidewaysRlRtl
    };
    var SidewaysLr = {
      ltr: SidewaysLtLtr,
      rtl: SidewaysLtRtl
    };
    var WritingModes = {
      "horizontal-tb": HorizontalTb,
      "vertical-lr": VerticalLr,
      "vertical-rl": VerticalRl,
      "sideways-lr": SidewaysLr,
      "sideways-rl": SidewaysRl
    };

    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * Use with caution, and **do not use the getter in useLayoutEffect!!**
     * `setState`'s getter does not have this problem, but then you're using your own state
     * instead of an existing value, which might not always be feasible.
     *
     * Weigh your options, and hopefully one of them gets the job done.
     *
     * @param value
     * @returns
     */

    function useStableGetter(value) {
      var ref = s(value);
      _(ref, () => value);
      return A$1(() => {
        return ref.current;
      }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * DO NOT USE THE RESULT IN useLayoutEffect!!
     *
     * TODO: Investigate options.diffed if the useLayoutEffect limitation becomes limitlessly limiting.
     *
     * Source: https://github.com/facebook/react/issues/14099#issuecomment-659298422
     */

    function useStableCallback(fn) {
      var currentCallbackGetter = useStableGetter(fn);
      return A$1((...args) => {
        var currentFunc = currentCallbackGetter();

        if (!currentFunc) {
          throw new Error('Callback retrieved from useStableCallback() cannot be called from useLayoutEffect().');
        }

        return currentFunc(...args);
      }, []);
    }

    /**
     * Wrap the native `useLayoutEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     */

    function useLayoutEffect(effect, inputs) {
      var prevInputs = s(inputs);

      var effect2 = () => {
        var changes = [];

        for (var i = 0; i < Math.max(prevInputs.current.length, inputs.length); ++i) {
          if (prevInputs.current[i] != inputs[i]) changes[i] = {
            from: prevInputs.current[i],
            to: inputs[i]
          };
        }

        var ret = effect(prevInputs.current, changes);
        prevInputs.current = inputs;
        return ret;
      };

      h(effect2, inputs);
    }

    function useTimeout({
      timeout,
      callback,
      triggerIndex
    }) {
      var stableCallback = useStableCallback(callback);
      var getTimeout = useStableGetter(timeout);
      var timeoutIsNull = timeout == null;
      y(() => {
        var timeout = getTimeout();
        console.assert(timeoutIsNull == (timeout == null));

        if (timeout) {
          var handle = setTimeout(stableCallback, timeout);
          return () => clearTimeout(handle);
        }
      }, [triggerIndex, timeoutIsNull]);
    }

    /**
     * Given an asyncronous event handler, returns a syncronous one that works on the DOM,
     * along with some other information related to the current state.
     * Does not modify any props.
     *
     * The handler is automatically throttled to only run one at a time.
     * If the handler is called, and then before it finishes, is called again,
     * it will be put on hold until the current one finishes, at which point
     * the second one will run.  If the handler is called a third time before
     * the first has finished, it will *replace* the second, so only the most
     * recently called iteration of the handler will run.
     *
     * You may optionally *also* specify a debounce parameter that waits until the
     * syncronous handler has not been called for the specified number of
     * milliseconds, at which point we *actually* run the asyncronous handler
     * according to the logic in the previous paragraph. This is in
     * *addition* to throttling the handler, and does not replace that behavior.
     *
     * Note that the parameters to the async handler are slightly different than
     * the sync handler &ndash; the first argument, as decided by you with the
     * `capture` parameter for this hook, is the "saved" information from the
     * event.  For example, the event's currentTarget's `value`, which may have
     * changed by the time the handler is *actually* called.  The second argument
     * is the original event, which might still have some useful fields on it
     * like `mouseX` or something, but is stale at least in regards to the
     * element it references.
     */

    function useAsyncHandler() {
      return function ({
        capture,
        debounce
      }) {
        // Always represents whatever promise is currently being waited on, or null if none.
        var [promise, setPromise, getPromise] = useState(null); // Keep track of how many times we've actually called the async handler

        var [runCount, setRunCount] = useState(0);
        var [resolveCount, setResolveCount] = useState(0);
        var [rejectCount, setRejectCount] = useState(0); // 

        var [currentType, setCurrentType] = useState(null); // If we're set to use a debounce, then when the timeout finishes,
        // the promise from this state object is transferred over to either 
        // the current promise or the pending promise.

        var [debouncedPromiseStarter, setDebouncedPromiseStarter, getDebouncedPromiseStarter] = useState(null); // When we want to start a new promise, we won't allow it to start if one is still running.
        // In that case, we store the promise (or rather, a way to start the promise) in state.

        var [pendingPromiseStarter, setPendingPromiseStarter, getPendingPromiseStarter] = useState(null); // We need to differentiate between `undefined` and "no error has been thrown".

        var [error, setError, getError] = useState(undefined);
        var [hasError, setHasError, getHasError] = useState(false); // Same thing, we need to differentiate between "nothing captured yet" and "`undefined` was captured"

        var [currentCapture, setCurrentCapture, getCurrentCapture] = useState(undefined);
        var [hasCapture, setHasCapture] = useState(false); // When the debounce timer is up (or we manually request the debounce to end)
        // run the normal "please consider running this promise" routine that we would
        // have just run immediately if we weren't debouncing our promises.

        var onDebounceTimeUp = A$1(() => {
          var debouncedPromiseStarter = getDebouncedPromiseStarter();
          if (debouncedPromiseStarter) wantToStartANewPromise(debouncedPromiseStarter);
          setDebouncedPromiseStarter(null);
        }, [wantToStartANewPromise, setDebouncedPromiseStarter]); // Handle the debounce. Logically this happens before the main step as a sort of step 0.
        // Resets the timeout any time the handler was requested to be called again
        // and when it finishes, actually call the handler (or set it as the pending promise)

        useTimeout({
          timeout: debounce !== null && debounce !== void 0 ? debounce : null,
          callback: onDebounceTimeUp,
          triggerIndex: debouncedPromiseStarter
        }); // See if we should set our current promise to be whatever the pending promise is
        // (usually because the current promise finished and became null).

        useLayoutEffect(() => {
          // Our current promise just finished and there's one waiting?
          if (promise == null && pendingPromiseStarter != null) {
            wantToStartANewPromise(pendingPromiseStarter);
            setPendingPromiseStarter(null);
          }
        }, [promise, pendingPromiseStarter]); // Called any time the async handler is about to be called for whatever reason,
        // except for debounce, which comes first, as a sort of "step 0".
        // Handles all the necessary boilerplate related to choosing whether to
        // run or set as pending, resetting state variables, etc.

        function wantToStartANewPromise(startPromise) {
          var alreadyRunningPromise = getPromise() != null; // Boilerplate wrapper around the given promise starter

          var startPromiseWithBoilerplate = () => {
            // When it starts, notify the caller
            setRunCount(r => ++r); // When it completes, notify the caller
            // When it fails, save the error and notify the caller
            // When it settles, reset our state so we can run a pending promise if it exists

            var onThen = () => {
              setResolveCount(c => ++c);
            };

            var onCatch = ex => {
              setError(ex);
              setHasError(true);
              setRejectCount(c => ++c);
            };

            var onFinally = () => {
              setPromise(null);
            }; // Handle the special case where the handler is synchronous


            var result;

            try {
              result = startPromise();

              if (result == undefined) {
                // It's synchronous and returned successfully.
                // Bail out early.
                onThen();
                onFinally();
                setCurrentType("sync");
                return;
              }

              console.assert("then" in result);
            } catch (ex) {
              // It's synchronous (or asynchronous but didn't await anything yet) and threw an error.
              // Bail out early.
              onCatch(ex);
              onFinally();
              setCurrentType("sync");
              return;
            } // The handler is asynchronous


            setCurrentType("async");
            return _asyncToGenerator(function* () {
              yield result;
            })().then(onThen).catch(onCatch).finally(onFinally);
          };

          if (!alreadyRunningPromise) {
            // Start the promise immediately, because there wasn't one running already.
            var nextPromise = startPromiseWithBoilerplate();

            if (nextPromise == undefined) ; else {
              setError(undefined);
              setHasError(false);
              setPromise(nextPromise);
            }
          } else {
            // Don't start the promise yet, 
            // and allow it to start in the future instead.
            setPendingPromiseStarter(_ => startPromiseWithBoilerplate);
          }
        }

        var ret = {
          getSyncHandler,
          getCurrentCapture,
          callCount: runCount,
          currentCapture,
          hasCapture,
          pending: promise != null,
          hasError,
          error,
          currentType,
          flushDebouncedPromise: onDebounceTimeUp,
          resolveCount,
          rejectCount,
          settleCount: rejectCount + resolveCount
        };
        return ret;

        function getSyncHandler(asyncHandler) {
          var syncHandler = useStableCallback(function syncHandler(event) {
            if (asyncHandler == null) return; // Get the most significant information from the event at this time,
            // which is necessary since the promise could actually be called much later
            // when the element's value (etc.) has changed.

            var captured = capture(event);
            setCurrentCapture(captured);
            setHasCapture(true);

            var startPromise = () => asyncHandler(captured, event);

            if (debounce == null) {
              wantToStartANewPromise(startPromise);
            } else {
              setDebouncedPromiseStarter(_ => startPromise);
            }
          });
          return asyncHandler == null ? undefined : syncHandler;
        }
      };
    }

    var _excluded$I = ["text"];
    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useLinearNavigation({
      getIndex,
      setIndex,
      managedChildren,
      navigationDirection
    }) {
      var _navigationDirection;

      (_navigationDirection = navigationDirection) !== null && _navigationDirection !== void 0 ? _navigationDirection : navigationDirection = "either";
      var index = getIndex();
      var childCount = managedChildren.length; // Make sure the tabbable index never escapes the bounds of all available children
      // TODO: Keep track of the original index and keep it, at least until keyboard navigation.

      useLayoutEffect(() => {
        if (index !== null) {
          if (index < 0) {
            setIndex(0);
          } else if (childCount > 0 && index >= childCount) {
            setIndex(childCount - 1);
          }
        }
      }, [index, childCount]); // These allow us to manipulate what our current tabbable child is.

      var navigateToIndex = A$1(index => {
        setIndex(index < 0 ? managedChildren.length + index : index);
      }, []);
      var navigateToNext = A$1(() => {
        setIndex(i => i === null ? null : i >= managedChildren.length - 1 ? managedChildren.length - 1 : ++i);
      }, []);
      var navigateToPrev = A$1(() => {
        setIndex(i => i === null ? null : i < 0 ? 0 : --i);
      }, []);
      var navigateToStart = A$1(() => {
        navigateToIndex(0);
      }, [navigateToIndex]);
      var navigateToEnd = A$1(() => {
        navigateToIndex(-1);
      }, [navigateToIndex]);
      var useLinearNavigationChild = A$1(() => {
        var _element$parentElemen;

        var {
          useRefElementProps,
          element
        } = useRefElement(); // Prefer the parent element's direction so that we're not calling getComputedStyle
        // on every single individual child, which is likely redundant.
        // TODO: Does useLogicalDirection need to hold a per-render & per-element cache to make this work?
        // Or does the browser automatically cache the computations until something changes?
        // Given that the values are live, it seems like it should be the latter...

        var {
          convertElementSize,
          getLogicalDirection
        } = useLogicalDirection((_element$parentElemen = element === null || element === void 0 ? void 0 : element.parentElement) !== null && _element$parentElemen !== void 0 ? _element$parentElemen : element);

        var useLinearNavigationChildProps = props => {
          var onKeyDown = e => {
            // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
            if (e.ctrlKey || e.metaKey) return;
            var info = getLogicalDirection();
            var allowsBlockNavigation = navigationDirection == "block" || navigationDirection == "either";
            var allowsInlineNavigation = navigationDirection == "inline" || navigationDirection == "either";

            switch (e.key) {
              case "ArrowUp":
                {
                  var propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  var directionAllowed = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation;

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowDown":
                {
                  var _propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";

                  var _directionAllowed = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation;

                  if (_directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[_propName]) === "btt") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowLeft":
                {
                  var _propName2 = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";

                  var _directionAllowed2 = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation;

                  if (_directionAllowed2) {
                    if ((info === null || info === void 0 ? void 0 : info[_propName2]) === "rtl") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowRight":
                {
                  var _propName3 = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";

                  var _directionAllowed3 = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation;

                  if (_directionAllowed3) {
                    if ((info === null || info === void 0 ? void 0 : info[_propName3]) === "rtl") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  e.preventDefault();
                  e.stopPropagation();
                  break;
                }

              case "Home":
                navigateToStart();
                e.preventDefault();
                e.stopPropagation();
                break;

              case "End":
                navigateToEnd();
                e.preventDefault();
                e.stopPropagation();
                break;
            }
          };

          return useRefElementProps(useMergedProps()({
            onKeyDown
          }, props));
        };

        return {
          useLinearNavigationChildProps
        };
      }, [navigationDirection, navigateToNext, navigateToPrev, navigateToStart, navigateToEnd]);
      return {
        useLinearNavigationChild,
        navigateToIndex,
        navigateToNext,
        navigateToPrev,
        navigateToStart,
        navigateToEnd
      };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useTypeaheadNavigation({
      collator,
      getIndex,
      typeaheadTimeout,
      setIndex
    }) {
      // For typeahead, keep track of what our current "search" string is (if we have one)
      // and also clear it every 1000 ms since the last time it changed.
      // Next, keep a mapping of typeahead values to indices for faster searching.
      // And, for the user's sake, let them know when their typeahead can't match anything anymore
      var [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
      useTimeout({
        timeout: typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000,
        callback: () => {
          setCurrentTypeahead(null);
          setInvalidTypeahead(null);
        },
        triggerIndex: currentTypeahead
      });
      var sortedTypeaheadInfo = s([]);
      var [invalidTypeahead, setInvalidTypeahead] = useState(false); // Handle typeahead for input method editors as well
      // Essentially, when active, ignore further keys 
      // because we're waiting for a CompositionEnd event

      var [imeActive, setImeActive, getImeActive] = useState(false); // Because composition events fire *after* keydown events 
      // (but within the same task, which, TODO, could be browser-dependent),
      // we can use this to keep track of which event we're listening for on the first keydown.

      var [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
      useLayoutEffect(() => {
        if (nextTypeaheadChar !== null) {
          setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar);
          setNextTypeaheadChar(null);
        }
      }, [nextTypeaheadChar]);
      var comparator = useStableCallback((lhs, rhs) => {
        var compare;

        if (typeof lhs === "string" && typeof rhs.text === "string") {
          var _safeRhs$toLowerCase;

          // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
          // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.
          var safeLhs = lhs.normalize("NFD");
          var safeRhs = rhs.text.normalize("NFD").substr(0, safeLhs.length);
          if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
          return compare;
        }

        return lhs - rhs;
      }); // Handle changes in typeahead that cause changes to the tabbable index

      y(() => {
        if (currentTypeahead && sortedTypeaheadInfo.current.length) {
          var sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, comparator);

          if (sortedTypeaheadIndex < 0) {
            // The user has typed an entry that doesn't exist in the list
            // (or more specifically "for which there is no entry that starts with that input")
            setInvalidTypeahead(true);
          } else {
            setInvalidTypeahead(false);
            /*
              We know roughly where, in the sorted array of strings, our next typeahead location is.
              But roughly isn't good enough if there are multiple matches.
              To convert our sorted index to the unsorted index we need, we have to find the first
              element that matches us *and* (if any such exist) is *after* our current selection.
                In other words, the only way typeahead moves backwards relative to our current
              position is if the only other option is behind us.
                It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
              Though there's also a case for just going upwards to the nearest to prevent jumpiness.
              But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
              I dunno. Going back to the start is the simplist though.
                Basically what this does: Starting from where we found ourselves after our binary search,
              scan backwards and forwards through all adjacent entries that also compare equally so that
              we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
              (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
                TODO: The binary search starts this off with a solid O(log n), but one-character
              searches are, thanks to pigeonhole principal, eventually guaranteed to become
              O(n*log n). This is annoying but probably not easily solvable? There could be an
              exception for one-character strings, but that's just kicking the can down
              the road. Maybe one or two characters would be good enough though.
            */
            // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.

            var lowestUnsortedIndexAll = null;
            var lowestSortedIndexAll = sortedTypeaheadIndex; // These two are only set for elements that are ahead of us, but the principle's the same otherwise

            var lowestUnsortedIndexNext = null;
            var lowestSortedIndexNext = sortedTypeaheadIndex;

            var updateBestFit = u => {
              var _getIndex;

              if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                lowestUnsortedIndexAll = u;
                lowestSortedIndexAll = i;
              }

              if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > ((_getIndex = getIndex()) !== null && _getIndex !== void 0 ? _getIndex : -Infinity)) {
                lowestUnsortedIndexNext = u;
                lowestSortedIndexNext = i;
              }
            };

            var i = sortedTypeaheadIndex;

            while (i >= 0 && comparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              --i;
            }

            i = sortedTypeaheadIndex;

            while (i < sortedTypeaheadInfo.current.length && comparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              ++i;
            }

            if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
          }
        }
      }, [currentTypeahead]);
      var useTypeaheadNavigationChild = A$1(_ref => {
        var {
          text
        } = _ref,
            i = _objectWithoutProperties(_ref, _excluded$I);

        y(() => {
          if (text) {
            // Find where to insert this item.
            // Because all index values should be unique, the returned sortedIndex
            // should always refer to a new location (i.e. be negative)                
            var sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, comparator);
            console.assert(sortedIndex < 0);

            if (sortedIndex < 0) {
              sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, {
                text,
                unsortedIndex: i.index
              });
            }

            return () => {
              // When unmounting, find where we were and remove ourselves.
              // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
              var sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, comparator);
              console.assert(sortedIndex >= 0);

              if (sortedIndex >= 0) {
                sortedTypeaheadInfo.current.splice(sortedIndex, 1);
              }
            };
          }
        }, [text]);

        var useTypeaheadNavigationChildProps = function (_ref2) {
          var props = _extends({}, _ref2);

          var {
            useRefElementProps,
            element
          } = useRefElement();

          var onCompositionStart = e => {
            setImeActive(true);
          };

          var onCompositionEnd = e => {
            setNextTypeaheadChar(e.data);
            setImeActive(false);
          };

          var onKeyDown = e => {
            var imeActive = getImeActive();
            var key = e.key; // Not handled by typeahead (i.e. assume this is a keyboard shortcut)

            if (e.ctrlKey || e.metaKey) return;

            if (!imeActive && e.key === "Backspace") {
              // Remove the last character in a way that doesn't split UTF-16 surrogates.
              setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
              e.preventDefault();
              e.stopPropagation();
              return;
            } // The key property represents the typed character OR the "named key attribute" of the key pressed.
            // There's no definite way to tell the difference, but for all intents and purposes
            // there are no one-character names, and there are no non-ASCII-alpha names.
            // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.


            var isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);

            if (isCharacterKey) {
              var _getCurrentTypeahead;

              if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ; else {
                e.preventDefault();
                e.stopPropagation(); // Note: Won't be true for the first keydown
                // but will be overwritten before useLayoutEffect is called
                // to actually apply the change

                if (!imeActive) setNextTypeaheadChar(key);
              }
            }
          };

          return useMergedProps()(useRefElementProps({
            onKeyDown,
            onCompositionStart,
            onCompositionEnd
          }), props);
        };

        return {
          useTypeaheadNavigationChildProps
        };
      }, []);
      return {
        useTypeaheadNavigationChild,
        currentTypeahead,
        invalidTypeahead
      };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */

    function binarySearch(array, wanted, comparator) {
      var firstIndex = 0;
      var lastIndex = array.length - 1;

      while (firstIndex <= lastIndex) {
        var testIndex = lastIndex + firstIndex >> 1;
        var comparisonResult = comparator(wanted, array[testIndex]);

        if (comparisonResult > 0) {
          firstIndex = testIndex + 1;
        } else if (comparisonResult < 0) {
          lastIndex = testIndex - 1;
        } else {
          return testIndex;
        }
      }

      return -firstIndex - 1;
    }

    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is slightly more complicated in that it returns both a
     * prop-modifying hook, but also a hook that each child will need
     * to use: `useManagedChild`.  It's stable across renders, so just
     * toss it into a `Context` so the children can have access to it.
     * This function registers the child with the parent and provides
     * it with any requested information, but doesn't do anything else
     * until it unmounts and retracts that information.
     */

    function useChildManager() {
      // This is blindly updated any time a child mounts or unmounts itself.
      // Used to make sure that any time the array of managed children updates,
      // we also re-render.
      var [childUpdateIndex, setChildUpdateIndex] = useState(0);
      var [totalChildrenMounted, setTotalChildrenMounted, getTotalChildrenMounted] = useState(0);
      var [totalChildrenUnounted, setTotalChildrenUnounted, getTotalChildrenUnounted] = useState(0);
      var childrenCurrentlyMounted = totalChildrenMounted - totalChildrenUnounted;
      var managedChildren = s([]
      /** TODO: Any problems caused by using an array when it should be an object? */
      );
      var mountedChildren = s([]);
      var mountOrder = s(new Map());
      var indicesByElement = s(new Map());
      var getMountIndex = A$1(index => {
        return mountOrder.current.get(index);
      }, []);
      var useManagedChild = A$1(info => {
        var {
          element,
          getElement,
          useRefElementProps
        } = useRefElement();
        useLayoutEffect(() => {
          var index = getTotalChildrenMounted();
          mountOrder.current.set(info.index, index);
          mountedChildren.current[index] = info;
          setTotalChildrenMounted(t => ++t);
          return () => {
            mountOrder.current.delete(info.index);
            mountedChildren.current[index] = null;
            setTotalChildrenUnounted(t => ++t);
          };
        }, [info.index]); // As soon as the component mounts, notify the parent and request a rerender.

        useLayoutEffect(([prevElement, prevIndex], changes) => {
          if (element) {
            indicesByElement.current.set(element, info.index);

            if (managedChildren.current[info.index] != undefined) {
              console.assert(info.index == undefined, "Two children with the same index were added, which may result in unexpected behavior.");
              debugger; // Intentional
            }

            setChildUpdateIndex(c => ++c);
            managedChildren.current[info.index] = _objectSpread2({}, info);
            return () => {
              setChildUpdateIndex(c => ++c);
              delete managedChildren.current[info.index];
              indicesByElement.current.delete(element);
            };
          }
        }, [element, info.index]); // Any time our child props change, make that information available generally.
        // *Don't re-render*, otherwise we'd be stuck in an
        // infinite loop every time an anonymous function is passed.
        // It comes in from the props so the child was already updated by it --
        // we don't need the parent to re-render every single child any time
        // "onClick" updates or whatever.  The relevant child already knows,
        // and that's what matters.

        useLayoutEffect(() => {
          if (managedChildren.current[info.index] != undefined) managedChildren.current[info.index] = _objectSpread2({}, info);
        }, [...Object.entries(info).flat()]);
        return {
          element,
          getElement,
          useManagedChildProps: useRefElementProps
        };
      }, []);
      return {
        useManagedChild,
        childCount: childrenCurrentlyMounted,
        managedChildren: managedChildren.current,
        mountedChildren: mountedChildren.current,
        indicesByElement: indicesByElement.current,
        totalChildrenMounted,
        totalChildrenUnounted,
        getMountIndex
      };
    }
    /**
     * Helper function for letting children know when they are or are not the
     * current selected/expanded/focused/whatever child.
     *
     * Automatically handles when children are mounted & unmounted and such.
     *
     * @param activatedIndex What index the current selected (etc.) child is
     * @param length How many children exist (as managedChildren.length)
     * @param setFlag A function that probably looks like (i, flag) => managedChildren[i].setActive(flag)
     */

    function useChildFlag(activatedIndex, length, setFlag) {
      var [prevActivatedIndex, setPrevActivatedIndex, getPrevActivatedIndex] = useState(null);
      var [prevChildCount, setPrevChildCount, getPrevChildCount] = useState(length); // Any time the number of components changes,
      // reset any initial, possibly incorrect state they might have had, just in case.

      useLayoutEffect(() => {
        var direction = Math.sign(length - getPrevChildCount());

        if (direction !== 0) {
          for (var i = (_getPrevChildCount = getPrevChildCount()) !== null && _getPrevChildCount !== void 0 ? _getPrevChildCount : 0; i != length; i += direction) {
            var _getPrevChildCount;

            setFlag(i, i === activatedIndex);
          }

          setPrevChildCount(length);
        }
      }, [setFlag, activatedIndex, length]);
      useLayoutEffect(() => {
        // Deactivate the previously activated component
        var prevActivatedIndex = getPrevActivatedIndex();

        if (prevActivatedIndex != activatedIndex) {
          if (prevActivatedIndex != null && prevActivatedIndex >= 0 && prevActivatedIndex < length) setFlag(prevActivatedIndex, false);
        } // Activate the current component


        if (activatedIndex != null && activatedIndex >= 0 && activatedIndex < length) {
          setFlag(activatedIndex, true);
          setPrevActivatedIndex(activatedIndex);
        }
      }, [setFlag, activatedIndex, length]);
    }

    var _excluded$H = ["managedChildren", "childCount", "useManagedChild", "indicesByElement"],
        _excluded2$f = ["tabIndex"],
        _excluded3$7 = ["tabIndex"];
    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `focusOnChange` should be set to true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const { focused, focusedInner, useHasFocusProps } = useHasFocus<ParentElement>();
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */

    function useRovingTabIndex({
      focusOnChange: foc,
      tabbableIndex
    }) {
      var [rerenderAndFocus, setRerenderAndFocus] = useState(null);
      var getFocusOnChange = useStableGetter(foc);
      var getTabbableIndex = useStableGetter(tabbableIndex);
      s(-Infinity); // Call the hook that allows us to collect information from children who provide it

      var _useChildManager = useChildManager(),
          {
        managedChildren,
        childCount,
        useManagedChild,
        indicesByElement
      } = _useChildManager,
          rest = _objectWithoutProperties(_useChildManager, _excluded$H); // Any time the tabbable index changes,
      // notify the previous child that it's no longer tabbable,
      // and notify the next child that is allowed to be tabbed to.


      useChildFlag(tabbableIndex, childCount, (index, tabbable) => {
        var _managedChildren$inde;

        if (index != null) (_managedChildren$inde = managedChildren[index]) === null || _managedChildren$inde === void 0 ? void 0 : _managedChildren$inde.setTabbable(tabbable);
      });
      A$1(() => {
        if (tabbableIndex != null) managedChildren[tabbableIndex].setTabbable(true);
      }, [tabbableIndex]);
      var useRovingTabIndexChild = A$1(info => {
        var [rrafIndex, setRrafIndex] = useState(1);
        var rerenderAndFocus = A$1(() => {
          setRrafIndex(i => ++i);
        }, []);

        var newInfo = _objectSpread2(_objectSpread2({}, info), {}, {
          rerenderAndFocus,
          setTabbable: A$1(tabbable => {
            setTabbable(tabbable);
          }, [])
        });

        var {
          element,
          getElement,
          useManagedChildProps
        } = useManagedChild(newInfo); // TODO: Using getTabbableIndex during render phase on mount

        var [tabbable, setTabbable] = useState(getTabbableIndex() == info.index);
        y(() => {
          if (element && tabbable) {
            setRerenderAndFocus(_ => rerenderAndFocus);

            if (getFocusOnChange() && "focus" in element) {
              requestAnimationFrame(() => {
                queueMicrotask(() => {
                  element.focus();
                });
              });
            }
          }
        }, [element, tabbable, rrafIndex]);

        function useRovingTabIndexSiblingProps(_ref) {
          var {
            tabIndex
          } = _ref,
              props = _objectWithoutProperties(_ref, _excluded2$f);

          if (tabIndex == null) {
            if (tabbable) tabIndex = 0;else tabIndex = -1;
          }

          return useMergedProps()({
            tabIndex
          }, props);
        }

        function useRovingTabIndexChildProps(_ref2) {
          var {
            tabIndex
          } = _ref2,
              props = _objectWithoutProperties(_ref2, _excluded3$7);

          if (tabIndex == null) {
            if (tabbable) tabIndex = 0;else tabIndex = -1;
          }

          return useMergedProps()(useManagedChildProps({
            tabIndex
          }), props);
        }
        return {
          useRovingTabIndexChildProps,
          useRovingTabIndexSiblingProps,
          tabbable
        };
      }, [useManagedChild]);
      return _objectSpread2({
        useRovingTabIndexChild,
        childCount,
        managedChildren,
        indicesByElement,
        focusCurrent: rerenderAndFocus
      }, rest);
    }

    var _excluded$G = ["managedChildren", "indicesByElement", "useRovingTabIndexChild", "focusCurrent"];
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */

    function useListNavigation({
      initialIndex,
      focusOnChange,
      collator,
      keyNavigation
    }) {
      var _keyNavigation;

      (_keyNavigation = keyNavigation) !== null && _keyNavigation !== void 0 ? _keyNavigation : keyNavigation = "either"; // Keep track of three things related to the currently tabbable element's index:
      // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.

      var [tabbableIndex, setTabbableIndex, getTabbableIndex] = useState(initialIndex === undefined ? 0 : initialIndex);
      var setIndex = A$1(index => {
        setTabbableIndex(index);
      }, []);

      var _useRovingTabIndex = useRovingTabIndex({
        focusOnChange,
        tabbableIndex
      }),
          {
        managedChildren,
        indicesByElement,
        useRovingTabIndexChild,
        focusCurrent
      } = _useRovingTabIndex,
          rest = _objectWithoutProperties(_useRovingTabIndex, _excluded$G);

      var {
        currentTypeahead,
        invalidTypeahead,
        useTypeaheadNavigationChild
      } = useTypeaheadNavigation({
        collator,
        getIndex: getTabbableIndex,
        setIndex,
        typeaheadTimeout: 1000
      });
      var {
        navigateToEnd,
        navigateToIndex,
        navigateToNext,
        navigateToPrev,
        navigateToStart,
        useLinearNavigationChild
      } = useLinearNavigation({
        navigationDirection: keyNavigation,
        getIndex: getTabbableIndex,
        setIndex,
        managedChildren
      });
      var useListNavigationChild = A$1(info => {
        var {
          useTypeaheadNavigationChildProps
        } = useTypeaheadNavigationChild(info);
        var {
          useLinearNavigationChildProps
        } = useLinearNavigationChild();
        var {
          useRovingTabIndexChildProps,
          useRovingTabIndexSiblingProps,
          tabbable
        } = useRovingTabIndexChild(info);

        var useListNavigationChildProps = function (_ref) {
          var props = _extends({}, _ref);

          return useMergedProps()(useRovingTabIndexChildProps(useTypeaheadNavigationChildProps(useLinearNavigationChildProps({
            onClick: roveToSelf
          }))), props);
        };

        var roveToSelf = A$1(() => {
          navigateToIndex(info.index);
        }, []);
        return {
          useListNavigationChildProps,
          useListNavigationSiblingProps: useRovingTabIndexSiblingProps,
          tabbable //roveToSelf,
          //element

        };
      }, [useTypeaheadNavigationChild, useLinearNavigationChild, useRovingTabIndexChild, navigateToIndex]);
      return _objectSpread2({
        useListNavigationChild,
        currentTypeahead,
        invalidTypeahead,
        tabbableIndex,
        setTabbableIndex,
        managedChildren,
        indicesByElement,
        navigateToIndex,
        navigateToNext,
        navigateToPrev,
        navigateToStart,
        navigateToEnd,
        focusCurrent
      }, rest);
    }

    /**
     *
     * There are several different ways that a focus event can happen.  Assume
     * the following steps happen in order:
     *
     * 1. The page loads.
     *    * Nothing is focused, but `document.activeElement` is `body`.
     *    * No focus events are fired.
     * 2. The window is focused, an unfocusable element is clicked, text is selected, etc.
     *    * The `activeElement` remains as `body`.
     *    * A `focus`/`focusin` event *MIGHT* be fired for `body`. Depending on
     *      the browser, this depends on whether the handler was attached to `window` or `document`.
     *      Probably just best to not rely on it, or listen to `window` focus events directly.
     * 3. A focusable element is clicked, etc.
     *    * The `activeElement` is set to the new element before any event even fires.
     *    * `focusout` and `blur` are *not* fired on `body`.
     *    * `focus` and `focusin` are fired on the new element. `relatedTarget` is null.
     * 4. A focusable element is clicked, etc.
     *    * **The `activeElement` is set to the `body`** before any event even fires.
     *    * `blur` and `focusout` are fired on the old element. `relatedTarget` is the new element.
     *    * The `activeElement` is now set to the new element.
     *    * `focusin` is fired on the new element. `relatedTarget` is the old element.
     * 5. An unfocusable element is clicked, text is selected, etc.
     *    * The `activeElement` is set to `body`.
     *    * `blur` and `focusout` are fired on the old element. `relatedTarget` is null.
     *    * `focusin` is *not* fired on `body`.
     *
     *
     * In summary:
     * 1. Focus events *do* notify us of all changes in focus, but there is no one single comprehensive event that provides us with all available information.
     * 2. `document.activeElement` *is not* always the same as what's being referenced by a focus event. In particular, it may become `body` at any arbitrary time.
     * 3. A `blur` without a `focus` can and will occur. This means it is not possible to solely use `focus` to detect all changes.
     * 4. A `blur` event whose `relatedTarget` is null indicates that there will be no following `focus` event.
     *
     *
     * @param callback
     * @returns
     */

    var currentlyFocusedElement = null;
    var lastFocusedElement = null;

    function getLastFocusedElement() {
      return lastFocusedElement;
    }

    function getCurrentlyFocusedElement() {
      return currentlyFocusedElement;
    }

    var updaters = new Set();

    function focusout(e) {
      if (e.relatedTarget == null) {
        currentlyFocusedElement = null;

        for (var f of updaters) {
          f({
            current: currentlyFocusedElement,
            last: lastFocusedElement,
            windowFocused
          });
        }
      }
    }

    function focusin(e) {
      currentlyFocusedElement = lastFocusedElement = e.target;

      for (var f of updaters) {
        f({
          current: currentlyFocusedElement,
          last: lastFocusedElement,
          windowFocused
        });
      }
    }

    var windowFocused = true;

    function windowFocus() {
      windowFocused = true;

      for (var f of updaters) {
        f({
          current: currentlyFocusedElement,
          last: lastFocusedElement,
          windowFocused
        });
      }
    }

    function windowBlur() {
      windowFocused = false;

      for (var f of updaters) {
        f({
          current: currentlyFocusedElement,
          last: lastFocusedElement,
          windowFocused
        });
      }
    }

    function useActiveElement(filter) {
      var [i, setI] = useState(0);
      h(() => {
        var F = info => {
          if (filter == null || filter(info)) setI(i => ++i);
        };

        if (updaters.size === 0) {
          document.addEventListener("focusin", focusin, {
            passive: true
          });
          document.addEventListener("focusout", focusout, {
            passive: true
          });
          window.addEventListener("focus", windowFocus, {
            passive: true
          });
          window.addEventListener("blur", windowBlur, {
            passive: true
          });
        }

        updaters.add(F);
        return () => {
          updaters.delete(F);

          if (updaters.size === 0) {
            document.removeEventListener("focusin", focusin);
            document.removeEventListener("focusout", focusout);
            window.removeEventListener("focus", windowFocus);
            window.removeEventListener("blur", windowBlur);
          }
        };
      }, [filter]);
      return {
        activeElement: currentlyFocusedElement,
        lastActiveElement: lastFocusedElement,
        getActiveElement: getCurrentlyFocusedElement,
        getLastActiveElement: getLastFocusedElement,
        windowFocused
      };
    }

    function useHasFocus({} = {}) {
      // These are slightly redundant, but any time the focus changes, we need to know if it's "relevant" to us.
      // It's "relevant" if the newly-focused element is a child of us,
      // OR if we're focused and focus moves OUTSIDE of us our our children.
      // Because of that second bit, we need to keep track of where the focus was the last time we checked for the filter.
      var [hasFocus, setHasFocus, getHasFocus] = useState(false);
      var [hasLastFocus, setHasLastFocus, getHasLastFocus] = useState(false);
      var {
        element,
        getElement,
        useRefElementProps
      } = useRefElement();
      var {
        activeElement,
        lastActiveElement
      } = useActiveElement(A$1(({
        current,
        last,
        windowFocused
      }) => {
        // Keep in mind that once we get our element, even if the hook and filter functions
        // don't re-run, the currently-focused element will still be returned below, and,
        // even if it's not us or one of our children, will still be safely filtered out at render time.
        var element = getElement();
        if (!element) return false;
        var hasFocusNow = element.contains(current) || element.contains(last);

        if (hasFocusNow) {
          return true;
        } else {
          var hadFocusBeforeThis = getHasLastFocus() || getHasFocus();

          if (hadFocusBeforeThis) {
            // Return true once, so that useActiveElement will return one instance of a different element having focus.
            // Then, back outside this filter function, we'll know that we're no longer focused.
            return true;
          }

          return false;
        }
      }, [])); // These are primarily used for bookkeeping during the filter function above.

      h(() => {
        var _element$contains;

        setHasFocus((_element$contains = element === null || element === void 0 ? void 0 : element.contains(activeElement)) !== null && _element$contains !== void 0 ? _element$contains : false);
      }, [element, activeElement]);
      h(() => {
        var _element$contains2;

        setHasLastFocus((_element$contains2 = element === null || element === void 0 ? void 0 : element.contains(lastActiveElement)) !== null && _element$contains2 !== void 0 ? _element$contains2 : false);
      }, [element, lastActiveElement]);
      var useHasFocusProps = A$1(props => {
        return useRefElementProps(props);
      }, [useRefElementProps]);
      var focused = d(() => {
        return element == activeElement;
      }, [element, activeElement]);
      var focusedInner = d(() => {
        var _element$contains3;

        return (_element$contains3 = element === null || element === void 0 ? void 0 : element.contains(activeElement)) !== null && _element$contains3 !== void 0 ? _element$contains3 : false;
      }, [element, activeElement]);
      var lastFocused = d(() => {
        return element == lastActiveElement;
      }, [element, lastActiveElement]);
      var lastFocusedInner = d(() => {
        var _element$contains4;

        return (_element$contains4 = element === null || element === void 0 ? void 0 : element.contains(lastActiveElement)) !== null && _element$contains4 !== void 0 ? _element$contains4 : false;
      }, [element, lastActiveElement]);
      return {
        useHasFocusProps,
        focused,
        focusedInner,
        lastFocused,
        lastFocusedInner
      };
    }

    /**
     * Wrap the native `useEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     */

    function useEffect(effect, inputs) {
      var prevInputs = s(inputs);

      var effect2 = () => {
        var changes = [];

        for (var i = 0; i < Math.max(prevInputs.current.length, inputs.length); ++i) {
          if (prevInputs.current[i] != inputs[i]) changes[i] = {
            from: prevInputs.current[i],
            to: inputs[i]
          };
        }

        var ret = effect(prevInputs.current, changes);
        prevInputs.current = inputs;
        return ret;
      };

      y(effect2, inputs);
    }

    var _excluded$F = ["index"],
        _excluded2$e = ["index", "text"];
    function useGridNavigation({
      focusOnChange: foc
    }) {
      var getFocusCellOnRowChange = useStableGetter(foc);
      var [currentRow, setCurrentRow, getCurrentRow] = useState(0);
      var [lastKnownCellIndex, setLastKnownCellIndex, getLastKnownCellIndex] = useState(0);
      useEffect(([prev]) => {
        console.log("currentRow: ".concat(prev, " -> ").concat(currentRow));
      }, [currentRow]);
      var {
        childCount,
        managedChildren,
        indicesByElement,
        getMountIndex,
        mountedChildren,
        totalChildrenMounted,
        totalChildrenUnounted,
        useManagedChild
      } = useChildManager();
      var {
        useLinearNavigationChild
      } = useLinearNavigation({
        managedChildren,
        getIndex: getCurrentRow,
        setIndex: setCurrentRow,
        navigationDirection: "block"
      });
      useChildFlag(currentRow, managedChildren.length, A$1((index, tabbable) => {
        var _managedChildren$inde;

        return (_managedChildren$inde = managedChildren[index]) === null || _managedChildren$inde === void 0 ? void 0 : _managedChildren$inde.setIsTabbableRow(tabbable, lastKnownCellIndex);
      }, [lastKnownCellIndex, managedChildren]));
      var useGridNavigationRow = A$1(_ref => {
        var {
          index
        } = _ref,
            info = _objectWithoutProperties(_ref, _excluded$F);

        var {
          useHasFocusProps,
          lastFocusedInner
        } = useHasFocus();
        var [isTabbableRow, setIsTabbableRow] = useState(false); // Besides just being a list nav child, it's also a list nav parent
        // yaaaayyy

        var {
          useListNavigationChild: useListNavigationChild2,
          childCount: cellCount,
          indicesByElement: cellIndicesByElement,
          managedChildren: managedCells,
          navigateToIndex: setCellIndex,
          tabbableIndex: tabbableCell,
          focusCurrent
        } = useListNavigation({
          focusOnChange: isTabbableRow && getFocusCellOnRowChange(),
          keyNavigation: "inline",
          initialIndex: null
        }); // Any time we become the currently tabbable row,
        // make sure the correct cell is selected and focused.
        // Any other time, make sure no cell is tabbable.

        useEffect(() => {
          if (isTabbableRow) {
            setCellIndex(getLastKnownCellIndex());
          } else {
            setCellIndex(null);
          }
        }, [isTabbableRow]); // Any time we become the currently tabbable row,
        // request the component rerender and focus itself.

        useEffect(() => {
          if (isTabbableRow && getFocusCellOnRowChange()) {
            focusCurrent === null || focusCurrent === void 0 ? void 0 : focusCurrent();
          }
        }, [focusCurrent, isTabbableRow]); // Any time the current cell changes 
        // (probably because we interacted with it, thus focusing it, 
        // changing it from null if the row wasn't already focused)
        // make sure that we're the currently tabbable row if we weren't already.

        useLayoutEffect(() => {
          if (tabbableCell !== null) {
            setLastKnownCellIndex(tabbableCell);
            setIsTabbableRow(true);
            setCurrentRow(index);
          }
        }, [index, tabbableCell, setLastKnownCellIndex]);
        var {
          useManagedChildProps
        } = useManagedChild(_objectSpread2({
          index,
          setIsTabbableRow: A$1((tabbable, newIndex) => {
            if (tabbable) {
              setCellIndex(newIndex);
            }

            setIsTabbableRow(tabbable);
          }, [])
        }, info));
        var {
          useLinearNavigationChildProps
        } = useLinearNavigationChild();
        var useGridNavigationRowProps = A$1(props => useManagedChildProps(useLinearNavigationChildProps(useHasFocusProps(props))), [useManagedChildProps]);
        var useGridNavigationCell = A$1(_ref2 => {
          var {
            index,
            text
          } = _ref2,
              info = _objectWithoutProperties(_ref2, _excluded2$e);

          var {
            tabbable,
            useListNavigationChildProps
          } = useListNavigationChild2(_objectSpread2({
            text,
            index
          }, info));
          var useGridNavigationCellProps = A$1(props => useListNavigationChildProps(props), [useListNavigationChildProps]);
          return {
            tabbable,
            useGridNavigationCellProps
          };
        }, [useListNavigationChild2]);
        return {
          useGridNavigationRowProps,
          useGridNavigationCell,
          cellCount,
          tabbableCell,
          isTabbableRow,
          managedCells
        };
      }, [setLastKnownCellIndex, useLinearNavigationChild, useManagedChild]);
      return {
        useGridNavigationRow,
        rowCount: childCount,
        cellIndex: lastKnownCellIndex,
        rowIndex: currentRow,
        managedRows: managedChildren
      };
    }

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */

    function useGlobalHandler(target, type, handler, options) {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      var stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
      if (handler == null) stableHandler = null;
      y(() => {
        if (stableHandler) {
          target.addEventListener(type, stableHandler, options);
          return () => target.removeEventListener(type, stableHandler, options);
        }
      }, [target, type, stableHandler]);
    }

    function getFromLocalStorage() {
      return function (key, converter = JSON.parse) {
        try {
          var item = localStorage.getItem(key);
          if (!item) return undefined;
          return converter(item);
        } catch (e) {
          debugger; // Intentional

          return undefined;
        }
      };
    }
    function storeToLocalStorage() {
      return function (key, value, converter = JSON.stringify) {
        try {
          localStorage.setItem(key, converter(value));
        } catch (e) {
          debugger; // Intentional
        }
      };
    }

    var Table$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";

    function base64(value) {
      return Table$1[value];
    }

    function random6Bits() {
      return Math.floor(Math.random() * 0b1000000);
    }

    function random64Bits() {
      return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     */


    function generateRandomId(prefix) {
      return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits().map(n => base64(n)).join(""));
    }
    /**
     * Returns a hook that modifies a set of props to provide a randomly-generated ID if one was not provided.
     *
     * If you'd like to use the ID in a property that's *not* named `id` (like `for` or `aria-labelledby` or whatnot), `useReferencedIdProps` is also provided.
     *
     * And the randomly-generated id itself is also provided in case you want to handle the logic yourself without `useMergedProps`.
     *
     * Unlike most other `use*Props` hooks, these are mostly stable.
     */

    function useRandomId({
      prefix
    } = {}) {
      var [randomId, setRandomId] = useState(() => generateRandomId(prefix));
      var [watchPrefixUpdates, setWatchPrefixUpdates, getWatchPrefixUpdates] = useState(false);
      h(() => {
        var watchPrefixUpdates = getWatchPrefixUpdates();
        if (watchPrefixUpdates) setRandomId(() => generateRandomId(prefix));
        setWatchPrefixUpdates(true);
      }, [prefix]); // Whatever ID was most recently used by the actual "id" prop.
      // Used so that any ID-referencing props don't need to provide the same value.
      //
      // TODO: This does mean that on the first render, if just the ID is provided,
      // there will be a temporary mismatch, but it's corrected before rendering finishes.
      // Is this okay?

      var [usedId, setUsedId, getUsedId] = useState(undefined);
      var useReferencedIdProps = A$1(function useReferencedIdProps(idPropName) {
        var ret = function (_ref) {
          var _ref2, _ref3;

          var {
            [idPropName]: givenId
          } = _ref,
              props = _objectWithoutProperties(_ref, [idPropName].map(_toPropertyKey));

          var usedId2 = (_ref2 = (_ref3 = givenId !== null && givenId !== void 0 ? givenId : usedId) !== null && _ref3 !== void 0 ? _ref3 : randomId) !== null && _ref2 !== void 0 ? _ref2 : undefined;
          if (idPropName === "id") setUsedId(usedId2);
          return useMergedProps()({
            [idPropName]: usedId2
          }, props);
        };

        return ret;
      }, [usedId, randomId]);
      var useRandomIdProps = A$1(function useRandomIdProps(p) {
        return useReferencedIdProps("id")(p);
      }, [useReferencedIdProps]);
      return {
        randomId,
        id: usedId,
        getId: getUsedId,
        useRandomIdProps,
        useReferencedIdProps
      };
    }

    /*!
    * tabbable 5.2.1
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };

    var isHidden = function isHidden(node, displayCheck) {
      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      }

      if (!displayCheck || displayCheck === 'full') {
        while (node) {
          if (getComputedStyle(node).display === 'none') {
            return true;
          }

          node = node.parentElement;
        }
      } else if (displayCheck === 'non-zero-area') {
        var _node$getBoundingClie = node.getBoundingClientRect(),
            width = _node$getBoundingClie.width,
            height = _node$getBoundingClie.height;

        return width === 0 && height === 0;
      }

      return false;
    }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset


    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (isInput(node) || node.tagName === 'SELECT' || node.tagName === 'TEXTAREA' || node.tagName === 'BUTTON') {
        var parentNode = node.parentElement;

        while (parentNode) {
          if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
            // look for the first <legend> as an immediate child of the disabled
            //  <fieldset>: if the node is in that legend, it'll be enabled even
            //  though the fieldset is disabled; otherwise, the node is in a
            //  secondary/subsequent legend, or somewhere else within the fieldset
            //  (however deep nested) and it'll be disabled
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i);

              if (child.tagName === 'LEGEND') {
                if (child.contains(node)) {
                  return false;
                } // the node isn't in the first legend (in doc order), so no matter
                //  where it is now, it'll be disabled


                return true;
              }
            } // the node isn't in a legend, so no matter where it is now, it'll be disabled


            return true;
          }

          parentNode = parentNode.parentElement;
        }
      } // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state


      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options.displayCheck) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
      var _a, _b, _c;
      /* Symbols for private properties */


      var _blockingElements = Symbol();

      var _alreadyInertElements = Symbol();

      var _topElParents = Symbol();

      var _siblingsToRestore = Symbol();

      var _parentMO = Symbol();
      /* Symbols for private static methods */


      var _topChanged = Symbol();

      var _swapInertedSibling = Symbol();

      var _inertSiblings = Symbol();

      var _restoreInertedSiblings = Symbol();

      var _getParents = Symbol();

      var _getDistributedChildren = Symbol();

      var _isInertable = Symbol();

      var _handleMutations = Symbol();

      class BlockingElementsImpl {
        constructor() {
          /**
           * The blocking elements.
           */
          this[_a] = [];
          /**
           * Used to keep track of the parents of the top element, from the element
           * itself up to body. When top changes, the old top might have been removed
           * from the document, so we need to memoize the inerted parents' siblings
           * in order to restore their inerteness when top changes.
           */

          this[_b] = [];
          /**
           * Elements that are already inert before the first blocking element is
           * pushed.
           */

          this[_c] = new Set();
        }

        destructor() {
          // Restore original inertness.
          this[_restoreInertedSiblings](this[_topElParents]); // Note we don't want to make these properties nullable on the class,
          // since then we'd need non-null casts in many places. Calling a method on
          // a BlockingElements instance after calling destructor will result in an
          // exception.


          var nullable = this;
          nullable[_blockingElements] = null;
          nullable[_topElParents] = null;
          nullable[_alreadyInertElements] = null;
        }

        get top() {
          var elems = this[_blockingElements];
          return elems[elems.length - 1] || null;
        }

        push(element) {
          if (!element || element === this.top) {
            return;
          } // Remove it from the stack, we'll bring it to the top.


          this.remove(element);

          this[_topChanged](element);

          this[_blockingElements].push(element);
        }

        remove(element) {
          var i = this[_blockingElements].indexOf(element);

          if (i === -1) {
            return false;
          }

          this[_blockingElements].splice(i, 1); // Top changed only if the removed element was the top element.


          if (i === this[_blockingElements].length) {
            this[_topChanged](this.top);
          }

          return true;
        }

        pop() {
          var top = this.top;
          top && this.remove(top);
          return top;
        }

        has(element) {
          return this[_blockingElements].indexOf(element) !== -1;
        }
        /**
         * Sets `inert` to all document elements except the new top element, its
         * parents, and its distributed content.
         */


        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
          var toKeepInert = this[_alreadyInertElements];
          var oldParents = this[_topElParents]; // No new top, reset old top if any.

          if (!newTop) {
            this[_restoreInertedSiblings](oldParents);

            toKeepInert.clear();
            this[_topElParents] = [];
            return;
          }

          var newParents = this[_getParents](newTop); // New top is not contained in the main document!


          if (newParents[newParents.length - 1].parentNode !== document.body) {
            throw Error('Non-connected element cannot be a blocking element');
          } // Cast here because we know we'll call _inertSiblings on newParents
          // below.


          this[_topElParents] = newParents;

          var toSkip = this[_getDistributedChildren](newTop); // No previous top element.


          if (!oldParents.length) {
            this[_inertSiblings](newParents, toSkip, toKeepInert);

            return;
          }

          var i = oldParents.length - 1;
          var j = newParents.length - 1; // Find common parent. Index 0 is the element itself (so stop before it).

          while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
            i--;
            j--;
          } // If up the parents tree there are 2 elements that are siblings, swap
          // the inerted sibling.


          if (oldParents[i] !== newParents[j]) {
            this[_swapInertedSibling](oldParents[i], newParents[j]);
          } // Restore old parents siblings inertness.


          i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i)); // Make new parents siblings inert.

          j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
        }
        /**
         * Swaps inertness between two sibling elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_swapInertedSibling](oldInert, newInert) {
          var siblingsToRestore = oldInert[_siblingsToRestore]; // oldInert is not contained in siblings to restore, so we have to check
          // if it's inertable and if already inert.

          if (this[_isInertable](oldInert) && !oldInert.inert) {
            oldInert.inert = true;
            siblingsToRestore.add(oldInert);
          } // If newInert was already between the siblings to restore, it means it is
          // inertable and must be restored.


          if (siblingsToRestore.has(newInert)) {
            newInert.inert = false;
            siblingsToRestore.delete(newInert);
          }

          newInert[_parentMO] = oldInert[_parentMO];
          newInert[_siblingsToRestore] = siblingsToRestore;
          oldInert[_parentMO] = undefined;
          oldInert[_siblingsToRestore] = undefined;
        }
        /**
         * Restores original inertness to the siblings of the elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_restoreInertedSiblings](elements) {
          for (var element of elements) {
            var mo = element[_parentMO];
            mo.disconnect();
            element[_parentMO] = undefined;
            var siblings = element[_siblingsToRestore];

            for (var sibling of siblings) {
              sibling.inert = false;
            }

            element[_siblingsToRestore] = undefined;
          }
        }
        /**
         * Inerts the siblings of the elements except the elements to skip. Stores
         * the inerted siblings into the element's symbol `_siblingsToRestore`.
         * Pass `toKeepInert` to collect the already inert elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_inertSiblings](elements, toSkip, toKeepInert) {
          for (var element of elements) {
            // Assume element is not a Document, so it must have a parentNode.
            var parent = element.parentNode;
            var children = parent.children;
            var inertedSiblings = new Set();

            for (var j = 0; j < children.length; j++) {
              var sibling = children[j]; // Skip the input element, if not inertable or to be skipped.

              if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
                continue;
              } // Should be collected since already inerted.


              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            } // Store the siblings that were inerted.


            element[_siblingsToRestore] = inertedSiblings; // Observe only immediate children mutations on the parent.

            var mo = new MutationObserver(this[_handleMutations].bind(this));
            element[_parentMO] = mo;
            var parentToObserve = parent; // If we're using the ShadyDOM polyfill, then our parent could be a
            // shady root, which is an object that acts like a ShadowRoot, but isn't
            // actually a node in the real DOM. Observe the real DOM parent instead.

            var maybeShadyRoot = parentToObserve;

            if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
              parentToObserve = maybeShadyRoot.host;
            }

            mo.observe(parentToObserve, {
              childList: true
            });
          }
        }
        /**
         * Handles newly added/removed nodes by toggling their inertness.
         * It also checks if the current top Blocking Element has been removed,
         * notifying and removing it.
         */


        [_handleMutations](mutations) {
          var parents = this[_topElParents];
          var toKeepInert = this[_alreadyInertElements];

          for (var mutation of mutations) {
            // If the target is a shadowRoot, get its host as we skip shadowRoots when
            // computing _topElParents.
            var target = mutation.target.host || mutation.target;
            var idx = target === document.body ? parents.length : parents.indexOf(target);
            var inertedChild = parents[idx - 1];
            var inertedSiblings = inertedChild[_siblingsToRestore]; // To restore.

            for (var i = 0; i < mutation.removedNodes.length; i++) {
              var sibling = mutation.removedNodes[i];

              if (sibling === inertedChild) {
                console.info('Detected removal of the top Blocking Element.');
                this.pop();
                return;
              }

              if (inertedSiblings.has(sibling)) {
                sibling.inert = false;
                inertedSiblings.delete(sibling);
              }
            } // To inert.


            for (var _i = 0; _i < mutation.addedNodes.length; _i++) {
              var _sibling = mutation.addedNodes[_i];

              if (!this[_isInertable](_sibling)) {
                continue;
              }

              if (toKeepInert && _sibling.inert) {
                toKeepInert.add(_sibling);
              } else {
                _sibling.inert = true;
                inertedSiblings.add(_sibling);
              }
            }
          }
        }
        /**
         * Returns if the element is inertable.
         */


        [_isInertable](element) {
          return false === /^(style|template|script)$/.test(element.localName);
        }
        /**
         * Returns the list of newParents of an element, starting from element
         * (included) up to `document.body` (excluded).
         */


        [_getParents](element) {
          var parents = [];
          var current = element; // Stop to body.

          while (current && current !== document.body) {
            // Skip shadow roots.
            if (current.nodeType === Node.ELEMENT_NODE) {
              parents.push(current);
            } // ShadowDom v1


            if (current.assignedSlot) {
              // Collect slots from deepest slot to top.
              while (current = current.assignedSlot) {
                parents.push(current);
              } // Continue the search on the top slot.


              current = parents.pop();
              continue;
            }

            current = current.parentNode || current.host;
          }

          return parents;
        }
        /**
         * Returns the distributed children of the element's shadow root.
         * Returns null if the element doesn't have a shadow root.
         */


        [_getDistributedChildren](element) {
          var shadowRoot = element.shadowRoot;

          if (!shadowRoot) {
            return null;
          }

          var result = new Set();
          var i;
          var j;
          var nodes;
          var slots = shadowRoot.querySelectorAll('slot');

          if (slots.length && slots[0].assignedNodes) {
            for (i = 0; i < slots.length; i++) {
              nodes = slots[i].assignedNodes({
                flatten: true
              });

              for (j = 0; j < nodes.length; j++) {
                if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                  result.add(nodes[j]);
                }
              }
            } // No need to search for <content>.

          }

          return result;
        }

      }

      document.$blockingElements = new BlockingElementsImpl();
    })();

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    createCommonjsModule(function (module, exports) {
      (function (global, factory) {
        factory() ;
      })(commonjsGlobal, function () {

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        /**
         * This work is licensed under the W3C Software and Document License
         * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
         */


        (function () {
          // Return early if we're not running inside of the browser.
          if (typeof window === 'undefined') {
            return;
          } // Convenience function for converting NodeLists.

          /** @type {typeof Array.prototype.slice} */


          var slice = Array.prototype.slice;
          /**
           * IE has a non-standard name for "matches".
           * @type {typeof Element.prototype.matches}
           */

          var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
          /** @type {string} */

          var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
          /**
           * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
           * attribute.
           *
           * Its main functions are:
           *
           * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
           *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
           *   each focusable node in the subtree with the singleton `InertManager` which manages all known
           *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
           *   instance exists for each focusable node which has at least one inert root as an ancestor.
           *
           * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
           *   attribute is removed from the root node). This is handled in the destructor, which calls the
           *   `deregister` method on `InertManager` for each managed inert node.
           */


          var InertRoot = function () {
            /**
             * @param {!Element} rootElement The Element at the root of the inert subtree.
             * @param {!InertManager} inertManager The global singleton InertManager object.
             */
            function InertRoot(rootElement, inertManager) {
              _classCallCheck(this, InertRoot);
              /** @type {!InertManager} */


              this._inertManager = inertManager;
              /** @type {!Element} */

              this._rootElement = rootElement;
              /**
               * @type {!Set<!InertNode>}
               * All managed focusable nodes in this InertRoot's subtree.
               */

              this._managedNodes = new Set(); // Make the subtree hidden from assistive technology

              if (this._rootElement.hasAttribute('aria-hidden')) {
                /** @type {?string} */
                this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
              } else {
                this._savedAriaHidden = null;
              }

              this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes


              this._makeSubtreeUnfocusable(this._rootElement); // Watch for:
              // - any additions in the subtree: make them unfocusable too
              // - any removals from the subtree: remove them from this inert root's managed nodes
              // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
              //   element, make that node a managed node.


              this._observer = new MutationObserver(this._onMutation.bind(this));

              this._observer.observe(this._rootElement, {
                attributes: true,
                childList: true,
                subtree: true
              });
            }
            /**
             * Call this whenever this object is about to become obsolete.  This unwinds all of the state
             * stored in this object and updates the state of all of the managed nodes.
             */


            _createClass(InertRoot, [{
              key: 'destructor',
              value: function destructor() {
                this._observer.disconnect();

                if (this._rootElement) {
                  if (this._savedAriaHidden !== null) {
                    this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                  } else {
                    this._rootElement.removeAttribute('aria-hidden');
                  }
                }

                this._managedNodes.forEach(function (inertNode) {
                  this._unmanageNode(inertNode.node);
                }, this); // Note we cast the nulls to the ANY type here because:
                // 1) We want the class properties to be declared as non-null, or else we
                //    need even more casts throughout this code. All bets are off if an
                //    instance has been destroyed and a method is called.
                // 2) We don't want to cast "this", because we want type-aware optimizations
                //    to know which properties we're setting.


                this._observer =
                /** @type {?} */
                null;
                this._rootElement =
                /** @type {?} */
                null;
                this._managedNodes =
                /** @type {?} */
                null;
                this._inertManager =
                /** @type {?} */
                null;
              }
              /**
               * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
               */

            }, {
              key: '_makeSubtreeUnfocusable',

              /**
               * @param {!Node} startNode
               */
              value: function _makeSubtreeUnfocusable(startNode) {
                var _this2 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this2._visitNode(node);
                });
                var activeElement = document.activeElement;

                if (!document.body.contains(startNode)) {
                  // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                  var node = startNode;
                  /** @type {!ShadowRoot|undefined} */

                  var root = undefined;

                  while (node) {
                    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      root =
                      /** @type {!ShadowRoot} */
                      node;
                      break;
                    }

                    node = node.parentNode;
                  }

                  if (root) {
                    activeElement = root.activeElement;
                  }
                }

                if (startNode.contains(activeElement)) {
                  activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1
                  // calling blur() will not actually move the focus.
                  // To work around this we call focus() on the body instead.

                  if (activeElement === document.activeElement) {
                    document.body.focus();
                  }
                }
              }
              /**
               * @param {!Node} node
               */

            }, {
              key: '_visitNode',
              value: function _visitNode(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!Element} */
                node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of
                // this inert root, so all of its managed nodes need to be adopted by this InertRoot.

                if (element !== this._rootElement && element.hasAttribute('inert')) {
                  this._adoptInertRoot(element);
                }

                if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                  this._manageNode(element);
                }
              }
              /**
               * Register the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_manageNode',
              value: function _manageNode(node) {
                var inertNode = this._inertManager.register(node, this);

                this._managedNodes.add(inertNode);
              }
              /**
               * Unregister the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_unmanageNode',
              value: function _unmanageNode(node) {
                var inertNode = this._inertManager.deregister(node, this);

                if (inertNode) {
                  this._managedNodes['delete'](inertNode);
                }
              }
              /**
               * Unregister the entire subtree starting at `startNode`.
               * @param {!Node} startNode
               */

            }, {
              key: '_unmanageSubtree',
              value: function _unmanageSubtree(startNode) {
                var _this3 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this3._unmanageNode(node);
                });
              }
              /**
               * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
               * @param {!Element} node
               */

            }, {
              key: '_adoptInertRoot',
              value: function _adoptInertRoot(node) {
                var inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,
                // so register it now if need be.


                if (!inertSubroot) {
                  this._inertManager.setInert(node, true);

                  inertSubroot = this._inertManager.getInertRoot(node);
                }

                inertSubroot.managedNodes.forEach(function (savedInertNode) {
                  this._manageNode(savedInertNode.node);
                }, this);
              }
              /**
               * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_onMutation',
              value: function _onMutation(records, self) {
                records.forEach(function (record) {
                  var target =
                  /** @type {!Element} */
                  record.target;

                  if (record.type === 'childList') {
                    // Manage added nodes
                    slice.call(record.addedNodes).forEach(function (node) {
                      this._makeSubtreeUnfocusable(node);
                    }, this); // Un-manage removed nodes

                    slice.call(record.removedNodes).forEach(function (node) {
                      this._unmanageSubtree(node);
                    }, this);
                  } else if (record.type === 'attributes') {
                    if (record.attributeName === 'tabindex') {
                      // Re-initialise inert node if tabindex changes
                      this._manageNode(target);
                    } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                      // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                      // already managed nodes from this inert subroot.
                      this._adoptInertRoot(target);

                      var inertSubroot = this._inertManager.getInertRoot(target);

                      this._managedNodes.forEach(function (managedNode) {
                        if (target.contains(managedNode.node)) {
                          inertSubroot._manageNode(managedNode.node);
                        }
                      });
                    }
                  }
                }, this);
              }
            }, {
              key: 'managedNodes',
              get: function get() {
                return new Set(this._managedNodes);
              }
              /** @return {boolean} */

            }, {
              key: 'hasSavedAriaHidden',
              get: function get() {
                return this._savedAriaHidden !== null;
              }
              /** @param {?string} ariaHidden */

            }, {
              key: 'savedAriaHidden',
              set: function set(ariaHidden) {
                this._savedAriaHidden = ariaHidden;
              }
              /** @return {?string} */
              ,
              get: function get() {
                return this._savedAriaHidden;
              }
            }]);

            return InertRoot;
          }();
          /**
           * `InertNode` initialises and manages a single inert node.
           * A node is inert if it is a descendant of one or more inert root elements.
           *
           * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
           * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
           * is intrinsically focusable or not.
           *
           * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
           * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
           * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
           * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
           * or removes the `tabindex` attribute if the element is intrinsically focusable.
           */


          var InertNode = function () {
            /**
             * @param {!Node} node A focusable element to be made inert.
             * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
             */
            function InertNode(node, inertRoot) {
              _classCallCheck(this, InertNode);
              /** @type {!Node} */


              this._node = node;
              /** @type {boolean} */

              this._overrodeFocusMethod = false;
              /**
               * @type {!Set<!InertRoot>} The set of descendant inert roots.
               *    If and only if this set becomes empty, this node is no longer inert.
               */

              this._inertRoots = new Set([inertRoot]);
              /** @type {?number} */

              this._savedTabIndex = null;
              /** @type {boolean} */

              this._destroyed = false; // Save any prior tabindex info and make this node untabbable

              this.ensureUntabbable();
            }
            /**
             * Call this whenever this object is about to become obsolete.
             * This makes the managed node focusable again and deletes all of the previously stored state.
             */


            _createClass(InertNode, [{
              key: 'destructor',
              value: function destructor() {
                this._throwIfDestroyed();

                if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                  var element =
                  /** @type {!Element} */
                  this._node;

                  if (this._savedTabIndex !== null) {
                    element.setAttribute('tabindex', this._savedTabIndex);
                  } else {
                    element.removeAttribute('tabindex');
                  } // Use `delete` to restore native focus method.


                  if (this._overrodeFocusMethod) {
                    delete element.focus;
                  }
                } // See note in InertRoot.destructor for why we cast these nulls to ANY.


                this._node =
                /** @type {?} */
                null;
                this._inertRoots =
                /** @type {?} */
                null;
                this._destroyed = true;
              }
              /**
               * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
               * If the object has been destroyed, any attempt to access it will cause an exception.
               */

            }, {
              key: '_throwIfDestroyed',

              /**
               * Throw if user tries to access destroyed InertNode.
               */
              value: function _throwIfDestroyed() {
                if (this.destroyed) {
                  throw new Error('Trying to access destroyed InertNode');
                }
              }
              /** @return {boolean} */

            }, {
              key: 'ensureUntabbable',

              /** Save the existing tabindex value and make the node untabbable and unfocusable */
              value: function ensureUntabbable() {
                if (this.node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!Element} */
                this.node;

                if (matches.call(element, _focusableElementsString)) {
                  if (
                  /** @type {!HTMLElement} */
                  element.tabIndex === -1 && this.hasSavedTabIndex) {
                    return;
                  }

                  if (element.hasAttribute('tabindex')) {
                    this._savedTabIndex =
                    /** @type {!HTMLElement} */
                    element.tabIndex;
                  }

                  element.setAttribute('tabindex', '-1');

                  if (element.nodeType === Node.ELEMENT_NODE) {
                    element.focus = function () {};

                    this._overrodeFocusMethod = true;
                  }
                } else if (element.hasAttribute('tabindex')) {
                  this._savedTabIndex =
                  /** @type {!HTMLElement} */
                  element.tabIndex;
                  element.removeAttribute('tabindex');
                }
              }
              /**
               * Add another inert root to this inert node's set of managing inert roots.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'addInertRoot',
              value: function addInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots.add(inertRoot);
              }
              /**
               * Remove the given inert root from this inert node's set of managing inert roots.
               * If the set of managing inert roots becomes empty, this node is no longer inert,
               * so the object should be destroyed.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'removeInertRoot',
              value: function removeInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots['delete'](inertRoot);

                if (this._inertRoots.size === 0) {
                  this.destructor();
                }
              }
            }, {
              key: 'destroyed',
              get: function get() {
                return (
                  /** @type {!InertNode} */
                  this._destroyed
                );
              }
            }, {
              key: 'hasSavedTabIndex',
              get: function get() {
                return this._savedTabIndex !== null;
              }
              /** @return {!Node} */

            }, {
              key: 'node',
              get: function get() {
                this._throwIfDestroyed();

                return this._node;
              }
              /** @param {?number} tabIndex */

            }, {
              key: 'savedTabIndex',
              set: function set(tabIndex) {
                this._throwIfDestroyed();

                this._savedTabIndex = tabIndex;
              }
              /** @return {?number} */
              ,
              get: function get() {
                this._throwIfDestroyed();

                return this._savedTabIndex;
              }
            }]);

            return InertNode;
          }();
          /**
           * InertManager is a per-document singleton object which manages all inert roots and nodes.
           *
           * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
           * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
           * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
           * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
           * is created for each such node, via the `_managedNodes` map.
           */


          var InertManager = function () {
            /**
             * @param {!Document} document
             */
            function InertManager(document) {
              _classCallCheck(this, InertManager);

              if (!document) {
                throw new Error('Missing required argument; InertManager needs to wrap a document.');
              }
              /** @type {!Document} */


              this._document = document;
              /**
               * All managed nodes known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertNode>}
               */

              this._managedNodes = new Map();
              /**
               * All inert roots known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertRoot>}
               */

              this._inertRoots = new Map();
              /**
               * Observer for mutations on `document.body`.
               * @type {!MutationObserver}
               */

              this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.

              addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.

              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
              } else {
                this._onDocumentLoaded();
              }
            }
            /**
             * Set whether the given element should be an inert root or not.
             * @param {!Element} root
             * @param {boolean} inert
             */


            _createClass(InertManager, [{
              key: 'setInert',
              value: function setInert(root, inert) {
                if (inert) {
                  if (this._inertRoots.has(root)) {
                    // element is already inert
                    return;
                  }

                  var inertRoot = new InertRoot(root, this);
                  root.setAttribute('inert', '');

                  this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.
                  // Ensure inert styles are added there.


                  if (!this._document.body.contains(root)) {
                    var parent = root.parentNode;

                    while (parent) {
                      if (parent.nodeType === 11) {
                        addInertStyle(parent);
                      }

                      parent = parent.parentNode;
                    }
                  }
                } else {
                  if (!this._inertRoots.has(root)) {
                    // element is already non-inert
                    return;
                  }

                  var _inertRoot = this._inertRoots.get(root);

                  _inertRoot.destructor();

                  this._inertRoots['delete'](root);

                  root.removeAttribute('inert');
                }
              }
              /**
               * Get the InertRoot object corresponding to the given inert root element, if any.
               * @param {!Node} element
               * @return {!InertRoot|undefined}
               */

            }, {
              key: 'getInertRoot',
              value: function getInertRoot(element) {
                return this._inertRoots.get(element);
              }
              /**
               * Register the given InertRoot as managing the given node.
               * In the case where the node has a previously existing inert root, this inert root will
               * be added to its set of inert roots.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {!InertNode} inertNode
               */

            }, {
              key: 'register',
              value: function register(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (inertNode !== undefined) {
                  // node was already in an inert subtree
                  inertNode.addInertRoot(inertRoot);
                } else {
                  inertNode = new InertNode(node, inertRoot);
                }

                this._managedNodes.set(node, inertNode);

                return inertNode;
              }
              /**
               * De-register the given InertRoot as managing the given inert node.
               * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
               * node from the InertManager's set of managed nodes if it is destroyed.
               * If the node is not currently managed, this is essentially a no-op.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
               */

            }, {
              key: 'deregister',
              value: function deregister(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (!inertNode) {
                  return null;
                }

                inertNode.removeInertRoot(inertRoot);

                if (inertNode.destroyed) {
                  this._managedNodes['delete'](node);
                }

                return inertNode;
              }
              /**
               * Callback used when document has finished loading.
               */

            }, {
              key: '_onDocumentLoaded',
              value: function _onDocumentLoaded() {
                // Find all inert roots in document and make them actually inert.
                var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
                inertElements.forEach(function (inertElement) {
                  this.setInert(inertElement, true);
                }, this); // Comment this out to use programmatic API only.

                this._observer.observe(this._document.body || this._document.documentElement, {
                  attributes: true,
                  subtree: true,
                  childList: true
                });
              }
              /**
               * Callback used when mutation observer detects attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_watchForInert',
              value: function _watchForInert(records, self) {
                var _this = this;

                records.forEach(function (record) {
                  switch (record.type) {
                    case 'childList':
                      slice.call(record.addedNodes).forEach(function (node) {
                        if (node.nodeType !== Node.ELEMENT_NODE) {
                          return;
                        }

                        var inertElements = slice.call(node.querySelectorAll('[inert]'));

                        if (matches.call(node, '[inert]')) {
                          inertElements.unshift(node);
                        }

                        inertElements.forEach(function (inertElement) {
                          this.setInert(inertElement, true);
                        }, _this);
                      }, _this);
                      break;

                    case 'attributes':
                      if (record.attributeName !== 'inert') {
                        return;
                      }

                      var target =
                      /** @type {!Element} */
                      record.target;
                      var inert = target.hasAttribute('inert');

                      _this.setInert(target, inert);

                      break;
                  }
                }, this);
              }
            }]);

            return InertManager;
          }();
          /**
           * Recursively walk the composed tree from |node|.
           * @param {!Node} node
           * @param {(function (!Element))=} callback Callback to be called for each element traversed,
           *     before descending into child nodes.
           * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
           */


          function composedTreeWalk(node, callback, shadowRootAncestor) {
            if (node.nodeType == Node.ELEMENT_NODE) {
              var element =
              /** @type {!Element} */
              node;

              if (callback) {
                callback(element);
              } // Descend into node:
              // If it has a ShadowRoot, ignore all child elements - these will be picked
              // up by the <content> or <shadow> elements. Descend straight into the
              // ShadowRoot.


              var shadowRoot =
              /** @type {!HTMLElement} */
              element.shadowRoot;

              if (shadowRoot) {
                composedTreeWalk(shadowRoot, callback);
                return;
              } // If it is a <content> element, descend into distributed elements - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'content') {
                var content =
                /** @type {!HTMLContentElement} */
                element; // Verifies if ShadowDom v0 is supported.

                var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];

                for (var i = 0; i < distributedNodes.length; i++) {
                  composedTreeWalk(distributedNodes[i], callback);
                }

                return;
              } // If it is a <slot> element, descend into assigned nodes - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'slot') {
                var slot =
                /** @type {!HTMLSlotElement} */
                element; // Verify if ShadowDom v1 is supported.

                var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                  flatten: true
                }) : [];

                for (var _i = 0; _i < _distributedNodes.length; _i++) {
                  composedTreeWalk(_distributedNodes[_i], callback);
                }

                return;
              }
            } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
            // element, nor a <shadow> element recurse normally.


            var child = node.firstChild;

            while (child != null) {
              composedTreeWalk(child, callback);
              child = child.nextSibling;
            }
          }
          /**
           * Adds a style element to the node containing the inert specific styles
           * @param {!Node} node
           */


          function addInertStyle(node) {
            if (node.querySelector('style#inert-style, link#inert-style')) {
              return;
            }

            var style = document.createElement('style');
            style.setAttribute('id', 'inert-style');
            style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
            node.appendChild(style);
          }

          if (!Element.prototype.hasOwnProperty('inert')) {
            /** @type {!InertManager} */
            var inertManager = new InertManager(document);
            Object.defineProperty(Element.prototype, 'inert', {
              enumerable: true,

              /** @this {!Element} */
              get: function get() {
                return this.hasAttribute('inert');
              },

              /** @this {!Element} */
              set: function set(inert) {
                inertManager.setInert(this, inert);
              }
            });
          }
        })();
      });
    });

    var blockingElements = document.$blockingElements;
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */

    function useBlockingElement(target) {
      /**
       * Push/pop the element from the blockingElements stack.
       */
      h(() => {
        if (target) {
          blockingElements.push(target);
          return () => {
            blockingElements.remove(target);
          };
        }
      }, [target]);
    }
    function getTopElement() {
      return blockingElements.top;
    }

    var elementsToRestoreFocusTo = new Map();
    function useFocusTrap({
      trapActive
    }) {
      var {
        element,
        useRefElementProps,
        getElement
      } = useRefElement();
      var {
        getLastActiveElement
      } = useActiveElement(); // When the trap becomes active, before we let the blockingElements hook run,
      // keep track of whatever's currently focused and save it.

      h(() => {
        if (trapActive && element) {
          var _getLastActiveElement;

          // Save the currently focused element
          // to whatever's currently at the top of the stack
          elementsToRestoreFocusTo.set(getTopElement(), (_getLastActiveElement = getLastActiveElement()) !== null && _getLastActiveElement !== void 0 ? _getLastActiveElement : document.body);
        }
      }, [trapActive, element]);
      useBlockingElement(trapActive ? element : null);
      /**
       * Any time we activate or deactivate the trap,
       * change focus to something else (something in
       * the trap if it's active, or whatever we've
       * tracked in elementsToRestoreFocusTo if not)
       */

      h(() => {
        if (trapActive && element) {
          var rafHandle = requestAnimationFrame(() => {
            // TODO: This extra queueMicrotask is needed for
            // ...reasons?
            queueMicrotask(() => {
              var _findFirstFocusable;

              (_findFirstFocusable = findFirstFocusable(element)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        } else if (element) {
          // Restore the focus to the element
          // that has returned to the top of the stack
          var _rafHandle = requestAnimationFrame(() => {
            queueMicrotask(() => {
              var _elementsToRestoreFoc;

              (_elementsToRestoreFoc = elementsToRestoreFocusTo.get(getTopElement())) === null || _elementsToRestoreFoc === void 0 ? void 0 : _elementsToRestoreFoc.focus();
              _rafHandle = 0;
            });
          });

          return () => {
            if (_rafHandle) cancelAnimationFrame(_rafHandle);
          };
        }
      }, [trapActive, element]);

      var useFocusTrapProps = props => {
        return useMergedProps()({
          "aria-modal": trapActive ? "true" : undefined
        }, useRefElementProps(props));
      };

      return {
        useFocusTrapProps,
        element,
        getElement
      };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */

    function findFirstFocusable(element) {
      var treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: node => node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      });
      var firstFocusable = treeWalker.firstChild();
      return firstFocusable;
    }

    function useForceUpdate() {
      var [, set] = l(0);
      return s(() => set(i => ++i)).current;
    }

    function useAriaTooltip({
      mouseoverDelay
    }) {
      var _mouseoverDelay;

      (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
      var [open, setOpen, getOpen] = useState(false);
      var [hasAnyMouseover, setHasAnyMouseover] = useState(false); //const [mouseoverIsValid, setMouseoverIsValid] = useState(false);

      var {
        useRandomIdProps: useTooltipIdProps,
        useReferencedIdProps: useTooltipIdReferencingProps
      } = useRandomId({
        prefix: "aria-tooltip-"
      });
      var {
        focusedInner: triggerFocused,
        useHasFocusProps
      } = useHasFocus();
      var [triggerHasMouseover, setTriggerHasMouseover] = useState(false);
      var [tooltipHasMouseover, setTooltipHasMouseover] = useState(false);
      useTimeout({
        timeout: mouseoverDelay,
        triggerIndex: +triggerHasMouseover + +tooltipHasMouseover,
        callback: () => {
          if (triggerHasMouseover || tooltipHasMouseover) setHasAnyMouseover(true);
        }
      });
      useTimeout({
        timeout: 50,
        triggerIndex: +triggerHasMouseover + +tooltipHasMouseover,
        callback: () => {
          if (!triggerHasMouseover && !tooltipHasMouseover) setHasAnyMouseover(false);
        }
      });
      y(() => {
        setOpen(hasAnyMouseover || triggerFocused);
      }, [hasAnyMouseover, triggerFocused]);
      var useTooltipTrigger = A$1(function useTooltipTrigger() {
        function onPointerEnter(e) {
          setTriggerHasMouseover(true);
        }

        function onPointerLeave(e) {
          setTriggerHasMouseover(false);
        }

        function useTooltipTriggerProps(_ref) {
          var props = _extends({}, _ref);

          // Note: Though it's important to make sure that focusing activates a tooltip,
          // it's perfectly reasonable that a child element will be the one that's focused,
          // not this one, so we don't set tabIndex=0
          return useTooltipIdReferencingProps("aria-describedby")(useMergedProps()({
            onPointerEnter,
            onPointerLeave
          }, useHasFocusProps(props)));
        }

        return {
          useTooltipTriggerProps
        };
      }, [useTooltipIdReferencingProps]);
      var useTooltip = A$1(function useTooltip() {
        function onPointerEnter(e) {
          setTooltipHasMouseover(true);
        }

        function onPointerLeave(e) {
          setTooltipHasMouseover(false);
        }

        function useTooltipProps(_ref2) {
          var props = _extends({}, _ref2);

          props.role = "tooltip";
          return useTooltipIdProps(useMergedProps()({
            onPointerEnter,
            onPointerLeave
          }, props));
        }

        return {
          useTooltipProps
        };
      }, [useTooltipIdProps]);
      return {
        useTooltip,
        useTooltipTrigger,
        isOpen: open,
        getIsOpen: getOpen
      };
    }

    function S(n, t) {
      for (var e in t) {
        n[e] = t[e];
      }

      return n;
    }

    function C(n, t) {
      for (var e in n) {
        if ("__source" !== e && !(e in t)) return !0;
      }

      for (var r in t) {
        if ("__source" !== r && n[r] !== t[r]) return !0;
      }

      return !1;
    }

    function E(n) {
      this.props = n;
    }

    function g(n, t) {
      function e(n) {
        var e = this.props.ref,
            r = e == n.ref;
        return !r && e && (e.call ? e(null) : e.current = null), t ? !t(this.props, n) || !r : C(this.props, n);
      }

      function r(t) {
        return this.shouldComponentUpdate = e, v$1(n, t);
      }

      return r.displayName = "Memo(" + (n.displayName || n.name) + ")", r.prototype.isReactComponent = !0, r.__f = !0, r;
    }

    (E.prototype = new _$1()).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function (n, t) {
      return C(this.props, n) || C(this.state, t);
    };
    var w = l$1.__b;

    l$1.__b = function (n) {
      n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), w && w(n);
    };

    var R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;

    function x(n) {
      function t(t, e) {
        var r = S({}, t);
        return delete r.ref, n(r, (e = t.ref || e) && ("object" != typeof e || "current" in e) ? e : null);
      }

      return t.$$typeof = R, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
    }

    var A = l$1.__e;

    l$1.__e = function (n, t, e) {
      if (n.then) for (var r, u = t; u = u.__;) {
        if ((r = u.__c) && r.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), r.__c(n, t);
      }
      A(n, t, e);
    };

    var O = l$1.unmount;

    function L() {
      this.__u = 0, this.t = null, this.__b = null;
    }

    function U(n) {
      var t = n.__.__c;
      return t && t.__e && t.__e(n);
    }

    function M() {
      this.u = null, this.o = null;
    }

    l$1.unmount = function (n) {
      var t = n.__c;
      t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), O && O(n);
    }, (L.prototype = new _$1()).__c = function (n, t) {
      var e = t.__c,
          r = this;
      null == r.t && (r.t = []), r.t.push(e);

      var u = U(r.__v),
          o = !1,
          i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };

      e.__R = i;

      var l = function () {
        if (! --r.__u) {
          if (r.state.__e) {
            var n = r.state.__e;

            r.__v.__k[0] = function n(t, e, r) {
              return t && (t.__v = null, t.__k = t.__k && t.__k.map(function (t) {
                return n(t, e, r);
              }), t.__c && t.__c.__P === e && (t.__e && r.insertBefore(t.__e, t.__d), t.__c.__e = !0, t.__c.__P = r)), t;
            }(n, n.__c.__P, n.__c.__O);
          }

          var t;

          for (r.setState({
            __e: r.__b = null
          }); t = r.t.pop();) {
            t.forceUpdate();
          }
        }
      },
          f = !0 === t.__h;

      r.__u++ || f || r.setState({
        __e: r.__b = r.__v.__k[0]
      }), n.then(i, i);
    }, L.prototype.componentWillUnmount = function () {
      this.t = [];
    }, L.prototype.render = function (n, t) {
      if (this.__b) {
        if (this.__v.__k) {
          var e = document.createElement("div"),
              r = this.__v.__k[0].__c;

          this.__v.__k[0] = function n(t, e, r) {
            return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach(function (n) {
              "function" == typeof n.__c && n.__c();
            }), t.__c.__H = null), null != (t = S({}, t)).__c && (t.__c.__P === r && (t.__c.__P = e), t.__c = null), t.__k = t.__k && t.__k.map(function (t) {
              return n(t, e, r);
            })), t;
          }(this.__b, e, r.__O = r.__P);
        }

        this.__b = null;
      }

      var u = t.__e && v$1(d$1, null, n.fallback);
      return u && (u.__h = null), [v$1(d$1, null, t.__e ? null : n.children), u];
    };

    var T = function (n, t, e) {
      if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
        for (; e.length > 3;) {
          e.pop()();
        }

        if (e[1] < e[0]) break;
        n.u = e = e[2];
      }
    };

    function D(n) {
      return this.getChildContext = function () {
        return n.context;
      }, n.children;
    }

    function I(n) {
      var t = this,
          e = n.i;
      t.componentWillUnmount = function () {
        S$1(null, t.l), t.l = null, t.i = null;
      }, t.i && t.i !== e && t.componentWillUnmount(), n.__v ? (t.l || (t.i = e, t.l = {
        nodeType: 1,
        parentNode: e,
        childNodes: [],
        appendChild: function (n) {
          this.childNodes.push(n), t.i.appendChild(n);
        },
        insertBefore: function (n, e) {
          this.childNodes.push(n), t.i.appendChild(n);
        },
        removeChild: function (n) {
          this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), t.i.removeChild(n);
        }
      }), S$1(v$1(D, {
        context: t.context
      }, n.__v), t.l)) : t.l && t.componentWillUnmount();
    }

    function W(n, t) {
      return v$1(I, {
        __v: n,
        i: t
      });
    }

    (M.prototype = new _$1()).__e = function (n) {
      var t = this,
          e = U(t.__v),
          r = t.o.get(n);
      return r[0]++, function (u) {
        var o = function () {
          t.props.revealOrder ? (r.push(u), T(t, n, r)) : u();
        };

        e ? e(o) : o();
      };
    }, M.prototype.render = function (n) {
      this.u = null, this.o = new Map();
      var t = A$2(n.children);
      n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

      for (var e = t.length; e--;) {
        this.o.set(t[e], this.u = [1, 0, this.u]);
      }

      return n.children;
    }, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function () {
      var n = this;
      this.o.forEach(function (t, e) {
        T(n, e, t);
      });
    };

    var j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        P = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        V = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };

    _$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (n) {
      Object.defineProperty(_$1.prototype, n, {
        configurable: !0,
        get: function () {
          return this["UNSAFE_" + n];
        },
        set: function (t) {
          Object.defineProperty(this, n, {
            configurable: !0,
            writable: !0,
            value: t
          });
        }
      });
    });
    var H = l$1.event;

    function Z() {}

    function Y() {
      return this.cancelBubble;
    }

    function $() {
      return this.defaultPrevented;
    }

    l$1.event = function (n) {
      return H && (n = H(n)), n.persist = Z, n.isPropagationStopped = Y, n.isDefaultPrevented = $, n.nativeEvent = n;
    };

    var G = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
        J = l$1.vnode;

    l$1.vnode = function (n) {
      var t = n.type,
          e = n.props,
          r = e;

      if ("string" == typeof t) {
        for (var u in r = {}, e) {
          var o = e[u];
          "value" === u && "defaultValue" in e && null == o || ("defaultValue" === u && "value" in e && null == e.value ? u = "value" : "download" === u && !0 === o ? o = "" : /ondoubleclick/i.test(u) ? u = "ondblclick" : /^onchange(textarea|input)/i.test(u + t) && !V(e.type) ? u = "oninput" : /^on(Ani|Tra|Tou|BeforeInp)/.test(u) ? u = u.toLowerCase() : P.test(u) ? u = u.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === o && (o = void 0), r[u] = o);
        }

        "select" == t && r.multiple && Array.isArray(r.value) && (r.value = A$2(e.children).forEach(function (n) {
          n.props.selected = -1 != r.value.indexOf(n.props.value);
        })), "select" == t && null != r.defaultValue && (r.value = A$2(e.children).forEach(function (n) {
          n.props.selected = r.multiple ? -1 != r.defaultValue.indexOf(n.props.value) : r.defaultValue == n.props.value;
        })), n.props = r;
      }

      t && e.class != e.className && (G.enumerable = "className" in e, null != e.className && (r.class = e.className), Object.defineProperty(r, "className", G)), n.$$typeof = j, J && J(n);
    };

    var K = l$1.__r;

    l$1.__r = function (n) {
      K && K(n);
    };

    /**
     * Shortcut for preact/compat's `forwardRef` that auto-assumes some things that are useful for forwarding refs to `HTMLElements` specifically.
     * Namely it involves de-gunking the type system by letting us return *generic* function and playing nice with React. In all other respects, it acts like `forwardRef`.
     */

    function forwardElementRef$1(Component) {
      var ForwardedComponent = x(Component);
      return ForwardedComponent;
    }

    var _excluded$E = ["children", "duration", "classBase", "measure", "exitVisibility", "open", "onTransitionUpdate", "animateOnMount"];

    function getClassName(classBase, open, phase) {
      if (phase) return "".concat(classBase || "transition", "-").concat(open, "-").concat(phase);else return "".concat(classBase || "transition", "-").concat(open);
    }

    function forceReflow(e) {
      // Try really hard to make sure this isn't optimized out by anything.
      // We need it for its document reflow side effect.
      e.getBoundingClientRect();
      return e;
    }
    /**
     * A hook that adds & removes class names in a way that facilitates proper transitions.
     *
     * The first argument contains the props related directly to the transition.
     *
     * The second argument contains any other props you might want merged into the final product (these are not read or manipulated or anything -- it's purely shorthand and can be omitted with `{}` and then your own `useMergedProps`).
     */


    function useCreateTransitionableProps({
      measure,
      animateOnMount,
      classBase,
      onTransitionUpdate,
      exitVisibility,
      duration,
      open,
      ref
    }, otherProps) {
      var _classBase;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      var {
        element,
        useRefElementProps
      } = useRefElement();
      var [phase, setPhase] = l(animateOnMount ? "init" : null);
      var [direction, setDirection] = l(open == null ? null : open ? "enter" : "exit");
      var [surfaceWidth, setSurfaceWidth] = l(null);
      var [surfaceHeight, setSurfaceHeight] = l(null);
      var [surfaceX, setSurfaceX] = l(null);
      var [surfaceY, setSurfaceY] = l(null);
      var [transitioningWidth, setTransitioningWidth] = l(null);
      var [transitioningHeight, setTransitioningHeight] = l(null);
      var [transitioningX, setTransitioningX] = l(null);
      var [transitioningY, setTransitioningY] = l(null);
      var {
        getLogicalDirection
      } = useLogicalDirection(element);
      var logicalDirection = getLogicalDirection();
      var onTransitionUpdateRef = s(onTransitionUpdate);
      var phaseRef = s(phase);
      var directionRef = s(direction);
      var durationRef = s(duration);
      var tooEarlyTimeoutRef = s(null);
      var tooEarlyValueRef = s(true);
      var tooLateTimeoutRef = s(null);
      var onTransitionEnd = A$1(e => {
        if (e.target === element && tooEarlyValueRef.current == false) {
          setPhase("finalize");
        }
      }, [element]);
      h(() => {
        onTransitionUpdateRef.current = onTransitionUpdate;
      }, [onTransitionUpdate]);
      h(() => {
        phaseRef.current = phase;
      }, [phase]);
      h(() => {
        directionRef.current = direction;
      }, [direction]);
      h(() => {
        durationRef.current = duration;
      }, [duration]);
      h(() => {
        var _onTransitionUpdateRe;

        if (direction && phase) (_onTransitionUpdateRe = onTransitionUpdateRef.current) === null || _onTransitionUpdateRe === void 0 ? void 0 : _onTransitionUpdateRe.call(onTransitionUpdateRef, direction, phase);
      }, [direction, phase]); // Every time the phase changes to "transition", add our transition timeout timeouts
      // to catch any time onTransitionEnd fails to report for whatever reason to be safe

      h(() => {
        if (phase == "transition") {
          var _durationRef$current;

          var timeoutDuration = (_durationRef$current = durationRef.current) !== null && _durationRef$current !== void 0 ? _durationRef$current : 1000;
          tooEarlyTimeoutRef.current = window.setTimeout(() => {
            tooEarlyValueRef.current = false;
            tooEarlyTimeoutRef.current = null;
          }, 50);
          tooLateTimeoutRef.current = window.setTimeout(() => {
            tooEarlyValueRef.current = true;
            tooLateTimeoutRef.current = null;
            setPhase("finalize");
          }, timeoutDuration);
        }

        return () => {
          if (tooEarlyTimeoutRef.current) clearTimeout(tooEarlyTimeoutRef.current);
          if (tooLateTimeoutRef.current) clearTimeout(tooLateTimeoutRef.current);
        };
      }, [phase]); // Any time "open" changes, update our direction and phase.
      // In addition, measure the size of the element if requested.

      h(() => {
        if (element && open != null) {
          var previousPhase = phaseRef.current; // Swap our direction

          if (open) setDirection("enter");else setDirection("exit");
          setPhase(previousPhase === null ? "finalize" : "init");

          if (measure) {
            var currentSizeWithTransition = element.getBoundingClientRect();
            {
              var {
                x,
                y,
                width,
                height
              } = currentSizeWithTransition;
              setTransitioningX(x + "px");
              setTransitioningY(y + "px");
              setTransitioningWidth(width + "px");
              setTransitioningHeight(height + "px");
            }

            if (previousPhase === "finalize") {
              // We're going to be messing with the actual element's class, 
              // so we'll want an easy way to restore it later.
              var backup = element.className;
              element.classList.add("".concat(classBase, "-measure"));
              element.classList.remove("".concat(classBase, "-enter"), "".concat(classBase, "-enter-init"), "".concat(classBase, "-enter-transition"), "".concat(classBase, "-enter-finalize"), "".concat(classBase, "-exit"), "".concat(classBase, "-exit-init"), "".concat(classBase, "-exit-transition"), "".concat(classBase, "-exit-finalize"));
              forceReflow(element);
              var sizeWithoutTransition = element.getBoundingClientRect();
              var {
                x: _x,
                y: _y,
                width: _width,
                height: _height
              } = sizeWithoutTransition;
              setSurfaceX(_x + "px");
              setSurfaceY(_y + "px");
              setSurfaceWidth(_width + "px");
              setSurfaceHeight(_height + "px");
              element.className = backup;
              forceReflow(element);
            }
          }
        }
      }, [open, element, measure, classBase]); // Any time the phase changes to init, immediately before the screen is painted,
      // change the phase to "transition" and re-render ().

      h(() => {
        if (element && directionRef.current != null) {
          var _classBase2;

          (_classBase2 = classBase) !== null && _classBase2 !== void 0 ? _classBase2 : classBase = "transition";

          if (phase === "init") {
            // Preact just finished rendering init
            // Now set our transition style.
            setPhase("transition");

            if (measure) {
              forceReflow(element);
            }
          }
        }
      }, [phase, measure, element]);
      var inlineDirection = logicalDirection === null || logicalDirection === void 0 ? void 0 : logicalDirection.inlineDirection;
      var blockDirection = logicalDirection === null || logicalDirection === void 0 ? void 0 : logicalDirection.blockDirection;
      var writingModeIsHorizontal = inlineDirection == "rtl" || inlineDirection == "ltr";
      var surfaceInlineInset = writingModeIsHorizontal ? surfaceX : surfaceY;
      var surfaceBlockInset = writingModeIsHorizontal ? surfaceY : surfaceX;
      var surfaceInlineSize = writingModeIsHorizontal ? surfaceWidth : surfaceHeight;
      var surfaceBlockSize = writingModeIsHorizontal ? surfaceHeight : surfaceWidth;
      var transitioningInlineInset = writingModeIsHorizontal ? transitioningX : transitioningY;
      var transitioningBlockInset = writingModeIsHorizontal ? transitioningY : transitioningX;
      var transitioningInlineSize = writingModeIsHorizontal ? transitioningWidth : transitioningHeight;
      var transitioningBlockSize = writingModeIsHorizontal ? transitioningHeight : transitioningWidth;
      var almostDone = useRefElementProps(_objectSpread2(_objectSpread2({
        ref,
        style: removeEmpty({
          ["--".concat(classBase, "-duration")]: duration,
          ["--".concat(classBase, "-surface-x")]: surfaceX,
          ["--".concat(classBase, "-surface-y")]: surfaceY,
          ["--".concat(classBase, "-surface-width")]: surfaceWidth,
          ["--".concat(classBase, "-surface-height")]: surfaceHeight,
          ["--".concat(classBase, "-surface-inline-inset")]: surfaceInlineInset,
          ["--".concat(classBase, "-surface-block-inset")]: surfaceBlockInset,
          ["--".concat(classBase, "-surface-inline-size")]: surfaceInlineSize,
          ["--".concat(classBase, "-surface-block-size")]: surfaceBlockSize,
          ["--".concat(classBase, "-transitioning-x")]: transitioningX,
          ["--".concat(classBase, "-transitioning-y")]: transitioningY,
          ["--".concat(classBase, "-transitioning-width")]: transitioningWidth,
          ["--".concat(classBase, "-transitioning-height")]: transitioningHeight,
          ["--".concat(classBase, "-transitioning-inline-inset")]: transitioningInlineInset,
          ["--".concat(classBase, "-transitioning-block-inset")]: transitioningBlockInset,
          ["--".concat(classBase, "-transitioning-inline-size")]: transitioningInlineSize,
          ["--".concat(classBase, "-transitioning-block-size")]: transitioningBlockSize
        }),
        onTransitionEnd
      }, {
        "aria-hidden": open ? undefined : "true"
      }), {}, {
        className: clsx(direction && getClassName(classBase, direction), direction && phase && getClassName(classBase, direction, phase), exitVisibility == "removed" && "".concat(classBase, "-removed-on-exit"), exitVisibility == "visible" && "".concat(classBase, "-visible-on-exit"), "".concat(classBase, "-inline-direction-").concat(inlineDirection !== null && inlineDirection !== void 0 ? inlineDirection : "ltr"), "".concat(classBase, "-block-direction-").concat(blockDirection !== null && blockDirection !== void 0 ? blockDirection : "ttb"))
      }));
      return useMergedProps()(almostDone, otherProps);
    }

    function removeEmpty(obj) {
      return Object.fromEntries(Object.entries(obj).filter(([_, v]) => v != null));
    }
    /**
     * A component that *wraps an HTMLElement or other ref-forwarding component* and allows it to use CSS to transition in/out.
     * Combines the props passed to it, the props its child has, and the props needed for the CSS transition, and passes them
     * all to the child element you provide.
     *
     * This is the most general component that others use as a base. By default, this component by itself doesn't actually add any CSS classes that animate anything (like opacity, for example).
     * It adds classes like `transition-enter-finalize`, but you need to provide the additional e.g. `fade` class that reacts to it.
     *
     * Use this if the other, more specialized Transition components don't fit your needs.
     *
     * @example `<Transitionable open={open} {...useCreateFadeProps(...)}><div>{children}</div></Transitionable>`
     * @example `<Transitionable open={open}><div {...useCreateFadeProps(...)}>{children}</div></Transitionable>`
     */


    var Transitionable = forwardElementRef$1(function Transition(_ref, r) {
      var {
        children: child,
        duration,
        classBase,
        measure,
        exitVisibility,
        open,
        onTransitionUpdate,
        animateOnMount
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$E);

      if (!childIsVNode(child)) {
        throw new Error("A Transitionable component must have exactly one component child (e.g. a <div>, but not \"a string\").");
      }

      var transitionProps = useCreateTransitionableProps({
        classBase,
        duration,
        measure,
        open,
        animateOnMount,
        onTransitionUpdate,
        ref: r,
        exitVisibility
      }, props);
      var mergedWithChildren = useMergedProps()(transitionProps, _objectSpread2(_objectSpread2({}, child.props), {}, {
        ref: child.ref
      }));
      return B(child, mergedWithChildren);
    });

    function childIsVNode(child) {
      if (!child) return false;

      if (Array.isArray(child)) {
        return false;
      }

      if (typeof child != "object") return false;
      return "props" in child;
    }

    var _excluded$D = ["classBase", "clipOrigin", "clipOriginInline", "clipOriginBlock", "clipMin", "clipMinInline", "clipMinBlock", "open"];
    /**
     * Creates a set of props that implement a Clip transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     * Be sure to merge these returned props with whatever the user passed in.
     */

    function useCreateClipProps({
      classBase,
      clipOrigin,
      clipOriginInline,
      clipOriginBlock,
      clipMin,
      clipMinInline,
      clipMinBlock
    }, otherProps) {
      var _classBase, _ref, _ref2, _ref3, _ref4;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      return useMergedProps()({
        className: clsx("".concat(classBase, "-clip")),
        classBase,
        style: {
          ["--".concat(classBase, "-clip-origin-inline")]: (_ref = clipOriginInline !== null && clipOriginInline !== void 0 ? clipOriginInline : clipOrigin) !== null && _ref !== void 0 ? _ref : 0.5,
          ["--".concat(classBase, "-clip-origin-block")]: (_ref2 = clipOriginBlock !== null && clipOriginBlock !== void 0 ? clipOriginBlock : clipOrigin) !== null && _ref2 !== void 0 ? _ref2 : 0,
          ["--".concat(classBase, "-clip-min-inline")]: (_ref3 = clipMinInline !== null && clipMinInline !== void 0 ? clipMinInline : clipMin) !== null && _ref3 !== void 0 ? _ref3 : 1,
          ["--".concat(classBase, "-clip-min-block")]: (_ref4 = clipMinBlock !== null && clipMinBlock !== void 0 ? clipMinBlock : clipMin) !== null && _ref4 !== void 0 ? _ref4 : 0
        }
      }, otherProps);
    }
    var Clip = forwardElementRef$1(function Clip(_ref5, ref) {
      var {
        classBase,
        clipOrigin,
        clipOriginInline,
        clipOriginBlock,
        clipMin,
        clipMinInline,
        clipMinBlock,
        open
      } = _ref5,
          rest = _objectWithoutProperties(_ref5, _excluded$D);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateClipProps({
        classBase,
        clipOrigin,
        clipOriginInline,
        clipOriginBlock,
        clipMin,
        clipMinInline,
        clipMinBlock
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$C = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Creates a set of props that implement a Fade transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     * Be sure to merge these returned props with whatever the user passed in.
     */

    function useCreateFadeProps({
      classBase,
      fadeMin,
      fadeMax
    }, otherProps) {
      var _classBase;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      return useMergedProps()({
        className: "".concat(classBase, "-fade"),
        classBase,
        style: {
          ["--".concat(classBase, "-fade-min")]: fadeMin !== null && fadeMin !== void 0 ? fadeMin : 0,
          ["--".concat(classBase, "-fade-max")]: fadeMax !== null && fadeMax !== void 0 ? fadeMax : 1
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Fade effect.
     *
     * Note that while it is absolutely possible to wrap another transition with `<Fade>`,
     * there will be some duplicate code run as two `<Transitionable>` components end up operating on the same element.
     * It's generally recommended to either use the components that include a combined fade effect,
     * or just directly a `<Transitionable>` on your own.
     *
     * @see `Transitionable`
     */

    var Fade = forwardElementRef$1(function Fade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$C);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$B = ["classBase", "fadeMin", "fadeMax", "open"];
    var ClipFade = forwardElementRef$1(function ClipFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$B);

      return v$1(Clip, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$A = ["classBase", "open", "minBlockSize"];
    /**
     * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     * Be sure to merge these returned props with whatever the user passed in.
     *
     * IMPORTANT: If used outside of a `<Collapse />`, you must include the `measure` prop on the `<Transitionable>` that you use.
     *
     * @example <Transitionable measure {...useCreateCollapseProps(...)} />
     */

    function useCreateCollapseProps({
      classBase,
      minBlockSize
    }, otherProps) {
      var _classBase;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      return useMergedProps()({
        classBase,
        measure: true,
        className: "".concat(classBase, "-collapse"),
        style: {
          ["--".concat(classBase, "-collapse-min-block")]: minBlockSize !== null && minBlockSize !== void 0 ? minBlockSize : 0
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Collapse effect.
     *
     * *Important*: This component is *not* efficient for the browser to animate!
     * Make sure you do testing on lower power devices, or prefer a lighter
     * alternative, like `<Clip>`.
     *
     * @see `Transitionable`
     */

    var Collapse = forwardElementRef$1(function Collapse(_ref, ref) {
      var {
        classBase,
        open,
        minBlockSize
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$A);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateCollapseProps({
        classBase,
        minBlockSize
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$z = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with both Collapse and Fade effects.
     *
     * @see `Transitionable` `Collapse` `Fade`
     */

    forwardElementRef$1(function CollapseFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$z);

      return v$1(Collapse, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$y = ["classBase", "slideTargetInline", "slideTargetBlock", "open"];
    /**
     * Creates a set of props that implement a Slide transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     */

    function useCreateSlideProps({
      classBase,
      slideTargetInline,
      slideTargetBlock
    }, otherProps) {
      var _classBase, _slideTargetInline, _slideTargetBlock, _slideTargetInline2, _slideTargetBlock2;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      var lastValidTargetInline = s((_slideTargetInline = slideTargetInline) !== null && _slideTargetInline !== void 0 ? _slideTargetInline : 1);
      var lastValidTargetBlock = s((_slideTargetBlock = slideTargetBlock) !== null && _slideTargetBlock !== void 0 ? _slideTargetBlock : 0);
      y(() => {
        if (slideTargetInline) lastValidTargetInline.current = slideTargetInline;
      }, [slideTargetInline]);
      y(() => {
        if (slideTargetBlock) lastValidTargetBlock.current = slideTargetBlock;
      }, [slideTargetBlock]);
      if (slideTargetInline == 0) slideTargetInline = lastValidTargetInline.current;
      if (slideTargetBlock == 0) slideTargetBlock = lastValidTargetBlock.current;
      return useMergedProps()({
        className: "".concat(classBase, "-slide"),
        classBase,
        style: {
          ["--".concat(classBase, "-slide-target-inline")]: "".concat((_slideTargetInline2 = slideTargetInline) !== null && _slideTargetInline2 !== void 0 ? _slideTargetInline2 : 0),
          ["--".concat(classBase, "-slide-target-block")]: "".concat((_slideTargetBlock2 = slideTargetBlock) !== null && _slideTargetBlock2 !== void 0 ? _slideTargetBlock2 : 0)
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Slide effect.
     *
     * Provide the direction the element will travel in with `slideInline` and `slideBlock`,
     * with `1` being `100%` of the element's width or height.
     *
     * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
     * which allows for convenient setups inside of a `SwapContainer`
     * (`slideInline={index - selectedIndex}` or similar.)
     *
     * @see `Transitionable`
     */

    var Slide = forwardElementRef$1(function Slide(_ref, ref) {
      var {
        classBase,
        slideTargetInline,
        slideTargetBlock,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$y);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateSlideProps({
        classBase,
        slideTargetInline,
        slideTargetBlock
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$x = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with both Slide and Fade effects.
     *
     * `slideInline={(index - selectedIndex) / 10}` would make the element look like it fades out before it travels to its target destination.
     *
     * @see `Transitionable` `Zoom`
     */

    var SlideFade = forwardElementRef$1(function SlideFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$x);

      return v$1(Slide, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$w = ["classBase", "zoomOrigin", "zoomOriginInline", "zoomOriginBlock", "zoomMin", "zoomMinInline", "zoomMinBlock", "open"];
    /**
     * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     */

    function useCreateZoomProps({
      classBase,
      zoomOrigin,
      zoomOriginInline,
      zoomOriginBlock,
      zoomMin,
      zoomMinInline,
      zoomMinBlock
    }, otherProps) {
      var _classBase, _ref, _ref2, _ref3, _ref4;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      return useMergedProps()({
        className: "".concat(classBase, "-zoom"),
        classBase,
        style: {
          ["--".concat(classBase, "-zoom-origin-inline")]: "".concat((_ref = zoomOriginInline !== null && zoomOriginInline !== void 0 ? zoomOriginInline : zoomOrigin) !== null && _ref !== void 0 ? _ref : 0.5),
          ["--".concat(classBase, "-zoom-origin-block")]: "".concat((_ref2 = zoomOriginBlock !== null && zoomOriginBlock !== void 0 ? zoomOriginBlock : zoomOrigin) !== null && _ref2 !== void 0 ? _ref2 : 0.5),
          ["--".concat(classBase, "-zoom-min-inline")]: "".concat((_ref3 = zoomMinInline !== null && zoomMinInline !== void 0 ? zoomMinInline : zoomMin) !== null && _ref3 !== void 0 ? _ref3 : 0),
          ["--".concat(classBase, "-zoom-min-block")]: "".concat((_ref4 = zoomMinBlock !== null && zoomMinBlock !== void 0 ? zoomMinBlock : zoomMin) !== null && _ref4 !== void 0 ? _ref4 : 0)
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Zoom effect.
     * @see `Transitionable` `ZoomFade`
     */

    var Zoom = forwardElementRef$1(function Zoom(_ref5, ref) {
      var {
        classBase,
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        zoomMin,
        zoomMinInline,
        zoomMinBlock,
        open
      } = _ref5,
          rest = _objectWithoutProperties(_ref5, _excluded$w);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateZoomProps({
        classBase,
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        zoomMin,
        zoomMinInline,
        zoomMinBlock
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$v = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with both Zoom and Fade effects.
     *
     * This is an ideal time to use the minimum size Zoom properties.
     *
     * @see `Transitionable` `Zoom`
     */

    var ZoomFade = forwardElementRef$1(function ZoomFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$v);

      return v$1(Zoom, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$u = ["classBase", "zoomMin", "zoomMinInline", "zoomMinBlock", "zoomOrigin", "zoomOriginInline", "zoomOriginBlock", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with both Slide and Zoom effects.
     *
     * Probably best combined with `useCreateFadeProps` (or just using a `SlideZoomFade`?).
     *
     * @see `Transitionable` `SlideFadeZoom` `Zoom` `Fade`
     */

    var SlideZoom = forwardElementRef$1(function SlideZoom(_ref, ref) {
      var {
        classBase,
        zoomMin,
        zoomMinInline,
        zoomMinBlock,
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$u);

      return v$1(Slide, _objectSpread2({
        open: open
      }, useCreateZoomProps({
        classBase,
        zoomMin,
        zoomMinInline,
        zoomMinBlock,
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$t = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with Zoom, Slide, and Fade effects.
     *
     * Note that this is basically just shorthand for some prop creation and prop merging functions.
     *
     * @see `Transitionable` `Slide` `Zoom` `Fade`
     */

    forwardElementRef$1(function SlideZoomFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$t);

      return v$1(SlideZoom, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$s = ["classBase", "flipAngleInline", "flipAngleBlock", "perspective", "open"];
    /**
     * Creates a set of props that implement a Flip transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     */

    function useCreateFlipProps({
      classBase,
      flipAngleInline,
      flipAngleBlock,
      perspective
    }, otherProps) {
      var _classBase, _flipAngleInline, _flipAngleBlock, _flipAngleInline2, _flipAngleBlock2;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      var lastValidTargetInline = s((_flipAngleInline = flipAngleInline) !== null && _flipAngleInline !== void 0 ? _flipAngleInline : 180);
      var lastValidTargetBlock = s((_flipAngleBlock = flipAngleBlock) !== null && _flipAngleBlock !== void 0 ? _flipAngleBlock : 0);
      y(() => {
        if (flipAngleInline) lastValidTargetInline.current = flipAngleInline;
      }, [flipAngleInline]);
      y(() => {
        if (flipAngleBlock) lastValidTargetBlock.current = flipAngleBlock;
      }, [flipAngleBlock]);
      if (flipAngleInline == 0) flipAngleInline = lastValidTargetInline.current;
      if (flipAngleBlock == 0) flipAngleBlock = lastValidTargetBlock.current;
      return useMergedProps()({
        className: "".concat(classBase, "-flip"),
        classBase,
        style: {
          ["--".concat(classBase, "-flip-angle-inline")]: "".concat((_flipAngleInline2 = flipAngleInline) !== null && _flipAngleInline2 !== void 0 ? _flipAngleInline2 : 0, "deg"),
          ["--".concat(classBase, "-flip-angle-block")]: "".concat((_flipAngleBlock2 = flipAngleBlock) !== null && _flipAngleBlock2 !== void 0 ? _flipAngleBlock2 : 0, "deg"),
          ["--".concat(classBase, "-perspective")]: "".concat(perspective !== null && perspective !== void 0 ? perspective : 800, "px")
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Flip effect.
     *
     * Provide the direction the element will travel in with `flipInline` and `flipBlock`,
     * with `1` being `100%` of the element's width or height.
     *
     * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
     * which allows for convenient setups inside of a `SwapContainer`
     * (`flipInline={index - selectedIndex}` or similar.)
     *
     * @see `Transitionable`
     */

    forwardElementRef$1(function Flip(_ref, ref) {
      var {
        classBase,
        flipAngleInline,
        flipAngleBlock,
        perspective,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$s);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateFlipProps({
        classBase,
        flipAngleInline,
        flipAngleBlock,
        perspective
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$r = ["children", "classBase", "inline"];
    /**
     * Creates a set of props that implement a swap container.
     * Be sure to merge these returned props with whatever the user passed in.
     */

    function useCreateSwappableProps({
      inline,
      classBase
    }, otherProps) {
      return useMergedProps()({
        className: clsx("".concat(classBase !== null && classBase !== void 0 ? classBase : "transition", "-swap-container"), inline && "".concat(classBase !== null && classBase !== void 0 ? classBase : "transition", "-swap-container-inline"))
      }, otherProps);
    }
    /**
     * Allows a set of child <Transitionable> components to animate in & out in-place. Very useful for, e.g., tab panels.
     *
     * You must manage each child `<Transitionable>` component's `open` prop -- this component *does not* manage any sort of state in that regard.
     *
     * Like `<Transitionable>`, *this wraps an HTMLElement (or other ref-forwarding component)*. This will be your container that holds each `<Transitionable>` (or component that uses it). Strictly speaking it could be anything, not a `<Transitionable>`, but if it doesnt't transition out then it's just going to be hanging around 100% of the time.
     *
     * Long way of saying, if you get a cryptic error with this component, make sure it has a single `<div>` child or something.
     * @param param0
     * @returns
     */

    var Swappable = forwardElementRef$1(function Swappable(_ref, ref) {
      var _inline;

      var {
        children,
        classBase,
        inline
      } = _ref,
          p = _objectWithoutProperties(_ref, _excluded$r);

      (_inline = inline) !== null && _inline !== void 0 ? _inline : inline = typeof children.type === "string" && inlineElements.has(children.type);
      var transitionProps = useCreateSwappableProps({
        classBase,
        inline
      }, _objectSpread2(_objectSpread2({}, p), {}, {
        ref
      }));
      var mergedWithChildren = useMergedProps()(transitionProps, children.props);
      return B(children, mergedWithChildren);
    }); // If "inline" isn't explicitly provided, we try to implicitly do it based on the child's tag.
    // Not perfect, but it's not supposed to be. `inline` is for perfect.

    var inlineElements = new Set(["a", "abbr", "acronym", "audio", "b", "bdi", "bdo", "big", "br", "button", "canvas", "cite", "code", "data", "datalist", "del", "dfn", "em", "embed", "i", "iframe", "img", "input", "ins", "kbd", "label", "map", "mark", "meter", "noscript", "object", "output", "picture", "progress", "q", "ruby", "s", "samp", "script", "select", "slot", "small", "span", "strong", "sub", "sup", "svg", "template", "textarea", "time", "u", "tt", "var", "video", "wbr"]);

    var EventDetail = Symbol("event-detail");
    function enhanceEvent(e, detail) {
      var event = e;
      event[EventDetail] = detail;
      return event;
    }

    var _excluded$q = ["aria-pressed", "tabIndex", "role"];
    var pulse = "vibrate" in navigator ? () => navigator.vibrate(10) : () => {};

    function excludes(tag, target, exclude) {
      if (exclude !== null && exclude !== void 0 && exclude[target]) return true;
      if (target === "space" || target === "enter") return tag == "button";
      return false;
    }
    /**
     * Easy way to "polyfill" button-like interactions onto, e.g., a div.
     *
     * Adds click, space on keyDown, and enter on keyUp, as well as haptic
     * feedback via a momentary vibration pulse when there's an onClick handler provided
     * (this can be disabled app-wide with `setButtonVibrate`).
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClick
     * @param exclude Whether the polyfill should apply (can specify for specific interactions)
     */


    function useButtonLikeEventHandlers(tag, onClickSync, exclude) {
      var [active, setActive] = useState(false);
      var onKeyUp = excludes(tag, "space", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync) {
          e.preventDefault();
          onClickSync(e);
          setActive(false);
        }
      };
      var onMouseDown = excludes(tag, "click", exclude) ? undefined : e => {
        if (e.button === 0) setActive(true);
      };
      var onMouseUp = excludes(tag, "click", exclude) ? undefined : e => {
        if (active) {
          if (e.button === 0) {
            setActive(false);

            if (onClickSync) {
              pulse();
              onClickSync(e);
            }
          }

          onBlur(e);
        }
      };

      var onBlur = e => {
        setActive(false);
      };

      var onMouseOut = excludes(tag, "click", exclude) ? undefined : onBlur;
      var onKeyDown = excludes(tag, "space", exclude) && excludes(tag, "enter", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync && !excludes(tag, "space", exclude)) {
          // We don't actually activate it on a space keydown
          // but we do preventDefault to stop the page from scrolling.
          setActive(true);
          e.preventDefault();
        }

        if (e.key == "Enter" && onClickSync && !excludes(tag, "enter", exclude)) {
          e.preventDefault();
          onClickSync(e);
        }
      };
      return props => useMergedProps()(_objectSpread2({
        onKeyDown,
        onKeyUp,
        onBlur,
        onMouseDown,
        onMouseUp,
        onMouseOut
      }, {
        "data-pseudo-active": active ? "true" : undefined
      }), props);
    }
    function useAriaButton({
      tag,
      pressed,
      onClick
    }) {
      function useAriaButtonProps(_ref) {
        var {
          "aria-pressed": ariaPressed,
          tabIndex,
          role
        } = _ref,
            p = _objectWithoutProperties(_ref, _excluded$q);

        var props = useButtonLikeEventHandlers(tag, e => onClick === null || onClick === void 0 ? void 0 : onClick(enhanceEvent(e, {
          pressed: pressed == null ? null : !pressed
        })), undefined)(p);
        var buttonProps = {
          role,
          tabIndex,
          "aria-pressed": ariaPressed !== null && ariaPressed !== void 0 ? ariaPressed : pressed === true ? "true" : pressed === false ? "false" : undefined
        };

        var divProps = _objectSpread2(_objectSpread2({}, buttonProps), {}, {
          tabIndex: tabIndex !== null && tabIndex !== void 0 ? tabIndex : 0,
          role: role !== null && role !== void 0 ? role : "button"
        });

        var anchorProps = _objectSpread2({}, divProps);

        switch (tag) {
          case "button":
            return useMergedProps()(buttonProps, props);

          case "a":
            return useMergedProps()(anchorProps, props);

          default:
            return useMergedProps()(divProps, props);
        }
      }

      return {
        useAriaButtonProps
      };
    }

    var _excluded$p = ["aria-expanded", "aria-disabled"],
        _excluded2$d = ["role"];
    function useAriaAccordion({
      expandedIndex,
      setExpandedIndex
    }) {
      var [lastFocusedIndex, setLastFocusedIndex, getLastFocusedIndex] = useState(0);
      var stableSetExpandedIndex = useStableCallback(setExpandedIndex !== null && setExpandedIndex !== void 0 ? setExpandedIndex : () => {});
      var {
        managedChildren: managedAccordionSections,
        useManagedChild: useManagedChildSection
      } = useChildManager();
      var {
        useLinearNavigationChild
      } = useLinearNavigation({
        managedChildren: managedAccordionSections,
        navigationDirection: "block",
        getIndex: getLastFocusedIndex,
        setIndex: setLastFocusedIndex
      }); // Any time list management changes the focused index, manually focus the child
      // TODO: Can this be cut?

      useLayoutEffect(() => {
        var _managedAccordionSect;

        if (lastFocusedIndex != null && lastFocusedIndex >= 0) (_managedAccordionSect = managedAccordionSections[lastFocusedIndex]) === null || _managedAccordionSect === void 0 ? void 0 : _managedAccordionSect.focus();
      }, [lastFocusedIndex]);
      useChildFlag(expandedIndex, managedAccordionSections.length, (i, open) => {
        var _managedAccordionSect2;

        return (_managedAccordionSect2 = managedAccordionSections[i]) === null || _managedAccordionSect2 === void 0 ? void 0 : _managedAccordionSect2.setOpenFromParent(open);
      });
      var useAriaAccordionSection = A$1(args => {
        var _ref, _args$open;

        var [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
        var {
          randomId: bodyRandomId,
          useRandomIdProps: useBodyRandomIdProps,
          useReferencedIdProps: useReferencedBodyIdProps
        } = useRandomId({
          prefix: "aria-accordion-section-body-"
        });
        var {
          randomId: headRandomId,
          useRandomIdProps: useHeadRandomIdProps,
          useReferencedIdProps: useReferencedHeadIdProps
        } = useRandomId({
          prefix: "aria-accordion-section-header-"
        });
        var open = (_ref = (_args$open = args.open) !== null && _args$open !== void 0 ? _args$open : openFromParent) !== null && _ref !== void 0 ? _ref : null; // TODO: Convert to use useManagedChild so that this hook 
        // is stable without (directly) depending on the open state.

        var useAriaAccordionSectionHeader = A$1(function useAriaAccordionSectionHeader({
          tag
        }) {
          var {
            useRefElementProps,
            element
          } = useRefElement();
          var focus = A$1(() => {
            element === null || element === void 0 ? void 0 : element.focus();
          }, [element]);
          var {
            useManagedChildProps
          } = useManagedChildSection({
            index: args.index,
            open: open,
            setOpenFromParent,
            focus
          });
          var {
            useLinearNavigationChildProps
          } = useLinearNavigationChild();

          function useAriaAccordionSectionHeaderProps(_ref2) {
            var {
              ["aria-expanded"]: ariaExpanded,
              ["aria-disabled"]: ariaDisabled
            } = _ref2,
                props = _objectWithoutProperties(_ref2, _excluded$p);

            var onFocus = () => {
              setLastFocusedIndex(args.index);
            };

            var onClick = () => {
              if (getOpenFromParent()) stableSetExpandedIndex(null);else stableSetExpandedIndex(args.index);
            };

            var retB = useMergedProps()({
              tabIndex: 0
            }, useButtonLikeEventHandlers(tag, onClick, undefined)(props));
            var ret3 = useMergedProps()(useHeadRandomIdProps(useReferencedBodyIdProps("aria-controls")(_objectSpread2({
              "aria-expanded": ariaExpanded !== null && ariaExpanded !== void 0 ? ariaExpanded : (!!open).toString(),
              "aria-disabled": ariaDisabled !== null && ariaDisabled !== void 0 ? ariaDisabled : open ? "true" : undefined
            }, useRefElementProps(useManagedChildProps(retB))))), {
              onFocus
            });
            return useLinearNavigationChildProps(ret3);
          }
          return {
            useAriaAccordionSectionHeaderProps
          };
        }, [open]);
        var useAriaAccordionSectionBody = A$1(function useAriaAccordionSectionBody() {
          function useAriaAccordionSectionBodyProps(_ref3) {
            var {
              role
            } = _ref3,
                props = _objectWithoutProperties(_ref3, _excluded2$d);

            var ret1 = useReferencedHeadIdProps("aria-labelledby")(_objectSpread2({
              role: role !== null && role !== void 0 ? role : "region"
            }, props));
            var ret2 = useBodyRandomIdProps(ret1);
            return ret2;
          }
          return {
            useAriaAccordionSectionBodyProps
          };
        }, []);
        return {
          expanded: open,
          useAriaAccordionSectionHeader,
          useAriaAccordionSectionBody
        };
      }, [useLinearNavigationChild]);
      return {
        useAriaAccordionSection
      };
    }

    var _excluded$o = ["aria-labelledby", "aria-label"];
    /**
     * Adds an ID and "aria-labelledby" for two elements, an "input" element and a "label" element.
     *
     * Returns the `useReferencedIdProps` hooks if you need to also add other ID-referencing attributes, like `for`
     *
     * @see useInputLabel
     */

    function useGenericLabel({
      labelPrefix,
      inputPrefix,
      backupText
    } = {
      labelPrefix: "label-",
      inputPrefix: "input-"
    }) {
      var {
        element: labelElement,
        getElement: getLabelElement,
        useRefElementProps: useLabelRefElementProps
      } = useRefElement();
      var {
        element: inputElement,
        getElement: getInputElement,
        useRefElementProps: useInputRefElementProps
      } = useRefElement();
      var {
        useRandomIdProps: useLabelRandomIdProps,
        id: labelId,
        randomId: labelRandomId,
        useReferencedIdProps: useReferencedLabelIdProps
      } = useRandomId({
        prefix: labelPrefix
      });
      var {
        useRandomIdProps: useInputRandomIdProps,
        id: inputId,
        randomId: inputRandomId,
        useReferencedIdProps: useReferencedInputIdProps
      } = useRandomId({
        prefix: inputPrefix
      });
      var labelHasMounted = !!labelElement;
      var useGenericLabelLabel = A$1(function useGenericLabelLabel() {
        return {
          useGenericLabelLabelProps: props => {
            return useLabelRandomIdProps(useLabelRefElementProps(props));
          }
        };
      }, []);
      var useGenericLabelInput = A$1(function useGenericLabelInput() {
        return {
          useGenericLabelInputProps: _ref => {
            var _ref2;

            var {
              "aria-labelledby": ariaLabelledby,
              "aria-label": ariaLabel
            } = _ref,
                props = _objectWithoutProperties(_ref, _excluded$o);

            return useInputRandomIdProps(useReferencedLabelIdProps("aria-labelledby")(useInputRefElementProps(useMergedProps()({
              "aria-label": (_ref2 = !labelHasMounted ? backupText : ariaLabel) !== null && _ref2 !== void 0 ? _ref2 : ariaLabel
            }, props))));
          }
        };
      }, [labelHasMounted]);
      return {
        useGenericLabelInput,
        useGenericLabelLabel,
        useReferencedLabelIdProps,
        useReferencedInputIdProps,
        labelId,
        inputId,
        labelElement,
        inputElement,
        getLabelElement,
        getInputElement
      };
    }
    /**
     * Handles the attributes `id`, `for`, and `aria-labelledby` for to related elements.
     *
     * It's assumed that the label is an `HTMLLabelElement`, and the input is something for which
     * the `for` attribute can reference.
     *
     */

    function useInputLabel({
      labelPrefix,
      inputPrefix
    } = {
      labelPrefix: "label-",
      inputPrefix: "input-"
    }) {
      var {
        useGenericLabelInput,
        useGenericLabelLabel,
        useReferencedInputIdProps,
        useReferencedLabelIdProps,
        inputId,
        labelId,
        inputElement,
        getInputElement,
        labelElement,
        getLabelElement
      } = useGenericLabel({
        labelPrefix,
        inputPrefix
      });
      var useInputLabelLabel = A$1(function useInputLabelLabel({
        tag
      }) {
        var {
          useGenericLabelLabelProps
        } = useGenericLabelLabel();
        return {
          useInputLabelLabelProps(props) {
            var withFor = useReferencedInputIdProps("for")(props);
            var withoutFor = props;
            return useGenericLabelLabelProps(tag == "label" ? withFor : withoutFor);
          }

        };
      }, [useGenericLabelInput]);
      var useInputLabelInput = A$1(function useInputLabelInput() {
        var {
          useGenericLabelInputProps
        } = useGenericLabelInput();
        return {
          useInputLabelInputProps(props) {
            return useGenericLabelInputProps(props);
          }

        };
      }, [useGenericLabelLabel]);
      return {
        useInputLabelLabel,
        useInputLabelInput,
        labelId,
        inputId,
        inputElement,
        labelElement,
        getInputElement,
        getLabelElement
      };
    }

    var handlesInput = (tag, labelPosition, which) => {
      if (labelPosition === "separate") {
        if (which === "input-element") return true;else if (which === "label-element") return tag != "input";
      } else if (labelPosition === "wrapping") {
        if (which === "input-element") return false;
        if (which == "label-element") return true;
      }
    };
    /**
     * Handles label type (wrapping or separate) for checkboxes, radios, switches, etc.
     * @param param0
     * @returns
     */


    function useCheckboxLike({
      checked,
      disabled,
      labelPosition,
      onInput,
      role
    }) {
      var stableOnInput = useStableCallback(e => {
        e.preventDefault();
        onInput === null || onInput === void 0 ? void 0 : onInput(e);
      });
      var {
        inputId,
        labelId,
        useInputLabelInput: useILInput,
        useInputLabelLabel: useILLabel,
        getLabelElement,
        getInputElement
      } = useInputLabel({
        labelPrefix: "aria-checkbox-label-",
        inputPrefix: "aria-checkbox-input-"
      });
      var useCheckboxLikeInputElement = A$1(function useCheckboxInputElement({
        tag
      }) {
        var {
          useInputLabelInputProps: useILInputProps
        } = useILInput();
        var {
          element,
          useRefElementProps
        } = useRefElement(); // onClick and onChange are a bit messy, so we need to
        // *always* make sure that the visible state is correct
        // after all the event dust settles.
        // See https://github.com/preactjs/preact/issues/2745,
        // and https://github.com/preactjs/preact/issues/1899#issuecomment-525690194

        y(() => {
          if (element && tag == "input") {
            element.checked = checked;
          }
        }, [tag, element, checked]);
        return {
          inputElement: element,
          useCheckboxLikeInputElementProps
        };

        function useCheckboxLikeInputElementProps(_ref3) {
          var p0 = _extends({}, _ref3);

          // For some reason, Chrome won't fire onInput events for radio buttons that are tabIndex=-1??
          // Needs investigating, but onInput works fine in Firefox
          // TODO
          var props = useButtonLikeEventHandlers(tag, disabled || !handlesInput(tag, labelPosition, "input-element") ? undefined : stableOnInput, undefined)({});
          if (tag == "input") props.onInput = e => e.preventDefault();
          props = useRefElementProps(useILInputProps(props));

          if (labelPosition == "wrapping") {
            // Because the wrapped label handles all interactions,
            // we need to make sure this element can't be interacted with
            // even if it's an input element.
            props.inert = true;
            props.tabIndex = -1;

            props.onFocus = e => getLabelElement().focus();
          } else {
            if (tag === "input") {
              props.checked = checked;
            } else {
              props.role = role;
              props.tabIndex = 0;
              props["aria-checked"] = checked ? "true" : undefined;
            }

            props["aria-disabled"] = disabled.toString();
          } // Make sure that label clicks can't affect the checkbox while it's disabled


          props.onClick = disabled ? e => {
            e.preventDefault();
          } : props.onClick;
          return useMergedProps()(p0, props);
        }
      }, [useILInput, role, labelPosition, disabled, checked]);
      var useCheckboxLikeLabelElement = A$1(function useCheckboxLabelElement({
        tag
      }) {
        var {
          useInputLabelLabelProps: useILLabelProps
        } = useILLabel({
          tag
        });

        function useCheckboxLikeLabelElementProps(_ref4) {
          var p0 = _extends({}, _ref4);

          var newProps = useButtonLikeEventHandlers("div", disabled || !handlesInput(tag, labelPosition, "label-element") ? undefined : stableOnInput, undefined)({});

          if (labelPosition == "wrapping") {
            newProps.tabIndex = 0;
            newProps.role = role;
            newProps["aria-disabled"] = disabled.toString();
            newProps["aria-checked"] = checked.toString();
          } // Just make sure that label clicks can't affect the checkbox while it's disabled


          newProps.onClick = disabled ? e => {
            e.preventDefault();
          } : newProps.onClick;
          return useMergedProps()(newProps, useILLabelProps(p0));
        }

        return {
          useCheckboxLikeLabelElementProps
        };
      }, [useILLabel, disabled, checked, role, labelPosition]);
      return {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        getLabelElement,
        getInputElement
      };
    }

    function useAriaCheckbox({
      labelPosition,
      checked,
      onInput,
      disabled
    }) {
      var onInputEnhanced = e => onInput === null || onInput === void 0 ? void 0 : onInput(enhanceEvent(e, {
        checked: !checked
      }));

      var {
        getInputElement,
        getLabelElement,
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement
      } = useCheckboxLike({
        checked: !!checked,
        labelPosition,
        role: "checkbox",
        disabled,
        onInput: onInputEnhanced
      });
      var useCheckboxInputElement = A$1(function useCheckboxInputElement({
        tag
      }) {
        var {
          inputElement,
          useCheckboxLikeInputElementProps
        } = useCheckboxLikeInputElement({
          tag
        });
        var isMixed = checked == "mixed";
        y(() => {
          if (inputElement && tag === "input") {
            inputElement.indeterminate = isMixed;
          }
        }, [inputElement, isMixed, tag]);
        return {
          useCheckboxInputElementProps
        };

        function useCheckboxInputElementProps(_ref) {
          var _props$checked;

          var p0 = _extends({}, _ref);

          var props = useCheckboxLikeInputElementProps(p0);
          (_props$checked = props.checked) !== null && _props$checked !== void 0 ? _props$checked : props.checked = !!checked;
          if (tag == "input") props.type = "checkbox";
          return props;
        }
      }, [checked, labelPosition, disabled]);
      var useCheckboxLabelElement = A$1(function useCheckboxLabelElement({
        tag
      }) {
        var {
          useCheckboxLikeLabelElementProps
        } = useCheckboxLikeLabelElement({
          tag
        });

        function useCheckboxLabelElementProps(_ref2) {
          var props = _extends({}, _ref2);

          return useCheckboxLikeLabelElementProps(props);
        }
        return {
          useCheckboxLabelElementProps
        };
      }, [useCheckboxLikeLabelElement, disabled, labelPosition]);
      return {
        useCheckboxInputElement,
        useCheckboxLabelElement
      };
    }

    var _excluded$n = ["aria-modal", "role"];
    /**
     * Adds event handlers for a modal-like soft-dismiss interaction.
     *
     * That is, any clicks or taps outside of the given component,
     * or any time the Escape key is pressed within the component,
     * (with various browser oddities regarding clicks on blank or inert areas handled)
     * the component will request to close itself.
     *
     * Of course, if you don't do anything in the `onClose` function,
     * it won't be a soft dismiss anymore.
     *
     * @param param0
     * @returns
     */

    function useSoftDismiss({
      onClose
    }) {
      var {
        element,
        useRefElementProps
      } = useRefElement();

      function onBackdropClick(e) {
        // Basically, "was this event fired on the root-most element, or at least an element not contained by the modal?"
        // Either could be how the browser handles these sorts of "interacting with nothing" events.
        if (e.target == document.documentElement || !(element && e.target instanceof Element && element instanceof Element && element.contains(e.target))) {
          onClose("backdrop");
        }
      } // Since everything else is inert, we listen for captured clicks on the window
      // (we don't use onClick since that doesn't fire when clicked on empty/inert areas)
      // Note: We need a *separate* touch event on mobile Safari, because
      // it doesn't let click events bubble or be captured from traditionally non-interactive elements,
      // but touch events work as expected.


      useGlobalHandler(window, "mousedown", !open ? null : onBackdropClick, {
        capture: true
      });
      useGlobalHandler(window, "touchstart", !open ? null : onBackdropClick, {
        capture: true
      });

      var onKeyDown = e => {
        if (e.key === "Escape") {
          onClose("escape");
        }
      };

      return {
        useSoftDismissProps: props => useMergedProps()(useRefElementProps({
          onKeyDown
        }), props)
      };
    }
    /**
     * A generic modal hook, used by modal dialogs, but can also
     * be used by anything that's modal with a backdrop.
     * @param param0
     * @returns
     */

    function useAriaModal({
      open,
      onClose
    }) {
      var stableOnClose = useStableCallback(onClose);
      var [modalDescribedByBody, setModalDescribedByBody] = useState(false);
      useHideScroll(open);
      var {
        id: modalId,
        useRandomIdProps: useModalIdProps,
        useReferencedIdProps: useModalReferencingIdProps
      } = useRandomId({
        prefix: "aria-modal-"
      });
      var {
        id: bodyId,
        useRandomIdProps: useBodyIdProps,
        useReferencedIdProps: useBodyReferencingIdProps
      } = useRandomId({
        prefix: "aria-modal-body-"
      });
      var {
        id: titleId,
        useRandomIdProps: useTitleIdProps,
        useReferencedIdProps: useTitleReferencingIdProps
      } = useRandomId({
        prefix: "aria-modal-title-"
      });
      var {
        useSoftDismissProps
      } = useSoftDismiss({
        onClose: stableOnClose
      });
      var useModalBackdrop = A$1(function useModalBackdrop() {
        function useModalBackdropProps(props) {
          return useMergedProps()({
            onPointerUp: () => stableOnClose("backdrop")
          }, props);
        }

        return {
          useModalBackdropProps
        };
      }, []);

      var useModalProps = function (_ref) {
        var p0 = _objectWithoutProperties(_ref, _excluded$n);

        var {
          useFocusTrapProps
        } = useFocusTrap({
          trapActive: open
        });
        var p1 = useTitleReferencingIdProps("aria-labelledby")(p0);
        var p2 = useModalIdProps(p1);
        var pFinal = useBodyReferencingIdProps("aria-describedby")(p2);
        return useFocusTrapProps(useMergedProps()(useSoftDismissProps({
          role: "dialog"
        }), modalDescribedByBody ? pFinal : p2));
      };

      var useModalTitle = A$1(function useModalTitle() {
        var useModalTitleProps = function (props) {
          return useTitleIdProps(props);
        };

        return {
          useModalTitleProps
        };
      }, []);
      var useModalBody = A$1(function useModalBody({
        descriptive
      }) {
        setModalDescribedByBody(descriptive);

        var useModalBodyProps = function (props) {
          return useBodyIdProps(props);
        };

        return {
          useModalBodyProps
        };
      }, []);
      return {
        useModalProps,
        useModalTitle,
        useModalBody,
        useModalBackdrop
      };
    }
    /**
     * Allows for hiding the scroll bar of the root HTML element
     * without shifting the layout of the page more than adding a fow pixels
     * of padding to the root element if necessary.
     * @param hideScroll
     */

    function useHideScroll(hideScroll) {
      var [scrollbarWidth, setScrollbarWidth, getScrollbarWidth] = useState(null);
      y(() => {
        if (hideScroll) {
          var widthWithScrollBar = document.documentElement.scrollWidth;
          document.documentElement.classList.add("document-scroll-hidden");
          document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") + 1).toString();
          var widthWithoutScrollBar = document.documentElement.scrollWidth;

          var _scrollbarWidth = widthWithoutScrollBar - widthWithScrollBar; // Failsafe -- if this measuring trick does something unexpected, just ignore it


          if (_scrollbarWidth > 80) _scrollbarWidth = 0;
          document.documentElement.style.setProperty("--scrollbar-width", "".concat(_scrollbarWidth, "px"));
          setScrollbarWidth(_scrollbarWidth);
          return () => {
            document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") - 1).toString();

            if (document.documentElement.dataset["scrollHiders"] == "0") {
              document.documentElement.removeAttribute("data-scroll-hiders");
              document.documentElement.classList.remove("document-scroll-hidden");
            }
          };
        }
      }, [hideScroll]);
      return {
        scrollbarWidth,
        getScrollbarWidth
      };
    }

    function useAriaDialog({
      open,
      onClose
    }) {
      // TODO: Differences between dialog and modal go here, presumably.
      // Non-modal dialogs need to be able to be repositioned, etc.
      var {
        useModalBackdrop,
        useModalBody,
        useModalProps,
        useModalTitle
      } = useAriaModal({
        open,
        onClose
      });
      var useDialogBackdrop = A$1(() => {
        var {
          useModalBackdropProps
        } = useModalBackdrop();
        return {
          useDialogBackdropProps: useModalBackdropProps
        };
      }, [useModalBackdrop]);
      var useDialogBody = A$1(({
        descriptive
      }) => {
        var {
          useModalBodyProps
        } = useModalBody({
          descriptive
        });
        return {
          useDialogBodyProps: useModalBodyProps
        };
      }, [useModalBackdrop]);
      var useDialogProps = useModalProps;
      var useDialogTitle = A$1(() => {
        var {
          useModalTitleProps
        } = useModalTitle();
        return {
          useDialogTitleProps: useModalTitleProps
        };
      }, [useModalTitle]);
      return {
        useDialogProps,
        useDialogTitle,
        useDialogBody,
        useDialogBackdrop
      };
    }

    function useDrawer({
      open,
      onClose
    }) {
      // TODO: Drawers are not always modal.
      var {
        useModalBackdrop,
        useModalBody,
        useModalProps,
        useModalTitle
      } = useAriaModal({
        open,
        onClose
      });
      var useDrawerBackdrop = A$1(() => {
        var {
          useModalBackdropProps
        } = useModalBackdrop();
        return {
          useDrawerBackdropProps: useModalBackdropProps
        };
      }, [useModalBackdrop]);
      var useDrawerBody = A$1(({
        descriptive
      }) => {
        var {
          useModalBodyProps
        } = useModalBody({
          descriptive
        });
        return {
          useDrawerBodyProps: useModalBodyProps
        };
      }, [useModalBackdrop]);
      var useDrawerProps = useModalProps;
      var useDrawerTitle = A$1(() => {
        var {
          useModalTitleProps
        } = useModalTitle();
        return {
          useDrawerTitleProps: useModalTitleProps
        };
      }, [useModalTitle]);
      return {
        useDrawerProps,
        useDrawerTitle,
        useDrawerBody,
        useDrawerBackdrop
      };
    }

    var _excluded$m = ["selectedIndex", "onSelect", "selectionMode"];
    function useAriaListboxSingle(_ref) {
      var {
        selectedIndex,
        onSelect,
        selectionMode
      } = _ref,
          args = _objectWithoutProperties(_ref, _excluded$m);

      var {
        lastFocusedInner,
        useHasFocusProps
      } = useHasFocus();
      var {
        useGenericLabelInput,
        useGenericLabelLabel,
        useReferencedInputIdProps,
        useReferencedLabelIdProps,
        inputElement
      } = useGenericLabel({
        labelPrefix: "aria-listbox-label-",
        inputPrefix: "aria-listbox-"
      });
      var {
        useListNavigationChild,
        navigateToIndex,
        managedChildren,
        setTabbableIndex,
        tabbableIndex,
        focusCurrent,
        currentTypeahead,
        invalidTypeahead
      } = useListNavigation(_objectSpread2(_objectSpread2({}, args), {}, {
        focusOnChange: lastFocusedInner
      }));
      var {
        useGenericLabelInputProps
      } = useGenericLabelInput();
      var stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
      useChildFlag(selectedIndex, managedChildren.length, (i, selected) => {
        var _managedChildren$i;

        return (_managedChildren$i = managedChildren[i]) === null || _managedChildren$i === void 0 ? void 0 : _managedChildren$i.setSelected(selected);
      });
      useLayoutEffect(([]) => {
        navigateToIndex(selectedIndex);
      }, [selectedIndex, managedChildren.length]);
      var childCount = managedChildren.length;
      var {
        lastActiveElement
      } = useActiveElement();
      var anyRadiosFocused = !!(inputElement !== null && inputElement !== void 0 && inputElement.contains(lastActiveElement));
      y(() => {
        if (!anyRadiosFocused) setTabbableIndex(selectedIndex);
      }, [anyRadiosFocused, selectedIndex, setTabbableIndex]);
      var useListboxSingleItem = A$1(info => {
        var [selected, setSelected, getSelected] = useState(false);
        var {
          tabbable,
          useListNavigationSiblingProps,
          useListNavigationChildProps
        } = useListNavigationChild(_objectSpread2({
          setSelected
        }, info));
        var {
          element,
          useRefElementProps
        } = useRefElement();
        var index = info.index;
        y(() => {
          if (element && tabbable && selectionMode == "focus") {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
          }
        }, [element, tabbable, selectionMode, index]);
        return {
          useListboxSingleItemProps,
          tabbable,
          selected,
          getSelected
        };

        function useListboxSingleItemProps(props) {
          var newProps = useButtonLikeEventHandlers(info.tag, e => {
            navigateToIndex(info.index);
            if (element) stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
            e.preventDefault();
          }, undefined)({});
          props.role = "option";
          props["aria-setsize"] = childCount.toString();
          props["aria-posinset"] = (info.index + 1).toString();
          props["aria-selected"] = selected.toString();
          return useListNavigationChildProps(useMergedProps()(newProps, useRefElementProps(props)));
        }
      }, [useListNavigationChild, selectionMode, childCount]);
      var useListboxSingleLabel = A$1(function useListboxSingleLabel() {
        function useListboxSingleLabelProps(props) {
          var {
            useGenericLabelLabelProps
          } = useGenericLabelLabel();
          useGenericLabelLabelProps(props);
        }

        return {
          useListboxSingleLabelProps
        };
      }, [useGenericLabelLabel]);
      return {
        useListboxSingleItem,
        useListboxSingleProps,
        useListboxSingleLabel,
        tabbableIndex,
        focus: focusCurrent,
        currentTypeahead,
        invalidTypeahead
      };

      function useListboxSingleProps(props) {
        props.role = "listbox";
        return useHasFocusProps(useGenericLabelInputProps(props));
      }
    }

    var _excluded$l = ["collator", "keyNavigation", "noTypeahead", "noWrap", "typeaheadTimeout"];
    function useAriaMenu(_ref) {
      var {
        collator,
        keyNavigation,
        noTypeahead,
        noWrap,
        typeaheadTimeout
      } = _ref,
          args = _objectWithoutProperties(_ref, _excluded$l);

      var [focusTrapActive, setFocusTrapActive] = l(null);
      var onClose = args.onClose;
      var onOpen = args.onOpen;
      var menubar = args.menubar;
      var open = menubar ? true : args.open;
      var stableOnClose = useStableCallback(onClose !== null && onClose !== void 0 ? onClose : () => {}); // TODO: It's awkward that the button focus props are out here where we don't have its type,
      // but focus management is super sensitive, and even waiting for a useLayoutEffect to sync state here
      // would be too late, so it would look like there's a moment between menu focus lost and button focus gained
      // where nothing is focused. 

      var {
        focusedInner: menuHasFocus,
        useHasFocusProps: useMenuHasFocusProps
      } = useHasFocus();
      var {
        focusedInner: buttonHasFocus,
        useHasFocusProps: useButtonHasFocusProps
      } = useHasFocus();
      var {
        activeElement,
        lastActiveElement,
        windowFocused
      } = useActiveElement();
      var {
        managedChildren,
        useListNavigationChild,
        tabbableIndex,
        focusCurrent: focusMenu
      } = useListNavigation({
        collator,
        keyNavigation,
        noTypeahead,
        noWrap,
        typeaheadTimeout,
        focusOnChange: menuHasFocus || buttonHasFocus
      });
      var {
        useRandomIdProps: useMenuIdProps,
        useReferencedIdProps: useMenuIdReferencingProps
      } = useRandomId({
        prefix: "aria-menu-"
      });
      var [openerElement, setOpenerElement] = l(null);
      var {
        useSoftDismissProps
      } = useSoftDismiss({
        onClose: stableOnClose
      });
      y(() => {
        setFocusTrapActive(open);
      }, [open]);
      var focusMenuStable = useStableCallback(focusMenu !== null && focusMenu !== void 0 ? focusMenu : () => {});
      y(() => {
        if (focusTrapActive) {
          focusMenuStable === null || focusMenuStable === void 0 ? void 0 : focusMenuStable();
        } else if (focusTrapActive === false) {
          openerElement === null || openerElement === void 0 ? void 0 : openerElement.focus();
        } else ;
      }, [focusTrapActive]); // Focus management is really finicky, and there's always going to be 
      // an edge case where nothing's focused for two consecutive frames 
      // on iOS or whatever, which would immediately close the menu 
      // any time it's been opened. So any time it *looks* like we should close,
      // try waiting 100ms. If it's still true then, then yeah, we should close.

      var shouldClose = focusTrapActive && windowFocused && !menuHasFocus && !buttonHasFocus;
      useTimeout({
        timeout: 100,
        callback: () => {
          if (shouldClose) {
            onClose === null || onClose === void 0 ? void 0 : onClose();
          }
        },
        triggerIndex: "".concat(shouldClose)
      }); // A menu sentinal is a hidden but focusable element that comes at the start or end of the element
      // that, when activated or focused over, closes the menu.
      // (if focused within 100ms of the open prop changing, instead of
      // closing the menu, focusing the sentinel immediately asks the menu to focus itself).
      // This exists because while mouse users can click out of a menu
      // and keyboard users can escape to close the menu,
      // screen readers and other input methods that don't use those two become stuck.

      var useMenuSentinel = A$1(() => {
        var [firstSentinelIsActive, setFirstSentinelIsActive] = l(false);
        useTimeout({
          callback: () => {
            setFirstSentinelIsActive(open);
          },
          timeout: 100,
          triggerIndex: "".concat(firstSentinelIsActive)
        });
        var onFocus = firstSentinelIsActive ? () => stableOnClose() : () => focusMenu === null || focusMenu === void 0 ? void 0 : focusMenu();

        var onClick = () => stableOnClose();

        return {
          useMenuSentinelProps: function (p) {
            return useMergedProps()({
              onFocus,
              onClick
            }, p);
          }
        };
      }, [focusMenu, open]);
      var useMenuButton = A$1(({
        tag
      }) => {
        var {
          element,
          getElement,
          useRefElementProps
        } = useRefElement();
        useLayoutEffect(() => {
          setOpenerElement(element);
        }, [element]);
        return {
          useMenuButtonProps: function (p) {
            var props = useRefElementProps(useMergedProps()({
              onClick: () => {
                return open ? onClose === null || onClose === void 0 ? void 0 : onClose() : onOpen === null || onOpen === void 0 ? void 0 : onOpen();
              }
            }, useMenuIdReferencingProps("aria-controls")(useButtonHasFocusProps(p))));
            props["aria-haspopup"] = "menu";
            props["aria-expanded"] = open ? "true" : undefined;
            return props;
          }
        };
      }, [open, onClose, onOpen, useMenuIdReferencingProps]);
      var useMenuSubmenuItem = A$1(args => {
        var {
          useMenuProps,
          useMenuButton
        } = useAriaMenu(args);
        var {
          useMenuButtonProps
        } = useMenuButton({
          tag: "li"
        });
        var {
          element,
          getElement,
          useRefElementProps
        } = useRefElement();
        useLayoutEffect(() => {
          setOpenerElement(element);
        }, [element]);
        return {
          element,
          getElement,
          useMenuProps,
          useMenuSubmenuItemProps: function (_ref2) {
            var props = _extends({}, _ref2);

            props.role = "menuitem";
            return useRefElementProps(useMenuButtonProps(useMenuIdReferencingProps("aria-controls")(props)));
          }
        };
      }, []);
      var useMenuItem = A$1(args => {
        var {
          useListNavigationChildProps
        } = useListNavigationChild(args); // const { getSyncHandler, ...asyncInfo } = useAsyncHandler<E>()({ capture: _ => void (0) });
        // const onClick = getSyncHandler(asyncInfo.pending ? null : (args.onClick ?? null));

        var onClick = args.onClick;

        function useMenuItemProps(_ref3) {
          var props = _extends({}, _ref3);

          props.role = "menuitem";
          return useMergedProps()({
            onClick
          }, useListNavigationChildProps(props));
        }

        return {
          useMenuItemProps
        };
      }, []);
      var useMenuItemCheckbox = A$1(args => {
        //const { getSyncHandler, ...asyncInfo } = useAsyncHandler<E>()({ capture: _ => !args.checked });
        //const onClick = getSyncHandler(asyncInfo.pending ? null : args.onChange);
        var onClick = e => args.onChange(enhanceEvent(e, {
          checked: !args.checked
        }));

        function useMenuItemProps(_ref4) {
          var props = _extends({}, _ref4);

          props.role = "menuitemcheckbox";
          return useMergedProps()({
            onClick
          }, props);
        }

        return {
          useMenuItemProps
        };
      }, []);

      function useMenuProps(_ref5) {
        var props = _extends({}, _ref5);

        props.role = "menu";

        function onKeyDown(e) {
          if (e.key == "Escape" && onClose) {
            onClose();
          }
        }

        return useMenuIdProps(useMenuHasFocusProps(useMergedProps()({
          onKeyDown
        }, useSoftDismissProps(props))));
      }

      return {
        useMenuProps,
        useMenuButton,
        useMenuItem,
        useMenuSentinel,
        useMenuItemCheckbox,
        useMenuSubmenuItem,
        focusMenu
      };
    }

    var _excluded$k = ["selectionMode", "selectedIndex", "onSelect", "orientation"];
    function useAriaTabs(_ref) {
      var {
        selectionMode,
        selectedIndex,
        onSelect,
        orientation: logicalOrientation
      } = _ref,
          args = _objectWithoutProperties(_ref, _excluded$k);

      var {
        useHasFocusProps: useTabListHasFocusProps,
        focusedInner: tabListFocused
      } = useHasFocus();
      var {
        element: listElement,
        useRefElementProps
      } = useRefElement();
      var {
        getLogicalDirection,
        convertToPhysicalOrientation
      } = useLogicalDirection(listElement);
      var physicalOrientation = convertToPhysicalOrientation(logicalOrientation);
      useRandomId({
        prefix: "aria-tab-list-"
      });
      var {
        useRandomIdProps: useTabLabelIdProps,
        useReferencedIdProps: useReferencedTabLabelId
      } = useRandomId({
        prefix: "aria-tab-label-"
      });
      var {
        managedChildren: managedTabs,
        navigateToIndex,
        useListNavigationChild,
        tabbableIndex,
        invalidTypeahead,
        currentTypeahead,
        focusCurrent
      } = useListNavigation(_objectSpread2(_objectSpread2({}, args), {}, {
        focusOnChange: tabListFocused,
        keyNavigation: logicalOrientation
      }));
      var {
        managedChildren: managedPanels,
        useManagedChild: useManagedTabPanel
      } = useChildManager();
      useStableCallback(onSelect);
      var childCount = managedTabs.length;
      useLayoutEffect(() => {
        for (var child of managedTabs) {
          child.setSelectionMode(selectionMode);
        }
      }, [selectionMode]);
      useChildFlag(selectedIndex, managedTabs.length, (i, selected) => {
        var _managedTabs$i;

        return (_managedTabs$i = managedTabs[i]) === null || _managedTabs$i === void 0 ? void 0 : _managedTabs$i.setSelected(selected);
      });
      useChildFlag(selectedIndex, managedPanels.length, (i, visible) => {
        var _managedPanels$i;

        return (_managedPanels$i = managedPanels[i]) === null || _managedPanels$i === void 0 ? void 0 : _managedPanels$i.setVisible(visible);
      });
      useLayoutEffect(([prevChildCount, prevSelectedIndex]) => {
        if (selectedIndex != null && selectionMode == "activate") {
          var _managedPanels$select;

          (_managedPanels$select = managedPanels[selectedIndex]) === null || _managedPanels$select === void 0 ? void 0 : _managedPanels$select.focus();
        }
      }, [childCount, selectedIndex, selectionMode]);
      var getTabListIsFocused = useStableGetter(tabListFocused);
      var useTab = A$1(function useTab(info) {
        //const [selectedTabId, setSelectedTabId, getSelectedTabId] = useState<string | undefined>(undefined);
        var [selectionModeL, setSelectionModeL] = useState(selectionMode);
        var {
          element,
          useRefElementProps
        } = useRefElement();
        var [tabPanelId, setTabPanelId] = useState(undefined);
        var {
          useRandomIdProps: useTabIdProps,
          id: tabId,
          getId: getTabId
        } = useRandomId({
          prefix: "aria-tab-"
        });
        var [selected, setSelected, getSelected] = useState(null);
        var {
          tabbable,
          useListNavigationChildProps,
          useListNavigationSiblingProps
        } = useListNavigationChild(_objectSpread2(_objectSpread2({}, info), {}, {
          setSelected,
          tabId,
          setTabPanelId,
          setSelectionMode: setSelectionModeL
        }));
        var getIndex = useStableGetter(info.index); // const { getSyncHandler, ...asyncInfo } = useAsyncHandler<Element>()({ capture: (e: unknown) => info.index });
        // const onSelect = getSyncHandler(asyncInfo.pending? null : (stableAsyncOnSelect ?? null));

        y(() => {
          if (tabbable && selectionModeL == "focus") {
            onSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: getIndex()
              }
            });
          }
        }, [tabbable, selectionModeL, element]);
        y(() => {
          var _managedPanels$info$i;

          (_managedPanels$info$i = managedPanels[info.index]) === null || _managedPanels$info$i === void 0 ? void 0 : _managedPanels$info$i.setTabId(tabId);
        }, [tabId, info.index]);
        /*useEffect(() => {
            if (selected)
                setSelectedTabId(tabId);
        }, [selected, tabId])*/

        function useTabProps(_ref2) {
          var props = _extends({}, _ref2);

          var newProps = useButtonLikeEventHandlers(info.tag, e => {
            navigateToIndex(info.index);
            onSelect === null || onSelect === void 0 ? void 0 : onSelect(enhanceEvent(e, {
              selectedIndex: getIndex()
            }));
            e.preventDefault();
          }, undefined)(props);
          newProps.role = "tab";
          newProps["aria-selected"] = (selected !== null && selected !== void 0 ? selected : false).toString();
          newProps["aria-controls"] = tabPanelId;
          return useMergedProps()({}, useTabIdProps(useListNavigationChildProps(useRefElementProps(newProps))));
        }

        return {
          useTabProps,
          selected
        };
      }, []);
      var useTabPanel = A$1(function usePanel(info) {
        //const [selectedTabPanelId, setSelectedTabPanelId, getSelectedTabPanelId] = useState<string | undefined>(undefined);
        var [shouldFocus, setShouldFocus] = useState(false);
        var [tabId, setTabId] = useState(undefined);
        var [selected, setSelected, getSelected] = useState(null);
        var {
          useRandomIdProps: usePanelIdProps,
          useReferencedIdProps: useReferencedPanelId,
          id: tabPanelId
        } = useRandomId({
          prefix: "aria-tab-panel-"
        });
        var {
          element,
          useManagedChildProps
        } = useManagedTabPanel(_objectSpread2(_objectSpread2({}, info), {}, {
          tabPanelId,
          setTabId,
          focus,
          setVisible: setSelected
        }));

        function focus() {
          if (getTabListIsFocused()) {
            setShouldFocus(true);
          }
        }

        y(() => {
          if (shouldFocus) {
            element === null || element === void 0 ? void 0 : element.focus();
            setShouldFocus(false);
          }
        }, [element, shouldFocus]);
        y(() => {
          var _managedTabs$info$ind;

          (_managedTabs$info$ind = managedTabs[info.index]) === null || _managedTabs$info$ind === void 0 ? void 0 : _managedTabs$info$ind.setTabPanelId(tabPanelId);
        }, [tabPanelId, info.index]);

        function useTabPanelProps(_ref3) {
          var _managedTabs$info$ind2, _props$tabIndex;

          var props = _extends({}, _ref3);

          props["aria-labelledby"] = (_managedTabs$info$ind2 = managedTabs[info.index]) === null || _managedTabs$info$ind2 === void 0 ? void 0 : _managedTabs$info$ind2.tabId;
          props.role = "tabpanel";
          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1; // Make sure the tab panel is tabbable.

          return useMergedProps()({}, usePanelIdProps(useManagedChildProps(props)));
        }

        return {
          useTabPanelProps,
          selected
        };
      }, []);
      var useTabsList = A$1(function useTabList() {
        function useTabListProps(_ref4) {
          var props = _extends({}, _ref4);

          props.role = "tablist";
          props["aria-orientation"] = physicalOrientation;
          return useReferencedTabLabelId("aria-labelledby")(useTabListHasFocusProps(useRefElementProps(props)));
        }

        return {
          useTabListProps
        };
      }, [physicalOrientation]);
      var useTabsLabel = A$1(function useTabsLabel() {
        function useTabsLabelProps(_ref5) {
          var props = _extends({}, _ref5);

          return useTabLabelIdProps(props);
        }

        return {
          useTabsLabelProps
        };
      }, []);
      return {
        useTab,
        useTabPanel,
        useTabsList,
        useTabsLabel,
        tabbableIndex,
        focusTabList: focusCurrent,
        currentTypeahead,
        invalidTypeahead
      };
    }

    var _excluded$j = ["value", "index", "text", "disabled", "labelPosition"];
    function useAriaRadioGroup({
      name,
      selectedValue,
      onInput
    }) {
      var {
        element,
        useRefElementProps
      } = useRefElement();
      var [selectedIndex, setSelectedIndex, getSelectedIndex] = useState(null);
      var byName = s(new Map());
      var stableOnInput = useStableCallback(onInput);
      var {
        useHasFocusProps,
        lastFocusedInner
      } = useHasFocus();
      var {
        managedChildren,
        useListNavigationChild,
        setTabbableIndex,
        tabbableIndex,
        focusCurrent,
        currentTypeahead,
        invalidTypeahead
      } = useListNavigation({
        focusOnChange: lastFocusedInner
      });
      var useRadioGroupProps = A$1(_ref => {
        var props = _extends({}, _ref);

        props.role = "radiogroup";
        return useRefElementProps(useHasFocusProps(props));
      }, [useHasFocusProps, useRefElementProps]);
      useChildFlag(selectedIndex, managedChildren.length, (i, checked) => {
        var _managedChildren$i;

        return (_managedChildren$i = managedChildren[i]) === null || _managedChildren$i === void 0 ? void 0 : _managedChildren$i.setChecked(checked);
      });
      var {
        lastActiveElement
      } = useActiveElement();
      var anyRadiosFocused = !!(element !== null && element !== void 0 && element.contains(lastActiveElement));
      y(() => {
        if (!anyRadiosFocused && selectedIndex != null) setTabbableIndex(selectedIndex);
      }, [anyRadiosFocused, selectedIndex, setTabbableIndex]);
      y(() => {
        getSelectedIndex();
        var newIndex = byName.current.get(selectedValue);
        setSelectedIndex(newIndex);
      }, [selectedValue]);
      var useRadio = A$1(function useAriaRadio(_ref2) {
        var {
          value,
          index,
          text,
          disabled,
          labelPosition
        } = _ref2,
            rest = _objectWithoutProperties(_ref2, _excluded$j);

        var [checked, setChecked] = useState(false);
        var onInput = A$1(e => {
          stableOnInput(enhanceEvent(e, {
            selectedValue: value
          }));
        }, [stableOnInput, value, index]);
        var {
          getInputElement,
          getLabelElement,
          useCheckboxLikeInputElement,
          useCheckboxLikeLabelElement
        } = useCheckboxLike({
          checked,
          disabled,
          labelPosition,
          onInput,
          role: "radio"
        }); //const {} = useCheckboxLikeInputElement({  })

        var byName2 = byName.current;
        h(() => {
          console.assert(!byName2.has(value));
          byName2.set(value, index);
          return () => {
            byName2.delete(value);
          };
        }, [value, index]);
        var {
          tabbable,
          useListNavigationChildProps,
          useListNavigationSiblingProps
        } = useListNavigationChild(_objectSpread2({
          index,
          setChecked,
          text
        }, rest));

        var useRadioInput = ({
          tag
        }) => {
          var useRadioInputProps = props => {
            if (tag == "input") {
              props.name = name;
              props.checked = checked;
            } else {
              props["aria-checked"] = checked.toString();
            }

            var {
              useCheckboxLikeInputElementProps
            } = useCheckboxLikeInputElement({
              tag
            });
            return useMergedProps()(useListNavigationChildProps(useCheckboxLikeInputElementProps({})), props);
          };

          return {
            useRadioInputProps
          };
        };

        var useRadioLabel = A$1(({
          tag
        }) => {
          var useRadioLabelProps = props => {
            var {
              useCheckboxLikeLabelElementProps
            } = useCheckboxLikeLabelElement({
              tag
            });
            return useCheckboxLikeLabelElementProps(useMergedProps()({}, props));
          };

          return {
            useRadioLabelProps
          };
        }, [useCheckboxLikeLabelElement]);
        return {
          useRadioInput,
          useRadioLabel
        };
      }, [byName, useListNavigationChild]);
      return {
        useRadio,
        useRadioGroupProps,
        managedChildren,
        getIndex: A$1(value => {
          return byName.current.get(value);
        }, [byName]),
        tabbableIndex,
        focusRadio: focusCurrent,
        currentTypeahead,
        invalidTypeahead
      };
    }

    var _excluded$i = ["role", "aria-live", "aria-relevant"];
    function useToasts({}) {
      // "Pointer" to whatever index toast is currently being shown.
      // E.g. it's 0 when the first toast is shown, then when dismissed, it becomes 1.
      // When the second toast is shown, it stays at 1 until dismissed, when it then becomes 2, etc.
      // Because toasts can potentially be dismissed out of order, this represents the "oldest" toast that still hasn't been dismissed,
      // even if "younger" ones have.
      var [activeToastIndex, setActiveToastIndex, getActiveToastIndex] = useState(-1);
      var [politeness, setPoliteness] = useState("polite");
      var {
        element,
        getElement,
        useRefElementProps
      } = useRefElement();
      var {
        indicesByElement,
        managedChildren,
        mountedChildren: toastQueue,
        useManagedChild,
        getMountIndex
      } = useChildManager(); // Any time a new toast mounts, update our bottommostToastIndex to point to it if necessary
      // ("necessary" just meaning if it's the first toast ever or all prior toasts have been dismissed)

      var onAnyToastMounted = A$1(index => {
        var bottom = getActiveToastIndex();

        while (bottom < toastQueue.length && (bottom < 0 || (_toastQueue$bottom = toastQueue[bottom]) !== null && _toastQueue$bottom !== void 0 && _toastQueue$bottom.dismissed)) {
          var _toastQueue$bottom;

          ++bottom;
        }

        setActiveToastIndex(bottom);
      }, [setActiveToastIndex]); // Any time a toast is dismissed, update our bottommostToastIndex to point to the next toast in the queue, if one exists.

      var onAnyToastDismissed = A$1(index => {
        var _getElement, _toastQueue$bottom3;

        var bottom = getActiveToastIndex();

        while (bottom < toastQueue.length && (bottom < 0 || bottom === index || (_toastQueue$bottom2 = toastQueue[bottom]) !== null && _toastQueue$bottom2 !== void 0 && _toastQueue$bottom2.dismissed)) {
          var _toastQueue$bottom2;

          ++bottom;
        }

        setActiveToastIndex(bottom);
        if ((_getElement = getElement()) !== null && _getElement !== void 0 && _getElement.contains(document.activeElement)) (_toastQueue$bottom3 = toastQueue[bottom]) === null || _toastQueue$bottom3 === void 0 ? void 0 : _toastQueue$bottom3.focus();
      }, [setActiveToastIndex]); // Any time the index pointing to the currently-showing toast changes,
      // update the relevant children and let them know that they're now either active or dismissed.

      useChildFlag(activeToastIndex, toastQueue.length, (i, set) => {
        var _toastQueue$i;

        if (set) console.assert(i <= getActiveToastIndex());
        (_toastQueue$i = toastQueue[i]) === null || _toastQueue$i === void 0 ? void 0 : _toastQueue$i.setStatus(set ? "active" : i < getActiveToastIndex() ? "dismissed" : "pending");
      });
      var useToast = A$1(({
        politeness,
        timeout
      }) => {
        var [status, setStatus, getStatus] = useState("pending");
        var dismissed = status === "dismissed";
        var dismiss = A$1(() => {
          setStatus("dismissed");
        }, []);
        var {
          randomId: toastId
        } = useRandomId({
          prefix: "toast-"
        }); //const [toastId, setToastId] = useState(() => generateRandomId("toast-"));

        h(() => {
          setPoliteness(politeness !== null && politeness !== void 0 ? politeness : "polite");
        }, [politeness]);
        var focus = A$1(() => {
          var element = getElement();

          if (element) {
            var firstFocusable = findFirstFocusable(element);
            firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
          }
        }, []);
        var {
          element,
          useManagedChildProps,
          getElement
        } = useManagedChild({
          dismissed,
          index: toastId,
          setStatus,
          focus
        });
        var isActive = status === "active";
        y(() => {
          onAnyToastMounted(getMountIndex(toastId));
        }, []);
        y(() => {
          if (dismissed) onAnyToastDismissed(getMountIndex(toastId));
        }, [dismissed]);
        useTimeout({
          timeout,
          callback: () => {
            if (isActive) setStatus("dismissed");
          },
          triggerIndex: isActive
        });
        return {
          status,
          getStatus,
          dismiss,
          useToastProps: function (_ref) {
            var props = _extends({}, _ref);

            return useMergedProps()(useManagedChildProps({}), props);
          }
        };
      }, []);

      function useToastContainerProps(_ref2) {
        var _ref3;

        var {
          role,
          "aria-live": ariaLive,
          "aria-relevant": ariaRelevant
        } = _ref2,
            props = _objectWithoutProperties(_ref2, _excluded$i);

        return useMergedProps()(useRefElementProps({
          class: "toasts-container",
          role: "status",
          "aria-live": (_ref3 = politeness !== null && politeness !== void 0 ? politeness : ariaLive) !== null && _ref3 !== void 0 ? _ref3 : "polite",
          "aria-relevant": ariaRelevant !== null && ariaRelevant !== void 0 ? ariaRelevant : "additions"
        }), props);
      }

      return {
        useToast,
        useToastContainerProps
      };
    }

    var _excluded$h = ["data-pseudo-active"];
    function forwardElementRef(component) {
      return x(component);
    }
    function usePseudoActive(_ref) {
      var {
        "data-pseudo-active": active
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$h);

      return useMergedProps()({
        className: clsx((active == true || active == "true") && "active")
      }, props);
    }
    var SpinnerDelayContext = D$1(1000);
    function useSpinnerDelay(pending, timeout) {
      var _ref2;

      var [showSpinner, setShowSpinner] = useState(false);
      y(() => {
        if (!pending) {
          setShowSpinner(false);
        }
      }, [pending]);
      var defaultDelay = F(SpinnerDelayContext);
      useTimeout({
        timeout: (_ref2 = timeout !== null && timeout !== void 0 ? timeout : defaultDelay) !== null && _ref2 !== void 0 ? _ref2 : 1000,
        callback: () => {
          setShowSpinner(pending);
        },
        triggerIndex: pending
      });
      return showSpinner;
    }

    var _excluded$g = ["expandedIndex", "setExpandedIndex", "children"],
        _excluded2$c = ["index", "open", "header", "headerLevel", "children", "Transition"];
    var UseAriaAccordionSectionContext = D$1(null);
    var Accordion = forwardElementRef(function Accordion(_ref, ref) {
      var {
        expandedIndex,
        setExpandedIndex,
        children
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$g);

      var {
        useAriaAccordionSection
      } = useAriaAccordion({
        expandedIndex,
        setExpandedIndex
      });
      return v$1("div", _objectSpread2({}, useMergedProps()({
        ref,
        className: "accordian"
      }, props)), v$1(UseAriaAccordionSectionContext.Provider, {
        value: useAriaAccordionSection
      }, children));
    });
    var AccordionSection = forwardElementRef(function AccordionSection(_ref2, ref) {
      var _Transition, _headerLevel;

      var {
        index,
        open,
        header,
        headerLevel,
        children,
        Transition
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$c);

      var useAriaAccordionSection = F(UseAriaAccordionSectionContext);
      var {
        expanded,
        useAriaAccordionSectionHeader,
        useAriaAccordionSectionBody
      } = useAriaAccordionSection({
        index,
        open
      });
      var {
        useAriaAccordionSectionHeaderProps
      } = useAriaAccordionSectionHeader({
        tag: "button"
      });
      var {
        useAriaAccordionSectionBodyProps
      } = useAriaAccordionSectionBody();
      (_Transition = Transition) !== null && _Transition !== void 0 ? _Transition : Transition = Collapse;
      (_headerLevel = headerLevel) !== null && _headerLevel !== void 0 ? _headerLevel : headerLevel = 2;
      console.log("".concat(index, ": ").concat(expanded === null || expanded === void 0 ? void 0 : expanded.toString()));
      var headerButtonProps = useAriaAccordionSectionHeaderProps({
        type: "button",
        class: clsx("accordion-button", !expanded ? " collapsed" : "")
      });
      var headerProps = {
        class: "accordion-header",
        children: v$1("button", _objectSpread2({}, headerButtonProps), header)
      };
      var headerJsx = headerLevel >= 1 && headerLevel <= 6 ? v$1("h".concat(headerLevel), headerProps) : v$1("div", useMergedProps()(headerProps, {
        role: "heading",
        "aria-level": "".concat(headerLevel)
      }));
      return v$1("div", _objectSpread2({}, {
        ref,
        class: "accordion-item"
      }), headerJsx, v$1(Transition, _objectSpread2({
        open: expanded
      }, useAriaAccordionSectionBodyProps(useMergedProps()(props, {
        class: ""
      }))), v$1("div", null, v$1("div", {
        class: "accordion-body"
      }, children))));
    });

    var _excluded$f = ["aria-valuemax", "aria-valuenow", "aria-valuetext", "role"],
        _excluded3$6 = ["loadingLabel", "spinnerTimeout", "mode", "colorFill", "childrenPosition", "children", "color"];
    // resumably because the number of elements changes. 
    // (and in really weird ways -- changing the animation speed in the console fixes it until you put it back at 100% speed???).
    // Assuming that's the case, it's easier to just take care of the element count on page load.

    var gimmickCount = 8;

    (() => {
      var _getFromLocalStorage;

      var lastSet = (_getFromLocalStorage = getFromLocalStorage()("circular-progress-gimmick-last-set", str => new Date(str))) !== null && _getFromLocalStorage !== void 0 ? _getFromLocalStorage : new Date(1970, 0, 1);
      var daysSinceLastGimmickSet = Math.floor((+new Date() - +lastSet) / 1000 / 60 / 60 / 24);

      if (daysSinceLastGimmickSet > 0) {
        var newCount = 4 + Math.round(Math.random() * 2 + Math.random() * 2);
        gimmickCount = newCount;
        storeToLocalStorage()("circular-progress-gimmick-last-set", new Date(), d => d.toISOString());
        storeToLocalStorage()("circular-progress-gimmick-count", gimmickCount, JSON.stringify);
      } else {
        var _getFromLocalStorage2;

        gimmickCount = (_getFromLocalStorage2 = getFromLocalStorage()("circular-progress-gimmick-count", JSON.parse)) !== null && _getFromLocalStorage2 !== void 0 ? _getFromLocalStorage2 : 8;
      }
    })();

    function useAriaProgressBar({
      tag,
      max,
      value,
      valueText
    }) {
      //const { inputId, labelId, useGenericLabelInput, useGenericLabelLabel, useReferencedInputIdProps, useReferencedLabelIdProps } = useGenericLabel({ inputPrefix: "progressbar-", labelPrefix: "progressbar-reference-" });
      var {
        id: progressBarId,
        getId,
        useRandomIdProps,
        useReferencedIdProps
      } = useRandomId({
        prefix: "progressbar-"
      });

      function useProgressProps(_ref) {
        var p = _objectWithoutProperties(_ref, _excluded$f);

        var extraProps = tag === "progress" ? {
          max,
          value: value !== null && value !== void 0 ? value : undefined,
          "aria-valuemin": "0",
          "aria-valuenow": value == null ? undefined : "".concat(value)
        } : {
          "aria-valuemin": "0",
          "aria-valuemax": max == null ? undefined : "".concat(max),
          "aria-valuetext": valueText == null ? undefined : "".concat(valueText),
          "aria-valuenow": value == null ? undefined : "".concat(value),
          role: "progressbar"
        };
        return useRandomIdProps(useMergedProps()(extraProps, p));
      }

      var useReferencedElement = A$1(function useReferencedElement() {
        function useReferencedProps(props) {
          return useReferencedIdProps("aria-controls")(props);
        }

        return {
          useReferencedProps
        };
      }, [useReferencedIdProps]);
      return {
        useProgressProps,
        useReferencedElement
      };
    }
    D$1(undefined);
    D$1(undefined);
    D$1(undefined);
    D$1(undefined);

    new Date().getDate() % 2;

    function Check() {
      return v$1("i", {
        class: "bi bi-check"
      });
    }

    function Cross() {
      return v$1("i", {
        class: "bi bi-x"
      });
    }

    var ProgressCircular = forwardElementRef(function (_ref3, ref) {
      var _loadingLabel, _childrenPosition;

      var {
        loadingLabel,
        spinnerTimeout,
        mode,
        colorFill,
        childrenPosition,
        children,
        color
      } = _ref3,
          p = _objectWithoutProperties(_ref3, _excluded3$6);

      (_loadingLabel = loadingLabel) !== null && _loadingLabel !== void 0 ? _loadingLabel : loadingLabel = "Operation pending";
      var {
        useProgressProps,
        useReferencedElement
      } = useAriaProgressBar({
        value: null,
        valueText: loadingLabel,
        max: 1,
        tag: "div"
      }); //useLayoutEffect(() => { provideParentWithHook?.(useReferencedElement) }, [useReferencedElement, provideParentWithHook])

      var {
        useReferencedProps
      } = useReferencedElement();
      var showSpinner = useSpinnerDelay(mode === "pending", spinnerTimeout); //const [spinnerShowCount, setSpinnerShowCount] = useState(0);
      //useEffect(() => { setSpinnerShowCount(s => ++s) }, [showSpinner]);

      y(() => {
        setShownStatusLongEnough(false);
      }, [mode]);
      var [shownStatusLongEnough, setShownStatusLongEnough] = useState(false);
      useTimeout({
        callback: () => {
          if (mode == "failed" || mode == "succeeded") setShownStatusLongEnough(true);
        },
        timeout: 1000,
        triggerIndex: mode
      });
      var progressProps = useProgressProps({
        "aria-hidden": "".concat(mode != "pending")
      });
      var progressElement = v$1("div", _objectSpread2({}, useMergedProps()({
        ref,
        className: clsx("circular-progress-container")
      }, useMergedProps()(progressProps, p))), mode === "pending" && !!loadingLabel && v$1("div", {
        role: "alert",
        "aria-live": "assertive",
        class: "visually-hidden"
      }, loadingLabel), v$1(Swappable, null, v$1("div", {
        className: "circular-progress-swappable"
      }, v$1(Fade, {
        open: mode === "pending" && showSpinner
      }, v$1("div", {
        style: {
          "--count": gimmickCount
        },
        className: clsx("circular-progress", color ? "circular-progress-".concat(color) : undefined, colorFill == "foreground" && "inverse-fill", colorFill === "foreground-only" && "no-fill")
      }, Array.from(function* () {
        for (var i = 0; i < gimmickCount; ++i) {
          yield v$1("div", null, v$1("div", null));
        }
      }()))), v$1(Fade, {
        open: !shownStatusLongEnough && mode === "succeeded"
      }, v$1("div", {
        class: "circular-progress-succeeded"
      }, v$1(Check, null))), v$1(Fade, {
        open: !shownStatusLongEnough && mode === "failed"
      }, v$1("div", {
        class: "circular-progress-failed"
      }, v$1(Cross, null))))));
      (_childrenPosition = childrenPosition) !== null && _childrenPosition !== void 0 ? _childrenPosition : childrenPosition = "after";
      return v$1(d$1, null, childrenPosition == "before" && progressElement, children && v$1(children.type, useMergedProps()({
        children: childrenPosition === "child" ? progressElement : undefined,
        ref: children.ref
      }, useReferencedProps(children.props))), childrenPosition == "after" && progressElement);
    });

    var UseButtonGroupChild = D$1(null);
    var DefaultFillStyleContext = D$1("fill");
    var DefaultColorStyleContext = D$1("primary");
    var DefaultSizeContext = D$1("md");
    var DefaultDisabledContext = D$1(false);
    var ProvideDefaultButtonFill = g(function ProvideDefaultButtonFill({
      value,
      children
    }) {
      return v$1(DefaultFillStyleContext.Provider, {
        value: value
      }, children);
    });
    var ProvideDefaultButtonColor = g(function ProvideDefaultButtonColor({
      value,
      children
    }) {
      return v$1(DefaultColorStyleContext.Provider, {
        value: value
      }, children);
    });
    var ProvideDefaultButtonSize = g(function ProvideDefaultButtonSize({
      value,
      children
    }) {
      return v$1(DefaultSizeContext.Provider, {
        value: value
      }, children);
    });
    var ProvideDefaultButtonDisabled = g(function ProvideDefaultButtonDisabled({
      value,
      children
    }) {
      return v$1(DefaultDisabledContext.Provider, {
        value: value
      }, children);
    });
    function useButtonFillVariant(providedValue) {
      var defaultFill = F(DefaultFillStyleContext);
      return providedValue !== null && providedValue !== void 0 ? providedValue : defaultFill;
    }
    function useButtonColorVariant(providedValue) {
      var defaultColor = F(DefaultColorStyleContext);
      return providedValue !== null && providedValue !== void 0 ? providedValue : defaultColor;
    }
    function useButtonSize(providedValue) {
      var defaultSize = F(DefaultSizeContext);
      return providedValue !== null && providedValue !== void 0 ? providedValue : defaultSize;
    }
    function useButtonDisabled(providedValue) {
      var defaultDisabled = F(DefaultDisabledContext);
      return providedValue !== null && providedValue !== void 0 ? providedValue : defaultDisabled;
    }
    function useButtonStyles(p) {
      var {
        colorVariant,
        size,
        fillVariant,
        disabled
      } = p;
      colorVariant = useButtonColorVariant(colorVariant);
      size = useButtonSize(size);
      fillVariant = useButtonFillVariant(fillVariant);
      disabled = useButtonDisabled(disabled);

      var useButtonStylesProps = props => useMergedProps()({
        "aria-disabled": disabled ? "true" : undefined,
        className: clsx(disabled && "disabled", "btn", "btn-".concat(fillVariant == "outline" ? "outline-" : "").concat(colorVariant), "btn-".concat(size), disabled && "disabled")
      }, props);

      return {
        colorVariant,
        size,
        fillVariant,
        disabled,
        useButtonStylesProps
      };
    }

    var _excluded$e = ["colorVariant", "size", "fillVariant", "disabled"],
        _excluded2$b = ["colorVariant", "size", "fillVariant", "disabled", "debounce", "showAsyncSuccess", "onClick"],
        _excluded3$5 = ["colorVariant", "size", "disabled", "pressed", "debounce", "onInput", "showAsyncSuccess"];

    function ButtonR(p, ref) {
      var _p$tag;

      if (((_p$tag = p.tag) === null || _p$tag === void 0 ? void 0 : _p$tag.toLowerCase()) === "a" || !!p.href) return v$1(AnchorButton, _objectSpread2({
        ref: ref
      }, p));else if (p.pressed != null) return v$1(ToggleButton, _objectSpread2({
        ref: ref
      }, p));else return v$1(ButtonButton, _objectSpread2({
        ref: ref
      }, p));
    }

    var AnchorButton = forwardElementRef(function AnchorButton(p, ref) {
      var {
        colorVariant,
        size,
        fillVariant,
        disabled
      } = p,
          props = _objectWithoutProperties(p, _excluded$e);

      var buttonStyleInfo = useButtonStyles({
        colorVariant,
        size,
        fillVariant,
        disabled
      });
      disabled = buttonStyleInfo.disabled;
      colorVariant = buttonStyleInfo.colorVariant;
      size = buttonStyleInfo.size;
      fillVariant = buttonStyleInfo.fillVariant;
      var useButtonStylesProps = buttonStyleInfo.useButtonStylesProps;
      return v$1("a", _objectSpread2({}, useButtonStylesProps(_objectSpread2(_objectSpread2({}, props), {}, {
        ref
      }))));
    });
    var ButtonButton = forwardElementRef(function ButtonButton(p, ref) {
      var {
        colorVariant,
        size,
        fillVariant,
        disabled,
        debounce,
        showAsyncSuccess,
        onClick: onClickAsync
      } = p,
          props = _objectWithoutProperties(p, _excluded2$b);

      var {
        getSyncHandler,
        pending,
        settleCount,
        hasError
      } = useAsyncHandler()({
        debounce,
        capture: A$1(() => {
          return undefined;
        }, [])
      });
      disabled || (disabled = pending);
      var {
        useAriaButtonProps
      } = useAriaButton({
        tag: "button"
      });
      var buttonStyleInfo = useButtonStyles({
        colorVariant,
        size,
        fillVariant,
        disabled
      });
      disabled = buttonStyleInfo.disabled;
      colorVariant = buttonStyleInfo.colorVariant;
      size = buttonStyleInfo.size;
      fillVariant = buttonStyleInfo.fillVariant;
      var useButtonStylesProps = buttonStyleInfo.useButtonStylesProps;
      var onClick = getSyncHandler(pending ? null : onClickAsync);
      return v$1(ProgressCircular, {
        mode: hasError ? "failed" : pending ? "pending" : settleCount && showAsyncSuccess ? "succeeded" : null,
        childrenPosition: "child",
        colorFill: fillVariant == "fill" ? "foreground" : "background"
      }, v$1("button", _objectSpread2({}, useAriaButtonProps(useButtonStylesProps(useMergedProps()({
        className: clsx(pending && "pending active", disabled && "disabled")
      }, _objectSpread2(_objectSpread2({}, props), {}, {
        onClick,
        ref
      })))))));
    });
    var ToggleButton = forwardElementRef(function ToggleButton(p, ref) {
      var {
        colorVariant,
        size,
        disabled,
        pressed,
        debounce,
        onInput: onPressAsync,
        showAsyncSuccess
      } = p,
          props = _objectWithoutProperties(p, _excluded3$5);

      var fillVariant = pressed ? "fill" : "outline";
      var inButtonGroup = !!F(UseButtonGroupChild);
      var getPressed = useStableGetter(pressed);
      var {
        getSyncHandler,
        pending,
        hasError,
        settleCount,
        hasCapture,
        currentCapture
      } = useAsyncHandler()({
        debounce,
        capture: A$1(() => {
          return !getPressed();
        }, [])
      });
      disabled || (disabled = pending);
      if (hasCapture && pending) pressed = currentCapture;
      var {
        useAriaButtonProps
      } = useAriaButton({
        tag: "button",
        pressed
      });
      var buttonStyleInfo = useButtonStyles({
        colorVariant,
        size,
        fillVariant,
        disabled
      });
      disabled = buttonStyleInfo.disabled;
      colorVariant = buttonStyleInfo.colorVariant;
      size = buttonStyleInfo.size;
      var useButtonStylesProps = buttonStyleInfo.useButtonStylesProps;
      var onClick = getSyncHandler(pending ? null : onPressAsync);
      return v$1(ProgressCircular, {
        mode: hasError ? "failed" : pending ? "pending" : settleCount && showAsyncSuccess ? "succeeded" : null,
        childrenPosition: "child",
        colorFill: fillVariant == "fill" ? "foreground" : "background"
      }, v$1("button", _objectSpread2({}, useAriaButtonProps(useButtonStylesProps(_objectSpread2({}, useMergedProps()({
        className: clsx("toggle-button", (pending || inButtonGroup && pressed) && "active"),
        onClick,
        ref
      }, props)))))));
    });
    var Button = forwardElementRef(ButtonR);

    var _excluded$d = ["colorVariant", "fillVariant", "size", "disabled", "selectedIndex", "wrap", "children"],
        _excluded2$a = ["index"];
    var ButtonGroup = forwardElementRef(function ButtonGroup(p, ref) {
      var {
        lastFocusedInner,
        useHasFocusProps
      } = useHasFocus();
      var {
        indicesByElement,
        managedChildren,
        useListNavigationChild,
        navigateToIndex,
        childCount
      } = useListNavigation({
        focusOnChange: lastFocusedInner
      }); // Styling props

      var {
        colorVariant,
        fillVariant,
        size,
        disabled,
        selectedIndex,
        wrap,
        children
      } = p,
          p3 = _objectWithoutProperties(p, _excluded$d);

      y(() => {
        if (selectedIndex != null) navigateToIndex(selectedIndex);
      }, [selectedIndex]); // Build new DOM props to merge based off the styling props

      colorVariant = useButtonColorVariant(colorVariant);
      size = useButtonSize(size);
      fillVariant = useButtonFillVariant(fillVariant);
      disabled = useButtonDisabled(disabled);
      var outerDomProps = useHasFocusProps(useMergedProps()({
        ref,
        role: "grid",
        class: "btn-group-aria-gridrow"
      }, p3));
      var innerDomProps = {
        role: "gridrow",
        disabled,
        className: clsx("btn-group", wrap && "wrap")
      }; // Remaining props, forwarded onto the DOM
      //const domProps =newDomProps, p3));

      outerDomProps["data-child-count"] = "".concat(childCount);
      return v$1(UseButtonGroupChild.Provider, {
        value: useListNavigationChild
      }, v$1(ProvideDefaultButtonColor, {
        value: colorVariant
      }, v$1(ProvideDefaultButtonFill, {
        value: fillVariant
      }, v$1(ProvideDefaultButtonSize, {
        value: size
      }, v$1(ProvideDefaultButtonDisabled, {
        value: disabled
      }, v$1("div", _objectSpread2({}, outerDomProps), v$1("div", _objectSpread2({}, innerDomProps), children)))))));
    });
    var ButtonGroupChild = forwardElementRef(function ButtonGroupChild1(_ref, ref) {
      var {
        index
      } = _ref,
          buttonProps = _objectWithoutProperties(_ref, _excluded2$a);

      // This is more-or-less forced to be a separate component because of the index prop.
      // It would be really nice to find a way to make that implicit based on DOM location,
      // specifically for small things like button groups...
      var useButtonGroupChild = F(UseButtonGroupChild);
      var {
        tabbable,
        useListNavigationChildProps,
        useListNavigationSiblingProps
      } = useButtonGroupChild({
        index,
        text: null
      }); // TODO: It's kinda fragile here how the sync onClick of listNavigation 
      // and the async onClick of button are mixing.

      var p = useListNavigationChildProps(_objectSpread2({
        ref,
        role: "gridcell"
      }, buttonProps));
      return v$1(Button, _objectSpread2({}, p));
    });

    var baseId = generateRandomId("render-portal-container-");
    function BodyPortal({
      children
    }) {
      var id = s(null);
      var [portalElement, setPortalElement] = l(null);
      y(() => {
        if (id.current == null) {
          id.current = generateRandomId();
        }

        var container = document.getElementById(baseId);

        if (!container) {
          container = document.createElement("div");
          container.id = baseId;
          container.className = "body-portal-container";
          document.body.appendChild(container);
        }

        var element = document.getElementById(id.current);

        if (!element) {
          element = document.createElement("div");
          element.className = "body-portal";
          element.id = id.current;
          container.appendChild(element);
        }

        setPortalElement(element);
        return () => document.removeChild(element);
      }, []);
      if (portalElement) return W(children, portalElement);else return null;
    }

    var _excluded$c = ["onClose", "open", "descriptive", "title", "footer", "Transition", "children"];
    var Dialog = forwardElementRef(function Dialog(_ref, ref) {
      var {
        onClose,
        open,
        descriptive,
        title,
        footer,
        Transition,
        children
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$c);

      var {
        useDialogBackdrop,
        useDialogBody,
        useDialogProps,
        useDialogTitle
      } = useAriaDialog({
        open,
        onClose
      });
      var {
        useDialogBackdropProps
      } = useDialogBackdrop();
      var {
        useDialogBodyProps
      } = useDialogBody({
        descriptive
      });
      var {
        useDialogTitleProps
      } = useDialogTitle();
      return v$1(BodyPortal, null, v$1("div", {
        class: "modal-portal-container"
      }, v$1(Fade, {
        open: open
      }, v$1("div", _objectSpread2({}, useDialogBackdropProps({
        class: "modal-backdrop  backdrop-filter-transition"
      })))), v$1(Transition, _objectSpread2({}, _objectSpread2({
        ref,
        open
      }, rest)), v$1("div", _objectSpread2({}, useDialogProps({
        class: "modal-dialog modal-dialog-scrollable"
      })), v$1("div", {
        class: "modal-content "
      }, title != null && v$1("div", _objectSpread2({}, useDialogTitleProps({
        class: "modal-header"
      })), v$1("h1", {
        class: "modal-title"
      }, title)), v$1("div", _objectSpread2({}, useDialogBodyProps({
        class: "modal-body"
      })), children), footer != null && v$1("div", {
        class: "modal-footer"
      }, footer))))));
    });

    var _excluded$b = ["onClose", "open", "descriptive", "title", "footer", "Transition", "children"];
    function Drawer(_ref) {
      var {
        onClose,
        open,
        descriptive,
        title,
        footer,
        Transition,
        children
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$b);

      var {
        useDrawerBackdrop,
        useDrawerBody,
        useDrawerProps,
        useDrawerTitle
      } = useDrawer({
        open,
        onClose
      });
      var {
        useDrawerBackdropProps
      } = useDrawerBackdrop();
      var {
        useDrawerBodyProps
      } = useDrawerBody({
        descriptive
      });
      var {
        useDrawerTitleProps
      } = useDrawerTitle();
      return v$1(BodyPortal, null, v$1("div", null, v$1(Fade, {
        open: open
      }, v$1("div", _objectSpread2({}, useDrawerBackdropProps({
        class: "offcanvas-backdrop backdrop-filter-transition"
      })))), v$1(Transition, _objectSpread2({}, _objectSpread2({
        open
      }, rest)), v$1("div", _objectSpread2({}, useDrawerProps({
        class: "offcanvas offcanvas-start",
        tabindex: -1
      })), v$1("div", {
        class: "offcanvas-header"
      }, v$1("h5", _objectSpread2({}, useDrawerTitleProps({
        class: "offcanvas-title"
      })), "Drawer"), v$1(Button, {
        tag: "button",
        class: "btn-close text-reset",
        "aria-label": "Close",
        onClick: () => onClose("escape")
      })), v$1("div", _objectSpread2({}, useDrawerBodyProps({
        class: "offcanvas-body"
      })), children)))));
    }

    var InInputGroupContext = D$1(false);
    var InInputGridContext = D$1(0);
    function useInputCaptures(type) {
      var capture = A$1(event => {
        switch (type) {
          case "text":
            return event.currentTarget.value;

          case "number":
            return event.currentTarget.valueAsNumber;
        }
      }, [type]);
      var uncapture = A$1(value => {
        switch (type) {
          case "text":
            return value;

          case "number":
            return "".concat(value);
        }
      }, [type]);
      return {
        capture,
        uncapture
      };
    }

    var _excluded$a = ["tag", "children"],
        _excluded2$9 = ["children", "tag"],
        _excluded3$4 = ["tag", "children", "disabled"];
    var InputGrid = forwardElementRef(function InputGrid(_ref, ref) {
      var {
        tag,
        children
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$a);

      return v$1(tag !== null && tag !== void 0 ? tag : "div", useMergedProps()({
        class: "input-grid",
        ref
      }, props), v$1(InInputGridContext.Provider, {
        value: F(InInputGridContext) + 1
      }, children));
    });
    /**
     * An InputGroup, that puts an Input and its Label together, visually, into one component.
     *
     * All Input-type components automatically detect when they're in an InputGroup and render different accordingly.
     */

    var InputGroup = forwardElementRef(function InputGroup(_ref2, ref) {
      var {
        children,
        tag
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$9);

      return v$1(tag !== null && tag !== void 0 ? tag : "div", useMergedProps()({
        class: "input-group",
        ref
      }, props), v$1(InInputGroupContext.Provider, {
        value: true
      }, children));
    });
    /**
     * Not generally needed, since most input components come with labels that do this for you.
     *
     * That being said, if you just need a static block of text not hooked up to any input element, this is your component.
     */

    var InputGroupText = forwardElementRef(function InputGroupText(_ref3, ref) {
      var {
        tag,
        children,
        disabled
      } = _ref3,
          props = _objectWithoutProperties(_ref3, _excluded3$4);

      /*
          return (
              cloneElement(children,
                  useMergedProps<any>()({ class: "input-group", ref }, children.props),
                  <InInputGroupContext.Provider value={true}>
                      {children}
                  </InInputGroupContext.Provider>
              )
          );*/

      /*const inInputGrid = !!useContext(InInputGridContext);
      if (inInputGrid) {
          children = <div class="form-control faux-form-control">{children}</div>
      }*/
      return v$1(tag !== null && tag !== void 0 ? tag : "div", useMergedProps()({
        class: clsx(disabled && "disabled", "input-group-text"),
        ref
      }, props), children);
    });

    var _excluded$9 = ["type", "disabled", "value", "onInput"],
        _excluded2$8 = ["getSyncHandler", "currentCapture", "pending", "hasError", "settleCount", "flushDebouncedPromise", "currentType"],
        _excluded3$3 = ["children", "width", "labelPosition"];

    function UnlabelledInput(_ref) {
      var {
        type,
        disabled,
        value,
        onInput: onInputAsync
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$9);

      var {
        capture,
        uncapture
      } = useInputCaptures(type);
      var {
        focusedInner,
        useHasFocusProps
      } = useHasFocus();

      var _useAsyncHandler = useAsyncHandler()({
        capture,
        debounce: 1500
      }),
          {
        getSyncHandler,
        currentCapture,
        pending,
        hasError,
        settleCount,
        flushDebouncedPromise,
        currentType
      } = _useAsyncHandler;
          _objectWithoutProperties(_useAsyncHandler, _excluded2$8);

      var onInput = getSyncHandler(disabled ? null : onInputAsync);
      var asyncState = hasError ? "failed" : pending ? "pending" : settleCount ? "succeeded" : null;
      var onBlur = flushDebouncedPromise;
      return v$1(ProgressCircular, {
        spinnerTimeout: 10,
        mode: currentType === "async" ? asyncState : null,
        childrenPosition: "after",
        color: "info"
      }, v$1("input", _objectSpread2({}, useHasFocusProps(useMergedProps()(props, {
        "aria-disabled": disabled ? "true" : undefined,
        readOnly: disabled,
        onBlur,
        class: clsx("form-control", disabled && "disabled", pending && "with-end-icon"),
        type,
        value: pending || focusedInner ? currentCapture : uncapture(value),
        onInput
      })))));
    }

    function Input(_ref2) {
      var _labelPosition;

      var {
        children,
        width,
        labelPosition
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded3$3);

      (_labelPosition = labelPosition) !== null && _labelPosition !== void 0 ? _labelPosition : labelPosition = "start";
      var {
        inputId,
        labelId,
        useInputLabelInput,
        useInputLabelLabel
      } = useInputLabel({
        inputPrefix: "input-",
        labelPrefix: "input-label-"
      });
      var {
        useInputLabelInputProps
      } = useInputLabelInput();
      var {
        useInputLabelLabelProps
      } = useInputLabelLabel({
        tag: "label"
      });
      var isInInputGroup = F(InInputGroupContext);
      var isInInputGrid = F(InInputGridContext);
      var stringLabel = "".concat(children);

      if (children != null && labelPosition === "hidden") {
        if (!["string", "number", "boolean"].includes(typeof children)) console.error("Hidden labels require a string-based label for the aria-label attribute.");else props["aria-label"] = stringLabel;
      }

      var labelJsx = v$1("label", _objectSpread2({}, useInputLabelLabelProps({
        class: clsx(props.disabled && "disabled", isInInputGroup ? "input-group-text" : labelPosition != "floating" ? "form-label" : "")
      })), children);
      var inputJsx = v$1(UnlabelledInput, _objectSpread2({}, useInputLabelInputProps(props)));

      if (isInInputGrid) {
        inputJsx = v$1("div", {
          class: "form-control faux-form-control",
          style: width !== null && width !== void 0 && width.endsWith("ch") ? {
            "--form-control-width": width !== null && width !== void 0 ? width : "20ch"
          } : width ? {
            width
          } : undefined
        }, inputJsx);
      }

      var inputWithLabel = v$1(d$1, null, labelPosition === "start" && labelJsx, inputJsx, (labelPosition === "end" || labelPosition == "floating") && labelJsx);
      if (labelPosition !== "floating") return inputWithLabel;else return v$1("div", {
        class: "form-floating"
      }, inputJsx);
    }

    var _excluded$8 = ["checked", "disabled", "onInput", "labelPosition", "children"],
        _excluded2$7 = ["tag", "children", "isInput"];

    function capture(e) {
      return e[EventDetail].checked;
    }
    /**
     * TODO: When inside an InputGroup, Checkboxes don't forward any properties or refs because there's no one DOM element to attach to.
     *
     * Probably need separate `inputRef` & `labelRef` properties for that,
     * but given there's also no easy way to forward props to just them a solution like that feels incomplete.
     */


    var Checkbox = forwardElementRef(function Checkbox(_ref, ref) {
      var _labelPosition, _disabled;

      var {
        checked,
        disabled,
        onInput: onInputAsync,
        labelPosition,
        children: label
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$8);

      (_labelPosition = labelPosition) !== null && _labelPosition !== void 0 ? _labelPosition : labelPosition = "end";
      var {
        getSyncHandler,
        pending,
        hasError,
        settleCount,
        hasCapture,
        currentCapture,
        currentType
      } = useAsyncHandler()({
        capture
      });
      disabled || (disabled = pending);
      var onInput = getSyncHandler(onInputAsync);
      var {
        useCheckboxInputElement,
        useCheckboxLabelElement
      } = useAriaCheckbox({
        checked: pending ? currentCapture : checked === "indeterminate" ? "mixed" : checked,
        disabled: (_disabled = disabled) !== null && _disabled !== void 0 ? _disabled : false,
        onInput,
        labelPosition: "separate"
      });
      var {
        useCheckboxInputElementProps
      } = useCheckboxInputElement({
        tag: "input"
      });
      var {
        useCheckboxLabelElementProps
      } = useCheckboxLabelElement({
        tag: "label"
      });
      var inInputGroup = F(InInputGroupContext);
      var stringLabel = "".concat(label);

      if (label != null && labelPosition === "hidden" && !["string", "number", "boolean"].includes(typeof label)) {
        console.error("Hidden labels require a string-based label for the aria-label attribute.");
      }

      var asyncState = hasError ? "failed" : pending ? "pending" : settleCount ? "succeeded" : null;
      var p = useMergedProps()(props, useCheckboxInputElementProps({
        ref,
        type: "checkbox",
        className: clsx("form-check-input", pending && "pending", disabled && "disabled", inInputGroup && "mt-0"),
        "aria-label": labelPosition === "hidden" ? stringLabel : undefined
      }));
      var inputElement = v$1(OptionallyInputGroup$1, {
        isInput: true,
        tag: inInputGroup ? "label" : null,
        tabIndex: -1,
        disabled: disabled
      }, v$1(ProgressCircular, {
        childrenPosition: "after",
        colorFill: "foreground-only",
        mode: currentType === "async" ? asyncState : null,
        color: "info"
      }, v$1("input", _objectSpread2({}, p))));
      var labelElement = v$1(d$1, null, label != null && v$1(OptionallyInputGroup$1, _objectSpread2({
        isInput: false,
        tag: "label"
      }, useCheckboxLabelElementProps({
        className: clsx(pending && "pending", disabled && "disabled", "form-check-label"),
        "aria-hidden": "true"
      })), label));
      var ret = v$1(d$1, null, labelPosition == "start" && labelElement, inputElement, labelPosition == "end" && labelElement);
      if (!inInputGroup) return v$1("div", _objectSpread2({}, useMergedProps()({}, {
        class: "form-check"
      })), ret);
      return ret;
    });
    D$1(null);
    D$1(null);
    function OptionallyInputGroup$1(_ref2) {
      var {
        tag,
        children,
        isInput
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$7);

      var inInputGroup = F(InInputGroupContext);
      var inInputGrid = !!F(InInputGridContext);
      if (!inInputGroup) return v$1(tag !== null && tag !== void 0 ? tag : d$1, props, children); // If we're in an InputGrid's InputGroup, then create a 
      // new child that's, CSS-wise, the "true" input.
      // The other one is used for its border styles and relative positioning.

      if (inInputGrid && isInput) children = v$1("div", {
        className: "input-group-text"
      }, children);
      return v$1(InputGroupText, _objectSpread2({
        tag: tag !== null && tag !== void 0 ? tag : "div"
      }, useMergedProps()({
        className: clsx(isInput && inInputGrid && "faux-input-group-text")
      }, props)), children);
    }

    var _excluded$7 = ["checked", "disabled", "onInput", "children", "labelPosition"],
        _excluded2$6 = ["tag", "isInput", "children"];
    /**
     * @see Checkbox
     * @param ref
     * @returns
     */

    function Switch(_ref, ref) {
      var _labelPosition, _disabled;

      var {
        checked,
        disabled,
        onInput: onInputAsync,
        children: label,
        labelPosition
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$7);

      (_labelPosition = labelPosition) !== null && _labelPosition !== void 0 ? _labelPosition : labelPosition = "end";
      var {
        getSyncHandler,
        pending,
        currentType,
        hasError,
        settleCount,
        currentCapture
      } = useAsyncHandler()({
        capture: e => e[EventDetail].checked
      });
      var asyncState = hasError ? "failed" : pending ? "pending" : settleCount ? "succeeded" : null;
      disabled || (disabled = pending);
      var onInput = getSyncHandler(onInputAsync);
      var {
        useCheckboxInputElement: useSwitchInputElement,
        useCheckboxLabelElement: useSwitchLabelElement
      } = useAriaCheckbox({
        checked: pending ? currentCapture : checked,
        disabled: (_disabled = disabled) !== null && _disabled !== void 0 ? _disabled : false,
        onInput,
        labelPosition: "separate"
      });
      var {
        useCheckboxInputElementProps: useSwitchInputElementProps
      } = useSwitchInputElement({
        tag: "input"
      });
      var {
        useCheckboxLabelElementProps: useSwitchLabelElementProps
      } = useSwitchLabelElement({
        tag: "label"
      });
      var inInputGroup = F(InInputGroupContext);
      var stringLabel = "".concat(label);

      if (label != null && labelPosition === "hidden" && !["string", "number", "boolean"].includes(typeof label)) {
        console.error("Hidden labels require a string-based label for the aria-label attribute.");
      }

      var inputElement = v$1(OptionallyInputGroup, {
        tag: inInputGroup ? "label" : null,
        disabled: disabled,
        tabIndex: -1,
        isInput: true
      }, v$1(ProgressCircular, {
        childrenPosition: "after",
        colorFill: "foreground-only",
        mode: currentType === "async" ? asyncState : null,
        color: "info"
      }, v$1("input", _objectSpread2({}, useSwitchInputElementProps({
        type: "checkbox",
        className: clsx(pending && "pending", "form-check-input", disabled && "disabled"),
        "aria-label": labelPosition === "hidden" ? stringLabel : undefined
      })))));
      var labelElement = v$1(d$1, null, label != null && v$1(OptionallyInputGroup, _objectSpread2({
        tag: "label",
        isInput: false
      }, useSwitchLabelElementProps({
        className: clsx(pending && "pending", "form-check-label", disabled && "disabled"),
        "aria-hidden": "true"
      })), label));
      var ret = v$1(d$1, null, labelPosition == "start" && labelElement, inputElement, labelPosition == "end" && labelElement);
      if (!inInputGroup) return v$1("div", _objectSpread2({}, useMergedProps()(rest, {
        ref,
        class: "form-check form-switch"
      })), ret);
      return ret;
    } // Note: Slightly different from the others
    // (^^^^ I'm really glad I left that there)

    function OptionallyInputGroup(_ref2) {
      var {
        tag,
        isInput,
        children
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$6);

      var inInputGroup = F(InInputGroupContext);
      var inInputGrid = F(InInputGridContext);
      if (!inInputGroup) return v$1(tag !== null && tag !== void 0 ? tag : d$1, props, children);
      if (inInputGrid && isInput) children = v$1("div", {
        className: clsx(isInput && inInputGrid && "form-switch", "input-group-text")
      }, children);
      return v$1(InputGroupText, _objectSpread2({
        tag: tag !== null && tag !== void 0 ? tag : "div"
      }, useMergedProps()({
        className: clsx("input-group-text", isInput && !inInputGrid && "form-switch", isInput && inInputGrid && "faux-input-group-text")
      }, props)), children);
    }

    var knownNames = new Set();
    var CurrentHandlerTypeContext = D$1("sync");
    var RadioGroupContext = D$1(null);
    function RadioGroup({
      children,
      name,
      selectedValue,
      label,
      labelPosition,
      onInput: onInputAsync
    }) {
      var {
        getSyncHandler,
        pending,
        hasError,
        settleCount,
        currentCapture,
        currentType
      } = useAsyncHandler()({
        capture: e => e[EventDetail].selectedValue
      });
      var onInput = getSyncHandler(onInputAsync);
      var {
        useRadio,
        useRadioGroupProps,
        managedChildren,
        getIndex
      } = useAriaRadioGroup({
        name,
        selectedValue: pending ? currentCapture : selectedValue,
        onInput: onInput
      });
      var stringLabel = undefined;

      if (labelPosition === "hidden") {
        if (label != null && !["string", "number", "boolean"].includes(typeof label)) {
          console.error("Hidden labels require a string-based label for the aria-label attribute.");
        } else {
          stringLabel = "".concat(label);
        }
      } // Debugging check -- multiple groups with the same name can cause weird glitches from native radio selection behavior.


      y(() => {
        if (knownNames.has(name)) {
          console.error("Multiple radio groups with the name \"".concat(name, "\" exist on the same page at the same time!"));
        }

        knownNames.add(name);
        return () => knownNames.delete(name);
      }, [name]);
      var selectedIndex = getIndex(currentCapture !== null && currentCapture !== void 0 ? currentCapture : selectedValue); //const capturedIndex = getIndex(currentCapture!);

      useChildFlag(selectedIndex, managedChildren.length, (index, isSelected) => managedChildren[index].setAsyncState(isSelected ? hasError ? "failed" : pending ? "pending" : "succeeded" : null)); // useChildFlag(pending ? capturedIndex : null, managedChildren.length, useCallback((index, isCaptured) => managedChildren[index].setPending(isCaptured? "in" : false), []));

      var {
        useGenericLabelLabel,
        useGenericLabelInput
      } = useGenericLabel({
        inputPrefix: "aria-radiogroup",
        labelPrefix: "aria-radiogroup-label",
        backupText: stringLabel
      });
      var {
        useGenericLabelInputProps
      } = useGenericLabelInput();
      var {
        useGenericLabelLabelProps
      } = useGenericLabelLabel();
      var labelJsx = v$1("div", _objectSpread2({}, useGenericLabelLabelProps({})));
      var groupJsx = v$1("div", _objectSpread2({}, useGenericLabelInputProps(useRadioGroupProps({
        "aria-label": labelPosition === "hidden" ? stringLabel : undefined
      }))), children);
      return v$1(CurrentHandlerTypeContext.Provider, {
        value: currentType !== null && currentType !== void 0 ? currentType : "sync"
      }, v$1(RadioGroupContext.Provider, {
        value: useRadio
      }, labelPosition == "start" && labelJsx, groupJsx, labelPosition == "end" && labelJsx));
    }
    function Radio({
      disabled,
      children: label,
      index,
      value,
      labelPosition
    }) {
      var _labelPosition, _disabled, _label;

      var useAriaRadio = F(RadioGroupContext);
      (_labelPosition = labelPosition) !== null && _labelPosition !== void 0 ? _labelPosition : labelPosition = "end";
      var text = null;
      var currentHandlerType = F(CurrentHandlerTypeContext);
      var [asyncState, setAsyncState] = useState(null);
      disabled || (disabled = asyncState === "pending");
      var {
        useRadioInput,
        useRadioLabel
      } = useAriaRadio({
        disabled: (_disabled = disabled) !== null && _disabled !== void 0 ? _disabled : false,
        labelPosition: "separate",
        index,
        text,
        value,
        setAsyncState
      });
      var {
        useRadioInputProps
      } = useRadioInput({
        tag: "input"
      });
      var {
        useRadioLabelProps
      } = useRadioLabel({
        tag: "label"
      });
      var inInputGroup = F(InInputGroupContext);
      (_label = label) !== null && _label !== void 0 ? _label : label = value;
      var stringLabel = "".concat(label);

      if (label != null && labelPosition === "hidden" && !["string", "number", "boolean"].includes(typeof label)) {
        console.error("Hidden labels require a string-based label for the aria-label attribute.");
      }

      var inputElement = v$1(OptionallyInputGroup$1, {
        isInput: true,
        tag: inInputGroup ? "label" : null,
        disabled: disabled,
        tabIndex: -1
      }, v$1(ProgressCircular, {
        childrenPosition: "after",
        colorFill: "foreground-only",
        mode: currentHandlerType == "async" ? asyncState : null,
        color: "info"
      }, v$1("input", _objectSpread2({}, useRadioInputProps({
        type: "radio",
        className: clsx(asyncState === "pending" && "pending", disabled && "disabled", "form-check-input"),
        "aria-label": labelPosition === "hidden" ? stringLabel : undefined
      })))));
      var labelElement = v$1(d$1, null, label != null && v$1(OptionallyInputGroup$1, _objectSpread2({
        isInput: false,
        tag: "label"
      }, useRadioLabelProps({
        className: clsx(asyncState === "pending" && "pending", disabled && "disabled", "form-check-label"),
        "aria-hidden": "true"
      })), label));
      var ret = v$1(d$1, null, labelPosition == "start" && labelElement, inputElement, labelPosition == "end" && labelElement);
      if (!inInputGroup) return v$1("div", {
        class: "form-check"
      }, ret);
      return ret;
    }

    var _excluded$6 = ["tag", "minWidth", "children"],
        _excluded2$5 = ["tag", "columns", "children"];
    /**
     * Very simple, easy responsive grid that guarantees each column is the minimum size.
     *
     * Easy one-liners all around here!
     */

    var GridResponsive = forwardElementRef(function ResponsiveGrid(_ref, ref) {
      var {
        tag,
        minWidth,
        children
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$6);

      return v$1(tag !== null && tag !== void 0 ? tag : "div", useMergedProps()({
        className: "responsive-grid",
        style: minWidth ? {
          "--grid-min-width": "".concat(minWidth)
        } : {},
        ref
      }, props), children);
    });
    /**
     * Very simple, easy static grid that guarantees the number of columns is displayed,
     * no matter how janky it looks.
     */

    forwardElementRef(function ResponsiveGrid(_ref2, ref) {
      var {
        tag,
        columns,
        children
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$5);

      return v$1(tag !== null && tag !== void 0 ? tag : "div", useMergedProps()({
        className: "static-grid",
        style: typeof columns === "string" ? {
          "--static-grid-columns": columns
        } : {
          "--grid-column-count": columns
        },
        ref
      }, props), children);
    });

    var _excluded$5 = ["onSelect", "selectedIndex", "selectionMode", "collator", "keyNavigation", "noTypeahead", "noWrap", "typeaheadTimeout", "tag", "select"],
        _excluded2$4 = ["index"];
    var UseListboxSingleItemContext = D$1(null);
    function ListSingle(props, ref) {
      var {
        onSelect: onSelectAsync,
        selectedIndex,
        selectionMode,
        collator,
        keyNavigation,
        noTypeahead,
        noWrap,
        typeaheadTimeout,
        tag,
        select
      } = props,
          domProps = _objectWithoutProperties(props, _excluded$5);

      var {
        getSyncHandler
      } = useAsyncHandler()({
        capture: e => e[EventDetail].selectedIndex
      });
      var onSelect = getSyncHandler(onSelectAsync);
      var {
        useListboxSingleItem,
        useListboxSingleLabel,
        useListboxSingleProps
      } = useAriaListboxSingle({
        onSelect,
        selectedIndex,
        selectionMode,
        typeaheadTimeout,
        noWrap,
        noTypeahead,
        keyNavigation,
        collator
      });
      return v$1(UseListboxSingleItemContext.Provider, {
        value: useListboxSingleItem
      }, v$1(tag, useMergedProps()({
        class: "list-group",
        ref
      }, useListboxSingleProps(domProps))));
    }
    function ListItemSingle(props, ref) {
      var useListItemSingle = F(UseListboxSingleItemContext);

      var _props$ref = _objectSpread2(_objectSpread2({}, props), {}, {
        ref
      }),
          {
        index
      } = _props$ref,
          domProps = _objectWithoutProperties(_props$ref, _excluded2$4);

      var [text, setText] = useState(null);
      var {
        useRefElementProps,
        element
      } = useRefElement();
      h(() => {
        if (element) setText(element.innerText);
      }, [element]);
      var {
        getSelected,
        tabbable,
        selected,
        useListboxSingleItemProps
      } = useListItemSingle({
        index,
        text,
        tag: "li"
      });
      return v$1("li", _objectSpread2({}, usePseudoActive(useMergedProps()({
        class: clsx("list-group-item", "list-group-item-action", selected && "active")
      }, useListboxSingleItemProps(useRefElementProps(domProps))))));
    }

    var _globalThis$process, _globalThis$process2, _globalThis$process2$, _globalThis$process$e, _globalThis$process$e2;

    (_globalThis$process = globalThis.process) !== null && _globalThis$process !== void 0 ? _globalThis$process : globalThis.process = {};
    (_globalThis$process2$ = (_globalThis$process2 = globalThis.process).env) !== null && _globalThis$process2$ !== void 0 ? _globalThis$process2$ : _globalThis$process2.env = {};
    (_globalThis$process$e2 = (_globalThis$process$e = globalThis.process.env).NODE_ENV) !== null && _globalThis$process$e2 !== void 0 ? _globalThis$process$e2 : _globalThis$process$e.NODE_ENV = "development";

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }

      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }

      return node;
    }

    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }

    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }

      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }

          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$2,
      requires: ['computeStyles']
    };

    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }

    var round$1 = Math.round;
    function getBoundingClientRect(element, includeScale) {
      if (includeScale === void 0) {
        includeScale = false;
      }

      var rect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;

      if (isHTMLElement(element) && includeScale) {
        var offsetHeight = element.offsetHeight;
        var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
        // Fallback to 1 in case both values are `0`

        if (offsetWidth > 0) {
          scaleX = rect.width / offsetWidth || 1;
        }

        if (offsetHeight > 0) {
          scaleY = rect.height / offsetHeight || 1;
        }
      }

      return {
        width: round$1(rect.width / scaleX),
        height: round$1(rect.height / scaleY),
        top: round$1(rect.top / scaleY),
        right: round$1(rect.right / scaleX),
        bottom: round$1(rect.bottom / scaleY),
        left: round$1(rect.left / scaleX),
        x: round$1(rect.left / scaleX),
        y: round$1(rect.top / scaleY)
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;

      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }

      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }

      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;

        do {
          if (next && parent.isSameNode(next)) {
            return true;
          } // $FlowFixMe[prop-missing]: need a better way to handle this...


          next = next.parentNode || next.host;
        } while (next);
      } // Give up, the result is false


      return false;
    }

    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === 'fixed') {
        return null;
      }

      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
      var isIE = navigator.userAgent.indexOf('Trident') !== -1;

      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle$1(element);

        if (elementCss.position === 'fixed') {
          return null;
        }
      }

      var currentNode = getParentNode(element);

      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    var max = Math.max;
    var min = Math.min;
    var round = Math.round;

    function within(min$1, value, max$1) {
      return max(min$1, min(value, max$1));
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect$1(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      if (process.env.NODE_ENV !== "production") {
        if (!isHTMLElement(arrowElement)) {
          console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
        }
      }

      if (!contains(state.elements.popper, arrowElement)) {
        if (process.env.NODE_ENV !== "production") {
          console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
        }

        return;
      }

      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$1,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(round(x * dpr) / dpr) || 0,
        y: round(round(y * dpr) / dpr) || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          variation = _ref2.variation,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets;

      var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,
          _ref3$x = _ref3.x,
          x = _ref3$x === void 0 ? 0 : _ref3$x,
          _ref3$y = _ref3.y,
          y = _ref3$y === void 0 ? 0 : _ref3$y;

      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);

          if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


        offsetParent = offsetParent;

        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom; // $FlowFixMe[prop-missing]

          y -= offsetParent[heightProp] - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right; // $FlowFixMe[prop-missing]

          x -= offsetParent[widthProp] - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref4) {
      var state = _ref4.state,
          options = _ref4.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

      if (process.env.NODE_ENV !== "production") {
        var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';

        if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
          return transitionProperty.indexOf(property) >= 0;
        })) {
          console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
        }
      }

      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }

      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    var passive = {
      passive: true
    };

    function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getViewportRect(element) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
      // can be obscured underneath it.
      // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
      // if it isn't open, so if this isn't available, the popper will be detected
      // to overflow the bottom of the screen too early.

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent

        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;

      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle$1(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;

      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element) {
      var rect = getBoundingClientRect(element);
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

      if (!isElement(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;

        if (process.env.NODE_ENV !== "production") {
          console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
        }
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement(placement);

        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases  research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name; // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step

      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis || checkAltAxis) {
        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
        var max$1 = popperOffsets[mainAxis] - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
        var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;

        if (checkMainAxis) {
          var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
          popperOffsets[mainAxis] = preventedOffset;
          data[mainAxis] = preventedOffset - offset;
        }

        if (checkAltAxis) {
          var _mainSide = mainAxis === 'x' ? top : left;

          var _altSide = mainAxis === 'x' ? bottom : right;

          var _offset = popperOffsets[altAxis];

          var _min = _offset + overflow[_mainSide];

          var _max = _offset - overflow[_altSide];

          var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);

          popperOffsets[altAxis] = _preventedOffset;
          data[altAxis] = _preventedOffset - _offset;
        }
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = rect.width / element.offsetWidth || 1;
      var scaleY = rect.height / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.


    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function format(str) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return [].concat(args).reduce(function (p, c) {
        return p.replace(/%s/, c);
      }, str);
    }

    var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
    var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
    var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
    function validateModifiers(modifiers) {
      modifiers.forEach(function (modifier) {
        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
        .filter(function (value, index, self) {
          return self.indexOf(value) === index;
        }).forEach(function (key) {
          switch (key) {
            case 'name':
              if (typeof modifier.name !== 'string') {
                console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
              }

              break;

            case 'enabled':
              if (typeof modifier.enabled !== 'boolean') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
              }

              break;

            case 'phase':
              if (modifierPhases.indexOf(modifier.phase) < 0) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
              }

              break;

            case 'fn':
              if (typeof modifier.fn !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'effect':
              if (modifier.effect != null && typeof modifier.effect !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'requires':
              if (modifier.requires != null && !Array.isArray(modifier.requires)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
              }

              break;

            case 'requiresIfExists':
              if (!Array.isArray(modifier.requiresIfExists)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
              }

              break;

            case 'options':
            case 'data':
              break;

            default:
              console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
                return "\"" + s + "\"";
              }).join(', ') + "; but \"" + key + "\" was provided.");
          }

          modifier.requires && modifier.requires.forEach(function (requirement) {
            if (modifiers.find(function (mod) {
              return mod.name === requirement;
            }) == null) {
              console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
            }
          });
        });
      });
    }

    function uniqueBy(arr, fn) {
      var identifiers = new Set();
      return arr.filter(function (item) {
        var identifier = fn(item);

        if (!identifiers.has(identifier)) {
          identifiers.add(identifier);
          return true;
        }
      });
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
    var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(setOptionsAction) {
            var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned
            // if one of the modifiers is invalid for any reason

            if (process.env.NODE_ENV !== "production") {
              var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
                var name = _ref.name;
                return name;
              });
              validateModifiers(modifiers);

              if (getBasePlacement(state.options.placement) === auto) {
                var flipModifier = state.orderedModifiers.find(function (_ref2) {
                  var name = _ref2.name;
                  return name === 'flip';
                });

                if (!flipModifier) {
                  console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
                }
              }

              var _getComputedStyle = getComputedStyle$1(popper),
                  marginTop = _getComputedStyle.marginTop,
                  marginRight = _getComputedStyle.marginRight,
                  marginBottom = _getComputedStyle.marginBottom,
                  marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
              // cause bugs with positioning, so we'll warn the consumer


              if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
                return parseFloat(margin);
              })) {
                console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
              }
            }

            runModifierEffects();
            return instance.update();
          },
          // Sync update  it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {
              if (process.env.NODE_ENV !== "production") {
                console.error(INVALID_ELEMENT_ERROR);
              }

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            var __debug_loops__ = 0;

            for (var index = 0; index < state.orderedModifiers.length; index++) {
              if (process.env.NODE_ENV !== "production") {
                __debug_loops__ += 1;

                if (__debug_loops__ > 100) {
                  console.error(INFINITE_LOOP_ERROR);
                  break;
                }
              }

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update  it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    function usePopperApi({
      updating,
      position,
      skidding,
      distance,
      paddingTop,
      paddingBottom,
      paddingLeft,
      paddingRight
    }) {
      var [popperInstance, setPopperInstance, getPopperInstance] = useState(null);
      var [usedPlacement, setUsedPlacement] = useState(null);
      var {
        element: sourceElement,
        getElement: getSourceElement,
        useRefElementProps: useSourceElementRefProps
      } = useRefElement();
      var {
        element: popperElement,
        getElement: getPopperElement,
        useRefElementProps: usePopperElementRefProps
      } = useRefElement();
      var {
        element: arrowElement,
        getElement: getArrowElement,
        useRefElementProps: useArrowElementRefProps
      } = useRefElement();
      var [sourceStyle, setSourceStyle] = useState(null);
      var [sourceAttributes, setSourceAttributes] = useState({});
      var [popperStyle, setPopperStyle] = useState(null);
      var [popperAttributes, setPopperAttributes] = useState({});
      var [arrowStyle, setArrowStyle] = useState(null);
      var [arrowAttributes, setArrowAttributes] = useState({});
      y(() => {
        if (updating) {
          var rafHandle = 0;

          function raf() {
            var _ref, _getPopperInstance;

            var p = (_ref = closed ? Promise.resolve() : (_getPopperInstance = getPopperInstance()) === null || _getPopperInstance === void 0 ? void 0 : _getPopperInstance.update()) !== null && _ref !== void 0 ? _ref : Promise.resolve();
            p.then(_ => {
              if (rafHandle != 0) {
                rafHandle = requestAnimationFrame(raf);
              }
            });
          }

          rafHandle = requestAnimationFrame(raf);
          return () => {
            cancelAnimationFrame(rafHandle); // Single-threaded languages are nice sometimes.

            rafHandle = 0;
          };
        }
      }, [updating]);
      var updateStateModifier = d(() => {
        var modifier = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({
            state,
            options,
            name,
            instance
          }) => {
            var usedPlacement = state.placement;
            if (usedPlacement.includes("-")) usedPlacement = usedPlacement.substr(0, usedPlacement.indexOf("-"));
            setUsedPlacement(usedPlacement);
            if (state.styles.reference) setSourceStyle(state.styles.reference);
            if (state.attributes.reference) setSourceAttributes(state.attributes.reference);
            if (state.styles.popper) setPopperStyle(state.styles.popper);
            if (state.attributes.popper) setPopperAttributes(state.attributes.popper);
            if (state.styles.arrow) setArrowStyle(state.styles.arrow);
            if (state.attributes.arrow) setArrowAttributes(state.attributes.arrow);
          },
          requires: ["computeStyles", "flip"]
        };
        return modifier;
      }, []);
      var {
        convertElementSize,
        getLogicalDirection
      } = useLogicalDirection(sourceElement);
      y(() => {
        if (sourceElement && popperElement) {
          var onFirstUpdate = () => {};

          var strategy = "absolute";
          var placement = logicalToPlacement(getLogicalDirection(), position);
          setPopperInstance(createPopper(sourceElement, popperElement, {
            modifiers: [{
              name: "flip",
              options: {}
            }, {
              name: "preventOverflow",
              options: {
                padding: {
                  bottom: paddingBottom,
                  top: paddingTop,
                  left: paddingLeft,
                  right: paddingRight
                }
              }
            }, updateStateModifier, {
              name: 'eventListeners',
              enabled: false
            }, {
              name: "applyStyles",
              enabled: false
            }],
            onFirstUpdate,
            placement,
            strategy
          }));
        }
      }, [sourceElement, popperElement, position, skidding, distance, paddingTop, paddingBottom, paddingLeft, paddingRight]);

      function usePopperSource() {
        function usePopperSourceProps(props) {
          var style = _objectSpread2({}, sourceStyle);

          return useMergedProps()(sourceAttributes, useMergedProps()({
            style
          }, useSourceElementRefProps(props)));
        }

        return {
          usePopperSourceProps
        };
      }

      function usePopperPopup({
        open
      }) {
        function usePopperPopupProps(props) {
          var style = _objectSpread2(_objectSpread2({}, popperStyle), {}, {
            pointerEvents: open ? undefined : "none"
          });

          return useMergedProps()(popperAttributes, useMergedProps()({
            style
          }, usePopperElementRefProps(props)));
        }

        return {
          usePopperPopupProps
        };
      }

      function usePopperArrow() {
        function usePopperArrowProps(props) {
          var style = _objectSpread2({}, arrowStyle);

          return useMergedProps()(popperAttributes, useMergedProps()({
            style
          }, useArrowElementRefProps(props)));
        }

        return {
          usePopperArrowProps
        };
      }

      return {
        usePopperSource,
        usePopperPopup,
        usePopperArrow,
        usedPlacement,
        getLogicalDirection
      };
    }
    function placementToLogical(logicalDirection, placement) {
      var {
        blockDirection,
        blockOrientation,
        inlineDirection,
        inlineOrientation
      } = logicalDirection;
      var logical;

      switch ("".concat(inlineDirection, "-").concat(blockDirection, ",").concat(placement)) {
        // There's a pattern, and it could be coded as a pattern
        case "ltr-ttb,top":
          logical = "block-start";
          break;

        case "ltr-btt,bottom":
          logical = "block-start";
          break;

        case "rtl-ttb,top":
          logical = "block-start";
          break;

        case "rtl-btt,bottom":
          logical = "block-start";
          break;

        case "ttb-ltr,left":
          logical = "block-start";
          break;

        case "btt-ltr,right":
          logical = "block-start";
          break;

        case "ttb-rtl,left":
          logical = "block-start";
          break;

        case "btt-rtl,right":
          logical = "block-start";
          break;

        case "ltr-ttb,bottom":
          logical = "block-end";
          break;

        case "rtl-ttb,bottom":
          logical = "block-end";
          break;

        case "ltr-btt,top":
          logical = "block-end";
          break;

        case "rtl-btt,top":
          logical = "block-end";
          break;

        case "ttb-ltr,right":
          logical = "block-end";
          break;

        case "ttb-rtl,right":
          logical = "block-end";
          break;

        case "btt-ltr,left":
          logical = "block-end";
          break;

        case "btt-rtl,left":
          logical = "block-end";
          break;

        case "ttb-ltr,top":
          logical = "inline-start";
          break;

        case "ttb-rtl,top":
          logical = "inline-start";
          break;

        case "btt-ltr,bottom":
          logical = "inline-start";
          break;

        case "btt-rtl,bottom":
          logical = "inline-start";
          break;

        case "ltr-ttb,left":
          logical = "inline-start";
          break;

        case "rtl-ttb,left":
          logical = "inline-start";
          break;

        case "ltr-btt,right":
          logical = "inline-start";
          break;

        case "rtl-btt,right":
          logical = "inline-start";
          break;

        case "ttb-ltr,bottom":
          logical = "inline-end";
          break;

        case "ttb-rtl,bottom":
          logical = "inline-end";
          break;

        case "btt-ltr,top":
          logical = "inline-end";
          break;

        case "btt-rtl,top":
          logical = "inline-end";
          break;

        case "ltr-ttb,right":
          logical = "inline-end";
          break;

        case "rtl-ttb,right":
          logical = "inline-end";
          break;

        case "ltr-btt,left":
          logical = "inline-end";
          break;

        case "rtl-btt,left":
          logical = "inline-end";
          break;
        // Shouldn't happen, but here for type correctness.

        case "ttb-ttb,bottom":
        case "ttb-ttb,top":
        case "btt-btt,bottom":
        case "btt-btt,top":
        case "ltr-ltr,bottom":
        case "ltr-ltr,top":
        case "rtl-rtl,bottom":
        case "rtl-rtl,top":
        case "ttb-btt,bottom":
        case "btt-ttb,top":
        case "btt-ttb,bottom":
        case "ttb-btt,top":
        case "ltr-rtl,bottom":
        case "rtl-ltr,top":
        case "rtl-ltr,bottom":
        case "ltr-rtl,top":
        case "ttb-ttb,right":
        case "ttb-ttb,left":
        case "btt-btt,right":
        case "btt-btt,left":
        case "ltr-ltr,right":
        case "ltr-ltr,left":
        case "rtl-rtl,right":
        case "rtl-rtl,left":
        case "ttb-btt,right":
        case "btt-ttb,left":
        case "btt-ttb,right":
        case "ttb-btt,left":
        case "ltr-rtl,right":
        case "rtl-ltr,left":
        case "rtl-ltr,right":
        case "ltr-rtl,left":
          debugger;
          logical = logical;
          break;
      }

      return logical;
    }
    function logicalToPlacement(logicalDirection, position) {
      var placement;
      var {
        blockDirection,
        blockOrientation,
        inlineDirection,
        inlineOrientation
      } = logicalDirection;

      if (position === "block-start" || position == "block-end") {
        switch ("".concat(position, "-").concat(blockDirection)) {
          case "block-start-ttb":
            placement = "top";
            break;

          case "block-end-btt":
            placement = "top";
            break;

          case "block-start-btt":
            placement = "bottom";
            break;

          case "block-end-ttb":
            placement = "bottom";
            break;

          case "block-start-ltr":
            placement = "left";
            break;

          case "block-end-rtl":
            placement = "left";
            break;

          case "block-end-ltr":
            placement = "right";
            break;

          case "block-start-rtl":
            placement = "right";
            break;

          default:
            placement = "bottom";
            break;
        }
      } else {
        switch ("".concat(position, "-").concat(inlineDirection)) {
          case "inline-start-ltr":
            placement = "left";
            break;

          case "inline-end-rtl":
            placement = "left";
            break;

          case "inline-end-ltr":
            placement = "right";
            break;

          case "inline-start-rtl":
            placement = "right";
            break;

          case "inline-start-ttb":
            placement = "top";
            break;

          case "inline-end-btt":
            placement = "top";
            break;

          case "inline-end-ttb":
            placement = "bottom";
            break;

          case "inline-start-btt":
            placement = "bottom";
            break;

          default:
            placement = "right";
            break;
        }
      }

      return placement;
    }
    function useShouldUpdatePopper(open, elementSize) {
      // Since scroll events are asynchronous, especially on iOS devices,
      // just manually adjust the position of the popper for a bit
      // any time basically any user interaction happens.
      var [updatingForABit, setUpdatingForABit] = useState(0);
      useTimeout({
        callback: () => {
          setUpdatingForABit(0);
        },
        timeout: 100,
        triggerIndex: updatingForABit
      });
      var onInteraction = A$1(() => {
        setUpdatingForABit(u => ++u);
      }, [closed]);
      if (!open) onInteraction = null;
      useGlobalHandler(document, "keydown", onInteraction, {
        passive: true,
        capture: true
      });
      useGlobalHandler(window, "click", onInteraction, {
        passive: true,
        capture: true
      });
      useGlobalHandler(window, "scroll", open ? onInteraction : null, {
        passive: true,
        capture: true
      });
      useGlobalHandler(window, "pointermove", open ? onInteraction : null, {
        passive: true,
        capture: true
      });
      useGlobalHandler(window, "resize", open ? onInteraction : null, {
        passive: true,
        capture: true
      });
      y(() => {
        var _onInteraction;

        (_onInteraction = onInteraction) === null || _onInteraction === void 0 ? void 0 : _onInteraction();
      }, Object.values(elementSize !== null && elementSize !== void 0 ? elementSize : {}));
      return {
        shouldUpdate: !!updatingForABit,
        onInteraction
      };
    }
    /**
     * Handle the e.g. zoomOriginDynamic props, to turn them into zoomOriginInline or zoomOriginBlock as appropriate.
     * TODO: Right now, all *Dynamic props are just handled as 1 - prop. Some probably need to be -1 * prop though.
     */

    function fixProps(logicalDirection, requestedPlacement, usedPlacement, props) {
      var logicalSnake = placementToLogical(logicalDirection, usedPlacement);
      var propAxis;
      var reverse;

      switch (logicalSnake) {
        case "block-start":
          propAxis = "Block";
          reverse = requestedPlacement == "block-end";
          break;

        case "block-end":
          propAxis = "Block";
          reverse = requestedPlacement == "block-start";
          break;

        case "inline-start":
          propAxis = "Inline";
          reverse = requestedPlacement == "inline-end";
          break;

        case "inline-end":
          propAxis = "Inline";
          reverse = requestedPlacement == "inline-start";
          break;
      }

      var newProps = _objectSpread2({}, props);

      for (var propName in props) {
        if (propName.endsWith("Dynamic") && typeof props[propName] === "number") {
          var newPropName = "".concat(propName.substr(0, propName.indexOf("Dynamic"))).concat(propAxis);
          newProps[newPropName] = !reverse ? newProps[propName] : 1 - newProps[propName];
          delete newProps[propName];
        }
      }

      return newProps;
    }

    var _excluded$4 = ["anchor", "anchorTag", "children", "tag", "Transition"],
        _excluded2$3 = ["children", "index"];

    var OnCloseContext = D$1(undefined);
    var UseMenuItemContext = D$1(null);
    function Menu(_ref) {
      var {
        anchor,
        anchorTag,
        children,
        tag,
        Transition
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$4);

      var [open, setOpen] = useState(false);
      var onClose = A$1(() => setOpen(false), []);

      var onOpen = () => setOpen(true);

      var {
        useElementSizeProps,
        elementSize
      } = useElementSize();
      var {
        shouldUpdate: updatingForABit,
        onInteraction
      } = useShouldUpdatePopper(open, elementSize);
      var {
        usePopperArrow,
        usePopperPopup,
        usePopperSource,
        usedPlacement,
        getLogicalDirection
      } = usePopperApi({
        position: "block-end",
        updating: updatingForABit
      });
      var {
        useMenuButton,
        useMenuItem,
        useMenuItemCheckbox,
        useMenuProps,
        useMenuSubmenuItem,
        focusMenu
      } = useAriaMenu({
        open,
        onClose,
        onOpen
      });
      var {
        useMenuButtonProps
      } = useMenuButton({
        tag: anchorTag !== null && anchorTag !== void 0 ? anchorTag : "button"
      });
      var {
        usePopperSourceProps
      } = usePopperSource();
      var {
        usePopperPopupProps
      } = usePopperPopup({
        open
      });
      var {
        usePopperArrowProps
      } = usePopperArrow();
      /*const [sentinelFocused, setSentinelFocused] = useState(false);
      useTimeout({ callback: () => { if (sentinelFocused) onClose(); setSentinelFocused(false); }, timeout: 1000, triggerIndex: sentinelFocused.toString() })*/

      var [firstSentinelIsActive, setFirstSentinelIsActive] = useState(false);
      useTimeout({
        callback: () => {
          setFirstSentinelIsActive(open);
        },
        timeout: 100,
        triggerIndex: "".concat(firstSentinelIsActive)
      });
      var menuChildren = v$1(d$1, null, v$1("div", _objectSpread2({}, usePopperArrowProps({}))), v$1("button", {
        className: "visually-hidden",
        onFocus: !firstSentinelIsActive ? () => focusMenu === null || focusMenu === void 0 ? void 0 : focusMenu() : () => onClose(),
        onClick: onClose
      }, "Close menu"), children, v$1("button", {
        className: "visually-hidden",
        onFocus: onClose,
        onClick: onClose
      }, "Close menu"));
      var logicalDirection = getLogicalDirection();
      if (logicalDirection && usedPlacement) rest = fixProps(logicalDirection, "block-end", usedPlacement, rest);
      return v$1(d$1, null, v$1(OnCloseContext.Provider, {
        value: onClose
      }, v$1(UseMenuItemContext.Provider, {
        value: useMenuItem
      }, B(anchor, useMergedProps()(useElementSizeProps({
        ref: anchor.ref,
        class: "dropdown-toggle ".concat(open ? "active" : "")
      }), usePopperSourceProps(useMenuButtonProps(anchor.props)))), v$1(BodyPortal, null, v$1("div", _objectSpread2({}, usePopperPopupProps({
        class: "dropdown-menu-popper"
      })), v$1(Transition, _objectSpread2(_objectSpread2({}, useMenuProps(rest)), {}, {
        open: open,
        onTransitionUpdate: onInteraction,
        exitVisibility: "hidden"
      }), v$1("div", null, v$1(tag, {
        children: menuChildren,
        className: "dropdown-menu"
      }))))))));
    }
    function MenuItem(_ref2) {
      var {
        children,
        index
      } = _ref2,
          rest = _objectWithoutProperties(_ref2, _excluded2$3);

      var useMenuItem = F(UseMenuItemContext);
      var [text, setText] = useState(null);
      var {
        useRefElementProps,
        element
      } = useRefElement();
      h(() => {
        if (element) setText(element.innerText);
      }, [element]);
      var {
        useMenuItemProps
      } = useMenuItem({
        index,
        text
      });
      return v$1("li", null, v$1("button", _objectSpread2({}, useMenuItemProps(useRefElementProps(useMergedProps()(rest, {
        class: "dropdown-item"
      })))), children));
    }

    var _excluded$3 = ["onSelect", "orientation", "selectedIndex", "selectionMode", "tag", "children", "visualVariant"],
        _excluded2$2 = ["index", "children"],
        _excluded3$2 = ["index", "children", "Transition"];
    var UseTabContext = D$1(null);
    var UseTabPanelContext = D$1(null);
    function Tabs(_ref) {
      var _orientation;

      var {
        onSelect: onSelectAsync,
        orientation,
        selectedIndex,
        selectionMode,
        tag,
        children,
        visualVariant
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$3);

      var capture = e => {
        return e[EventDetail].selectedIndex;
      };

      (_orientation = orientation) !== null && _orientation !== void 0 ? _orientation : orientation = "inline";
      var {
        getSyncHandler
      } = useAsyncHandler()({
        capture: capture
      });
      var onSelect = getSyncHandler(onSelectAsync);
      var {
        useTab,
        useTabPanel,
        useTabsLabel,
        useTabsList
      } = useAriaTabs({
        onSelect,
        selectedIndex,
        selectionMode,
        orientation
      });
      var {
        useTabListProps
      } = useTabsList();
      return v$1("div", {
        class: clsx("tabs-container", "tabs-orientation-".concat(orientation))
      }, v$1(UseTabContext.Provider, {
        value: useTab
      }, B(children[0], useTabListProps(useMergedProps()({
        className: clsx("nav", visualVariant == "pills" ? "nav-pills" : "nav-tabs")
      }, _objectSpread2({}, props))), children[0].props.children)), v$1(UseTabPanelContext.Provider, {
        value: useTabPanel
      }, v$1(Swappable, null, v$1("div", {
        class: "tab-content"
      }, children.slice(1)))));
    }
    function Tab(_ref2) {
      var {
        index,
        children
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$2);

      var useTabContext = F(UseTabContext);
      var {
        useTabProps,
        selected
      } = useTabContext({
        index,
        text: null,
        tag: "button"
      });
      return v$1("li", {
        className: "nav-item",
        role: "presentation"
      }, v$1("button", _objectSpread2({}, useTabProps(useMergedProps()({
        class: clsx("nav-link", selected && "active")
      }, props))), children));
    }
    function TabPanel(_ref3) {
      var {
        index,
        children,
        Transition
      } = _ref3,
          rest = _objectWithoutProperties(_ref3, _excluded3$2);

      var useTabPanel = F(UseTabPanelContext);
      var {
        useTabPanelProps,
        selected
      } = useTabPanel({
        index
      });
      return v$1(Transition, useTabPanelProps(_objectSpread2({
        class: "",
        open: selected,
        children
      }, rest)));
    }

    var PushToastContext = D$1(null);
    var DefaultToastTimeout = D$1(5000);
    function ToastsProvider({
      children,
      defaultTimeout
    }) {
      var [pushToast, setPushToast] = useState(null);
      var pushToastStable = useStableCallback(toast => {
        pushToast === null || pushToast === void 0 ? void 0 : pushToast(toast);
      });
      return v$1(d$1, null, v$1(DefaultToastTimeout.Provider, {
        value: defaultTimeout !== null && defaultTimeout !== void 0 ? defaultTimeout : 5000
      }, v$1(ToastsProviderHelper, {
        setPushToast: setPushToast
      }), pushToast && v$1(PushToastContext.Provider, {
        value: pushToastStable
      }, children)));
    }
    function usePushToast() {
      var pushToast = F(PushToastContext);
      return pushToast;
    } // Extracted to a separate component to avoid rerendering all non-toast children

    function ToastsProviderHelper({
      setPushToast
    }) {
      var [children, setChildren] = useState([]);
      var pushToast = A$1(toast => {
        var randomKey = generateRandomId();
        setChildren(prev => [...prev, B(toast, {
          key: randomKey
        })]);
      }, []);
      h(() => {
        setPushToast(_ => pushToast);
      }, [pushToast]);
      return v$1(BodyPortal, null, v$1(ToastsContainerChildrenContext.Provider, {
        value: children
      }, v$1(ToastsContainer, null)));
    }

    var ToastsContainerChildrenContext = D$1([]);
    var UseToastContext = D$1(null);

    function ToastsContainer(props) {
      var children = F(ToastsContainerChildrenContext);
      var {
        useToast,
        useToastContainerProps
      } = useToasts(props);
      return v$1(UseToastContext.Provider, {
        value: useToast
      }, v$1("div", _objectSpread2({}, useToastContainerProps(props)), children));
    }

    var ToastDismissContext = D$1(null);
    function Toast({
      timeout,
      politeness,
      children
    }) {
      var useToast = F(UseToastContext);
      var defaultTimeout = F(DefaultToastTimeout);
      var {
        useToastProps,
        dismiss,
        status
      } = useToast({
        timeout: timeout !== null && timeout !== void 0 ? timeout : defaultTimeout,
        politeness
      });
      return v$1(ToastDismissContext.Provider, {
        value: dismiss
      }, v$1(SlideFade, {
        open: status != "dismissed",
        slideTargetInline: 1,
        animateOnMount: true,
        exitVisibility: "removed"
      }, v$1("div", _objectSpread2({}, useToastProps({
        class: "toast show"
      })), v$1("div", {
        class: "d-flex"
      }, v$1("div", {
        class: "toast-body"
      }, children), v$1(Button, {
        class: "btn-close me-2 m-auto",
        "aria-label": "Dismiss alert",
        onClick: dismiss
      })))));
    }
    /*
    export function ToastHeader({ children }: { children: ComponentChildren }) {
        return (
            <div class="toast-header">
                <div class="me-auto">
                    {children}
                </div>
                <Button class="btn-close" aria-label="Close" />
            </div>
        )
    }*/

    var _excluded$2 = ["children", "position", "tooltip", "Transition", "mouseoverDelay"];
    function Tooltip(_ref) {
      var {
        children,
        position,
        tooltip,
        Transition,
        mouseoverDelay
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$2);

      var {
        getIsOpen,
        isOpen,
        useTooltip,
        useTooltipTrigger
      } = useAriaTooltip({
        mouseoverDelay
      });
      var {
        useElementSizeProps,
        elementSize
      } = useElementSize();
      var cloneable;

      if (typeof children === "string" || typeof children === "number" || typeof children == "boolean" || typeof children === "bigint") {
        cloneable = v$1("span", null, children);
      } else if (Array.isArray(children)) {
        cloneable = v$1("span", null, children);
      } else {
        cloneable = children;
      }

      var {
        useTooltipProps
      } = useTooltip();
      var {
        useTooltipTriggerProps
      } = useTooltipTrigger();
      var {
        shouldUpdate,
        onInteraction
      } = useShouldUpdatePopper(isOpen, elementSize);
      var {
        getLogicalDirection,
        usePopperArrow,
        usePopperPopup,
        usePopperSource,
        usedPlacement
      } = usePopperApi({
        updating: shouldUpdate,
        position
      });
      var {
        usePopperPopupProps
      } = usePopperPopup({
        open: isOpen
      });
      var {
        usePopperArrowProps
      } = usePopperArrow();
      var {
        usePopperSourceProps
      } = usePopperSource();
      var logicalDirection = getLogicalDirection();
      if (logicalDirection && usedPlacement) rest = fixProps(logicalDirection, "block-end", usedPlacement, rest); // TODO: It's required for this to be exitVisibility="hidden" for transforms to work?
      // Probably an issue in the Transition element itself because it's not browser-specific but it's a little weird

      return v$1(d$1, null, B(cloneable, useMergedProps()({
        ref: cloneable.ref
      }, useTooltipTriggerProps(useElementSizeProps(usePopperSourceProps(cloneable.props))))), v$1(BodyPortal, null, v$1("div", _objectSpread2({}, usePopperPopupProps({
        class: "tooltip-wrapper"
      })), v$1(Transition, _objectSpread2(_objectSpread2({}, rest), {}, {
        open: isOpen,
        onTransitionUpdate: onInteraction,
        exitVisibility: "hidden"
      }), v$1("div", _objectSpread2({}, useTooltipProps(useMergedProps()({
        class: "tooltip show",
        role: "tooltip"
      }, {}))), v$1("div", _objectSpread2({}, usePopperArrowProps({
        class: "tooltip-arrow"
      }))), v$1("div", {
        class: "tooltip-inner"
      }, tooltip))))));
    }

    var _excluded$1 = ["children"],
        _excluded2$1 = ["children"],
        _excluded3$1 = ["type"],
        _excluded4$1 = ["type"],
        _excluded5$1 = ["type", "tag"],
        _excluded6$1 = ["type", "tag"],
        _excluded7$1 = ["type", "src"],
        _excluded8 = ["tag"],
        _excluded9 = ["position"],
        _excluded10 = ["tag"],
        _excluded11 = ["tag"];
    var Card = forwardElementRef(function Card(p, ref) {
      var {
        children
      } = p,
          props = _objectWithoutProperties(p, _excluded$1);

      return v$1("div", _objectSpread2({}, useMergedProps()({
        ref,
        className: "card"
      }, props)), children);
    });

    function CardElement2(_ref, ref) {
      var {
        children
      } = _ref,
          p = _objectWithoutProperties(_ref, _excluded2$1);

      switch (p.type) {
        default:
        case "paragraph":
          {
            var props = _objectWithoutProperties(p, _excluded3$1);

            return v$1(CardBody, _objectSpread2(_objectSpread2({}, props), {}, {
              ref: ref
            }), v$1(CardText, null, children));
          }

        case "footer":
          {
            var props = _objectWithoutProperties(p, _excluded4$1);

            return v$1(CardFooter, _objectSpread2(_objectSpread2({}, props), {}, {
              ref: ref
            }), children);
          }

        case "subtitle":
          {
            var {
              type: _type2,
              tag
            } = p,
                props = _objectWithoutProperties(p, _excluded5$1);

            return v$1(CardBody, _objectSpread2(_objectSpread2({}, props), {}, {
              ref: ref
            }), v$1(CardSubtitle, {
              tag: tag
            }, children));
          }

        case "title":
          {
            var {
              type: _type3,
              tag: _tag
            } = p,
                props = _objectWithoutProperties(p, _excluded6$1);

            return v$1(CardBody, _objectSpread2(_objectSpread2({}, props), {}, {
              ref: ref
            }), v$1(CardTitle, {
              tag: _tag
            }, children));
          }

        case "image":
          {
            var {
              type: _type4,
              src
            } = p,
                props = _objectWithoutProperties(p, _excluded7$1);

            return v$1(CardImage, _objectSpread2(_objectSpread2({
              src: src,
              position: "both"
            }, props), {}, {
              ref: ref
            }), children);
          }

        case "flush":
          {
            var {
              tag: _tag2
            } = p,
                props = _objectWithoutProperties(p, _excluded8);

            return v$1(_tag2, props, children);
          }
      }
    }

    var CardElement = forwardElementRef(CardElement2);
    var CardImage = forwardElementRef(function CardImage(p, ref) {
      var {
        position
      } = p,
          props = _objectWithoutProperties(p, _excluded9);

      return v$1("img", _objectSpread2({}, useMergedProps()(props, {
        ref,
        className: "card-img".concat(position == "both" ? "" : "-".concat(position))
      })));
    });
    var CardBody = forwardElementRef(function CardBody(props, ref) {
      return v$1("div", _objectSpread2({}, useMergedProps()(props, {
        ref,
        className: "card-body"
      })));
    });
    var CardFooter = forwardElementRef(function CardHeader(props, ref) {
      return v$1("div", _objectSpread2({}, useMergedProps()(props, {
        ref,
        className: "card"
      })));
    });
    var CardTitle = forwardElementRef(function CardTitle(p, ref) {
      var {
        tag
      } = p,
          props = _objectWithoutProperties(p, _excluded10);

      return v$1(tag !== null && tag !== void 0 ? tag : "h5", useMergedProps()(props, {
        ref,
        className: "card-title"
      }));
    });
    var CardSubtitle = forwardElementRef(function CardSubtitle(p, ref) {
      var {
        tag
      } = p,
          props = _objectWithoutProperties(p, _excluded11);

      return v$1(tag !== null && tag !== void 0 ? tag : "h5", useMergedProps()(props, {
        ref,
        className: clsx("card-subtitle", "mb-2", "text-muted")
      }));
    });
    var CardText = forwardElementRef(function CardText(props, ref) {
      return v$1("div", _objectSpread2({}, useMergedProps()(props, {
        ref,
        className: "card-text"
      })));
    });
    forwardElementRef(function CardHeader(props, ref) {
      return v$1("div", _objectSpread2({}, useMergedProps()(props, {
        ref,
        className: "card-header"
      })));
    });
    v$1(CardElement, {
      type: "title",
      tag: "h1",
      children: "",
      class: ""
    });

    function DemoButtons() {
        var _this = this;
        var _a = useState("outline"), buttonsFill = _a[0], setButtonsFill = _a[1];
        var _b = useState("md"), buttonsSize = _b[0];
        var _c = useState("primary"), buttonsColor = _c[0], setButtonsColor = _c[1];
        var _d = useState(false), toggleOn = _d[0], setToggleOn = _d[1];
        var _e = useState(3000), asyncTimeout = _e[0], setAsyncTimeout = _e[1];
        var _f = useState(true), usesAsync = _f[0], setUsesAsync = _f[1];
        var _g = useState(false), asyncFails = _g[0], setAsyncFails = _g[1];
        var _h = useState(true), usesLinkButton = _h[0], setUsesLinkButton = _h[1];
        var pushToast = usePushToast();
        var onClickSync = function () { return pushToast(v$1(Toast, null, "Button was clicked")); };
        var onClickAsync = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$3(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Button operation failed.");
                        else
                            onClickSync();
                        return [2 /*return*/];
                }
            });
        }); };
        var onClick = usesAsync ? onClickAsync : onClickSync;
        var onToggleInputAsync = function (b) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$3(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Button operation failed.");
                        else
                            setToggleOn(b);
                        return [2 /*return*/];
                }
            });
        }); };
        var onToggleInput = usesAsync ? onToggleInputAsync : setToggleOn;
        return (v$1(ProvideDefaultButtonFill, { value: buttonsFill },
            v$1(ProvideDefaultButtonSize, { value: buttonsSize },
                v$1(ProvideDefaultButtonColor, { value: buttonsColor },
                    v$1("div", { class: "demo" },
                        v$1(Card, null,
                            v$1(CardElement, { type: "title", tag: "h2" }, "Buttons"),
                            v$1(CardElement, null,
                                v$1(Button, { onClick: onClick }, "I'm a button")),
                            v$1(CardElement, null,
                                "A ",
                                v$1("code", null, "Button"),
                                " is a ",
                                v$1("code", null, "Button"),
                                " is a ",
                                v$1("code", null, "Button"),
                                " \u2013 you can click, tap, or Space-key it to activate it and do something.  If the given action is asynchronous, then the button will disable itself and display a spinner during the operation."),
                            v$1(CardElement, { type: "subtitle", tag: "h3" }, "Async inputs"),
                            v$1(CardElement, null,
                                "The ",
                                v$1("code", null, "onClick"),
                                " event handler for buttons can be sync or async, and they will react appropriately if the operation takes long enough.",
                                v$1(InputGrid, null,
                                    v$1(InputGroup, null,
                                        v$1(Checkbox, { onInput: setUsesAsync, checked: usesAsync, labelPosition: "start" }, "Use async handler")),
                                    v$1(InputGroup, null,
                                        v$1(Checkbox, { onInput: setAsyncFails, checked: asyncFails, labelPosition: "start", disabled: !usesAsync }, "Async handler rejects")),
                                    v$1(InputGroup, null,
                                        v$1(Input, { width: "8ch", disabled: !usesAsync, type: "number", onInput: setAsyncTimeout, value: asyncTimeout }, "Async timeout")))),
                            v$1(CardElement, null,
                                v$1(Button, { onClick: onClick }, "Click me")),
                            v$1(CardElement, { type: "paragraph" },
                                v$1("code", null, "const onClick = " + (usesAsync ? "async " : "") + "() => { " + (usesAsync ? "await sleep(" + asyncTimeout + "); " : "") + "pushToast(<Toast ... />); }\n<Button onClick={onClick}>Click me</Button>")),
                            v$1("hr", null),
                            v$1(CardElement, { type: "subtitle", tag: "h3" }, "Color & fill"),
                            v$1(CardElement, { type: "paragraph" },
                                "Buttons can be styled in different colors and fill styles. You can provide a global default with ",
                                v$1("code", null, "Context"),
                                " objects, like ",
                                v$1("code", null, "<ProvideDefaultButtonFill>"),
                                "."),
                            v$1(CardElement, null,
                                "All outline styles have extra CSS applied to make them have correct contrast ratios on the default body background, partially because toggle buttons don't allow their ",
                                v$1("code", null, "fill"),
                                " to be controlled."),
                            v$1(CardElement, null,
                                v$1(ButtonGroup, null,
                                    v$1(ButtonGroupChild, { index: 0, onInput: function () { return setButtonsFill("fill"); }, pressed: buttonsFill === "fill", colorVariant: "primary" }, "Fill"),
                                    v$1(ButtonGroupChild, { index: 1, onInput: function () { return setButtonsFill("outline"); }, pressed: buttonsFill === "outline", colorVariant: "primary" }, "Outline"))),
                            v$1(CardElement, null,
                                v$1(ButtonGroup, { wrap: true },
                                    v$1(ButtonGroupChild, { index: 0, colorVariant: "primary", pressed: buttonsColor == "primary", onInput: function () { return setButtonsColor("primary"); } }, "Primary"),
                                    v$1(ButtonGroupChild, { index: 1, colorVariant: "secondary", pressed: buttonsColor == "secondary", onInput: function () { return setButtonsColor("secondary"); } }, "Secondary"),
                                    v$1(ButtonGroupChild, { index: 2, colorVariant: "success", pressed: buttonsColor == "success", onInput: function () { return setButtonsColor("success"); } }, "Success"),
                                    v$1(ButtonGroupChild, { index: 3, colorVariant: "warning", pressed: buttonsColor == "warning", onInput: function () { return setButtonsColor("warning"); } }, "Warning"),
                                    v$1(ButtonGroupChild, { index: 4, colorVariant: "danger", pressed: buttonsColor == "danger", onInput: function () { return setButtonsColor("danger"); } }, "Danger"),
                                    v$1(ButtonGroupChild, { index: 5, colorVariant: "info", pressed: buttonsColor == "info", onInput: function () { return setButtonsColor("info"); } }, "Info"),
                                    v$1(ButtonGroupChild, { index: 6, colorVariant: "light", pressed: buttonsColor == "light", onInput: function () { return setButtonsColor("light"); } }, "Light"),
                                    v$1(ButtonGroupChild, { index: 7, colorVariant: "dark", pressed: buttonsColor == "dark", onInput: function () { return setButtonsColor("dark"); } }, "Dark"))),
                            v$1(CardElement, null,
                                v$1(Button, { onClick: onClick },
                                    buttonsFill === "fill" ? "Filled" : "Outlined",
                                    " ",
                                    buttonsColor,
                                    " button")),
                            v$1(CardElement, null,
                                v$1("code", null, "<Button fillVariant=\"" + buttonsFill + "\" colorVariant=\"" + buttonsColor + "\">Variant button</Button>")),
                            v$1("hr", null),
                            v$1(CardElement, { type: "subtitle", tag: "h3" }, "Link buttons"),
                            v$1(CardElement, null,
                                "A link can be styled as a button while retaining native link functionality (middle clicks, etc.). These buttons have no ",
                                v$1("code", null, "onClick"),
                                " handler, instead taking ",
                                v$1("code", null, "href"),
                                " and the other ",
                                v$1("code", null, "<a>"),
                                " props."),
                            v$1(CardElement, null,
                                "A ",
                                v$1("code", null, "<Button>"),
                                " will use an anchor link internally if you provide it with an ",
                                v$1("code", null, "href"),
                                " prop, or optionally setting the ",
                                v$1("code", null, "tag"),
                                " prop to ",
                                v$1("code", null, "a"),
                                ".",
                                v$1(InputGroup, null,
                                    v$1(Checkbox, { onInput: setUsesLinkButton, checked: usesLinkButton, labelPosition: "start" }, "Use link button"))),
                            v$1(CardElement, null, usesLinkButton ? v$1(Button, { target: "_blank", href: "https://www.example.com" },
                                "example.com ",
                                v$1("i", { class: "bi bi-box-arrow-up-right" })) : v$1(Button, { onClick: onClick }, "Regular button")),
                            v$1(CardElement, { type: "paragraph" },
                                v$1("code", null, usesLinkButton ? "<Button href=\"https://www.example.com\">Link button</Button>" : "<Button onClick={onClick}>Regular button</Button>")),
                            v$1("hr", null),
                            v$1(CardElement, { type: "subtitle", tag: "h3" }, "Toggle buttons"),
                            v$1(CardElement, null,
                                "If given a ",
                                v$1("code", null, "pressed"),
                                " prop, a button will become a toggle button, with an off/on state.  It will style itself as outlined when unpressed, and filled when pressed, so they are best used in groups."),
                            v$1(CardElement, null,
                                v$1(Button, { pressed: toggleOn, onInput: onToggleInput }, "Toggle button")),
                            v$1(CardElement, { type: "paragraph" },
                                v$1("code", null, "<Button pressed={pressed} onInput={onInput}>Toggle button</Button>")),
                            v$1("hr", null),
                            v$1(CardElement, { type: "subtitle", tag: "h3" }, "Button Groups"),
                            v$1(CardElement, null,
                                "A ",
                                v$1("code", null, "<ButtonGroup>"),
                                " can be used to group a set of ",
                                v$1("code", null, "<ButtonGroupChild>"),
                                " (which is the exact same as a ",
                                v$1("code", null, "<Button>"),
                                ", but with an ",
                                v$1("code", null, "index"),
                                " prop). This gives them keyboard navigation abilities."),
                            v$1(CardElement, null,
                                v$1(ButtonGroup, { wrap: true },
                                    v$1(ButtonGroupChild, { index: 0, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "First button"),
                                    v$1(ButtonGroupChild, { index: 1, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Second button"),
                                    v$1(ButtonGroupChild, { index: 2, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Third button"),
                                    v$1(ButtonGroupChild, { index: 3, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Fourth button"),
                                    v$1(ButtonGroupChild, { index: 4, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Fifth button"),
                                    v$1(ButtonGroupChild, { index: 5, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Sixth button"),
                                    v$1(ButtonGroupChild, { index: 6, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Seventh button"),
                                    v$1(ButtonGroupChild, { index: 7, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Eighth button"))),
                            v$1(CardElement, { type: "paragraph" },
                                v$1("code", null, "<ButtonGroup wrap>\n    <ButtonGroupChild index={0}>First button</ButtonGroupChild>\n    <ButtonGroupChild index={1}>Second button</ButtonGroupChild>\n    <ButtonGroupChild index={2}>Third button</ButtonGroupChild>\n    <ButtonGroupChild index={3}>Fourth button</ButtonGroupChild>\n    <ButtonGroupChild index={4}>Fifth button</ButtonGroupChild>\n    <ButtonGroupChild index={5}>Sixth button</ButtonGroupChild>\n    <ButtonGroupChild index={6}>Seventh button</ButtonGroupChild>\n    <ButtonGroupChild index={7}>Eighth button</ButtonGroupChild>\n</ButtonGroup>"))))))));
    }
    function sleep$3(arg0) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, arg0); })];
            });
        });
    }

    function DemoChecks() {
        var _this = this;
        var _a = useState(false), asyncFails = _a[0], setAsyncFails = _a[1];
        var _b = useState(3000), asyncTimeout = _b[0], setAsyncTimeout = _b[1];
        var _c = useState(true), usesAsync = _c[0], setUsesAsync = _c[1];
        var _d = useState(false), demoChecked = _d[0], setDemoChecked = _d[1];
        var _e = useState(0), demoRadio = _e[0], setDemoRadio = _e[1];
        var _f = useState(false), disabled = _f[0], setDisabled = _f[1];
        var _g = useState("end"), labelPosition = _g[0], setLabelPosition = _g[1];
        var asyncCheckboxInput = A$1(function (checked) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$2(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Attempt to change checkbox & radio failed");
                        setDemoChecked(checked);
                        return [2 /*return*/];
                }
            });
        }); }, [asyncTimeout, asyncFails]);
        var asyncRadioInput = A$1(function (value) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$2(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Attempt to change radio failed");
                        setDemoRadio(value);
                        return [2 /*return*/];
                }
            });
        }); }, [asyncTimeout, asyncFails]);
        return (v$1("div", { class: "demo" },
            v$1(Card, null,
                v$1(CardElement, { type: "title", tag: "h2" }, "Checkboxes, switches, & radios"),
                v$1(CardElement, null,
                    v$1(Checkbox, { checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "I'm a checkbox")),
                v$1(CardElement, null,
                    "Several components related to on/off togglable form-like selection controls are provided:",
                    v$1("ul", null,
                        v$1("li", null,
                            v$1("code", null, "Checkbox")),
                        v$1("li", null,
                            v$1("code", null, "Switch")),
                        v$1("li", null,
                            v$1("code", null, "Radio")),
                        v$1("li", null,
                            v$1("code", null, "Checkbox Group"))),
                    v$1("code", null, "Checkbox"),
                    " and ",
                    v$1("code", null, "Switch"),
                    " work as you'd expect. ",
                    v$1("code", null, "RadioGroup"),
                    " is a parent around a set of ",
                    v$1("code", null, "Radio"),
                    " components that communicate with each other. The children ",
                    v$1("code", null, "Radio"),
                    " components can be any descendant of the parent ",
                    v$1("code", null, "RadioGroup"),
                    " \u2013 the DOM structure ",
                    v$1("em", null, "does not"),
                    " matter beyond requiring they be somewhere descendant. ",
                    v$1("code", null, "CheckboxGroup"),
                    " works similarly to ",
                    v$1("code", null, "RadioGroup"),
                    " in that way."),
                v$1(CardElement, null,
                    "See Also: Single Select lists for an alternative to ",
                    v$1("code", null, "RadioGroup"),
                    ", and Multi Select lists for an alternative to ",
                    v$1("code", null, "CheckboxGroup"),
                    "."),
                v$1(CardElement, { type: "subtitle", tag: "h3" }, "Async inputs"),
                v$1(CardElement, null,
                    "The ",
                    v$1("code", null, "onInput"),
                    " event handler for all types of inputs can be sync or async.",
                    v$1(InputGrid, null,
                        v$1(InputGroup, null,
                            v$1(Checkbox, { onInput: setUsesAsync, checked: usesAsync, labelPosition: "start" }, "Async event handler")),
                        v$1(InputGroup, null,
                            v$1(Checkbox, { onInput: setAsyncFails, checked: asyncFails, labelPosition: "start", disabled: !usesAsync }, "Async handler rejects")),
                        v$1(InputGroup, null,
                            v$1(Input, { disabled: !usesAsync, type: "number", onInput: setAsyncTimeout, value: asyncTimeout }, "Async timeout")))),
                v$1(CardElement, null,
                    v$1(Checkbox, { checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Checkbox"),
                    v$1(Switch, { checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Switch")),
                v$1(CardElement, null,
                    v$1(RadioGroup, { name: "radio-demo-1", selectedValue: demoRadio, onInput: usesAsync ? asyncRadioInput : setDemoRadio },
                        v$1(Radio, { index: 0, value: 0 }, "Radio #1"),
                        v$1(Radio, { index: 1, value: 1 }, "Radio #2"),
                        v$1(Radio, { index: 2, value: 2 }, "Radio #3"))),
                v$1(CardElement, { type: "paragraph" },
                    v$1("code", null, "<Checkbox checked={checked} onInput={setChecked}>Checkbox</Checkbox>\n<Switch checked={checked} onInput={onInput}>Switch</Switch>\n<RadioGroup name=\"radio-demo-1\" selectedValue={value} onInput={setValue}>\n<Radio index={0} value=\"value1\">Radio #1</Radio>\n<Radio index={1} value=\"value2\">Radio #2</Radio>\n<Radio index={2} value=\"value3\">Radio #3</Radio>\n</RadioGroup>")),
                v$1("hr", null),
                v$1(CardElement, { type: "subtitle", tag: "h3" }, "Disabling"),
                v$1(CardElement, null,
                    "When disabled, all inputs remain focusable so that they can still be announced by screen readers, have tooltips via mouseover, etc.",
                    v$1(InputGroup, null,
                        v$1(Checkbox, { onInput: setDisabled, checked: disabled, labelPosition: "start" }, "Inputs disabled"))),
                v$1(CardElement, null,
                    v$1(Checkbox, { disabled: disabled, checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Checkbox "),
                    v$1(Switch, { disabled: disabled, checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Switch")),
                v$1(CardElement, null,
                    v$1(RadioGroup, { name: "radio-demo-2", selectedValue: demoRadio, onInput: usesAsync ? asyncRadioInput : setDemoRadio },
                        v$1(Radio, { disabled: disabled, index: 0, value: 0 }, "Radio #1"),
                        v$1(Radio, { disabled: disabled, index: 1, value: 1 }, "Radio #2"),
                        v$1(Radio, { disabled: disabled, index: 2, value: 2 }, "Radio #3"))),
                v$1("hr", null),
                v$1(CardElement, { type: "subtitle", tag: "h3" },
                    v$1("code", null, "InputGroup"),
                    " styling"),
                v$1(CardElement, { type: "paragraph" },
                    "An ",
                    v$1("code", null, "<InputGroup>"),
                    " can be used to significantly change the styling of input components. The inputs and their labels will style themselves or automatically wrap themselves in ",
                    v$1("code", null, "<InputGroupText>"),
                    " as appropriate."),
                v$1(CardElement, null,
                    v$1(InputGrid, null,
                        v$1(InputGroup, null,
                            v$1(Checkbox, { checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Checkbox")),
                        v$1(InputGroup, null,
                            v$1(Switch, { checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Switch")),
                        v$1(RadioGroup, { name: "radio-demo-5", selectedValue: demoRadio, onInput: usesAsync ? asyncRadioInput : setDemoRadio },
                            v$1(InputGroup, null,
                                v$1(Radio, { index: 0, value: 0 }, "Radio #1")),
                            v$1(InputGroup, null,
                                v$1(Radio, { index: 1, value: 1 }, "Radio #2")),
                            v$1(InputGroup, null,
                                v$1(Radio, { index: 2, value: 2 }, "Radio #3"))))),
                v$1(CardElement, { type: "paragraph" },
                    v$1("code", null, "<InputGroup>\n    <Checkbox checked={checked} onInput={setChecked}>Checkbox</Checkbox>\n</InputGroup>\n<InputGroup>\n    <Switch checked={checked} onInput={onInput}>Switch</Switch>\n</InputGroup>\n<RadioGroup name=\"radio-demo-5\" selectedValue={value} onInput={setValue}>\n    <InputGroup>\n        <Radio index={0} value=\"value1\" labelPosition=\"start\">Radio #1</Radio>\n        <Radio index={1} value=\"value2\" labelPosition=\"hidden\">Radio #2</Radio>\n        <Radio index={2} value=\"value3\" labelPosition=\"end\">Radio #3</Radio>\n    </InputGroup>\n</RadioGroup>")),
                v$1("hr", null),
                v$1(CardElement, { type: "subtitle", tag: "h3" }, "Labels"),
                v$1(CardElement, null,
                    "By default, the label is positioned after the checkbox, radio, or switch.  You can change this with ",
                    v$1("code", null, "labelPosition"),
                    "."),
                v$1(CardElement, null,
                    "Note that the ",
                    v$1("code", null, "start"),
                    " label position only has any visual effect while in an ",
                    v$1("code", null, "InputGroup"),
                    ", as Bootstrap places \"naked\" checkboxes and such in the margin area before the label no matter what order they come in the DOM."),
                v$1(CardElement, null,
                    v$1(RadioGroup, { name: "radio-demo-6", selectedValue: labelPosition, onInput: setLabelPosition, labelPosition: labelPosition },
                        v$1(Radio, { labelPosition: labelPosition, index: 0, value: "start" }, "Before"),
                        v$1(Radio, { labelPosition: labelPosition, index: 1, value: "end" }, "After"),
                        v$1(Radio, { labelPosition: labelPosition, index: 2, value: "hidden" }, "Hidden (still announced verbally)"))),
                v$1(CardElement, null,
                    v$1(InputGrid, null,
                        v$1(InputGroup, null,
                            v$1(Checkbox, { labelPosition: labelPosition, checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Checkbox")),
                        v$1(InputGroup, null,
                            v$1(Switch, { labelPosition: labelPosition, checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Switch")),
                        v$1(RadioGroup, { name: "radio-demo-7", selectedValue: demoRadio, onInput: usesAsync ? asyncRadioInput : setDemoRadio },
                            v$1(InputGroup, null,
                                v$1(Radio, { labelPosition: labelPosition, index: 0, value: 0 }, "Radio #1")),
                            v$1(InputGroup, null,
                                v$1(Radio, { labelPosition: labelPosition, index: 1, value: 1 }, "Radio #2")),
                            v$1(InputGroup, null,
                                v$1(Radio, { labelPosition: labelPosition, index: 2, value: 2 }, "Radio #3"))))))));
    }
    function sleep$2(arg0) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, arg0); })];
            });
        });
    }

    function DemoInputs() {
        var _this = this;
        var _a = useState(false), asyncFails = _a[0], setAsyncFails = _a[1];
        var _b = useState(3000), asyncTimeout = _b[0], setAsyncTimeout = _b[1];
        var _c = useState(true), usesAsync = _c[0], setUsesAsync = _c[1];
        var _d = useState(""), text = _d[0], setText = _d[1];
        var _e = useState(0), number = _e[0], setNumber = _e[1];
        var asyncTextInput = A$1(function (text) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$1(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Attempt to change text failed");
                        setText(text);
                        return [2 /*return*/];
                }
            });
        }); }, [asyncTimeout, asyncFails]);
        var asyncNumberInput = A$1(function (value) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$1(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Attempt to change number failed");
                        setNumber(value);
                        return [2 /*return*/];
                }
            });
        }); }, [asyncTimeout, asyncFails]);
        var onTextInput = usesAsync ? asyncTextInput : setText;
        var onNumberInput = usesAsync ? asyncNumberInput : setNumber;
        return (v$1("div", { class: "demo" },
            v$1(Card, null,
                v$1(CardElement, { type: "title", tag: "h2" }, "Text boxes"),
                v$1(CardElement, null,
                    v$1("div", { class: "position-relative" },
                        v$1(Input, { type: "text", value: text, onInput: onTextInput }, "I'm a text box"))),
                v$1(CardElement, null,
                    v$1("code", null, "<Input>"),
                    " components allow for inputting text, numbers, etc. and asyncronously saving it somewhere else as it's being typed."),
                v$1(CardElement, { type: "subtitle", tag: "h3" }, "Async inputs"),
                v$1(CardElement, null,
                    "The ",
                    v$1("code", null, "onInput"),
                    " event handler for all types of inputs can be sync or async.",
                    v$1(InputGrid, null,
                        v$1(InputGroup, null,
                            v$1(Checkbox, { onInput: setUsesAsync, checked: usesAsync, labelPosition: "start" }, "Async event handler")),
                        v$1(InputGroup, null,
                            v$1(Checkbox, { onInput: setAsyncFails, checked: asyncFails, labelPosition: "start", disabled: !usesAsync }, "Async handler rejects")),
                        v$1(InputGroup, null,
                            v$1(Input, { disabled: !usesAsync, type: "number", onInput: setAsyncTimeout, value: asyncTimeout }, "Async timeout")))),
                v$1(CardElement, null,
                    v$1("div", { class: "position-relative" },
                        v$1(Input, { type: "text", value: text, onInput: onTextInput }, "Text-based input")),
                    v$1("div", { class: "position-relative" },
                        v$1(Input, { type: "number", value: number, onInput: onNumberInput, min: -5 }, "Number-based input"))),
                v$1(CardElement, { type: "paragraph" },
                    v$1("code", null, "<Input type=\"text\" value={text} onInput={onTextInput}>Text-based input</Input>\n<Input type=\"number\" value={number} onInput={onNumberInput} min={-5}>Number-based input</Input>")),
                v$1(CardElement, { type: "paragraph" },
                    "When placed in an ",
                    v$1("code", null, "<InputGroup>"),
                    ", the styling will be significantly different:"),
                v$1(CardElement, null,
                    v$1(InputGrid, null,
                        v$1(InputGroup, null,
                            v$1(Input, { type: "text", value: text, onInput: onTextInput }, "Text-based input")),
                        v$1(InputGroup, null,
                            v$1(Input, { type: "number", value: number, onInput: onNumberInput, min: -5 }, "Number-based input")))),
                v$1(CardElement, { type: "paragraph" },
                    v$1("code", null, "<InputGrid>\n    <InputGroup><Input type=\"text\" value={text} onInput={onTextInput}>Text-based input</Input></InputGroup>\n    <InputGroup><Input type=\"number\" value={number} onInput={onNumberInput} min={-5}>Number-based input</Input></InputGroup>\n</InputGrid>")))));
    }
    function sleep$1(arg0) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, arg0); })];
            });
        });
    }

    function DemoLayout() {
        return (v$1("div", { class: "demo" },
            v$1(Card, null,
                v$1(CardElement, { type: "title", tag: "h2" }, "Layout"),
                v$1(CardElement, null, "Inputs offer various ways that they can b"),
                v$1(CardElement, { type: "subtitle", tag: "h3" },
                    v$1("code", null, "<InputGroup>")),
                v$1(CardElement, null,
                    "All input types, from checkboxes to number inputs, can be placed within an ",
                    v$1("code", null, "<InputGrid>"),
                    " to give an alternate styling to the default \"free floating\" style."),
                v$1(CardElement, null,
                    "In addition, to help with alignment, a set of ",
                    v$1("code", null, "InputGroup"),
                    "s can also be placed within an ",
                    v$1("code", null, "InputGrid"),
                    " to manage simple cases."),
                v$1(CardElement, null,
                    "With an ",
                    v$1("code", null, "<InputGrid>"),
                    ":",
                    v$1(InputGrid, null,
                        v$1(InputGroup, null,
                            v$1(Checkbox, { disabled: true, checked: true, labelPosition: "start" }, "Checkbox")),
                        v$1(InputGroup, null,
                            v$1(Checkbox, { disabled: true, checked: true, labelPosition: "start" }, "Another checkbox")),
                        v$1(InputGroup, null,
                            v$1(Input, { disabled: true, onInput: function () { }, type: "number", value: 0 }, "Numeric input")))),
                v$1(CardElement, null,
                    "Without an ",
                    v$1("code", null, "<InputGrid>"),
                    ":",
                    v$1(InputGroup, null,
                        v$1(Checkbox, { disabled: true, checked: true, labelPosition: "start" }, "Checkbox")),
                    v$1(InputGroup, null,
                        v$1(Checkbox, { disabled: true, checked: true, labelPosition: "start" }, "Another checkbox")),
                    v$1(InputGroup, null,
                        v$1(Input, { disabled: true, onInput: function () { }, type: "number", value: 0 }, "Numeric input"))),
                v$1(CardElement, { type: "subtitle", tag: "h3" }, "Simple grids"),
                v$1(CardElement, null,
                    "Two different grid components are provided for two separate use cases:",
                    v$1("ul", null,
                        v$1("li", null,
                            "<",
                            v$1("code", null, "GridResponsive"),
                            ">, which takes a minimum column size and fits as many columns as possible given that constraint"),
                        v$1("li", null,
                            "<",
                            v$1("code", null, "GridStatic"),
                            ">, which takes a minimum column count and fits that many columns in no matter the resulting size and/or jankiness"))))));
    }

    var _excluded = ["children", "small", "striped", "hoverable", "border", "variant", "borderColor"],
        _excluded2 = ["children", "variant"],
        _excluded3 = ["children", "variant"],
        _excluded4 = ["children", "variant"],
        _excluded5 = ["children", "index", "variant"],
        _excluded6 = ["value", "children", "index", "variant", "focus", "active"],
        _excluded7 = ["index", "focus", "children", "variant", "active", "unsortable"];
    var CurrentSortedColumnContext = D$1(null);
    var SetCurrentSortedColumnContext = D$1(null); // This is the hook that rows use for navigation

    var UseBodyGridNavigationRowContext = D$1(null); // This is the hook that cells use for navigation

    var UseBodyGridNavigationCellContext = D$1(null);
    var UseHeadGridNavigationRowContext = D$1(null);
    var UseHeadGridNavigationCellContext = D$1(null); // This is, internally, what the header cell calls when the user clicks it.
    // The body creates it--it sorts the known rows and updates the children.

    var InternalSortHandlerContext = D$1(null); // This is used by the body. It creates the sort handler, but in order
    // to get it to the head, where the clickable header cells are, we need
    // this Context, used by the parent Table, to fascilitate communication.

    var SetInternalSortHandlerContext = D$1(null);
    var Table = forwardElementRef(function Table(_ref, ref) {
      var {
        children,
        small,
        striped,
        hoverable,
        border,
        variant,
        borderColor
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded);

      var [sortedColumn, setSortedColumn] = useState(null); // This is the one that's used for the button in the table head

      var [internalSortHandler, setInternalSortHandler] = useState(null);
      return v$1("table", _objectSpread2({}, useMergedProps()({
        ref,
        role: "group",
        className: clsx("table", small && "table-sm", striped && "table-striped", hoverable && "table-hover", border === "all" && "table-bordered", border === "none" && "table-borderless", variant && "table-".concat(variant), borderColor && "border-".concat(borderColor))
      }, props)), v$1(SetInternalSortHandlerContext.Provider, {
        value: setInternalSortHandler
      }, v$1(InternalSortHandlerContext.Provider, {
        value: internalSortHandler
      }, v$1(CurrentSortedColumnContext.Provider, {
        value: sortedColumn
      }, v$1(SetCurrentSortedColumnContext.Provider, {
        value: setSortedColumn
      }, children)))));
    });
    var CellIsInHeaderContext = D$1(false);
    var TableHead = forwardElementRef(function TableHead(_ref2, ref) {
      var {
        children,
        variant
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2);

      var {
        focusedInner,
        useHasFocusProps
      } = useHasFocus({});
      var {
        cellIndex,
        rowIndex,
        rowCount,
        useGridNavigationRow
      } = useGridNavigation({
        focusOnChange: focusedInner
      });
      return v$1(UseHeadGridNavigationRowContext.Provider, {
        value: useGridNavigationRow
      }, v$1(CellIsInHeaderContext.Provider, {
        value: true
      }, v$1("thead", _objectSpread2({}, useHasFocusProps(useMergedProps()({
        ref,
        role: "rowgroup",
        "data-current-row": rowIndex,
        "data-current-column": cellIndex,
        "data-row-count": rowCount,
        className: clsx(variant && "table-".concat(variant))
      }, props))), children)));
    });

    function compare3(lhs, rhs) {
      if ("".concat(+lhs) === lhs) lhs = +lhs;
      if ("".concat(+rhs) === rhs) rhs = +rhs;
      if (typeof lhs === "string") rhs = "".concat(rhs);
      if (typeof rhs === "string") lhs = "".concat(lhs);
      console.assert(typeof lhs === typeof rhs);
      if (typeof lhs === "string") return lhs.localeCompare(rhs);
      if (typeof lhs === "number") return +lhs - +rhs;
      return 0;
    }

    function compare2(lhs, rhs) {
      if (typeof lhs === "boolean" || lhs instanceof Date) lhs = +lhs;
      if (typeof rhs === "boolean" || rhs instanceof Date) rhs = +rhs;
      return compare3(lhs, rhs);
    }

    function compare1(lhs, rhs) {
      if (lhs == null && rhs == null) {
        // They're both null
        return 0;
      } else if (lhs == null || rhs == null) {
        // One of the two is null -- easy case
        return lhs != null ? -1 : 1;
      }

      return compare2(lhs, rhs);
    }

    var SortContext = D$1(null);
    var TableBody = forwardElementRef(function TableBody(_ref3, ref) {
      var {
        children,
        variant
      } = _ref3,
          props = _objectWithoutProperties(_ref3, _excluded3);

      var {
        focusedInner,
        useHasFocusProps
      } = useHasFocus({});
      var {
        cellIndex,
        rowIndex,
        rowCount,
        useGridNavigationRow,
        managedRows
      } = useGridNavigation({
        focusOnChange: focusedInner
      }); // This hooks up to internalSortHandler, used by the table head.

      var sort = A$1((column, direction) => {
        var sortedRows = managedRows.slice().sort((lhsRow, rhsRow) => {
          var result = compare1(lhsRow.getManagedCells()[column].literalValue, rhsRow.getManagedCells()[column].literalValue);
          if (direction[0] == "d") return -result;
          return result;
        });

        var _loop = function (literalIndex) {
          var overriddenIndex = sortedRows[literalIndex].index;
          var overriddenCells = sortedRows[overriddenIndex].getManagedCells();
          var literalCells = sortedRows[literalIndex].getManagedCells();
          managedRows[literalIndex].setOverriddenRowIndex(overriddenIndex);

          var _loop2 = function (_cellIndex) {
            overriddenCells[_cellIndex].provideWithSiblingsSetOverriddenValue(() => literalCells[_cellIndex].setOverriddenValue);
          };

          for (var _cellIndex = 0; _cellIndex < overriddenCells.length; ++_cellIndex) {
            _loop2(_cellIndex);
          }
        };

        for (var literalIndex = 0; literalIndex < sortedRows.length; ++literalIndex) {
          _loop(literalIndex);
        }
      }, []);
      var setInternalSortHandler = F(SetInternalSortHandlerContext);
      y(() => {
        setInternalSortHandler(() => sort);
      }, [setInternalSortHandler, sort]);
      return v$1("tbody", _objectSpread2({}, useHasFocusProps(useMergedProps()({
        ref,
        role: "rowgroup",
        "data-current-row": rowIndex,
        "data-current-column": cellIndex,
        "data-row-count": rowCount,
        className: clsx(variant && "table-".concat(variant))
      }, props))), v$1(UseBodyGridNavigationRowContext.Provider, {
        value: useGridNavigationRow
      }, v$1(SortContext.Provider, {
        value: sort
      }, children)));
    });
    forwardElementRef(function TableFoot(_ref4, ref) {
      var {
        children,
        variant
      } = _ref4,
          props = _objectWithoutProperties(_ref4, _excluded4);

      var {
        focusedInner,
        useHasFocusProps
      } = useHasFocus({});
      var {
        cellIndex,
        rowIndex,
        rowCount,
        useGridNavigationRow
      } = useGridNavigation({
        focusOnChange: focusedInner
      });
      return v$1(UseBodyGridNavigationRowContext.Provider, {
        value: useGridNavigationRow
      }, v$1("tfoot", _objectSpread2({}, useHasFocusProps(useMergedProps()({
        ref,
        "data-current-row": rowIndex,
        "data-current-column": cellIndex,
        "data-row-count": rowCount,
        className: clsx(variant && "table-".concat(variant))
      }, props))), children));
    });
    var TableRow = forwardElementRef(function TableRow(_ref5, ref) {
      var {
        children,
        index: literalRowIndex,
        variant
      } = _ref5,
          props = _objectWithoutProperties(_ref5, _excluded5);

      var isInTHead = F(CellIsInHeaderContext);
      var useGridNavigationRow = F(isInTHead ? UseHeadGridNavigationRowContext : UseBodyGridNavigationRowContext);
      var [overriddenRowIndex, setOverriddenRowIndex] = useState(literalRowIndex);
      var {
        cellCount,
        useGridNavigationRowProps,
        useGridNavigationCell,
        tabbableCell,
        isTabbableRow,
        managedCells
      } = useGridNavigationRow({
        index: literalRowIndex,
        setOverriddenRowIndex,
        getManagedCells: useStableCallback(() => managedCells)
      });

      var rowProps = _objectSpread2({
        children
      }, useMergedProps()({
        ref,
        role: "row",
        "data-literal-index": literalRowIndex,
        "data-overridden-index": overriddenRowIndex,
        "data-tabbable": "".concat(isTabbableRow),
        "data-tabbable-cell": "".concat(tabbableCell),
        className: clsx(variant && "table-".concat(variant)),
        "data-cell-count": cellCount
      }, props)); // This is what we display under the default circumstance (we're displaying our own row)


      var rowJsx = v$1("tr", _objectSpread2({}, useGridNavigationRowProps(rowProps)), children);
      var Provider = !isInTHead ? UseBodyGridNavigationCellContext.Provider : UseHeadGridNavigationCellContext.Provider;
      return v$1(Provider, {
        value: useGridNavigationCell
      }, v$1(OverriddenRowIndexContext.Provider, {
        value: overriddenRowIndex
      }, rowJsx));
    });
    var OverriddenRowIndexContext = D$1(null);
    var TableCell = forwardElementRef(function TableCell(_ref6, ref) {
      var _focus;

      var {
        value: literalValue,
        children,
        index,
        variant,
        focus,
        active
      } = _ref6,
          props = _objectWithoutProperties(_ref6, _excluded6);

      (_focus = focus) !== null && _focus !== void 0 ? _focus : focus = "cell";
      var useGridNavigationCell = F(UseBodyGridNavigationCellContext);
      var isDisplayChildren = typeof children == "string" || typeof children == "number" || typeof children == "boolean";
      var displayValue = isDisplayChildren ? children : literalValue;
      var [overriddenValue, setOverriddenValue] = useState(literalValue);
      var [setSiblingOverriddenValue, provideWithSiblingsSetOverriddenValue] = useState(null);
      var {
        tabbable,
        useGridNavigationCellProps
      } = useGridNavigationCell({
        index,
        text: null,
        overriddenValue,
        literalValue,
        displayValue,
        provideWithSiblingsSetOverriddenValue,
        setOverriddenValue
      });
      var overriddenRowIndex = F(OverriddenRowIndexContext);
      var cellProps = useMergedProps()({
        ref,
        role: "gridcell",
        "data-literal-value": "".concat(literalValue),
        "data-display-value": "".concat(displayValue),
        "data-overridden-value": "".concat(overriddenValue),
        "data-overridden-row": "".concat(overriddenRowIndex),
        className: clsx(variant && "table-".concat(variant))
      }, props);
      y(() => {
        setSiblingOverriddenValue === null || setSiblingOverriddenValue === void 0 ? void 0 : setSiblingOverriddenValue(displayValue);
      }, [setSiblingOverriddenValue, displayValue]);

      if (children && !isDisplayChildren) {
        return v$1("td", _objectSpread2({}, cellProps), v$1(children, useGridNavigationCellProps({
          overriddenRowIndex,
          overriddenValue,
          className: "test"
        })));
      } else {
        return v$1("td", _objectSpread2({}, useGridNavigationCellProps(cellProps)), stringify(overriddenValue));
      }
    });
    var TableHeaderCell = forwardElementRef(function TableHeaderCell(_ref7, ref) {
      var _focus2;

      var {
        index,
        focus,
        children,
        variant,
        active,
        unsortable
      } = _ref7,
          props = _objectWithoutProperties(_ref7, _excluded7);

      (_focus2 = focus) !== null && _focus2 !== void 0 ? _focus2 : focus = "cell";
      var [sortDirection, setSortDirection, getSortDirection] = useState(null);
      var isInTHead = F(CellIsInHeaderContext);
      var useGridNavigationCell = F(UseHeadGridNavigationCellContext);
      var {
        useRefElementProps,
        element
      } = useRefElement();
      var [text, setText] = useState(null);
      h(() => {
        if (element) {
          setText(element.innerText);
        }
      }, [element]);
      var {
        tabbable,
        useGridNavigationCellProps
      } = useGridNavigationCell({
        index,
        text
      });
      var currentSortedColumn = F(CurrentSortedColumnContext);
      var setCurrentSortedColumn = F(SetCurrentSortedColumnContext);
      y(() => {
        if (currentSortedColumn != index) setSortDirection(null);
      }, [currentSortedColumn, index]);
      var onSort = F(InternalSortHandlerContext);
      var onSortClick = A$1(() => {
        var nextSortDirection = getSortDirection();
        if (nextSortDirection === "ascending") nextSortDirection = "descending";else nextSortDirection = "ascending";
        setSortDirection(nextSortDirection);
        onSort === null || onSort === void 0 ? void 0 : onSort(index, nextSortDirection);
        setCurrentSortedColumn(prev => index);
      }, [onSort, index]);
      var cellProps = useButtonLikeEventHandlers("th", unsortable ? null : onSortClick, undefined)(useRefElementProps(useMergedProps()({
        ref,
        role: "columnheader",
        scope: isInTHead ? "col" : "row",
        className: clsx(variant && "table-".concat(variant), unsortable && "unsortable")
      }, props)));
      var sortIcon = v$1(Swappable, null, v$1("div", {
        class: clsx("table-sort-icon-container", "sort-direction-".concat(sortDirection !== null && sortDirection !== void 0 ? sortDirection : "null"))
      }, v$1(Fade, {
        open: sortDirection == null
      }, v$1("i", {
        class: "bi bi-sort-down-alt hover-only"
      })), v$1(Fade, {
        open: sortDirection == "descending"
      }, v$1("i", {
        class: "bi bi-sort-up no-hover-only"
      })), v$1(Fade, {
        open: sortDirection == "descending"
      }, v$1("i", {
        class: "bi bi-sort-down-alt hover-only"
      })), v$1(Fade, {
        open: sortDirection == "ascending"
      }, v$1("i", {
        class: "bi bi-sort-down-alt no-hover-only"
      })), v$1(Fade, {
        open: sortDirection == "ascending"
      }, v$1("i", {
        class: "bi bi-sort-up hover-only"
      }))));

      if (focus === "child") {
        return v$1("th", _objectSpread2({}, cellProps), v$1("div", null, B(children, useGridNavigationCellProps({}), children.props.children), sortIcon));
      } else {
        return v$1("th", _objectSpread2({}, useGridNavigationCellProps(cellProps)), v$1("div", null, children, sortIcon));
      }
    });

    function stringify(value) {
      if (value == null) return null; // TODO: This could be a lot better

      if (value instanceof Date) return value.toLocaleString();
      return "".concat(value);
    }

    var RandomWords$1 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    function RandomRow(_a) {
        var index = _a.index;
        var d = new Date(new Date().getFullYear(), 0, index);
        return (v$1(TableRow, { index: index },
            v$1(TableCell, { index: 0, value: RandomWords$1[index] }),
            v$1(TableCell, { index: 1, value: Math.pow(index, 2) }),
            v$1(TableCell, { index: 2, value: d }, d.toLocaleString()),
            v$1(CheckboxTableCell, { index: 3 })));
    }
    var checkedRows = new Set();
    function CheckboxTableCell(_a) {
        var index = _a.index;
        var forceUpdate = useForceUpdate();
        var TableCellChild = A$1(forwardElementRef(function (_a, ref) {
            _a.overriddenValue; var overriddenRowIndex = _a.overriddenRowIndex, props = __rest(_a, ["overriddenValue", "overriddenRowIndex"]);
            var onInput = function (c) {
                if (c)
                    checkedRows.add(overriddenRowIndex);
                else
                    checkedRows.delete(overriddenRowIndex);
                // Just poking at a Set that's not hooked up to any lifecycle functions
                // won't update the visuals at all.
                // Forcibly update ourselves, which will, upon re-rendering, notify out
                // "partner" row (the one that's actually showing our data) of
                // the change.
                forceUpdate();
            };
            return v$1(Checkbox, __assign({ ref: ref }, props, { checked: checkedRows.has(overriddenRowIndex), onInput: onInput, labelPosition: "hidden" }), "Demo table checkbox");
        }), []);
        return v$1(TableCell, { index: index, value: checkedRows.has(index) }, TableCellChild);
    }
    function DemoTable() {
        var _a = useState(5), rowCount = _a[0], setRowCount = _a[1];
        return (v$1("div", { class: "demo" },
            v$1(Card, null,
                v$1(CardElement, { type: "title", tag: "h2" }, "Table"),
                v$1(CardElement, null,
                    "Tables allow for automatic display, navigation, and sorting of data.  All data is provided by the children and you don't need to provide a data structure to the parent ",
                    v$1("code", null, "Table"),
                    " element."),
                v$1(CardElement, null,
                    "By default, all table columns are sortable based on the ",
                    v$1("code", null, "value"),
                    " prop you provide each cell. If you would like to explicitly mark a column as unsortable, give that column's header cell the ",
                    v$1("code", null, "unsortable"),
                    " prop."),
                v$1(CardElement, null,
                    "A ",
                    v$1("code", null, "<TableCell>"),
                    " will, by default, just display its ",
                    v$1("code", null, "value"),
                    ".  This will work fine for strings, booleans, and a lot of numbers, but if you need to format your value, you can pass the string you'd like to actually display in the cell as the cell's child."),
                v$1(CardElement, null, "Cells can display more than just strings or string representations of things, such as buttons, formatted text, or any other JSX. How to do so is explained below the example."),
                v$1(CardElement, null,
                    v$1(Input, { type: "number", value: rowCount, onInput: setRowCount }, "Row count")),
                v$1(CardElement, null,
                    v$1(Table, null,
                        v$1(TableHead, null,
                            v$1(TableRow, { index: 0 },
                                v$1(TableHeaderCell, { index: 0 }, "String"),
                                v$1(TableHeaderCell, { index: 1 }, "Number"),
                                v$1(TableHeaderCell, { index: 2 }, "Date"),
                                v$1(TableHeaderCell, { index: 3 }, "Checkbox"))),
                        v$1(TableBody, null, Array.from(function () {
                            var i;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        i = 0;
                                        _a.label = 1;
                                    case 1:
                                        if (!(i < rowCount)) return [3 /*break*/, 4];
                                        return [4 /*yield*/, v$1(RandomRow, { index: i })];
                                    case 2:
                                        _a.sent();
                                        _a.label = 3;
                                    case 3:
                                        ++i;
                                        return [3 /*break*/, 1];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        }())))),
                v$1(CardElement, null,
                    v$1("code", null, "<Table>\n    <TableHead>\n        <TableRow index={0}>\n            <TableHeaderCell index={0}>String</TableHeaderCell>\n            <TableHeaderCell index={1}>Number</TableHeaderCell>\n            <TableHeaderCell index={2}>Date</TableHeaderCell>\n            <TableHeaderCell index={3}>Checkbox</TableHeaderCell>\n        </TableRow>\n    </TableHead>\n    <TableBody>\n\n        <TableRow index={0}>\n            <TableCell index={0} value={RandomWords[index]} />\n            <TableCell index={1} value={index ** 2} />\n            <TableCell index={2} value={d}>{d.toLocaleString()}</TableCell>\n            <CheckboxTableCell index={3} /> {/* Custom component -- see below */}\n        </TableRow>\n\n        <TableRow index={1} />\n        <TableRow index={2} />\n        <TableRow index={3} />\n        <TableRow index={4} />\n\n    </TableBody>\n</Table>")),
                v$1(CardElement, null,
                    "To display contents that are more complicated than a data literal, like the recursively-complicated structure built by JSX, you'll need a wrapper component. Please note that the details of this component are very specific, and all of the following must be met:",
                    v$1("ul", null,
                        v$1("li", null,
                            "The child component is a ref-forwarding component.  Use ",
                            v$1("code", null, "forwardElementRef"),
                            " (or just the built-in ",
                            v$1("code", null, "forwardRef"),
                            ") to do this."),
                        v$1("li", null,
                            "The child component passes its ref (probably the one from ",
                            v$1("code", null, "forwardRef"),
                            ") to its child component. It's fine to merge it with other refs, but it needs to get there eventually."),
                        v$1("li", null, "The child component additionally passes all unused props it receives onto its child component. Most components provided by this library do this, even if they're not explicitly typed to indicate this."),
                        v$1("li", null,
                            "The child component is stable (as in, it's not an anonymous function defined on each render).  If the child component is just a plain ol' global function like most, this isn't an issue.  If it's defined inside a component, make sure it's wrapped in ",
                            v$1("code", null, "useCallback"),
                            " to keep it stable."),
                        v$1("li", null,
                            "If the child component uses both ",
                            v$1("code", null, "forwardRef"),
                            " and ",
                            v$1("code", null, "useCallback"),
                            " (from the previous rule), then ",
                            v$1("code", null, "useCallback"),
                            " must be on the outside. This isn't specific to table cells or anything, but it's easy to miss."))),
                v$1(CardElement, null,
                    v$1("code", null, "// The TableCell's child must forward its ref and all props to the child component\n// so that it can handle everything the TableCell would normally handle, like focus management\nfunction CheckboxTableCell({ index }: { index: number }) {\n    const forceUpdate = useForceUpdate();\n\n    const TableCellChild = useCallback(\n        forwardElementRef(({ overriddenValue, overriddenRowIndex, ...props }: TableCellChildProps<HTMLButtonElement>, ref: any) => {\n            const onInput = (c: boolean) => {\n                if (c)\n                    checkedRows.add(overriddenRowIndex)\n                else\n                    checkedRows.delete(overriddenRowIndex)\n\n                // Just poking at a Set that's not hooked up to any lifecycle functions\n                // won't update the visuals at all.\n                // Forcibly update ourselves, which will, upon re-rendering, notify out\n                // \"partner\" row (the one that's actually showing our data) of\n                // the change.\n                forceUpdate();\n            }\n            return <Checkbox \n                ref={ref}   // Don't forget to pass in the ref that was forwarded!!\n                {...props}  // If you get type errors, force it with {...props as never} \n                checked={checkedRows.has(overriddenRowIndex)} \n                onInput={onInput} \n                labelPosition=\"hidden\">Demo table checkbox</Checkbox>;\n        }), []);\n\n    return <TableCell index={index} value={checkedRows.has(index)}>{TableCellChild}</TableCell>\n};\n\n\n// Presumably you'll have better state management than a global variable.\n// A context would work nicely.\nlet checkedRows = new Set<number>();")))));
    }

    var RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    g(function (_a) {
        var depth = _a.depth;
        var _b = useState(false), active = _b[0], setActive = _b[1];
        var useFocusTrapProps = useFocusTrap({ trapActive: active }).useFocusTrapProps;
        //const { useRovingTabIndexChild, useRovingTabIndexProps } = useRovingTabIndex<HTMLUListElement, RovingTabIndexChildInfo>({ tabbableIndex, focusOnChange: false });
        var divProps = useFocusTrapProps({ ref: undefined, className: "focus-trap-demo" });
        if (depth == 2)
            return v$1("div", null);
        return (v$1("div", { className: "demo" },
            v$1("label", null,
                "Active: ",
                v$1("input", { type: "checkbox", checked: active, onInput: function (e) { e.preventDefault(); setActive(e.currentTarget.checked); } })),
            v$1("div", __assign({}, divProps),
                v$1(DemoUseFocusTrapChild, { active: active, setActive: setActive, depth: depth !== null && depth !== void 0 ? depth : 0 }))));
    });
    var DemoUseFocusTrapChild = g(function (_a) {
        var setActive = _a.setActive, active = _a.active; _a.depth;
        return (v$1(d$1, null,
            v$1("button", null, "Button 1"),
            v$1("button", null, "Button 2"),
            v$1("button", null, "Button 3"),
            v$1("label", null,
                "Active: ",
                v$1("input", { type: "checkbox", checked: active, onInput: function (e) { e.preventDefault(); setActive(e.currentTarget.checked); } }))));
    });
    var DemoDialog = g(function () {
        var onClose = (function () { return setOpen(false); });
        var _a = useState(false), open = _a[0], setOpen = _a[1];
        return (v$1("div", { class: "demo" },
            v$1(Tooltip, { tooltip: "Open dialog", position: "block-start", Transition: ZoomFade, zoomOriginDynamic: 0, zoomMin: 0.85 },
                v$1(InputGroup, null,
                    v$1(Checkbox, { checked: open, onInput: setOpen }, "Open dialog"))),
            v$1(Dialog, { Transition: ClipFade, clipOriginBlock: 0, open: open, onClose: onClose, descriptive: false, title: "Dialog Title", footer: v$1("button", { onClick: onClose }, "Close") },
                v$1("p", { tabIndex: -1 }, "Dialog body content"),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")))));
    });
    var DemoDrawer = g(function () {
        var onClose = (function () { return setOpen(false); });
        var _a = useState(false), open = _a[0], setOpen = _a[1];
        //open = true;
        return (v$1("div", { class: "demo" },
            v$1(Checkbox, { checked: open, onInput: setOpen }, "Open Drawer"),
            v$1(Drawer, { Transition: Slide, slideTargetInline: -1, open: open, onClose: onClose, descriptive: false, title: "Dialog Title" },
                v$1("p", { tabIndex: -1 }, "Dialog body content"),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")))));
    });
    var DemoMenu = g(function () {
        return (v$1("div", { class: "demo" },
            v$1(Menu, { Transition: ZoomFade, zoomOriginDynamic: 0, zoomMin: 0.85, tag: "ul", anchor: v$1(Button, null, "Open menu") },
                v$1(MenuItem, { index: 0 }, "AItem #1"),
                v$1(MenuItem, { index: 1 }, "BItem #2"),
                v$1(MenuItem, { index: 2 }, "CItem #3"),
                v$1(MenuItem, { index: 3 }, "DItem #4"))));
    });
    g(function () {
        var _a = useHasFocus(), focused = _a.focused, focusedInner = _a.focusedInner, useHasFocusProps = _a.useHasFocusProps;
        return (v$1("div", { class: "demo" },
            v$1("h2", null, "useHasFocus"),
            v$1("div", __assign({}, useHasFocusProps({ style: { border: "1px solid black" }, tabIndex: 0 })),
                "Outer ",
                v$1("div", { tabIndex: 0, style: { border: "1px solid black" } }, "Inner element")),
            v$1("div", null,
                v$1("ul", null,
                    v$1("li", null,
                        "Strictly focused: ",
                        focused.toString()),
                    v$1("li", null,
                        "Inner focused: ",
                        focusedInner.toString())))));
    });
    var DemoTabs = g(function () {
        var _a = useState(0), selectedIndex = _a[0], setSelectedIndex = _a[1];
        var _b = useState("activate"), selectionMode = _b[0];
        return (v$1("div", { class: "demo" },
            v$1("div", null,
                v$1(Tabs, { orientation: "block", onSelect: setSelectedIndex, selectedIndex: selectedIndex, selectionMode: selectionMode, tag: "ol" },
                    v$1("ol", null,
                        v$1(Tab, { index: 0 }, "Tab #1"),
                        v$1(Tab, { index: 1 }, "Tab #2"),
                        v$1(Tab, { index: 2 }, "Tab #3")),
                    v$1(TabPanel, { index: 0, Transition: ZoomFade, zoomMin: 0.8, zoomOriginBlock: 0 },
                        v$1("div", null, RandomWords.slice(0, Math.floor((1 / 3) * RandomWords.length)).join(" "))),
                    v$1(TabPanel, { index: 1, Transition: ZoomFade, zoomMin: 0.8, zoomOriginBlock: 0 },
                        v$1("div", null, RandomWords.slice(0, Math.floor((2 / 3) * RandomWords.length)).join(" "))),
                    v$1(TabPanel, { index: 2, Transition: ZoomFade, zoomMin: 0.8, zoomOriginBlock: 0 },
                        v$1("div", null, RandomWords.slice(0, Math.floor((3 / 3) * RandomWords.length)).join(" ")))))));
    });
    g(function () {
        var _a = useAriaTooltip({}), useTooltip = _a.useTooltip, useTooltipTrigger = _a.useTooltipTrigger, isOpen = _a.isOpen;
        var useTooltipProps = useTooltip().useTooltipProps;
        var useTooltipTriggerProps = useTooltipTrigger().useTooltipTriggerProps;
        return (v$1("div", { class: "demo" },
            v$1("p", null,
                "This is a paragraph with a ",
                v$1("span", __assign({}, useTooltipTriggerProps({})), "tooltip right here."),
                v$1("span", __assign({}, useTooltipProps({ hidden: !isOpen })), "This is the tooltip content."))));
    });
    function sleep(ms) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, ms); })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    }
    /*
    const DemoButtons = memo(() => {
        const [buttonsFill, setButtonsFill] = useState<"fill" | "outline">("outline");
        const [buttonsSize, setButtonsSize] = useState<"sm" | "md" | "lg">("md");

        const pushToast = usePushToast();
        function onClick(str: string) {
            return async function onClick() {
                await sleep(5000);
                pushToast(<Toast>Button was clicked ({str})</Toast>)
            }
        }

        return (
            <div class="demo">

                <ButtonGroup>
                    <ButtonGroupChild index={0} onClick={() => setButtonsFill("fill")} pressed={buttonsFill === "fill"} colorVariant="primary">Fill</ButtonGroupChild>
                    <ButtonGroupChild index={1} onClick={() => setButtonsFill("outline")} pressed={buttonsFill === "outline"} colorVariant="primary">Outline</ButtonGroupChild>
                </ButtonGroup>

                <ProvideDefaultButtonFill value={buttonsFill}>
                    <ProvideDefaultButtonSize value={buttonsSize}>
                        <ButtonGroup>
                            <ButtonGroupChild onClick={onClick("primary")} index={0} tag="button" colorVariant="primary">Primary</ButtonGroupChild>
                            <ButtonGroupChild onClick={onClick("secondary")} index={1} tag="button" colorVariant="secondary">Secondary</ButtonGroupChild>
                            <ButtonGroupChild onClick={onClick("success")} index={2} tag="button" colorVariant="success">Success</ButtonGroupChild>
                            <ButtonGroupChild onClick={onClick("warning")} index={3} tag="button" colorVariant="warning">Warning</ButtonGroupChild>
                        </ButtonGroup>
                        <ButtonGroup>
                            <ButtonGroupChild onClick={onClick("danger")} index={0} tag="button" colorVariant="danger">Danger</ButtonGroupChild>
                            <ButtonGroupChild onClick={onClick("info")} index={1} tag="button" colorVariant="info">Info</ButtonGroupChild>
                            <ButtonGroupChild onClick={onClick("light")} index={2} tag="button" colorVariant="light">Light</ButtonGroupChild>
                            <ButtonGroupChild onClick={onClick("dark")} index={3} tag="button" colorVariant="dark">Dark</ButtonGroupChild>
                            <ButtonGroupChild tag="a" index={4} href="#" colorVariant="link">Link</ButtonGroupChild>
                        </ButtonGroup>
                    </ProvideDefaultButtonSize>
                </ProvideDefaultButtonFill>
            </div>
        )
    });*/
    var DemoAccordion = g(function () {
        var _a = useState(-1), expandedIndex = _a[0], setExpandedIndex = _a[1];
        return (v$1("div", { class: "demo" },
            v$1("div", null,
                v$1(Accordion, { expandedIndex: expandedIndex, setExpandedIndex: setExpandedIndex },
                    v$1(AccordionSection, { index: 0, header: "Accordion Item #1" },
                        v$1("div", null,
                            v$1("strong", null, "This is the 1st item's accordion body."),
                            " It is visible by default, You can modify any of this with custom CSS or overriding our default variables. It's also worth noting that just about any HTML can go within the ",
                            v$1("code", null, "AccordionSection"),
                            ".")),
                    v$1(AccordionSection, { index: 1, header: "Accordion Item #2" },
                        v$1("div", null,
                            v$1("strong", null, "This is the 2nd item's accordion body."),
                            " It is hidden by default,  You can modify any of this with custom CSS or overriding our default variables. It's also worth noting that just about any HTML can go within the ",
                            v$1("code", null, "AccordionSection"),
                            ".")),
                    v$1(AccordionSection, { index: 2, header: "Accordion Item #3" },
                        v$1("div", null,
                            v$1("strong", null, "This is the 3rd item's accordion body."),
                            " It is hidden by default,  You can modify any of this with custom CSS or overriding our default variables. It's also worth noting that just about any HTML can go within the ",
                            v$1("code", null, "AccordionSection"),
                            "."))))));
    });
    var DemoList = g(function () {
        var _a = useState(0), index = _a[0], setIndex = _a[1];
        return (v$1("div", { class: "demo" },
            "Selected: ",
            index,
            v$1(ListSingle, { select: "single", onSelect: setIndex, selectedIndex: index, selectionMode: "activate", tag: "ul" },
                v$1(ListItemSingle, { index: 0 }, "Primary"),
                v$1(ListItemSingle, { index: 1 }, "Secondary"),
                v$1(ListItemSingle, { index: 2 }, "Success"),
                v$1(ListItemSingle, { index: 3 }, "Warning"),
                v$1(ListItemSingle, { index: 4 }, "Danger"),
                v$1(ListItemSingle, { index: 5 }, "Info"),
                v$1(ListItemSingle, { index: 6 }, "Light"),
                v$1(ListItemSingle, { index: 7 }, "Dark"),
                v$1(ListItemSingle, { index: 8 }, "Link"))));
    });
    var DemoInput = g(function () {
        var _a = useState(""), text = _a[0], setText = _a[1];
        var _b = useState(""), radioValue = _b[0], setRadioValue = _b[1];
        var onInput1 = A$1(function (value) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep(5000)];
                    case 1:
                        _a.sent();
                        setText(value);
                        return [2 /*return*/];
                }
            });
        }); }, [setRadioValue]);
        var onInput2 = A$1(function (value) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep(5000)];
                    case 1:
                        _a.sent();
                        setRadioValue(value);
                        return [2 /*return*/];
                }
            });
        }); }, [setRadioValue]);
        return (v$1("div", { class: "demo" },
            v$1(InputGroup, null,
                v$1(Input, { type: "text", onInput: onInput1, value: text, width: "100%" }, "Test input")),
            v$1(RadioGroup, { selectedValue: radioValue, name: "demo-radio", onInput: onInput2 },
                v$1(InputGroup, null,
                    v$1(Radio, { index: 0, value: "ARadio" })),
                v$1(InputGroup, null,
                    v$1(Radio, { index: 1, value: "BRadio" })),
                v$1(InputGroup, null,
                    v$1(Radio, { index: 2, value: "CRadio" })))));
    });
    var Component = function () {
        return v$1(GridResponsive, { minWidth: "35em" },
            v$1(ToastsProvider, null,
                v$1(DemoTable, null),
                v$1(DemoButtons, null),
                v$1(DemoChecks, null),
                v$1(DemoInputs, null),
                v$1(DemoLayout, null),
                v$1(DemoAccordion, null),
                v$1(DemoDialog, null),
                v$1(DemoDrawer, null),
                v$1(DemoInput, null),
                v$1(DemoList, null),
                v$1(DemoTabs, null),
                v$1(DemoMenu, null),
                v$1("input", null)));
    };
    requestAnimationFrame(function () {
        S$1(v$1(Component, null), document.getElementById("root"));
    });

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5tanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL2Rpc3QvaG9va3MubWpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1jaGlsZHJlbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1jbGFzc2VzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1yZWZzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1zdHlsZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXN0YXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXJlZi1lbGVtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWVsZW1lbnQtc2l6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1sb2dpY2FsLWRpcmVjdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1zdGFibGUtZ2V0dGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXN0YWJsZS1jYWxsYmFjay5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1sYXlvdXQtZWZmZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXRpbWVvdXQuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtYXN5bmMtaGFuZGxlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWNoaWxkLW1hbmFnZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2Utcm92aW5nLXRhYmluZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxpc3QtbmF2aWdhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1hY3RpdmUtZWxlbWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1oYXMtZm9jdXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtZWZmZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWdyaWQtbmF2aWdhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1ldmVudC1oYW5kbGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXBlcnNpc3RlbnQtc3RhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtcmFuZG9tLWlkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3RhYmJhYmxlL2Rpc3QvaW5kZXguZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jsb2NraW5nLWVsZW1lbnRzL2Rpc3QvYmxvY2tpbmctZWxlbWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvd2ljZy1pbmVydC9kaXN0L2luZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWJsb2NraW5nLWVsZW1lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtZm9jdXMtdHJhcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1mb3JjZS11cGRhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtdG9vbHRpcC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L2Rpc3QvY29tcGF0Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9mb3J3YXJkLWVsZW1lbnQtcmVmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3RyYW5zaXRpb25hYmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL2NsaXAuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vZmFkZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9jbGlwLWZhZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vY29sbGFwc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vY29sbGFwc2UtZmFkZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zbGlkZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zbGlkZS1mYWRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3pvb20uanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vem9vbS1mYWRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NsaWRlLXpvb20uanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc2xpZGUtem9vbS1mYWRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL2ZsaXAuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3dhcHBhYmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvcHJvcHMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtYnV0dG9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWFjY29yZGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1sYWJlbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1jaGVja2JveC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1tb2RhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1kaWFsb2cuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtZHJhd2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWxpc3Rib3gtc2luZ2xlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLW1lbnUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtdGFicy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1yYWRpby1ncm91cC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS10b2FzdHMuanMiLCIuLi9wcm9wcy5qcyIsIi4uL2FjY29yZGlvbi9hY2NvcmRpb24uanMiLCIuLi9wcm9ncmVzcy9saW5lYXIuanMiLCIuLi9idXR0b24vZGVmYXVsdHMuanMiLCIuLi9idXR0b24vYnV0dG9uLmpzIiwiLi4vYnV0dG9uL2J1dHRvbi1ncm91cC5qcyIsIi4uL3BvcnRhbC9pbmRleC5qcyIsIi4uL2RpYWxvZy9kaWFsb2cuanMiLCIuLi9kcmF3ZXIvZHJhd2VyLmpzIiwiLi4vaW5wdXQtZ3JvdXAvcHJvcHMuanMiLCIuLi9pbnB1dC1ncm91cC9pbnB1dC1ncm91cC5qcyIsIi4uL2lucHV0LWdyb3VwL2lucHV0LXRleHQuanMiLCIuLi9pbnB1dC1ncm91cC9pbnB1dC1jaGVjay5qcyIsIi4uL2lucHV0LWdyb3VwL2lucHV0LXN3aXRjaC5qcyIsIi4uL2lucHV0LWdyb3VwL2lucHV0LXJhZGlvLmpzIiwiLi4vbGF5b3V0L2dyaWQuanMiLCIuLi9saXN0L2xpc3Qtc2luZ2xlLmpzIiwiLi4vbWVudS9wb3BwZXItY29uZmlnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy93aXRoaW4uanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9leHBhbmRUb0hhc2hNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZVNjcm9sbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZWJvdW5jZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZm9ybWF0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdW5pcXVlQnkuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyIsIi4uL21lbnUvcG9wcGVyLWFwaS5qcyIsIi4uL21lbnUvbWVudS5qcyIsIi4uL3RhYnMvdGFicy5qcyIsIi4uL3RvYXN0L3RvYXN0LmpzIiwiLi4vdG9vbHRpcC90b29sdGlwLmpzIiwiLi4vY2FyZC9jYXJkLmpzIiwiZGVtb3MvYnV0dG9ucy50c3giLCJkZW1vcy9jaGVja3MudHN4IiwiZGVtb3MvaW5wdXRzLnRzeCIsImRlbW9zL2xheW91dC50c3giLCIuLi90YWJsZS90YWJsZS5qcyIsImRlbW9zL3RhYmxlcy50c3giLCJpbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG4iLCJ2YXIgbixsLHUsaSx0LG8scixmLGU9e30sYz1bXSxzPS9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkfGl0ZXJhL2k7ZnVuY3Rpb24gYShuLGwpe2Zvcih2YXIgdSBpbiBsKW5bdV09bFt1XTtyZXR1cm4gbn1mdW5jdGlvbiBoKG4pe3ZhciBsPW4ucGFyZW50Tm9kZTtsJiZsLnJlbW92ZUNoaWxkKG4pfWZ1bmN0aW9uIHYobCx1LGkpe3ZhciB0LG8scixmPXt9O2ZvcihyIGluIHUpXCJrZXlcIj09cj90PXVbcl06XCJyZWZcIj09cj9vPXVbcl06ZltyXT11W3JdO2lmKGFyZ3VtZW50cy5sZW5ndGg+MiYmKGYuY2hpbGRyZW49YXJndW1lbnRzLmxlbmd0aD4zP24uY2FsbChhcmd1bWVudHMsMik6aSksXCJmdW5jdGlvblwiPT10eXBlb2YgbCYmbnVsbCE9bC5kZWZhdWx0UHJvcHMpZm9yKHIgaW4gbC5kZWZhdWx0UHJvcHMpdm9pZCAwPT09ZltyXSYmKGZbcl09bC5kZWZhdWx0UHJvcHNbcl0pO3JldHVybiB5KGwsZix0LG8sbnVsbCl9ZnVuY3Rpb24geShuLGksdCxvLHIpe3ZhciBmPXt0eXBlOm4scHJvcHM6aSxrZXk6dCxyZWY6byxfX2s6bnVsbCxfXzpudWxsLF9fYjowLF9fZTpudWxsLF9fZDp2b2lkIDAsX19jOm51bGwsX19oOm51bGwsY29uc3RydWN0b3I6dm9pZCAwLF9fdjpudWxsPT1yPysrdTpyfTtyZXR1cm4gbnVsbCE9bC52bm9kZSYmbC52bm9kZShmKSxmfWZ1bmN0aW9uIHAoKXtyZXR1cm57Y3VycmVudDpudWxsfX1mdW5jdGlvbiBkKG4pe3JldHVybiBuLmNoaWxkcmVufWZ1bmN0aW9uIF8obixsKXt0aGlzLnByb3BzPW4sdGhpcy5jb250ZXh0PWx9ZnVuY3Rpb24gayhuLGwpe2lmKG51bGw9PWwpcmV0dXJuIG4uX18/ayhuLl9fLG4uX18uX19rLmluZGV4T2YobikrMSk6bnVsbDtmb3IodmFyIHU7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2UpcmV0dXJuIHUuX19lO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIG4udHlwZT9rKG4pOm51bGx9ZnVuY3Rpb24gYihuKXt2YXIgbCx1O2lmKG51bGwhPShuPW4uX18pJiZudWxsIT1uLl9fYyl7Zm9yKG4uX19lPW4uX19jLmJhc2U9bnVsbCxsPTA7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2Upe24uX19lPW4uX19jLmJhc2U9dS5fX2U7YnJlYWt9cmV0dXJuIGIobil9fWZ1bmN0aW9uIG0obil7KCFuLl9fZCYmKG4uX19kPSEwKSYmdC5wdXNoKG4pJiYhZy5fX3IrK3x8ciE9PWwuZGVib3VuY2VSZW5kZXJpbmcpJiYoKHI9bC5kZWJvdW5jZVJlbmRlcmluZyl8fG8pKGcpfWZ1bmN0aW9uIGcoKXtmb3IodmFyIG47Zy5fX3I9dC5sZW5ndGg7KW49dC5zb3J0KGZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uX192Ll9fYi1sLl9fdi5fX2J9KSx0PVtdLG4uc29tZShmdW5jdGlvbihuKXt2YXIgbCx1LGksdCxvLHI7bi5fX2QmJihvPSh0PShsPW4pLl9fdikuX19lLChyPWwuX19QKSYmKHU9W10sKGk9YSh7fSx0KSkuX192PXQuX192KzEsaihyLHQsaSxsLl9fbix2b2lkIDAhPT1yLm93bmVyU1ZHRWxlbWVudCxudWxsIT10Ll9faD9bb106bnVsbCx1LG51bGw9PW8/ayh0KTpvLHQuX19oKSx6KHUsdCksdC5fX2UhPW8mJmIodCkpKX0pfWZ1bmN0aW9uIHcobixsLHUsaSx0LG8scixmLHMsYSl7dmFyIGgsdixwLF8sYixtLGcsdz1pJiZpLl9fa3x8YyxBPXcubGVuZ3RoO2Zvcih1Ll9faz1bXSxoPTA7aDxsLmxlbmd0aDtoKyspaWYobnVsbCE9KF89dS5fX2tbaF09bnVsbD09KF89bFtoXSl8fFwiYm9vbGVhblwiPT10eXBlb2YgXz9udWxsOlwic3RyaW5nXCI9PXR5cGVvZiBffHxcIm51bWJlclwiPT10eXBlb2YgX3x8XCJiaWdpbnRcIj09dHlwZW9mIF8/eShudWxsLF8sbnVsbCxudWxsLF8pOkFycmF5LmlzQXJyYXkoXyk/eShkLHtjaGlsZHJlbjpffSxudWxsLG51bGwsbnVsbCk6Xy5fX2I+MD95KF8udHlwZSxfLnByb3BzLF8ua2V5LG51bGwsXy5fX3YpOl8pKXtpZihfLl9fPXUsXy5fX2I9dS5fX2IrMSxudWxsPT09KHA9d1toXSl8fHAmJl8ua2V5PT1wLmtleSYmXy50eXBlPT09cC50eXBlKXdbaF09dm9pZCAwO2Vsc2UgZm9yKHY9MDt2PEE7disrKXtpZigocD13W3ZdKSYmXy5rZXk9PXAua2V5JiZfLnR5cGU9PT1wLnR5cGUpe3dbdl09dm9pZCAwO2JyZWFrfXA9bnVsbH1qKG4sXyxwPXB8fGUsdCxvLHIsZixzLGEpLGI9Xy5fX2UsKHY9Xy5yZWYpJiZwLnJlZiE9diYmKGd8fChnPVtdKSxwLnJlZiYmZy5wdXNoKHAucmVmLG51bGwsXyksZy5wdXNoKHYsXy5fX2N8fGIsXykpLG51bGwhPWI/KG51bGw9PW0mJihtPWIpLFwiZnVuY3Rpb25cIj09dHlwZW9mIF8udHlwZSYmbnVsbCE9Xy5fX2smJl8uX19rPT09cC5fX2s/Xy5fX2Q9cz14KF8scyxuKTpzPVAobixfLHAsdyxiLHMpLGF8fFwib3B0aW9uXCIhPT11LnR5cGU/XCJmdW5jdGlvblwiPT10eXBlb2YgdS50eXBlJiYodS5fX2Q9cyk6bi52YWx1ZT1cIlwiKTpzJiZwLl9fZT09cyYmcy5wYXJlbnROb2RlIT1uJiYocz1rKHApKX1mb3IodS5fX2U9bSxoPUE7aC0tOyludWxsIT13W2hdJiYoXCJmdW5jdGlvblwiPT10eXBlb2YgdS50eXBlJiZudWxsIT13W2hdLl9fZSYmd1toXS5fX2U9PXUuX19kJiYodS5fX2Q9ayhpLGgrMSkpLE4od1toXSx3W2hdKSk7aWYoZylmb3IoaD0wO2g8Zy5sZW5ndGg7aCsrKU0oZ1toXSxnWysraF0sZ1srK2hdKX1mdW5jdGlvbiB4KG4sbCx1KXt2YXIgaSx0O2ZvcihpPTA7aTxuLl9fay5sZW5ndGg7aSsrKSh0PW4uX19rW2ldKSYmKHQuX189bixsPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQudHlwZT94KHQsbCx1KTpQKHUsdCx0LG4uX19rLHQuX19lLGwpKTtyZXR1cm4gbH1mdW5jdGlvbiBBKG4sbCl7cmV0dXJuIGw9bHx8W10sbnVsbD09bnx8XCJib29sZWFuXCI9PXR5cGVvZiBufHwoQXJyYXkuaXNBcnJheShuKT9uLnNvbWUoZnVuY3Rpb24obil7QShuLGwpfSk6bC5wdXNoKG4pKSxsfWZ1bmN0aW9uIFAobixsLHUsaSx0LG8pe3ZhciByLGYsZTtpZih2b2lkIDAhPT1sLl9fZClyPWwuX19kLGwuX19kPXZvaWQgMDtlbHNlIGlmKG51bGw9PXV8fHQhPW98fG51bGw9PXQucGFyZW50Tm9kZSluOmlmKG51bGw9PW98fG8ucGFyZW50Tm9kZSE9PW4pbi5hcHBlbmRDaGlsZCh0KSxyPW51bGw7ZWxzZXtmb3IoZj1vLGU9MDsoZj1mLm5leHRTaWJsaW5nKSYmZTxpLmxlbmd0aDtlKz0yKWlmKGY9PXQpYnJlYWsgbjtuLmluc2VydEJlZm9yZSh0LG8pLHI9b31yZXR1cm4gdm9pZCAwIT09cj9yOnQubmV4dFNpYmxpbmd9ZnVuY3Rpb24gQyhuLGwsdSxpLHQpe3ZhciBvO2ZvcihvIGluIHUpXCJjaGlsZHJlblwiPT09b3x8XCJrZXlcIj09PW98fG8gaW4gbHx8SChuLG8sbnVsbCx1W29dLGkpO2ZvcihvIGluIGwpdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgbFtvXXx8XCJjaGlsZHJlblwiPT09b3x8XCJrZXlcIj09PW98fFwidmFsdWVcIj09PW98fFwiY2hlY2tlZFwiPT09b3x8dVtvXT09PWxbb118fEgobixvLGxbb10sdVtvXSxpKX1mdW5jdGlvbiAkKG4sbCx1KXtcIi1cIj09PWxbMF0/bi5zZXRQcm9wZXJ0eShsLHUpOm5bbF09bnVsbD09dT9cIlwiOlwibnVtYmVyXCIhPXR5cGVvZiB1fHxzLnRlc3QobCk/dTp1K1wicHhcIn1mdW5jdGlvbiBIKG4sbCx1LGksdCl7dmFyIG87bjppZihcInN0eWxlXCI9PT1sKWlmKFwic3RyaW5nXCI9PXR5cGVvZiB1KW4uc3R5bGUuY3NzVGV4dD11O2Vsc2V7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGkmJihuLnN0eWxlLmNzc1RleHQ9aT1cIlwiKSxpKWZvcihsIGluIGkpdSYmbCBpbiB1fHwkKG4uc3R5bGUsbCxcIlwiKTtpZih1KWZvcihsIGluIHUpaSYmdVtsXT09PWlbbF18fCQobi5zdHlsZSxsLHVbbF0pfWVsc2UgaWYoXCJvXCI9PT1sWzBdJiZcIm5cIj09PWxbMV0pbz1sIT09KGw9bC5yZXBsYWNlKC9DYXB0dXJlJC8sXCJcIikpLGw9bC50b0xvd2VyQ2FzZSgpaW4gbj9sLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik6bC5zbGljZSgyKSxuLmx8fChuLmw9e30pLG4ubFtsK29dPXUsdT9pfHxuLmFkZEV2ZW50TGlzdGVuZXIobCxvP1Q6SSxvKTpuLnJlbW92ZUV2ZW50TGlzdGVuZXIobCxvP1Q6SSxvKTtlbHNlIGlmKFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIiE9PWwpe2lmKHQpbD1sLnJlcGxhY2UoL3hsaW5rW0g6aF0vLFwiaFwiKS5yZXBsYWNlKC9zTmFtZSQvLFwic1wiKTtlbHNlIGlmKFwiaHJlZlwiIT09bCYmXCJsaXN0XCIhPT1sJiZcImZvcm1cIiE9PWwmJlwidGFiSW5kZXhcIiE9PWwmJlwiZG93bmxvYWRcIiE9PWwmJmwgaW4gbil0cnl7bltsXT1udWxsPT11P1wiXCI6dTticmVhayBufWNhdGNoKG4pe31cImZ1bmN0aW9uXCI9PXR5cGVvZiB1fHwobnVsbCE9dSYmKCExIT09dXx8XCJhXCI9PT1sWzBdJiZcInJcIj09PWxbMV0pP24uc2V0QXR0cmlidXRlKGwsdSk6bi5yZW1vdmVBdHRyaWJ1dGUobCkpfX1mdW5jdGlvbiBJKG4pe3RoaXMubFtuLnR5cGUrITFdKGwuZXZlbnQ/bC5ldmVudChuKTpuKX1mdW5jdGlvbiBUKG4pe3RoaXMubFtuLnR5cGUrITBdKGwuZXZlbnQ/bC5ldmVudChuKTpuKX1mdW5jdGlvbiBqKG4sdSxpLHQsbyxyLGYsZSxjKXt2YXIgcyxoLHYseSxwLGssYixtLGcseCxBLFA9dS50eXBlO2lmKHZvaWQgMCE9PXUuY29uc3RydWN0b3IpcmV0dXJuIG51bGw7bnVsbCE9aS5fX2gmJihjPWkuX19oLGU9dS5fX2U9aS5fX2UsdS5fX2g9bnVsbCxyPVtlXSksKHM9bC5fX2IpJiZzKHUpO3RyeXtuOmlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFApe2lmKG09dS5wcm9wcyxnPShzPVAuY29udGV4dFR5cGUpJiZ0W3MuX19jXSx4PXM/Zz9nLnByb3BzLnZhbHVlOnMuX186dCxpLl9fYz9iPShoPXUuX19jPWkuX19jKS5fXz1oLl9fRTooXCJwcm90b3R5cGVcImluIFAmJlAucHJvdG90eXBlLnJlbmRlcj91Ll9fYz1oPW5ldyBQKG0seCk6KHUuX19jPWg9bmV3IF8obSx4KSxoLmNvbnN0cnVjdG9yPVAsaC5yZW5kZXI9TyksZyYmZy5zdWIoaCksaC5wcm9wcz1tLGguc3RhdGV8fChoLnN0YXRlPXt9KSxoLmNvbnRleHQ9eCxoLl9fbj10LHY9aC5fX2Q9ITAsaC5fX2g9W10pLG51bGw9PWguX19zJiYoaC5fX3M9aC5zdGF0ZSksbnVsbCE9UC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJihoLl9fcz09aC5zdGF0ZSYmKGguX19zPWEoe30saC5fX3MpKSxhKGguX19zLFAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG0saC5fX3MpKSkseT1oLnByb3BzLHA9aC5zdGF0ZSx2KW51bGw9PVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiZudWxsIT1oLmNvbXBvbmVudFdpbGxNb3VudCYmaC5jb21wb25lbnRXaWxsTW91bnQoKSxudWxsIT1oLmNvbXBvbmVudERpZE1vdW50JiZoLl9faC5wdXNoKGguY29tcG9uZW50RGlkTW91bnQpO2Vsc2V7aWYobnVsbD09UC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJm0hPT15JiZudWxsIT1oLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmguY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhtLHgpLCFoLl9fZSYmbnVsbCE9aC5zaG91bGRDb21wb25lbnRVcGRhdGUmJiExPT09aC5zaG91bGRDb21wb25lbnRVcGRhdGUobSxoLl9fcyx4KXx8dS5fX3Y9PT1pLl9fdil7aC5wcm9wcz1tLGguc3RhdGU9aC5fX3MsdS5fX3YhPT1pLl9fdiYmKGguX19kPSExKSxoLl9fdj11LHUuX19lPWkuX19lLHUuX19rPWkuX19rLHUuX19rLmZvckVhY2goZnVuY3Rpb24obil7biYmKG4uX189dSl9KSxoLl9faC5sZW5ndGgmJmYucHVzaChoKTticmVhayBufW51bGwhPWguY29tcG9uZW50V2lsbFVwZGF0ZSYmaC5jb21wb25lbnRXaWxsVXBkYXRlKG0saC5fX3MseCksbnVsbCE9aC5jb21wb25lbnREaWRVcGRhdGUmJmguX19oLnB1c2goZnVuY3Rpb24oKXtoLmNvbXBvbmVudERpZFVwZGF0ZSh5LHAsayl9KX1oLmNvbnRleHQ9eCxoLnByb3BzPW0saC5zdGF0ZT1oLl9fcywocz1sLl9fcikmJnModSksaC5fX2Q9ITEsaC5fX3Y9dSxoLl9fUD1uLHM9aC5yZW5kZXIoaC5wcm9wcyxoLnN0YXRlLGguY29udGV4dCksaC5zdGF0ZT1oLl9fcyxudWxsIT1oLmdldENoaWxkQ29udGV4dCYmKHQ9YShhKHt9LHQpLGguZ2V0Q2hpbGRDb250ZXh0KCkpKSx2fHxudWxsPT1oLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHwoaz1oLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHkscCkpLEE9bnVsbCE9cyYmcy50eXBlPT09ZCYmbnVsbD09cy5rZXk/cy5wcm9wcy5jaGlsZHJlbjpzLHcobixBcnJheS5pc0FycmF5KEEpP0E6W0FdLHUsaSx0LG8scixmLGUsYyksaC5iYXNlPXUuX19lLHUuX19oPW51bGwsaC5fX2gubGVuZ3RoJiZmLnB1c2goaCksYiYmKGguX19FPWguX189bnVsbCksaC5fX2U9ITF9ZWxzZSBudWxsPT1yJiZ1Ll9fdj09PWkuX192Pyh1Ll9faz1pLl9fayx1Ll9fZT1pLl9fZSk6dS5fX2U9TChpLl9fZSx1LGksdCxvLHIsZixjKTsocz1sLmRpZmZlZCkmJnModSl9Y2F0Y2gobil7dS5fX3Y9bnVsbCwoY3x8bnVsbCE9cikmJih1Ll9fZT1lLHUuX19oPSEhYyxyW3IuaW5kZXhPZihlKV09bnVsbCksbC5fX2Uobix1LGkpfX1mdW5jdGlvbiB6KG4sdSl7bC5fX2MmJmwuX19jKHUsbiksbi5zb21lKGZ1bmN0aW9uKHUpe3RyeXtuPXUuX19oLHUuX19oPVtdLG4uc29tZShmdW5jdGlvbihuKXtuLmNhbGwodSl9KX1jYXRjaChuKXtsLl9fZShuLHUuX192KX19KX1mdW5jdGlvbiBMKGwsdSxpLHQsbyxyLGYsYyl7dmFyIHMsYSx2LHk9aS5wcm9wcyxwPXUucHJvcHMsZD11LnR5cGUsXz0wO2lmKFwic3ZnXCI9PT1kJiYobz0hMCksbnVsbCE9cilmb3IoO188ci5sZW5ndGg7XysrKWlmKChzPXJbX10pJiYocz09PWx8fChkP3MubG9jYWxOYW1lPT1kOjM9PXMubm9kZVR5cGUpKSl7bD1zLHJbX109bnVsbDticmVha31pZihudWxsPT1sKXtpZihudWxsPT09ZClyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocCk7bD1vP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsZCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkLHAuaXMmJnApLHI9bnVsbCxjPSExfWlmKG51bGw9PT1kKXk9PT1wfHxjJiZsLmRhdGE9PT1wfHwobC5kYXRhPXApO2Vsc2V7aWYocj1yJiZuLmNhbGwobC5jaGlsZE5vZGVzKSxhPSh5PWkucHJvcHN8fGUpLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLHY9cC5kYW5nZXJvdXNseVNldElubmVySFRNTCwhYyl7aWYobnVsbCE9cilmb3IoeT17fSxfPTA7XzxsLmF0dHJpYnV0ZXMubGVuZ3RoO18rKyl5W2wuYXR0cmlidXRlc1tfXS5uYW1lXT1sLmF0dHJpYnV0ZXNbX10udmFsdWU7KHZ8fGEpJiYodiYmKGEmJnYuX19odG1sPT1hLl9faHRtbHx8di5fX2h0bWw9PT1sLmlubmVySFRNTCl8fChsLmlubmVySFRNTD12JiZ2Ll9faHRtbHx8XCJcIikpfWlmKEMobCxwLHksbyxjKSx2KXUuX19rPVtdO2Vsc2UgaWYoXz11LnByb3BzLmNoaWxkcmVuLHcobCxBcnJheS5pc0FycmF5KF8pP186W19dLHUsaSx0LG8mJlwiZm9yZWlnbk9iamVjdFwiIT09ZCxyLGYscj9yWzBdOmkuX19rJiZrKGksMCksYyksbnVsbCE9cilmb3IoXz1yLmxlbmd0aDtfLS07KW51bGwhPXJbX10mJmgocltfXSk7Y3x8KFwidmFsdWVcImluIHAmJnZvaWQgMCE9PShfPXAudmFsdWUpJiYoXyE9PWwudmFsdWV8fFwicHJvZ3Jlc3NcIj09PWQmJiFfKSYmSChsLFwidmFsdWVcIixfLHkudmFsdWUsITEpLFwiY2hlY2tlZFwiaW4gcCYmdm9pZCAwIT09KF89cC5jaGVja2VkKSYmXyE9PWwuY2hlY2tlZCYmSChsLFwiY2hlY2tlZFwiLF8seS5jaGVja2VkLCExKSl9cmV0dXJuIGx9ZnVuY3Rpb24gTShuLHUsaSl7dHJ5e1wiZnVuY3Rpb25cIj09dHlwZW9mIG4/bih1KTpuLmN1cnJlbnQ9dX1jYXRjaChuKXtsLl9fZShuLGkpfX1mdW5jdGlvbiBOKG4sdSxpKXt2YXIgdCxvO2lmKGwudW5tb3VudCYmbC51bm1vdW50KG4pLCh0PW4ucmVmKSYmKHQuY3VycmVudCYmdC5jdXJyZW50IT09bi5fX2V8fE0odCxudWxsLHUpKSxudWxsIT0odD1uLl9fYykpe2lmKHQuY29tcG9uZW50V2lsbFVubW91bnQpdHJ5e3QuY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChuKXtsLl9fZShuLHUpfXQuYmFzZT10Ll9fUD1udWxsfWlmKHQ9bi5fX2spZm9yKG89MDtvPHQubGVuZ3RoO28rKyl0W29dJiZOKHRbb10sdSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBuLnR5cGUpO2l8fG51bGw9PW4uX19lfHxoKG4uX19lKSxuLl9fZT1uLl9fZD12b2lkIDB9ZnVuY3Rpb24gTyhuLGwsdSl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3Iobix1KX1mdW5jdGlvbiBTKHUsaSx0KXt2YXIgbyxyLGY7bC5fXyYmbC5fXyh1LGkpLHI9KG89XCJmdW5jdGlvblwiPT10eXBlb2YgdCk/bnVsbDp0JiZ0Ll9fa3x8aS5fX2ssZj1bXSxqKGksdT0oIW8mJnR8fGkpLl9faz12KGQsbnVsbCxbdV0pLHJ8fGUsZSx2b2lkIDAhPT1pLm93bmVyU1ZHRWxlbWVudCwhbyYmdD9bdF06cj9udWxsOmkuZmlyc3RDaGlsZD9uLmNhbGwoaS5jaGlsZE5vZGVzKTpudWxsLGYsIW8mJnQ/dDpyP3IuX19lOmkuZmlyc3RDaGlsZCxvKSx6KGYsdSl9ZnVuY3Rpb24gcShuLGwpe1MobixsLHEpfWZ1bmN0aW9uIEIobCx1LGkpe3ZhciB0LG8scixmPWEoe30sbC5wcm9wcyk7Zm9yKHIgaW4gdSlcImtleVwiPT1yP3Q9dVtyXTpcInJlZlwiPT1yP289dVtyXTpmW3JdPXVbcl07cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg+MiYmKGYuY2hpbGRyZW49YXJndW1lbnRzLmxlbmd0aD4zP24uY2FsbChhcmd1bWVudHMsMik6aSkseShsLnR5cGUsZix0fHxsLmtleSxvfHxsLnJlZixudWxsKX1mdW5jdGlvbiBEKG4sbCl7dmFyIHU9e19fYzpsPVwiX19jQ1wiK2YrKyxfXzpuLENvbnN1bWVyOmZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uY2hpbGRyZW4obCl9LFByb3ZpZGVyOmZ1bmN0aW9uKG4pe3ZhciB1LGk7cmV0dXJuIHRoaXMuZ2V0Q2hpbGRDb250ZXh0fHwodT1bXSwoaT17fSlbbF09dGhpcyx0aGlzLmdldENoaWxkQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiBpfSx0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mdW5jdGlvbihuKXt0aGlzLnByb3BzLnZhbHVlIT09bi52YWx1ZSYmdS5zb21lKG0pfSx0aGlzLnN1Yj1mdW5jdGlvbihuKXt1LnB1c2gobik7dmFyIGw9bi5jb21wb25lbnRXaWxsVW5tb3VudDtuLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dS5zcGxpY2UodS5pbmRleE9mKG4pLDEpLGwmJmwuY2FsbChuKX19KSxuLmNoaWxkcmVufX07cmV0dXJuIHUuUHJvdmlkZXIuX189dS5Db25zdW1lci5jb250ZXh0VHlwZT11fW49Yy5zbGljZSxsPXtfX2U6ZnVuY3Rpb24obixsKXtmb3IodmFyIHUsaSx0O2w9bC5fXzspaWYoKHU9bC5fX2MpJiYhdS5fXyl0cnl7aWYoKGk9dS5jb25zdHJ1Y3RvcikmJm51bGwhPWkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yJiYodS5zZXRTdGF0ZShpLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihuKSksdD11Ll9fZCksbnVsbCE9dS5jb21wb25lbnREaWRDYXRjaCYmKHUuY29tcG9uZW50RGlkQ2F0Y2gobiksdD11Ll9fZCksdClyZXR1cm4gdS5fX0U9dX1jYXRjaChsKXtuPWx9dGhyb3cgbn19LHU9MCxpPWZ1bmN0aW9uKG4pe3JldHVybiBudWxsIT1uJiZ2b2lkIDA9PT1uLmNvbnN0cnVjdG9yfSxfLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihuLGwpe3ZhciB1O3U9bnVsbCE9dGhpcy5fX3MmJnRoaXMuX19zIT09dGhpcy5zdGF0ZT90aGlzLl9fczp0aGlzLl9fcz1hKHt9LHRoaXMuc3RhdGUpLFwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJihuPW4oYSh7fSx1KSx0aGlzLnByb3BzKSksbiYmYSh1LG4pLG51bGwhPW4mJnRoaXMuX192JiYobCYmdGhpcy5fX2gucHVzaChsKSxtKHRoaXMpKX0sXy5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5fX3YmJih0aGlzLl9fZT0hMCxuJiZ0aGlzLl9faC5wdXNoKG4pLG0odGhpcykpfSxfLnByb3RvdHlwZS5yZW5kZXI9ZCx0PVtdLG89XCJmdW5jdGlvblwiPT10eXBlb2YgUHJvbWlzZT9Qcm9taXNlLnByb3RvdHlwZS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpOnNldFRpbWVvdXQsZy5fX3I9MCxmPTA7ZXhwb3J0e1MgYXMgcmVuZGVyLHEgYXMgaHlkcmF0ZSx2IGFzIGNyZWF0ZUVsZW1lbnQsdiBhcyBoLGQgYXMgRnJhZ21lbnQscCBhcyBjcmVhdGVSZWYsaSBhcyBpc1ZhbGlkRWxlbWVudCxfIGFzIENvbXBvbmVudCxCIGFzIGNsb25lRWxlbWVudCxEIGFzIGNyZWF0ZUNvbnRleHQsQSBhcyB0b0NoaWxkQXJyYXksbCBhcyBvcHRpb25zfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC5tb2R1bGUuanMubWFwXG4iLCJpbXBvcnR7b3B0aW9ucyBhcyBufWZyb21cInByZWFjdFwiO3ZhciB0LHUscixvPTAsaT1bXSxjPW4uX19iLGY9bi5fX3IsZT1uLmRpZmZlZCxhPW4uX19jLHY9bi51bm1vdW50O2Z1bmN0aW9uIG0odCxyKXtuLl9faCYmbi5fX2godSx0LG98fHIpLG89MDt2YXIgaT11Ll9fSHx8KHUuX19IPXtfXzpbXSxfX2g6W119KTtyZXR1cm4gdD49aS5fXy5sZW5ndGgmJmkuX18ucHVzaCh7fSksaS5fX1t0XX1mdW5jdGlvbiBsKG4pe3JldHVybiBvPTEscCh3LG4pfWZ1bmN0aW9uIHAobixyLG8pe3ZhciBpPW0odCsrLDIpO3JldHVybiBpLnQ9bixpLl9fY3x8KGkuX189W28/byhyKTp3KHZvaWQgMCxyKSxmdW5jdGlvbihuKXt2YXIgdD1pLnQoaS5fX1swXSxuKTtpLl9fWzBdIT09dCYmKGkuX189W3QsaS5fX1sxXV0saS5fX2Muc2V0U3RhdGUoe30pKX1dLGkuX19jPXUpLGkuX199ZnVuY3Rpb24geShyLG8pe3ZhciBpPW0odCsrLDMpOyFuLl9fcyYmayhpLl9fSCxvKSYmKGkuX189cixpLl9fSD1vLHUuX19ILl9faC5wdXNoKGkpKX1mdW5jdGlvbiBoKHIsbyl7dmFyIGk9bSh0KyssNCk7IW4uX19zJiZrKGkuX19ILG8pJiYoaS5fXz1yLGkuX19IPW8sdS5fX2gucHVzaChpKSl9ZnVuY3Rpb24gcyhuKXtyZXR1cm4gbz01LGQoZnVuY3Rpb24oKXtyZXR1cm57Y3VycmVudDpufX0sW10pfWZ1bmN0aW9uIF8obix0LHUpe289NixoKGZ1bmN0aW9uKCl7XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uKHQoKSk6biYmKG4uY3VycmVudD10KCkpfSxudWxsPT11P3U6dS5jb25jYXQobikpfWZ1bmN0aW9uIGQobix1KXt2YXIgcj1tKHQrKyw3KTtyZXR1cm4gayhyLl9fSCx1KSYmKHIuX189bigpLHIuX19IPXUsci5fX2g9biksci5fX31mdW5jdGlvbiBBKG4sdCl7cmV0dXJuIG89OCxkKGZ1bmN0aW9uKCl7cmV0dXJuIG59LHQpfWZ1bmN0aW9uIEYobil7dmFyIHI9dS5jb250ZXh0W24uX19jXSxvPW0odCsrLDkpO3JldHVybiBvLmM9bixyPyhudWxsPT1vLl9fJiYoby5fXz0hMCxyLnN1Yih1KSksci5wcm9wcy52YWx1ZSk6bi5fX31mdW5jdGlvbiBUKHQsdSl7bi51c2VEZWJ1Z1ZhbHVlJiZuLnVzZURlYnVnVmFsdWUodT91KHQpOnQpfWZ1bmN0aW9uIHEobil7dmFyIHI9bSh0KyssMTApLG89bCgpO3JldHVybiByLl9fPW4sdS5jb21wb25lbnREaWRDYXRjaHx8KHUuY29tcG9uZW50RGlkQ2F0Y2g9ZnVuY3Rpb24obil7ci5fXyYmci5fXyhuKSxvWzFdKG4pfSksW29bMF0sZnVuY3Rpb24oKXtvWzFdKHZvaWQgMCl9XX1mdW5jdGlvbiB4KCl7aS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKHQuX19QKXRyeXt0Ll9fSC5fX2guZm9yRWFjaChnKSx0Ll9fSC5fX2guZm9yRWFjaChqKSx0Ll9fSC5fX2g9W119Y2F0Y2godSl7dC5fX0guX19oPVtdLG4uX19lKHUsdC5fX3YpfX0pLGk9W119bi5fX2I9ZnVuY3Rpb24obil7dT1udWxsLGMmJmMobil9LG4uX19yPWZ1bmN0aW9uKG4pe2YmJmYobiksdD0wO3ZhciByPSh1PW4uX19jKS5fX0g7ciYmKHIuX19oLmZvckVhY2goZyksci5fX2guZm9yRWFjaChqKSxyLl9faD1bXSl9LG4uZGlmZmVkPWZ1bmN0aW9uKHQpe2UmJmUodCk7dmFyIG89dC5fX2M7byYmby5fX0gmJm8uX19ILl9faC5sZW5ndGgmJigxIT09aS5wdXNoKG8pJiZyPT09bi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fCgocj1uLnJlcXVlc3RBbmltYXRpb25GcmFtZSl8fGZ1bmN0aW9uKG4pe3ZhciB0LHU9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQociksYiYmY2FuY2VsQW5pbWF0aW9uRnJhbWUodCksc2V0VGltZW91dChuKX0scj1zZXRUaW1lb3V0KHUsMTAwKTtiJiYodD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodSkpfSkoeCkpLHU9dm9pZCAwfSxuLl9fYz1mdW5jdGlvbih0LHUpe3Uuc29tZShmdW5jdGlvbih0KXt0cnl7dC5fX2guZm9yRWFjaChnKSx0Ll9faD10Ll9faC5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuIW4uX198fGoobil9KX1jYXRjaChyKXt1LnNvbWUoZnVuY3Rpb24obil7bi5fX2gmJihuLl9faD1bXSl9KSx1PVtdLG4uX19lKHIsdC5fX3YpfX0pLGEmJmEodCx1KX0sbi51bm1vdW50PWZ1bmN0aW9uKHQpe3YmJnYodCk7dmFyIHU9dC5fX2M7aWYodSYmdS5fX0gpdHJ5e3UuX19ILl9fLmZvckVhY2goZyl9Y2F0Y2godCl7bi5fX2UodCx1Ll9fdil9fTt2YXIgYj1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ZnVuY3Rpb24gZyhuKXt2YXIgdD11O1wiZnVuY3Rpb25cIj09dHlwZW9mIG4uX19jJiZuLl9fYygpLHU9dH1mdW5jdGlvbiBqKG4pe3ZhciB0PXU7bi5fX2M9bi5fXygpLHU9dH1mdW5jdGlvbiBrKG4sdCl7cmV0dXJuIW58fG4ubGVuZ3RoIT09dC5sZW5ndGh8fHQuc29tZShmdW5jdGlvbih0LHUpe3JldHVybiB0IT09blt1XX0pfWZ1bmN0aW9uIHcobix0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Qobik6dH1leHBvcnR7bCBhcyB1c2VTdGF0ZSxwIGFzIHVzZVJlZHVjZXIseSBhcyB1c2VFZmZlY3QsaCBhcyB1c2VMYXlvdXRFZmZlY3QscyBhcyB1c2VSZWYsXyBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlLGQgYXMgdXNlTWVtbyxBIGFzIHVzZUNhbGxiYWNrLEYgYXMgdXNlQ29udGV4dCxUIGFzIHVzZURlYnVnVmFsdWUscSBhcyB1c2VFcnJvckJvdW5kYXJ5fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvb2tzLm1vZHVsZS5qcy5tYXBcbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSBcInByZWFjdFwiO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkQ2hpbGRyZW4obGhzUHJvcHMsIHJoc1Byb3BzKSB7XHJcbiAgICBjb25zdCBsaHMgPSBsaHNQcm9wcz8uY2hpbGRyZW47XHJcbiAgICBjb25zdCByaHMgPSByaHNQcm9wcz8uY2hpbGRyZW47XHJcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbGhzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHJldCA9IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCBsaHMsIHJocyk7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbWVyZ2VkLWNoaWxkcmVuLmpzLm1hcCIsImZ1bmN0aW9uIHRvVmFsKG1peCkge1xuXHR2YXIgaywgeSwgc3RyPScnO1xuXG5cdGlmICh0eXBlb2YgbWl4ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbWl4ID09PSAnbnVtYmVyJykge1xuXHRcdHN0ciArPSBtaXg7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1peCA9PT0gJ29iamVjdCcpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShtaXgpKSB7XG5cdFx0XHRmb3IgKGs9MDsgayA8IG1peC5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRpZiAobWl4W2tdKSB7XG5cdFx0XHRcdFx0aWYgKHkgPSB0b1ZhbChtaXhba10pKSB7XG5cdFx0XHRcdFx0XHRzdHIgJiYgKHN0ciArPSAnICcpO1xuXHRcdFx0XHRcdFx0c3RyICs9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoayBpbiBtaXgpIHtcblx0XHRcdFx0aWYgKG1peFtrXSkge1xuXHRcdFx0XHRcdHN0ciAmJiAoc3RyICs9ICcgJyk7XG5cdFx0XHRcdFx0c3RyICs9IGs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG5cdHZhciBpPTAsIHRtcCwgeCwgc3RyPScnO1xuXHR3aGlsZSAoaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRpZiAodG1wID0gYXJndW1lbnRzW2krK10pIHtcblx0XHRcdGlmICh4ID0gdG9WYWwodG1wKSkge1xuXHRcdFx0XHRzdHIgJiYgKHN0ciArPSAnICcpO1xuXHRcdFx0XHRzdHIgKz0geFxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3RyO1xufVxuIiwiaW1wb3J0IHsgZGVmYXVsdCBhcyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuLyoqXHJcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlaXIgYGNsYXNzYCBhbmQgYGNsYXNzTmFtZWAgcHJvcGVydGllcy5cclxuICogRHVwbGljYXRlIGNsYXNzZXMgYXJlIHJlbW92ZWQgKG9yZGVyIGRvZXNuJ3QgbWF0dGVyIGFueXdheSkuXHJcbiAqXHJcbiAqIEBwYXJhbSBsaHMgQ2xhc3NlcyBvZiB0aGUgZmlyc3QgY29tcG9uZW50XHJcbiAqIEBwYXJhbSByaHMgQ2xhc3NlcyBvZiB0aGUgc2Vjb25kIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIGNvbWJpbmVkIGNsYXNzZXMgZnJvbSBib3RoIGFyZ3VtZW50cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDbGFzc2VzKGxocywgcmhzKSB7XHJcbiAgICAvLyBOb3RlOiBGb3IgdGhlIHNha2Ugb2YgZm9yd2FyZCBjb21wYXRpYmlsaXR5LCB0aGlzIGZ1bmN0aW9uIGlzIGxhYmVsbGVkIGFzXHJcbiAgICAvLyBhIGhvb2ssIGJ1dCBhcyBpdCB1c2VzIG5vIG90aGVyIGhvb2tzIGl0IHRlY2huaWNhbGx5IGlzbid0IG9uZS5cclxuICAgIHJldHVybiBtZXJnZUNsYXNzZXMobGhzLCByaHMpO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlQ2xhc3NlcyhsaHMsIHJocykge1xyXG4gICAgY29uc3QgbGhzQ2xhc3MgPSBsaHM/LmNsYXNzO1xyXG4gICAgY29uc3QgbGhzQ2xhc3NOYW1lID0gbGhzPy5jbGFzc05hbWU7XHJcbiAgICBjb25zdCByaHNDbGFzcyA9IHJocz8uY2xhc3M7XHJcbiAgICBjb25zdCByaHNDbGFzc05hbWUgPSByaHM/LmNsYXNzTmFtZTtcclxuICAgIGlmIChsaHNDbGFzcyB8fCByaHNDbGFzcyB8fCBsaHNDbGFzc05hbWUgfHwgcmhzQ2xhc3NOYW1lKSB7XHJcbiAgICAgICAgbGV0IGxoc0NsYXNzZXMgPSBjbHN4KGxoc0NsYXNzLCBsaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBsZXQgcmhzQ2xhc3NlcyA9IGNsc3gocmhzQ2xhc3MsIHJoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgIGxldCBhbGxDbGFzc2VzID0gbmV3IFNldChbLi4uQXJyYXkuZnJvbShsaHNDbGFzc2VzKSwgLi4uQXJyYXkuZnJvbShyaHNDbGFzc2VzKV0pO1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGFsbENsYXNzZXMpLmpvaW4oXCIgXCIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0eXBldGVzdCgpIHtcclxuICAgIGNvbnN0IGMgPSBbXHJcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh1bmRlZmluZWQsIHVuZGVmaW5lZCksXHJcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh7fSwgdW5kZWZpbmVkKSxcclxuICAgICAgICB1c2VNZXJnZWRDbGFzc2VzKHVuZGVmaW5lZCwge30pLFxyXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoe30sIHt9KSxcclxuICAgICAgICB1c2VNZXJnZWRDbGFzc2VzKHsgY2xhc3M6IFwic3RyaW5nXCIgfSwge30pLFxyXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoeyBjbGFzczogXCJzdHJpbmdcIiB9LCB7IGNsYXNzOiB1bmRlZmluZWQgfSksXHJcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh7IGNsYXNzOiB1bmRlZmluZWQgfSwgeyBjbGFzczogXCJzdHJpbmdcIiB9KSxcclxuICAgICAgICB1c2VNZXJnZWRDbGFzc2VzKHsgY2xhc3NOYW1lOiBcInN0cmluZ1wiIH0sIHsgY2xhc3NOYW1lOiB1bmRlZmluZWQgfSksXHJcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh7IGNsYXNzTmFtZTogdW5kZWZpbmVkIH0sIHsgY2xhc3NOYW1lOiBcInN0cmluZ1wiIH0pLFxyXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoeyBjbGFzczogXCJzdHJpbmdcIiB9LCB7IGNsYXNzTmFtZTogdW5kZWZpbmVkIH0pLFxyXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoeyBjbGFzc05hbWU6IHVuZGVmaW5lZCB9LCB7IGNsYXNzOiBcInN0cmluZ1wiIH0pLFxyXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoeyBjbGFzc05hbWU6IFwic3RyaW5nXCIgfSwgeyBjbGFzczogdW5kZWZpbmVkIH0pLFxyXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoeyBjbGFzczogdW5kZWZpbmVkIH0sIHsgY2xhc3NOYW1lOiBcInN0cmluZ1wiIH0pLFxyXG4gICAgXTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBjWzBdLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBjWzFdLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBjWzJdLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBjWzNdLmNvbmNhdChcIlwiKTtcclxuICAgIGNbNF0uY29uY2F0KFwiXCIpO1xyXG4gICAgY1s1XS5jb25jYXQoXCJcIik7XHJcbiAgICBjWzZdLmNvbmNhdChcIlwiKTtcclxuICAgIGNbN10uY29uY2F0KFwiXCIpO1xyXG4gICAgY1s4XS5jb25jYXQoXCJcIik7XHJcbiAgICBjWzldLmNvbmNhdChcIlwiKTtcclxuICAgIGNbMTBdLmNvbmNhdChcIlwiKTtcclxuICAgIGNbMTFdLmNvbmNhdChcIlwiKTtcclxuICAgIGNbMTJdLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBjWzEzXTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbWVyZ2VkLWNsYXNzZXMuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWYoaW5zdGFuY2UsIHJlZikge1xyXG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJlZihpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICAgIHJlZi5jdXJyZW50ID0gaW5zdGFuY2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxyXG4gKiBAcGFyYW0gbGhzXHJcbiAqIEBwYXJhbSByaHNcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRSZWZzKCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsaHNQcm9wcywgcmhzUHJvcHMpIHtcclxuICAgICAgICBjb25zdCBsaHMgPSBsaHNQcm9wcz8ucmVmO1xyXG4gICAgICAgIGNvbnN0IHJocyA9IHJoc1Byb3BzPy5yZWY7XHJcbiAgICAgICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcmV0ID0gdXNlQ2FsbGJhY2soKGN1cnJlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgbGhzKTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcclxuICAgICAgICAgICAgfSwgW2xocywgcmhzXSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vKlxyXG5mdW5jdGlvbiB0eXBldGVzdDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SFRNTElucHV0RWxlbWVudD4+KHByb3BzOiBQKSB7XHJcblxyXG4gICAgY29uc3QgcmVmOiBSZWZPYmplY3Q8SFRNTElucHV0RWxlbWVudD4gPSB1c2VSZWY8SFRNTElucHV0RWxlbWVudD4obnVsbCk7XHJcblxyXG4gICAgZnVuY3Rpb24gYWNjZXB0c1JlZihyZWY6IFJlZjxhbnk+KSB7IH1cclxuICAgIGZ1bmN0aW9uIGFjY2VwdHNPcHRpb25hbFJlZihyZWY6IFJlZjxhbnk+IHwgdW5kZWZpbmVkKSB7IH1cclxuXHJcbiAgICBjb25zdCBjID0gW1xyXG4gICAgICAgIHVzZU1lcmdlZFJlZnM8SFRNTElucHV0RWxlbWVudD4oKSh1bmRlZmluZWQsIHVuZGVmaW5lZCksXHJcbiAgICAgICAgdXNlTWVyZ2VkUmVmczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB1bmRlZmluZWQpLFxyXG4gICAgICAgIHVzZU1lcmdlZFJlZnM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgdW5kZWZpbmVkKSxcclxuICAgICAgICB1c2VNZXJnZWRSZWZzPEhUTUxJbnB1dEVsZW1lbnQ+KCkodW5kZWZpbmVkLCBwcm9wcyksXHJcbiAgICAgICAgdXNlTWVyZ2VkUmVmczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwcm9wcyksXHJcbiAgICAgICAgdXNlTWVyZ2VkUmVmczxIVE1MSW5wdXRFbGVtZW50PigpKHsgcmVmIH0sIHByb3BzKSxcclxuICAgICAgICB1c2VNZXJnZWRSZWZzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoeyByZWYgfSwgeyByZWY6IHVuZGVmaW5lZCB9KSxcclxuICAgICAgICB1c2VNZXJnZWRSZWZzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoeyByZWY6IHVuZGVmaW5lZCB9LCB7IHJlZiB9KSxcclxuICAgICAgICB1c2VNZXJnZWRSZWZzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoeyByZWYgfSwgeyByZWYgfSksXHJcbiAgICBdIGFzIGNvbnN0O1xyXG5cclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBhY2NlcHRzUmVmKGNbMF0pO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIGFjY2VwdHNSZWYoY1sxXSk7XHJcblxyXG4gICAgYWNjZXB0c09wdGlvbmFsUmVmKGNbMl0pO1xyXG4gICAgYWNjZXB0c09wdGlvbmFsUmVmKGNbM10pO1xyXG4gICAgYWNjZXB0c09wdGlvbmFsUmVmKGNbNF0pO1xyXG5cclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yIFRPRE9cclxuICAgIGFjY2VwdHNSZWYoY1s1XSk7XHJcbiAgICBhY2NlcHRzUmVmKGNbNl0pO1xyXG4gICAgYWNjZXB0c1JlZihjWzddKTtcclxuICAgIGFjY2VwdHNSZWYoY1s4XSk7XHJcbn1cclxuKi9cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW1lcmdlZC1yZWZzLmpzLm1hcCIsIi8qKlxyXG4gKiBNZXJnZXMgdHdvIHN0eWxlIG9iamVjdHMsIHJldHVybmluZyB0aGUgcmVzdWx0LlxyXG4gKlxyXG4gKiBAcGFyYW0gc3R5bGUgVGhlIHVzZXItZ2l2ZW4gc3R5bGUgcHJvcCBmb3IgdGhpcyBjb21wb25lbnRcclxuICogQHBhcmFtIG9iaiBUaGUgQ1NTIHByb3BlcnRpZXMgeW91IHdhbnQgYWRkZWQgdG8gdGhlIHVzZXItZ2l2ZW4gc3R5bGVcclxuICogQHJldHVybnMgQSBDU1Mgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgb2YgYm90aCBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFN0eWxlcyhsaHMsIHJocykge1xyXG4gICAgLy8gRWFzeSBjYXNlLCB3aGVuIHRoZXJlIGFyZSBubyBzdHlsZXMgdG8gbWVyZ2UgcmV0dXJuIG5vdGhpbmcuXHJcbiAgICBpZiAoIWxocz8uc3R5bGUgJiYgIXJocz8uc3R5bGUpXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIGlmICh0eXBlb2YgbGhzICE9IHR5cGVvZiByaHMpIHtcclxuICAgICAgICAvLyBFYXN5IGNhc2VzLCB3aGVuIG9uZSBpcyBudWxsIGFuZCB0aGUgb3RoZXIgaXNuJ3QuXHJcbiAgICAgICAgaWYgKGxocz8uc3R5bGUgJiYgIXJocz8uc3R5bGUpXHJcbiAgICAgICAgICAgIHJldHVybiBsaHMuc3R5bGU7XHJcbiAgICAgICAgaWYgKCFsaHM/LnN0eWxlICYmIHJocz8uc3R5bGUpXHJcbiAgICAgICAgICAgIHJldHVybiByaHMuc3R5bGU7XHJcbiAgICAgICAgLy8gVGhleSdyZSBib3RoIG5vbi1udWxsIGJ1dCBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIHR5cGUgdG8gYW4gb2JqZWN0IGJhZyB0eXBlIGFuZCBydW4gaXQgYWdhaW4uXHJcbiAgICAgICAgaWYgKGxocz8uc3R5bGUgJiYgcmhzPy5zdHlsZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxocz8uc3R5bGUgPT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRTdHlsZXMoeyBzdHlsZTogT2JqZWN0LmZyb21FbnRyaWVzKGxocz8uc3R5bGUuc3BsaXQoXCI7XCIpLm1hcChzdGF0ZW1lbnQgPT4gc3RhdGVtZW50LnNwbGl0KFwiOlwiKSkpIH0sIHJocyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyhsaHM/LnN0eWxlLCB7IHN0eWxlOiBPYmplY3QuZnJvbUVudHJpZXMobGhzPy5zdHlsZS5zcGxpdChcIjtcIikubWFwKHN0YXRlbWVudCA9PiBzdGF0ZW1lbnQuc3BsaXQoXCI6XCIpKSkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIExvZ2ljPz8/XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vIFRoZXkncmUgYm90aCBzdHJpbmdzLCBqdXN0IGNvbmNhdGVuYXRlIHRoZW0uXHJcbiAgICBpZiAodHlwZW9mIGxocz8uc3R5bGUgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHJldHVybiBgJHtsaHMuc3R5bGV9OyR7cmhzPy5zdHlsZSA/PyBcIlwifWA7XHJcbiAgICB9XHJcbiAgICAvLyBUaGV5J3JlIGJvdGggb2JqZWN0cywganVzdCBtZXJnZSB0aGVtLlxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi4obGhzPy5zdHlsZSA/PyB7fSksXHJcbiAgICAgICAgLi4uKHJocz8uc3R5bGUgPz8ge30pXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1tZXJnZWQtc3R5bGVzLmpzLm1hcCIsImltcG9ydCB7IHVzZU1lcmdlZENoaWxkcmVuIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1jaGlsZHJlblwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRDbGFzc2VzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1jbGFzc2VzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFJlZnMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXJlZnNcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkU3R5bGVzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1zdHlsZXNcIjtcclxubGV0IGxvZyA9IChzdHIpID0+IHsgZGVidWdnZXI7IC8qIEludGVudGlvbmFsICovIH07XHJcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVMb2dnaW5nUHJvcENvbmZsaWN0cyhsb2cyKSB7XHJcbiAgICBsb2cgPSBsb2cyO1xyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZW0gYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICpcclxuICogVGhlIGhvb2sgaXMgYXdhcmUgb2YgYW5kIGNhbiBpbnRlbGxpZ2VudGx5IG1lcmdlIGBjbGFzc05hbWVgLCBgY2xhc3NgLCBgc3R5bGVgLCBgcmVmYCwgYW5kIGFsbCBldmVudCBoYW5kbGVycy5cclxuICogQHBhcmFtIGxoczJcclxuICogQHBhcmFtIHJoczJcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRQcm9wcygpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobGhzMiwgcmhzMikge1xyXG4gICAgICAgIC8vIEZpcnN0LCBwdXQgaW4gYWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIGVhc3kgdG8gcmVhc29uIGFib3V0XHJcbiAgICAgICAgLy8gYW5kIGFsbCBsaHMgcHJvcHMuIFdlJ3JlIGdvaW5nIHRvIG1lcmdlIGluIHJocyBqdXN0IGFmdGVyLlxyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IGxoc0NoaWxkcmVuLCBjbGFzczogbGhzQ2xhc3MsIGNsYXNzTmFtZTogbGhzQ2xhc3NOYW1lLCBzdHlsZTogbGhzU3R5bGUsIHJlZjogbGhzUmVmLCAuLi5saHMgfSA9IGxoczI7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogcmhzQ2hpbGRyZW4sIGNsYXNzOiByaHNDbGFzcywgY2xhc3NOYW1lOiByaHNDbGFzc05hbWUsIHN0eWxlOiByaHNTdHlsZSwgcmVmOiByaHNSZWYsIC4uLnJocyB9ID0gcmhzMjtcclxuICAgICAgICBsZXQgcmV0ID0ge1xyXG4gICAgICAgICAgICAuLi5saHMsXHJcbiAgICAgICAgICAgIHJlZjogdXNlTWVyZ2VkUmVmcygpKGxoczIsIHJoczIpLFxyXG4gICAgICAgICAgICBzdHlsZTogdXNlTWVyZ2VkU3R5bGVzKGxoczIsIHJoczIpLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IHVzZU1lcmdlZENsYXNzZXMobGhzMiwgcmhzMiksXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiB1c2VNZXJnZWRDaGlsZHJlbihsaHMyLCByaHMyKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHJldC5yZWYgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgZGVsZXRlIHJldC5yZWY7XHJcbiAgICAgICAgaWYgKHJldC5zdHlsZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBkZWxldGUgcmV0LnN0eWxlO1xyXG4gICAgICAgIGlmIChyZXQuY2xhc3NOYW1lID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGRlbGV0ZSByZXQuY2xhc3NOYW1lO1xyXG4gICAgICAgIGlmIChyZXQuY2hpbGRyZW4gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgZGVsZXRlIHJldC5jaGlsZHJlbjtcclxuICAgICAgICAvLyBOb3csIGRvICpldmVyeXRoaW5nKiBlbHNlXHJcbiAgICAgICAgLy8gTWVyZ2UgZXZlcnkgcmVtYWluaW5nIGV4aXN0aW5nIGVudHJ5IGluIGxocyB3aXRoIHdoYXQgd2UndmUgYWxyZWFkeSBwdXQgaW4gcmV0LlxyXG4gICAgICAgIC8vY29uc3QgbGhzRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGxocykgYXMgW2tleW9mIFQsIFRba2V5b2YgVF1dW107XHJcbiAgICAgICAgY29uc3QgcmhzRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHJocyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBbcmhzS2V5LCByaHNWYWx1ZV0gb2YgcmhzRW50cmllcykge1xyXG4gICAgICAgICAgICBjb25zdCBsaHNWYWx1ZSA9IGxoc1tyaHNLZXldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgbWVyZ2VkIChvciBvbmUncyBhIGZ1bmN0aW9uIGFuZCB0aGUgb3RoZXIncyBudWxsKS5cclxuICAgICAgICAgICAgICAgIC8vIE5vdCBhbiAqZWFzeSogY2FzZSwgYnV0IGEgd2VsbC1kZWZpbmVkIG9uZS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlRnVuY3Rpb25zKGxoc1ZhbHVlLCByaHNWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IG1lcmdlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XHJcbiAgICAgICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbCAmJiByaHNWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJoc1ZhbHVlID09PSBudWxsICYmIGxoc1ZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IGxoc1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IGxoc1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgcmVhbGx5IGlkZWFsIHRob3VnaC5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVnaC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nPy4oYENvdWxkIG5vdCBtZXJnZSBpbmNvbXBhdGlibGUgcHJvcCBcIiR7cmhzS2V5fVwiICh0eXBlOiAke3R5cGVvZiByaHNWYWx1ZX0sIHZhbHVlczogWyR7bGhzVmFsdWV9LCAke3Joc1ZhbHVlfV0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUZ1bmN0aW9ucyhsaHMsIHJocykge1xyXG4gICAgaWYgKCFsaHMpXHJcbiAgICAgICAgcmV0dXJuIHJocztcclxuICAgIGlmICghcmhzKVxyXG4gICAgICAgIHJldHVybiBsaHM7XHJcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBsZXQgbHYgPSBsaHM/LiguLi5hcmdzKTtcclxuICAgICAgICBsZXQgcnYgPSByaHM/LiguLi5hcmdzKTtcclxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2VuZXJpY0dldFRlc3QoKSB7XHJcbiAgICBjb25zdCB0MSA9IG51bGw7XHJcbiAgICBjb25zdCB0MiA9IG51bGw7XHJcbiAgICBjb25zdCB0MyA9IG51bGw7XHJcbiAgICBpZiAodDMuaWQgPT0gbnVsbCkge1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdDMuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgfVxyXG59XHJcbi8qXHJcbmZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG5cclxuICAgIGNvbnN0IGlkMDogR2VuZXJpY0dldDx7fSwgXCJpZFwiLCBzdHJpbmc+ID0gXCJcIjtcclxuICAgIGNvbnN0IGlkMzogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ0OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDU6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNjogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgLy9jb25zdCBpZDI6IFppcFNpbmdsZTxzdHJpbmcgfCB1bmRlZmluZWQsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDE6IFppcE9iamVjdDx7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0geyBpZDogdW5kZWZpbmVkIH07XHJcblxyXG4gICAgdHlwZSBNMSA9IEdlbmVyaWNHZXQ8UCwgXCJzdHlsZVwiLCBzdHJpbmc+O1xyXG4gICAgdHlwZSBNMiA9IEdlbmVyaWNHZXQ8e30sIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIGNvbnN0IG0xOiBNMSA9IFwiXCI7XHJcbiAgICBjb25zdCBtMjogTTEgPSB1bmRlZmluZWQ7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xyXG4gICAgY29uc3QgbTM6IE0xID0gMDtcclxuXHJcbiAgICBjb25zdCBtNDogTTIgPSBcIlwiO1xyXG4gICAgY29uc3QgbTU6IE0yID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG02OiBNMiA9IDA7XHJcblxyXG4gICAgY29uc3QgcDE6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDI6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDM6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNDogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHt9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHt9KTtcclxuICAgIGNvbnN0IHA1ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywge30pO1xyXG4gICAgY29uc3QgcDYgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNyA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IFwic3RyaW5nXCIgfSk7XHJcblxyXG5cclxuICAgIHAxLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwMi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcDMuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHA0LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHA1LmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDcuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNy5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDUuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA3LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBpdCB3b3JrcyByZWN1cnNpdmVseVxyXG4gICAgY29uc3QgcjFhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDEpO1xyXG4gICAgY29uc3QgcjFiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDEpO1xyXG4gICAgY29uc3QgcjJhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDIpO1xyXG4gICAgY29uc3QgcjJiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDIpO1xyXG4gICAgY29uc3QgcjNhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDMpO1xyXG4gICAgY29uc3QgcjNiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDMpO1xyXG4gICAgY29uc3QgcjRhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDQpO1xyXG4gICAgY29uc3QgcjRiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDQpO1xyXG4gICAgY29uc3QgcjVhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDUpO1xyXG4gICAgY29uc3QgcjViID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDUpO1xyXG4gICAgY29uc3QgcjZhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDYpO1xyXG4gICAgY29uc3QgcjZiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDYpO1xyXG4gICAgY29uc3QgcjdhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDcpO1xyXG4gICAgY29uc3QgcjdiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDcpO1xyXG5cclxuXHJcbiAgICByMWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIxYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcjNhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByM2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHI0YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjRiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHI1YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjViLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI2Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByN2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNWEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjViLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI2YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmIuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjdhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3Yi5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjVhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjViLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG59XHJcbmZ1bmN0aW9uIGFjY2VwdHNOZXZlcihuOiBuZXZlcikge31cclxuKi8gXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1tZXJnZWQtcHJvcHMuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlU3RhdGUgYXMgdXNlU3RhdGVQIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG4vKipcclxuICogU2xpZ2h0bHkgZW5oYW5jZWQgdmVyc2lvbiBvZiBgdXNlU3RhdGVgIHRoYXQgaW5jbHVkZXMgYSBnZXR0ZXIgdGhhdCByZW1haW5zIGNvbnN0YW50XHJcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cclxuICpcclxuICogQHBhcmFtIGluaXRpYWxTdGF0ZVxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xyXG4gICAgLy8gV2Uga2VlcCBib3RoXHJcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlUChpbml0aWFsU3RhdGUpO1xyXG4gICAgY29uc3QgcmVmID0gdXNlUmVmKHN0YXRlKTtcclxuICAgIC8vIEhpamFjayB0aGUgbm9ybWFsIHNldHRlciBmdW5jdGlvbiBcclxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxyXG4gICAgY29uc3Qgc2V0ID0gdXNlQ2FsbGJhY2soKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIGxldCBjYWxsYmFjayA9IHZhbHVlO1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShwcmV2VmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHRWYWx1ZSA9IGNhbGxiYWNrKHByZXZWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgc2V0U3RhdGUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IGdldCA9ICgpID0+IHsgcmV0dXJuIHJlZi5jdXJyZW50OyB9O1xyXG4gICAgY29uc29sZS5hc3NlcnQocmVmLmN1cnJlbnQgPT09IHN0YXRlKTtcclxuICAgIHJldHVybiBbc3RhdGUsIHNldCwgZ2V0XTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2Utc3RhdGUuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG4vKipcclxuICogQWxsb3dzIGFjY2Vzc2luZyB0aGUgZWxlbWVudCBhIHJlZiByZWZlcmVuY2VzIGFzIHNvb24gYXMgaXQgZG9lcyBzby5cclxuICogKlRoaXMgaG9vayBpdHNlbGYgcmV0dXJucyBhIGhvb2sqLS11c2VSZWZFbGVtZW50UHJvcHMgbW9kaWZpZXMgdGhlIHByb3BzIHRoYXQgeW91IHdlcmUgZ29pbmcgdG8gcGFzcyB0byBhbiBIVE1MRWxlbWVudCxcclxuICogYWRkaW5nIGEgUmVmQ2FsbGJhY2sgYW5kIG1lcmdpbmcgaXQgd2l0aCBhbnkgZXhpc3RpbmcgcmVmIHRoYXQgZXhpc3RlZCBvbiB0aGUgcHJvcHMuXHJcbiAqXHJcbiAqIERvbid0IGZvcmdldCB0byBwcm92aWRlIHRoZSBFbGVtZW50IGFzIHRoZSB0eXBlIGFyZ3VtZW50IVxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudCwgYW5kIHRoZSBzdWItaG9vayB0aGF0IG1ha2VzIGl0IHJldHJpZXZhYmxlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnQoKSB7XHJcbiAgICAvLyBMZXQgdXMgc3RvcmUgdGhlIGFjdHVhbCAocmVmZXJlbmNlIHRvKSB0aGUgZWxlbWVudCB3ZSBjYXB0dXJlXHJcbiAgICBjb25zdCBbZWxlbWVudCwgc2V0RWxlbWVudCwgZ2V0RWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIC8vIENyZWF0ZSBhIFJlZkNhbGxiYWNrIHRoYXQncyBmaXJlZCB3aGVuIG1vdW50ZWQgXHJcbiAgICAvLyBhbmQgdGhhdCBub3RpZmllcyB1cyBvZiBvdXIgZWxlbWVudCB3aGVuIHdlIGhhdmUgaXRcclxuICAgIGNvbnN0IG15UmVmID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcclxuICAgICAgICBpZiAoZSlcclxuICAgICAgICAgICAgc2V0RWxlbWVudCgoKSA9PiBlKTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHVzZVJlZkVsZW1lbnRQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wcykgPT4gdXNlTWVyZ2VkUHJvcHMoKSh7IHJlZjogbXlSZWYgfSwgcHJvcHMpLCBbXSk7XHJcbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcclxuICAgIC8vIHRoZSBwcm9wcyBhbmQgYWxsb3dzIHVzIHRvIGFjdHVhbGx5IGZpbmQgdGhlIGVsZW1lbnRcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlUmVmRWxlbWVudFByb3BzLFxyXG4gICAgICAgIGVsZW1lbnQsXHJcbiAgICAgICAgZ2V0RWxlbWVudFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0ZXN0KCkge1xyXG4gICAgZnVuY3Rpb24gZm9vKHByb3BzKSB7XHJcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgICAgICBjb25zdCBwMSA9IHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgaWYgKHAxLnN0eWxlID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcDEuc3R5bGUgPT09IFwic3RyaW5nXCIpIHsgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwMS5zdHlsZT8uYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtcmVmLWVsZW1lbnQuanMubWFwIiwiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VFbGVtZW50U2l6ZSh7IG9ic2VydmVCb3ggfSA9IHt9KSB7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgY29uc3QgW3NpemUsIHNldFNpemUsIGdldFNpemVdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50V2lkdGgsIHNjcm9sbFdpZHRoLCBvZmZzZXRXaWR0aCwgY2xpZW50SGVpZ2h0LCBzY3JvbGxIZWlnaHQsIG9mZnNldEhlaWdodCwgY2xpZW50TGVmdCwgc2Nyb2xsTGVmdCwgb2Zmc2V0TGVmdCwgY2xpZW50VG9wLCBzY3JvbGxUb3AsIG9mZnNldFRvcCB9ID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHNldFNpemUoeyBjbGllbnRXaWR0aCwgc2Nyb2xsV2lkdGgsIG9mZnNldFdpZHRoLCBjbGllbnRIZWlnaHQsIHNjcm9sbEhlaWdodCwgb2Zmc2V0SGVpZ2h0LCBjbGllbnRMZWZ0LCBzY3JvbGxMZWZ0LCBvZmZzZXRMZWZ0LCBjbGllbnRUb3AsIHNjcm9sbFRvcCwgb2Zmc2V0VG9wIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoIShcIlJlc2l6ZU9ic2VydmVyXCIgaW4gd2luZG93KSkge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVVcGRhdGUsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVVwZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4geyBoYW5kbGVVcGRhdGUoKTsgfSk7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHsgYm94OiBvYnNlcnZlQm94IH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtlbGVtZW50LCBvYnNlcnZlQm94XSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVsZW1lbnQsXHJcbiAgICAgICAgZWxlbWVudFNpemU6IHNpemUsXHJcbiAgICAgICAgZ2V0RWxlbWVudFNpemU6IGdldFNpemUsXHJcbiAgICAgICAgdXNlRWxlbWVudFNpemVQcm9wczogdXNlUmVmRWxlbWVudFByb3BzXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1lbGVtZW50LXNpemUuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcclxuICAgIHJldHVybiAoc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyKDEpKTtcclxufVxyXG4vKipcclxuICogSW5zcGVjdHMgdGhlIGVsZW1lbnQncyBzdHlsZSBhbmQgZGV0ZXJtaW5lcyB0aGUgbG9naWNhbCBkaXJlY3Rpb24gdGhhdCB0ZXh0IGZsb3dzLlxyXG4gKlxyXG4gKiBDZXJ0YWluIENTUyBwcm9wZXJ0aWVzLCBsaWtlIGBibG9jay1zaXplYCwgcmVzcGVjdCB0aGUgY3VycmVudCB3cml0aW5nIG1vZGUgYW5kIHRleHQgZGlyZWN0aW9uLlxyXG4gKiBCdXQgYHRyYW5zZm9ybWAsIGBjbGlwYCwgZXRjLiBkb24ndC5cclxuICpcclxuICogVGhpcyBpcyBwcm92aWRlZCBzbyB0aGF0IENTUyBwcm9wZXJ0aWVzIGNhbiBjb25zaXN0ZW50bHkgdXNlIHRob3NlIGxvZ2ljYWwgcHJvcGVydGllcy5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3Mtd3JpdGluZy1tb2Rlcy8jbG9naWNhbC10by1waHlzaWNhbFxyXG4gKlxyXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcclxuICogKiBgZ2V0TG9naWNhbERpcmVjdGlvbmA6IHJldHJpZXZlcyBhIGBMb2dpY2FsRGlyZWN0aW9uSW5mb2AgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50LiAoRnVuY3Rpb24gaXMgY29uc3RhbnQgYmV0d2VlbiByZW5kZXJzKVxyXG4gKiAqIGBjb252ZXJ0RWxlbWVudFNpemVgOiBXaGVuIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgdXNlRWxlbWVudFNpemVgLCBhbGxvd3MgeW91IHRvIHJldHJpZXZlIHRoZSBsb2dpY2FsIHNpemUgb2YgYW4gZWxlbWVudCBpbnN0ZWFkIG9mIHRoZSBwaHlzaWNhbCBzaXplLlxyXG4gKiAqIGBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb25gOiBCYXNlZCBvbiB0aGUgY3VycmVudCBkaXJlY3Rpb24sIGNvbnZlcnRzIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIiB0byBcImlubGluZVwiIG9yIFwiYmxvY2tcIi5cclxuICogKiBgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbmA6ICBCYXNlZCBvbiB0aGUgY3VycmVudCBkaXJlY3Rpb24sIGNvbnZlcnRzIFwiaW5saW5lXCIgb3IgXCJibG9ja1wiIHRvIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2dpY2FsRGlyZWN0aW9uKGVsZW1lbnQpIHtcclxuICAgIGNvbnN0IFt3cml0aW5nTW9kZSwgc2V0V3JpdGluZ01vZGVdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBbZGlyZWN0aW9uLCBzZXREaXJlY3Rpb25dID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBbdGV4dE9yaWVudGF0aW9uLCBzZXRUZXh0T3JpZW50YXRpb25dID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCB3cml0aW5nTW9kZVJlZiA9IHVzZVJlZih3cml0aW5nTW9kZSk7XHJcbiAgICBjb25zdCBkaXJlY3Rpb25SZWYgPSB1c2VSZWYoZGlyZWN0aW9uKTtcclxuICAgIGNvbnN0IHRleHRPcmllbnRhdGlvblJlZiA9IHVzZVJlZih0ZXh0T3JpZW50YXRpb24pO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgd3JpdGluZ01vZGVSZWYuY3VycmVudCA9IHdyaXRpbmdNb2RlOyB9LCBbd3JpdGluZ01vZGVdKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IGRpcmVjdGlvblJlZi5jdXJyZW50ID0gZGlyZWN0aW9uOyB9LCBbZGlyZWN0aW9uXSk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyB0ZXh0T3JpZW50YXRpb25SZWYuY3VycmVudCA9IHRleHRPcmllbnRhdGlvbjsgfSwgW3RleHRPcmllbnRhdGlvbl0pO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCB3ID0gY29tcHV0ZWRTdHlsZXMud3JpdGluZ01vZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBjb21wdXRlZFN0eWxlcy50ZXh0T3JpZW50YXRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IGQgPSBjb21wdXRlZFN0eWxlcy5kaXJlY3Rpb247XHJcbiAgICAgICAgICAgIHNldFdyaXRpbmdNb2RlKHcgfHwgXCJob3Jpem9udGFsLXRiXCIpO1xyXG4gICAgICAgICAgICBzZXREaXJlY3Rpb24oZCB8fCBcInJ0bFwiKTtcclxuICAgICAgICAgICAgc2V0VGV4dE9yaWVudGF0aW9uKHQgfHwgXCJtaXhlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGdldExvZ2ljYWxEaXJlY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgbGV0IHdyaXRpbmdNb2RlID0gd3JpdGluZ01vZGVSZWYuY3VycmVudDtcclxuICAgICAgICBsZXQgZGlyZWN0aW9uID0gZGlyZWN0aW9uUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgbGV0IHRleHRPcmllbnRhdGlvbiA9IHRleHRPcmllbnRhdGlvblJlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmICghd3JpdGluZ01vZGUgfHwgIWRpcmVjdGlvbiB8fCAhdGV4dE9yaWVudGF0aW9uKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBpZiAodGV4dE9yaWVudGF0aW9uID09IFwidXByaWdodFwiKVxyXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBcImx0clwiO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLldyaXRpbmdNb2Rlc1t3cml0aW5nTW9kZSA/PyBcImhvcml6b250YWwtdGJcIl1bZGlyZWN0aW9uID8/IFwibHRyXCJdXHJcbiAgICAgICAgfTtcclxuICAgIH0sIFt3cml0aW5nTW9kZVJlZiwgZGlyZWN0aW9uUmVmLCB0ZXh0T3JpZW50YXRpb25SZWZdKTtcclxuICAgIGNvbnN0IGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbiA9IHVzZUNhbGxiYWNrKChlbGVtZW50T3JpZW50YXRpb24sIGRpcmVjdGlvbikgPT4ge1xyXG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbigpO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24/LmlubGluZU9yaWVudGF0aW9uID09PSBlbGVtZW50T3JpZW50YXRpb24pXHJcbiAgICAgICAgICAgIHJldHVybiBcImlubGluZVwiO1xyXG4gICAgICAgIHJldHVybiBcImJsb2NrXCI7XHJcbiAgICB9LCBbZ2V0TG9naWNhbERpcmVjdGlvbl0pO1xyXG4gICAgY29uc3QgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbiA9IHVzZUNhbGxiYWNrKChlbGVtZW50T3JpZW50YXRpb24sIGRpcmVjdGlvbikgPT4ge1xyXG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbigpO1xyXG4gICAgICAgIGlmIChlbGVtZW50T3JpZW50YXRpb24gPT0gXCJpbmxpbmVcIikge1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PSBcImhvcml6b250YWxcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImhvcml6b250YWxcIjtcclxuICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24/LmJsb2NrT3JpZW50YXRpb24gPT0gXCJ2ZXJ0aWNhbFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcclxuICAgICAgICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtnZXRMb2dpY2FsRGlyZWN0aW9uXSk7XHJcbiAgICBjb25zdCBjb252ZXJ0RWxlbWVudFNpemUgPSB1c2VDYWxsYmFjaygoZWxlbWVudFNpemUsIGRpcmVjdGlvbikgPT4ge1xyXG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbigpO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgeyBpbmxpbmVTaXplLCBibG9ja1NpemUsIGlubGluZURpcmVjdGlvbiwgYmxvY2tEaXJlY3Rpb24gfSA9IGRpcmVjdGlvbjtcclxuICAgICAgICAgICAgLy8gU2l6ZSBpcyByZWxhdGl2ZWx5IHNpbXBsZVxyXG4gICAgICAgICAgICBsZXQgY2xpZW50SW5saW5lU2l6ZSA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoaW5saW5lU2l6ZSl9YF07XHJcbiAgICAgICAgICAgIGxldCBjbGllbnRCbG9ja1NpemUgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGJsb2NrU2l6ZSl9YF07XHJcbiAgICAgICAgICAgIGxldCBvZmZzZXRJbmxpbmVTaXplID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShpbmxpbmVTaXplKX1gXTtcclxuICAgICAgICAgICAgbGV0IG9mZnNldEJsb2NrU2l6ZSA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoYmxvY2tTaXplKX1gXTtcclxuICAgICAgICAgICAgbGV0IHNjcm9sbElubGluZVNpemUgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGlubGluZVNpemUpfWBdO1xyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsQmxvY2tTaXplID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShibG9ja1NpemUpfWBdO1xyXG4gICAgICAgICAgICAvLyBQb3NpdGlvbiByZXF1aXJlcyB1cyB0byBzb21ldGltZXMgdXNlIG9uZSBwcm9wZXJ0eSAobGlrZSBgbGVmdGApXHJcbiAgICAgICAgICAgIC8vIG9yIHNvbWV0aW1lcyB0d28gKGxpa2UgYGxlZnRgICsgYHdpZHRoYClcclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UGh5c2ljYWxMZWZ0VG9wKGRpcikgeyBpZiAoZGlyID09PSBcImx0clwiIHx8IGRpciA9PSBcInJ0bFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibGVmdFwiOyByZXR1cm4gXCJ0b3BcIjsgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRQaHlzaWNhbFJpZ2h0Qm90dG9tKGRpcikgeyBpZiAoZGlyID09PSBcInJ0bFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwid2lkdGhcIjsgaWYgKGRpciA9PT0gXCJidHRcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImhlaWdodFwiOyByZXR1cm4gbnVsbDsgfVxyXG4gICAgICAgICAgICBjb25zdCBmMSA9IGdldFBoeXNpY2FsTGVmdFRvcChpbmxpbmVEaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBmMiA9IGdldFBoeXNpY2FsUmlnaHRCb3R0b20oaW5saW5lRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgZjMgPSBnZXRQaHlzaWNhbExlZnRUb3AoYmxvY2tEaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBmNCA9IGdldFBoeXNpY2FsUmlnaHRCb3R0b20oYmxvY2tEaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBsZXQgY2xpZW50SW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGYxKX1gXSArICghZjIgPyAwIDogZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmMil9YF0pO1xyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsSW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGYxKX1gXSArICghZjIgPyAwIDogZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMil9YF0pO1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0SW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYxKX1gXSArICghZjIgPyAwIDogZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMil9YF0pO1xyXG4gICAgICAgICAgICBsZXQgY2xpZW50QmxvY2tJbnNldCA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjMpfWBdICsgKCFmNCA/IDAgOiBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGY0KX1gXSk7XHJcbiAgICAgICAgICAgIGxldCBzY3JvbGxCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMyl9YF0gKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjQpfWBdKTtcclxuICAgICAgICAgICAgbGV0IG9mZnNldEJsb2NrSW5zZXQgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYzKX1gXSArICghZjQgPyAwIDogZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmNCl9YF0pO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50SW5saW5lU2l6ZSxcclxuICAgICAgICAgICAgICAgIHNjcm9sbElubGluZVNpemUsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRJbmxpbmVTaXplLFxyXG4gICAgICAgICAgICAgICAgY2xpZW50QmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsQmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0QmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgY2xpZW50SW5saW5lSW5zZXQsXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxJbmxpbmVJbnNldCxcclxuICAgICAgICAgICAgICAgIG9mZnNldElubGluZUluc2V0LFxyXG4gICAgICAgICAgICAgICAgY2xpZW50QmxvY2tJbnNldCxcclxuICAgICAgICAgICAgICAgIHNjcm9sbEJsb2NrSW5zZXQsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRCbG9ja0luc2V0LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sIFtnZXRMb2dpY2FsRGlyZWN0aW9uXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldExvZ2ljYWxEaXJlY3Rpb24sXHJcbiAgICAgICAgY29udmVydEVsZW1lbnRTaXplLFxyXG4gICAgICAgIGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbixcclxuICAgICAgICBjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uXHJcbiAgICB9O1xyXG59XHJcbjtcclxuY29uc3QgSG9yaXpvbnRhbFRiTHRyID0ge1xyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcImx0clwiLFxyXG4gICAgYmxvY2tEaXJlY3Rpb246IFwidHRiXCIsXHJcbiAgICBpbmxpbmVPcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXHJcbiAgICBibG9ja09yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXHJcbiAgICBpbmxpbmVTaXplOiBcIndpZHRoXCIsXHJcbiAgICBibG9ja1NpemU6IFwiaGVpZ2h0XCIsXHJcbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwibHRyXCIsXHJcbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFwidHRiXCJcclxufTtcclxuY29uc3QgSG9yaXpvbnRhbFRiUnRsID0ge1xyXG4gICAgLi4uSG9yaXpvbnRhbFRiTHRyLFxyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInJ0bFwiLFxyXG59O1xyXG5jb25zdCBWZXJ0aWNhbFJsTHRyID0ge1xyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiLFxyXG4gICAgYmxvY2tEaXJlY3Rpb246IFwicnRsXCIsXHJcbiAgICBpbmxpbmVPcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgYmxvY2tPcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXHJcbiAgICBpbmxpbmVTaXplOiBcImhlaWdodFwiLFxyXG4gICAgYmxvY2tTaXplOiBcIndpZHRoXCIsXHJcbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwidHRiXCIsXHJcbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFwicnRsXCJcclxufTtcclxuY29uc3QgVmVydGljYWxSbFJ0bCA9IHtcclxuICAgIC4uLlZlcnRpY2FsUmxMdHIsXHJcbiAgICBpbmxpbmVEaXJlY3Rpb246IFwiYnR0XCJcclxufTtcclxuY29uc3QgU2lkZXdheXNSbEx0ciA9IHsgLi4uVmVydGljYWxSbEx0ciB9O1xyXG5jb25zdCBTaWRld2F5c1JsUnRsID0geyAuLi5WZXJ0aWNhbFJsUnRsIH07XHJcbmNvbnN0IFZlcnRpY2FsTHJMdHIgPSB7XHJcbiAgICAuLi5WZXJ0aWNhbFJsTHRyLFxyXG4gICAgYmxvY2tEaXJlY3Rpb246IFwibHRyXCIsXHJcbn07XHJcbmNvbnN0IFZlcnRpY2FsTHJSdGwgPSB7XHJcbiAgICAuLi5WZXJ0aWNhbFJsUnRsLFxyXG4gICAgYmxvY2tEaXJlY3Rpb246IFwibHRyXCIsXHJcbn07XHJcbmNvbnN0IFNpZGV3YXlzTHRMdHIgPSB7XHJcbiAgICAuLi5WZXJ0aWNhbExyTHRyLFxyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcImJ0dFwiLFxyXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcImJ0dFwiLFxyXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcImx0clwiXHJcbn07XHJcbmNvbnN0IFNpZGV3YXlzTHRSdGwgPSB7XHJcbiAgICAuLi5TaWRld2F5c0x0THRyLFxyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiXHJcbn07XHJcbmNvbnN0IEhvcml6b250YWxUYiA9IHtcclxuICAgIGx0cjogSG9yaXpvbnRhbFRiTHRyLFxyXG4gICAgcnRsOiBIb3Jpem9udGFsVGJSdGxcclxufTtcclxuY29uc3QgVmVydGljYWxSbCA9IHtcclxuICAgIGx0cjogVmVydGljYWxSbEx0cixcclxuICAgIHJ0bDogVmVydGljYWxSbFJ0bFxyXG59O1xyXG5jb25zdCBWZXJ0aWNhbExyID0ge1xyXG4gICAgbHRyOiBWZXJ0aWNhbExyTHRyLFxyXG4gICAgcnRsOiBWZXJ0aWNhbExyUnRsXHJcbn07XHJcbmNvbnN0IFNpZGV3YXlzUmwgPSB7XHJcbiAgICBsdHI6IFNpZGV3YXlzUmxMdHIsXHJcbiAgICBydGw6IFNpZGV3YXlzUmxSdGxcclxufTtcclxuY29uc3QgU2lkZXdheXNMciA9IHtcclxuICAgIGx0cjogU2lkZXdheXNMdEx0cixcclxuICAgIHJ0bDogU2lkZXdheXNMdFJ0bFxyXG59O1xyXG5jb25zdCBXcml0aW5nTW9kZXMgPSB7XHJcbiAgICBcImhvcml6b250YWwtdGJcIjogSG9yaXpvbnRhbFRiLFxyXG4gICAgXCJ2ZXJ0aWNhbC1sclwiOiBWZXJ0aWNhbExyLFxyXG4gICAgXCJ2ZXJ0aWNhbC1ybFwiOiBWZXJ0aWNhbFJsLFxyXG4gICAgXCJzaWRld2F5cy1sclwiOiBTaWRld2F5c0xyLFxyXG4gICAgXCJzaWRld2F5cy1ybFwiOiBTaWRld2F5c1JsXHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1sb2dpY2FsLWRpcmVjdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyB1c2VSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG4vKipcclxuICogR2l2ZW4gYW4gaW5wdXQgdmFsdWUsIHJldHVybnMgYSBjb25zdGFudCBnZXR0ZXIgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZFxyXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXHJcbiAqXHJcbiAqIFVzZSB3aXRoIGNhdXRpb24sIGFuZCAqKmRvIG5vdCB1c2UgdGhlIGdldHRlciBpbiB1c2VMYXlvdXRFZmZlY3QhISoqXHJcbiAqIGBzZXRTdGF0ZWAncyBnZXR0ZXIgZG9lcyBub3QgaGF2ZSB0aGlzIHByb2JsZW0sIGJ1dCB0aGVuIHlvdSdyZSB1c2luZyB5b3VyIG93biBzdGF0ZVxyXG4gKiBpbnN0ZWFkIG9mIGFuIGV4aXN0aW5nIHZhbHVlLCB3aGljaCBtaWdodCBub3QgYWx3YXlzIGJlIGZlYXNpYmxlLlxyXG4gKlxyXG4gKiBXZWlnaCB5b3VyIG9wdGlvbnMsIGFuZCBob3BlZnVsbHkgb25lIG9mIHRoZW0gZ2V0cyB0aGUgam9iIGRvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUdldHRlcih2YWx1ZSkge1xyXG4gICAgY29uc3QgcmVmID0gdXNlUmVmKHZhbHVlKTtcclxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH0sIFtdKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2Utc3RhYmxlLWdldHRlci5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcclxuLyoqXHJcbiAqIEFsdGVybmF0ZSB1c2VDYWxsYmFjaygpIHdoaWNoIGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lICh3cmFwcGVkKSBmdW5jdGlvbiByZWZlcmVuY2VcclxuICogc28gdGhhdCBpdCBjYW4gYmUgZXhjbHVkZWQgZnJvbSB0aGUgZGVwZW5kZW5jeSBhcnJheXMgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMuXHJcbiAqXHJcbiAqIERPIE5PVCBVU0UgVEhFIFJFU1VMVCBJTiB1c2VMYXlvdXRFZmZlY3QhIVxyXG4gKlxyXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSBvcHRpb25zLmRpZmZlZCBpZiB0aGUgdXNlTGF5b3V0RWZmZWN0IGxpbWl0YXRpb24gYmVjb21lcyBsaW1pdGxlc3NseSBsaW1pdGluZy5cclxuICpcclxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0MDk5I2lzc3VlY29tbWVudC02NTkyOTg0MjJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjayhmbikge1xyXG4gICAgY29uc3QgY3VycmVudENhbGxiYWNrR2V0dGVyID0gdXNlU3RhYmxlR2V0dGVyKGZuKTtcclxuICAgIHJldHVybiB1c2VDYWxsYmFjaygoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRGdW5jID0gY3VycmVudENhbGxiYWNrR2V0dGVyKCk7XHJcbiAgICAgICAgaWYgKCFjdXJyZW50RnVuYykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrKCkgY2Fubm90IGJlIGNhbGxlZCBmcm9tIHVzZUxheW91dEVmZmVjdCgpLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudEZ1bmMoLi4uYXJncyk7XHJcbiAgICB9LCBbXSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXN0YWJsZS1jYWxsYmFjay5qcy5tYXAiLCJpbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0TmF0aXZlLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbi8qKlxyXG4gKiBXcmFwIHRoZSBuYXRpdmUgYHVzZUxheW91dEVmZmVjdGAgdG8gYWRkIGFyZ3VtZW50c1xyXG4gKiB0aGF0IGFsbG93IGFjY2Vzc2luZyB0aGUgcHJldmlvdXMgdmFsdWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxyXG4gKiBhcyB3ZWxsIGFzIHRoZSBjaGFuZ2VzIHRoYXQgY2F1c2VkIHRoZSBob29rIHRvIGJlIGNhbGxlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWZmZWN0XHJcbiAqIEBwYXJhbSBpbnB1dHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoZWZmZWN0LCBpbnB1dHMpIHtcclxuICAgIGNvbnN0IHByZXZJbnB1dHMgPSB1c2VSZWYoaW5wdXRzKTtcclxuICAgIGNvbnN0IGVmZmVjdDIgPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHByZXZJbnB1dHMuY3VycmVudC5sZW5ndGgsIGlucHV0cy5sZW5ndGgpOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHByZXZJbnB1dHMuY3VycmVudFtpXSAhPSBpbnB1dHNbaV0pXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzW2ldID0geyBmcm9tOiBwcmV2SW5wdXRzLmN1cnJlbnRbaV0sIHRvOiBpbnB1dHNbaV0gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmV0ID0gZWZmZWN0KHByZXZJbnB1dHMuY3VycmVudCwgY2hhbmdlcyk7XHJcbiAgICAgICAgcHJldklucHV0cy5jdXJyZW50ID0gaW5wdXRzO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9O1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0TmF0aXZlKGVmZmVjdDIsIGlucHV0cyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWxheW91dC1lZmZlY3QuanMubWFwIiwiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRpbWVvdXQoeyB0aW1lb3V0LCBjYWxsYmFjaywgdHJpZ2dlckluZGV4IH0pIHtcclxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2spO1xyXG4gICAgY29uc3QgZ2V0VGltZW91dCA9IHVzZVN0YWJsZUdldHRlcih0aW1lb3V0KTtcclxuICAgIGNvbnN0IHRpbWVvdXRJc051bGwgPSAodGltZW91dCA9PSBudWxsKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydCh0aW1lb3V0SXNOdWxsID09ICh0aW1lb3V0ID09IG51bGwpKTtcclxuICAgICAgICBpZiAodGltZW91dCkge1xyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KHN0YWJsZUNhbGxiYWNrLCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0cmlnZ2VySW5kZXgsIHRpbWVvdXRJc051bGxdKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtdGltZW91dC5qcy5tYXAiLCJpbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWxheW91dC1lZmZlY3RcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlVGltZW91dCB9IGZyb20gXCIuL3VzZS10aW1lb3V0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG4vKipcclxuICogR2l2ZW4gYW4gYXN5bmNyb25vdXMgZXZlbnQgaGFuZGxlciwgcmV0dXJucyBhIHN5bmNyb25vdXMgb25lIHRoYXQgd29ya3Mgb24gdGhlIERPTSxcclxuICogYWxvbmcgd2l0aCBzb21lIG90aGVyIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAqIERvZXMgbm90IG1vZGlmeSBhbnkgcHJvcHMuXHJcbiAqXHJcbiAqIFRoZSBoYW5kbGVyIGlzIGF1dG9tYXRpY2FsbHkgdGhyb3R0bGVkIHRvIG9ubHkgcnVuIG9uZSBhdCBhIHRpbWUuXHJcbiAqIElmIHRoZSBoYW5kbGVyIGlzIGNhbGxlZCwgYW5kIHRoZW4gYmVmb3JlIGl0IGZpbmlzaGVzLCBpcyBjYWxsZWQgYWdhaW4sXHJcbiAqIGl0IHdpbGwgYmUgcHV0IG9uIGhvbGQgdW50aWwgdGhlIGN1cnJlbnQgb25lIGZpbmlzaGVzLCBhdCB3aGljaCBwb2ludFxyXG4gKiB0aGUgc2Vjb25kIG9uZSB3aWxsIHJ1bi4gIElmIHRoZSBoYW5kbGVyIGlzIGNhbGxlZCBhIHRoaXJkIHRpbWUgYmVmb3JlXHJcbiAqIHRoZSBmaXJzdCBoYXMgZmluaXNoZWQsIGl0IHdpbGwgKnJlcGxhY2UqIHRoZSBzZWNvbmQsIHNvIG9ubHkgdGhlIG1vc3RcclxuICogcmVjZW50bHkgY2FsbGVkIGl0ZXJhdGlvbiBvZiB0aGUgaGFuZGxlciB3aWxsIHJ1bi5cclxuICpcclxuICogWW91IG1heSBvcHRpb25hbGx5ICphbHNvKiBzcGVjaWZ5IGEgZGVib3VuY2UgcGFyYW1ldGVyIHRoYXQgd2FpdHMgdW50aWwgdGhlXHJcbiAqIHN5bmNyb25vdXMgaGFuZGxlciBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciB0aGUgc3BlY2lmaWVkIG51bWJlciBvZlxyXG4gKiBtaWxsaXNlY29uZHMsIGF0IHdoaWNoIHBvaW50IHdlICphY3R1YWxseSogcnVuIHRoZSBhc3luY3Jvbm91cyBoYW5kbGVyXHJcbiAqIGFjY29yZGluZyB0byB0aGUgbG9naWMgaW4gdGhlIHByZXZpb3VzIHBhcmFncmFwaC4gVGhpcyBpcyBpblxyXG4gKiAqYWRkaXRpb24qIHRvIHRocm90dGxpbmcgdGhlIGhhbmRsZXIsIGFuZCBkb2VzIG5vdCByZXBsYWNlIHRoYXQgYmVoYXZpb3IuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgcGFyYW1ldGVycyB0byB0aGUgYXN5bmMgaGFuZGxlciBhcmUgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW5cclxuICogdGhlIHN5bmMgaGFuZGxlciAmbmRhc2g7IHRoZSBmaXJzdCBhcmd1bWVudCwgYXMgZGVjaWRlZCBieSB5b3Ugd2l0aCB0aGVcclxuICogYGNhcHR1cmVgIHBhcmFtZXRlciBmb3IgdGhpcyBob29rLCBpcyB0aGUgXCJzYXZlZFwiIGluZm9ybWF0aW9uIGZyb20gdGhlXHJcbiAqIGV2ZW50LiAgRm9yIGV4YW1wbGUsIHRoZSBldmVudCdzIGN1cnJlbnRUYXJnZXQncyBgdmFsdWVgLCB3aGljaCBtYXkgaGF2ZVxyXG4gKiBjaGFuZ2VkIGJ5IHRoZSB0aW1lIHRoZSBoYW5kbGVyIGlzICphY3R1YWxseSogY2FsbGVkLiAgVGhlIHNlY29uZCBhcmd1bWVudFxyXG4gKiBpcyB0aGUgb3JpZ2luYWwgZXZlbnQsIHdoaWNoIG1pZ2h0IHN0aWxsIGhhdmUgc29tZSB1c2VmdWwgZmllbGRzIG9uIGl0XHJcbiAqIGxpa2UgYG1vdXNlWGAgb3Igc29tZXRoaW5nLCBidXQgaXMgc3RhbGUgYXQgbGVhc3QgaW4gcmVnYXJkcyB0byB0aGVcclxuICogZWxlbWVudCBpdCByZWZlcmVuY2VzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFzeW5jSGFuZGxlcigpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoeyBjYXB0dXJlLCBkZWJvdW5jZSB9KSB7XHJcbiAgICAgICAgLy8gQWx3YXlzIHJlcHJlc2VudHMgd2hhdGV2ZXIgcHJvbWlzZSBpcyBjdXJyZW50bHkgYmVpbmcgd2FpdGVkIG9uLCBvciBudWxsIGlmIG5vbmUuXHJcbiAgICAgICAgY29uc3QgW3Byb21pc2UsIHNldFByb21pc2UsIGdldFByb21pc2VdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBob3cgbWFueSB0aW1lcyB3ZSd2ZSBhY3R1YWxseSBjYWxsZWQgdGhlIGFzeW5jIGhhbmRsZXJcclxuICAgICAgICBjb25zdCBbcnVuQ291bnQsIHNldFJ1bkNvdW50XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgICAgIGNvbnN0IFtyZXNvbHZlQ291bnQsIHNldFJlc29sdmVDb3VudF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgICAgICBjb25zdCBbcmVqZWN0Q291bnQsIHNldFJlamVjdENvdW50XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgICAgIC8vIFxyXG4gICAgICAgIGNvbnN0IFtjdXJyZW50VHlwZSwgc2V0Q3VycmVudFR5cGVdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICAgICAgLy8gSWYgd2UncmUgc2V0IHRvIHVzZSBhIGRlYm91bmNlLCB0aGVuIHdoZW4gdGhlIHRpbWVvdXQgZmluaXNoZXMsXHJcbiAgICAgICAgLy8gdGhlIHByb21pc2UgZnJvbSB0aGlzIHN0YXRlIG9iamVjdCBpcyB0cmFuc2ZlcnJlZCBvdmVyIHRvIGVpdGhlciBcclxuICAgICAgICAvLyB0aGUgY3VycmVudCBwcm9taXNlIG9yIHRoZSBwZW5kaW5nIHByb21pc2UuXHJcbiAgICAgICAgY29uc3QgW2RlYm91bmNlZFByb21pc2VTdGFydGVyLCBzZXREZWJvdW5jZWRQcm9taXNlU3RhcnRlciwgZ2V0RGVib3VuY2VkUHJvbWlzZVN0YXJ0ZXJdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICAgICAgLy8gV2hlbiB3ZSB3YW50IHRvIHN0YXJ0IGEgbmV3IHByb21pc2UsIHdlIHdvbid0IGFsbG93IGl0IHRvIHN0YXJ0IGlmIG9uZSBpcyBzdGlsbCBydW5uaW5nLlxyXG4gICAgICAgIC8vIEluIHRoYXQgY2FzZSwgd2Ugc3RvcmUgdGhlIHByb21pc2UgKG9yIHJhdGhlciwgYSB3YXkgdG8gc3RhcnQgdGhlIHByb21pc2UpIGluIHN0YXRlLlxyXG4gICAgICAgIGNvbnN0IFtwZW5kaW5nUHJvbWlzZVN0YXJ0ZXIsIHNldFBlbmRpbmdQcm9taXNlU3RhcnRlciwgZ2V0UGVuZGluZ1Byb21pc2VTdGFydGVyXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGB1bmRlZmluZWRgIGFuZCBcIm5vIGVycm9yIGhhcyBiZWVuIHRocm93blwiLlxyXG4gICAgICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3IsIGdldEVycm9yXSA9IHVzZVN0YXRlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgY29uc3QgW2hhc0Vycm9yLCBzZXRIYXNFcnJvciwgZ2V0SGFzRXJyb3JdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgIC8vIFNhbWUgdGhpbmcsIHdlIG5lZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIFwibm90aGluZyBjYXB0dXJlZCB5ZXRcIiBhbmQgXCJgdW5kZWZpbmVkYCB3YXMgY2FwdHVyZWRcIlxyXG4gICAgICAgIGNvbnN0IFtjdXJyZW50Q2FwdHVyZSwgc2V0Q3VycmVudENhcHR1cmUsIGdldEN1cnJlbnRDYXB0dXJlXSA9IHVzZVN0YXRlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgY29uc3QgW2hhc0NhcHR1cmUsIHNldEhhc0NhcHR1cmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgIC8vIFdoZW4gdGhlIGRlYm91bmNlIHRpbWVyIGlzIHVwIChvciB3ZSBtYW51YWxseSByZXF1ZXN0IHRoZSBkZWJvdW5jZSB0byBlbmQpXHJcbiAgICAgICAgLy8gcnVuIHRoZSBub3JtYWwgXCJwbGVhc2UgY29uc2lkZXIgcnVubmluZyB0aGlzIHByb21pc2VcIiByb3V0aW5lIHRoYXQgd2Ugd291bGRcclxuICAgICAgICAvLyBoYXZlIGp1c3QgcnVuIGltbWVkaWF0ZWx5IGlmIHdlIHdlcmVuJ3QgZGVib3VuY2luZyBvdXIgcHJvbWlzZXMuXHJcbiAgICAgICAgY29uc3Qgb25EZWJvdW5jZVRpbWVVcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGVib3VuY2VkUHJvbWlzZVN0YXJ0ZXIgPSBnZXREZWJvdW5jZWRQcm9taXNlU3RhcnRlcigpO1xyXG4gICAgICAgICAgICBpZiAoZGVib3VuY2VkUHJvbWlzZVN0YXJ0ZXIpXHJcbiAgICAgICAgICAgICAgICB3YW50VG9TdGFydEFOZXdQcm9taXNlKGRlYm91bmNlZFByb21pc2VTdGFydGVyKTtcclxuICAgICAgICAgICAgc2V0RGVib3VuY2VkUHJvbWlzZVN0YXJ0ZXIobnVsbCk7XHJcbiAgICAgICAgfSwgW3dhbnRUb1N0YXJ0QU5ld1Byb21pc2UsIHNldERlYm91bmNlZFByb21pc2VTdGFydGVyXSk7XHJcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBkZWJvdW5jZS4gTG9naWNhbGx5IHRoaXMgaGFwcGVucyBiZWZvcmUgdGhlIG1haW4gc3RlcCBhcyBhIHNvcnQgb2Ygc3RlcCAwLlxyXG4gICAgICAgIC8vIFJlc2V0cyB0aGUgdGltZW91dCBhbnkgdGltZSB0aGUgaGFuZGxlciB3YXMgcmVxdWVzdGVkIHRvIGJlIGNhbGxlZCBhZ2FpblxyXG4gICAgICAgIC8vIGFuZCB3aGVuIGl0IGZpbmlzaGVzLCBhY3R1YWxseSBjYWxsIHRoZSBoYW5kbGVyIChvciBzZXQgaXQgYXMgdGhlIHBlbmRpbmcgcHJvbWlzZSlcclxuICAgICAgICB1c2VUaW1lb3V0KHtcclxuICAgICAgICAgICAgdGltZW91dDogZGVib3VuY2UgPz8gbnVsbCxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IG9uRGVib3VuY2VUaW1lVXAsXHJcbiAgICAgICAgICAgIHRyaWdnZXJJbmRleDogZGVib3VuY2VkUHJvbWlzZVN0YXJ0ZXJcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBTZWUgaWYgd2Ugc2hvdWxkIHNldCBvdXIgY3VycmVudCBwcm9taXNlIHRvIGJlIHdoYXRldmVyIHRoZSBwZW5kaW5nIHByb21pc2UgaXNcclxuICAgICAgICAvLyAodXN1YWxseSBiZWNhdXNlIHRoZSBjdXJyZW50IHByb21pc2UgZmluaXNoZWQgYW5kIGJlY2FtZSBudWxsKS5cclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBPdXIgY3VycmVudCBwcm9taXNlIGp1c3QgZmluaXNoZWQgYW5kIHRoZXJlJ3Mgb25lIHdhaXRpbmc/XHJcbiAgICAgICAgICAgIGlmIChwcm9taXNlID09IG51bGwgJiYgcGVuZGluZ1Byb21pc2VTdGFydGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHdhbnRUb1N0YXJ0QU5ld1Byb21pc2UocGVuZGluZ1Byb21pc2VTdGFydGVyKTtcclxuICAgICAgICAgICAgICAgIHNldFBlbmRpbmdQcm9taXNlU3RhcnRlcihudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtwcm9taXNlLCBwZW5kaW5nUHJvbWlzZVN0YXJ0ZXJdKTtcclxuICAgICAgICAvLyBDYWxsZWQgYW55IHRpbWUgdGhlIGFzeW5jIGhhbmRsZXIgaXMgYWJvdXQgdG8gYmUgY2FsbGVkIGZvciB3aGF0ZXZlciByZWFzb24sXHJcbiAgICAgICAgLy8gZXhjZXB0IGZvciBkZWJvdW5jZSwgd2hpY2ggY29tZXMgZmlyc3QsIGFzIGEgc29ydCBvZiBcInN0ZXAgMFwiLlxyXG4gICAgICAgIC8vIEhhbmRsZXMgYWxsIHRoZSBuZWNlc3NhcnkgYm9pbGVycGxhdGUgcmVsYXRlZCB0byBjaG9vc2luZyB3aGV0aGVyIHRvXHJcbiAgICAgICAgLy8gcnVuIG9yIHNldCBhcyBwZW5kaW5nLCByZXNldHRpbmcgc3RhdGUgdmFyaWFibGVzLCBldGMuXHJcbiAgICAgICAgZnVuY3Rpb24gd2FudFRvU3RhcnRBTmV3UHJvbWlzZShzdGFydFByb21pc2UpIHtcclxuICAgICAgICAgICAgbGV0IGFscmVhZHlSdW5uaW5nUHJvbWlzZSA9IChnZXRQcm9taXNlKCkgIT0gbnVsbCk7XHJcbiAgICAgICAgICAgIC8vIEJvaWxlcnBsYXRlIHdyYXBwZXIgYXJvdW5kIHRoZSBnaXZlbiBwcm9taXNlIHN0YXJ0ZXJcclxuICAgICAgICAgICAgbGV0IHN0YXJ0UHJvbWlzZVdpdGhCb2lsZXJwbGF0ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gaXQgc3RhcnRzLCBub3RpZnkgdGhlIGNhbGxlclxyXG4gICAgICAgICAgICAgICAgc2V0UnVuQ291bnQociA9PiArK3IpO1xyXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBpdCBjb21wbGV0ZXMsIG5vdGlmeSB0aGUgY2FsbGVyXHJcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGl0IGZhaWxzLCBzYXZlIHRoZSBlcnJvciBhbmQgbm90aWZ5IHRoZSBjYWxsZXJcclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gaXQgc2V0dGxlcywgcmVzZXQgb3VyIHN0YXRlIHNvIHdlIGNhbiBydW4gYSBwZW5kaW5nIHByb21pc2UgaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBvblRoZW4gPSAoKSA9PiB7IHNldFJlc29sdmVDb3VudChjID0+ICsrYyk7IH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbkNhdGNoID0gKGV4KSA9PiB7IHNldEVycm9yKGV4KTsgc2V0SGFzRXJyb3IodHJ1ZSk7IHNldFJlamVjdENvdW50KGMgPT4gKytjKTsgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9uRmluYWxseSA9ICgpID0+IHsgc2V0UHJvbWlzZShudWxsKTsgfTtcclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHRoZSBoYW5kbGVyIGlzIHN5bmNocm9ub3VzXHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzdGFydFByb21pc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIHN5bmNocm9ub3VzIGFuZCByZXR1cm5lZCBzdWNjZXNzZnVsbHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhaWwgb3V0IGVhcmx5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblRoZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25GaW5hbGx5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlKFwic3luY1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChcInRoZW5cIiBpbiByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBzeW5jaHJvbm91cyAob3IgYXN5bmNocm9ub3VzIGJ1dCBkaWRuJ3QgYXdhaXQgYW55dGhpbmcgeWV0KSBhbmQgdGhyZXcgYW4gZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgZWFybHkuXHJcbiAgICAgICAgICAgICAgICAgICAgb25DYXRjaChleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb25GaW5hbGx5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGUoXCJzeW5jXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBoYW5kbGVyIGlzIGFzeW5jaHJvbm91c1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGUoXCJhc3luY1wiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4geyBhd2FpdCByZXN1bHQ7IH0pKCkudGhlbihvblRoZW4pLmNhdGNoKG9uQ2F0Y2gpLmZpbmFsbHkob25GaW5hbGx5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCFhbHJlYWR5UnVubmluZ1Byb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBwcm9taXNlIGltbWVkaWF0ZWx5LCBiZWNhdXNlIHRoZXJlIHdhc24ndCBvbmUgcnVubmluZyBhbHJlYWR5LlxyXG4gICAgICAgICAgICAgICAgbGV0IG5leHRQcm9taXNlID0gc3RhcnRQcm9taXNlV2l0aEJvaWxlcnBsYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFByb21pc2UgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSG9sZCBvbiEgVGhlIGhhbmRsZXIgd2FzIGFjdHVhbGx5IHN5bmNocm9ub3VzLCBhbmQgYWxyZWFkeSBmaW5pc2hlZC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBCYWlsIG91dCBlYXJseS5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEVycm9yKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0SGFzRXJyb3IoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFByb21pc2UobmV4dFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc3RhcnQgdGhlIHByb21pc2UgeWV0LCBcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBhbGxvdyBpdCB0byBzdGFydCBpbiB0aGUgZnV0dXJlIGluc3RlYWQuXHJcbiAgICAgICAgICAgICAgICBzZXRQZW5kaW5nUHJvbWlzZVN0YXJ0ZXIoXyA9PiBzdGFydFByb21pc2VXaXRoQm9pbGVycGxhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXQgPSB7XHJcbiAgICAgICAgICAgIGdldFN5bmNIYW5kbGVyLFxyXG4gICAgICAgICAgICBnZXRDdXJyZW50Q2FwdHVyZSxcclxuICAgICAgICAgICAgY2FsbENvdW50OiBydW5Db3VudCxcclxuICAgICAgICAgICAgY3VycmVudENhcHR1cmUsXHJcbiAgICAgICAgICAgIGhhc0NhcHR1cmUsXHJcbiAgICAgICAgICAgIHBlbmRpbmc6IChwcm9taXNlICE9IG51bGwpLFxyXG4gICAgICAgICAgICBoYXNFcnJvcixcclxuICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgIGN1cnJlbnRUeXBlLFxyXG4gICAgICAgICAgICBmbHVzaERlYm91bmNlZFByb21pc2U6IG9uRGVib3VuY2VUaW1lVXAsXHJcbiAgICAgICAgICAgIHJlc29sdmVDb3VudCxcclxuICAgICAgICAgICAgcmVqZWN0Q291bnQsXHJcbiAgICAgICAgICAgIHNldHRsZUNvdW50OiByZWplY3RDb3VudCArIHJlc29sdmVDb3VudFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICBmdW5jdGlvbiBnZXRTeW5jSGFuZGxlcihhc3luY0hhbmRsZXIpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3luY0hhbmRsZXIgPSB1c2VTdGFibGVDYWxsYmFjayhmdW5jdGlvbiBzeW5jSGFuZGxlcihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFzeW5jSGFuZGxlciA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbW9zdCBzaWduaWZpY2FudCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBldmVudCBhdCB0aGlzIHRpbWUsXHJcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBpcyBuZWNlc3Nhcnkgc2luY2UgdGhlIHByb21pc2UgY291bGQgYWN0dWFsbHkgYmUgY2FsbGVkIG11Y2ggbGF0ZXJcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGVsZW1lbnQncyB2YWx1ZSAoZXRjLikgaGFzIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlZCA9IGNhcHR1cmUoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudENhcHR1cmUoY2FwdHVyZWQpO1xyXG4gICAgICAgICAgICAgICAgc2V0SGFzQ2FwdHVyZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9ICgpID0+IGFzeW5jSGFuZGxlcihjYXB0dXJlZCwgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlYm91bmNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YW50VG9TdGFydEFOZXdQcm9taXNlKHN0YXJ0UHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXREZWJvdW5jZWRQcm9taXNlU3RhcnRlcihfID0+IHN0YXJ0UHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYXN5bmNIYW5kbGVyID09IG51bGwgPyB1bmRlZmluZWQgOiBzeW5jSGFuZGxlcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1hc3luYy1oYW5kbGVyLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtbGF5b3V0LWVmZmVjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlVGltZW91dCB9IGZyb20gXCIuL3VzZS10aW1lb3V0XCI7XHJcbmltcG9ydCB7IHVzZUxvZ2ljYWxEaXJlY3Rpb24gfSBmcm9tIFwiLi91c2UtbG9naWNhbC1kaXJlY3Rpb25cIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbi8qKlxyXG4gKiBXaGVuIHVzZWQgaW4gdGFuZGVtIHdpdGggYHVzZVJvdmluZ1RhYkluZGV4YCwgYWxsb3dzIGNvbnRyb2wgb2ZcclxuICogdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdGhlIGFycm93IGtleXMuXHJcbiAqXHJcbiAqIEBzZWUgdXNlTGlzdE5hdmlnYXRpb24sIHdoaWNoIHBhY2thZ2VzIGV2ZXJ5dGhpbmcgdXAgdG9nZXRoZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTGluZWFyTmF2aWdhdGlvbih7IGdldEluZGV4LCBzZXRJbmRleCwgbWFuYWdlZENoaWxkcmVuLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0pIHtcclxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24gPz89IFwiZWl0aGVyXCI7XHJcbiAgICBjb25zdCBpbmRleCA9IGdldEluZGV4KCk7XHJcbiAgICBjb25zdCBjaGlsZENvdW50ID0gbWFuYWdlZENoaWxkcmVuLmxlbmd0aDtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgdGFiYmFibGUgaW5kZXggbmV2ZXIgZXNjYXBlcyB0aGUgYm91bmRzIG9mIGFsbCBhdmFpbGFibGUgY2hpbGRyZW5cclxuICAgIC8vIFRPRE86IEtlZXAgdHJhY2sgb2YgdGhlIG9yaWdpbmFsIGluZGV4IGFuZCBrZWVwIGl0LCBhdCBsZWFzdCB1bnRpbCBrZXlib2FyZCBuYXZpZ2F0aW9uLlxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoaW5kZXggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgc2V0SW5kZXgoMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRDb3VudCA+IDAgJiYgaW5kZXggPj0gY2hpbGRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgc2V0SW5kZXgoY2hpbGRDb3VudCAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2luZGV4LCBjaGlsZENvdW50XSk7XHJcbiAgICAvLyBUaGVzZSBhbGxvdyB1cyB0byBtYW5pcHVsYXRlIHdoYXQgb3VyIGN1cnJlbnQgdGFiYmFibGUgY2hpbGQgaXMuXHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvSW5kZXggPSB1c2VDYWxsYmFjaygoaW5kZXgpID0+IHsgc2V0SW5kZXgoaW5kZXggPCAwID8gKG1hbmFnZWRDaGlsZHJlbi5sZW5ndGggKyBpbmRleCkgOiBpbmRleCk7IH0sIFtdKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9OZXh0ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBzZXRJbmRleCgoaSkgPT4gaSA9PT0gbnVsbCA/IG51bGwgOiBpID49IG1hbmFnZWRDaGlsZHJlbi5sZW5ndGggLSAxID8gbWFuYWdlZENoaWxkcmVuLmxlbmd0aCAtIDEgOiArK2kpOyB9LCBbXSk7XHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvUHJldiA9IHVzZUNhbGxiYWNrKCgpID0+IHsgc2V0SW5kZXgoKGkpID0+IGkgPT09IG51bGwgPyBudWxsIDogaSA8IDAgPyAwIDogLS1pKTsgfSwgW10pO1xyXG4gICAgY29uc3QgbmF2aWdhdGVUb1N0YXJ0ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBuYXZpZ2F0ZVRvSW5kZXgoMCk7IH0sIFtuYXZpZ2F0ZVRvSW5kZXhdKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9FbmQgPSB1c2VDYWxsYmFjaygoKSA9PiB7IG5hdmlnYXRlVG9JbmRleCgtMSk7IH0sIFtuYXZpZ2F0ZVRvSW5kZXhdKTtcclxuICAgIGNvbnN0IHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcywgZWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgICAgIC8vIFByZWZlciB0aGUgcGFyZW50IGVsZW1lbnQncyBkaXJlY3Rpb24gc28gdGhhdCB3ZSdyZSBub3QgY2FsbGluZyBnZXRDb21wdXRlZFN0eWxlXHJcbiAgICAgICAgLy8gb24gZXZlcnkgc2luZ2xlIGluZGl2aWR1YWwgY2hpbGQsIHdoaWNoIGlzIGxpa2VseSByZWR1bmRhbnQuXHJcbiAgICAgICAgLy8gVE9ETzogRG9lcyB1c2VMb2dpY2FsRGlyZWN0aW9uIG5lZWQgdG8gaG9sZCBhIHBlci1yZW5kZXIgJiBwZXItZWxlbWVudCBjYWNoZSB0byBtYWtlIHRoaXMgd29yaz9cclxuICAgICAgICAvLyBPciBkb2VzIHRoZSBicm93c2VyIGF1dG9tYXRpY2FsbHkgY2FjaGUgdGhlIGNvbXB1dGF0aW9ucyB1bnRpbCBzb21ldGhpbmcgY2hhbmdlcz9cclxuICAgICAgICAvLyBHaXZlbiB0aGF0IHRoZSB2YWx1ZXMgYXJlIGxpdmUsIGl0IHNlZW1zIGxpa2UgaXQgc2hvdWxkIGJlIHRoZSBsYXR0ZXIuLi5cclxuICAgICAgICBjb25zdCB7IGNvbnZlcnRFbGVtZW50U2l6ZSwgZ2V0TG9naWNhbERpcmVjdGlvbiB9ID0gdXNlTG9naWNhbERpcmVjdGlvbihlbGVtZW50Py5wYXJlbnRFbGVtZW50ID8/IGVsZW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZFByb3BzID0gKHByb3BzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCBieSB0eXBlYWhlYWQgKGkuZS4gYXNzdW1lIHRoaXMgaXMgYSBrZXlib2FyZCBzaG9ydGN1dClcclxuICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBnZXRMb2dpY2FsRGlyZWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWxsb3dzQmxvY2tOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJibG9ja1wiIHx8IG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJlaXRoZXJcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWxsb3dzSW5saW5lTmF2aWdhdGlvbiA9IChuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiaW5saW5lXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IFwiYmxvY2tEaXJlY3Rpb25cIiA6IFwiaW5saW5lRGlyZWN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IGFsbG93c0Jsb2NrTmF2aWdhdGlvbiA6IGFsbG93c0lubGluZU5hdmlnYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwiYnR0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcImJsb2NrRGlyZWN0aW9uXCIgOiBcImlubGluZURpcmVjdGlvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9IChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBhbGxvd3NCbG9ja05hdmlnYXRpb24gOiBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcImJ0dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJpbmxpbmVEaXJlY3Rpb25cIiA6IFwiYmxvY2tEaXJlY3Rpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gYWxsb3dzSW5saW5lTmF2aWdhdGlvbiA6IGFsbG93c0Jsb2NrTmF2aWdhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJydGxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImlubGluZURpcmVjdGlvblwiIDogXCJibG9ja0RpcmVjdGlvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uIDogYWxsb3dzQmxvY2tOYXZpZ2F0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcInJ0bFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIb21lXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9TdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJFbmRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0VuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlUmVmRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzKCkoeyBvbktleURvd24gfSwgcHJvcHMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZFByb3BzXHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtuYXZpZ2F0aW9uRGlyZWN0aW9uLCBuYXZpZ2F0ZVRvTmV4dCwgbmF2aWdhdGVUb1ByZXYsIG5hdmlnYXRlVG9TdGFydCwgbmF2aWdhdGVUb0VuZF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGQsXHJcbiAgICAgICAgbmF2aWdhdGVUb0luZGV4LFxyXG4gICAgICAgIG5hdmlnYXRlVG9OZXh0LFxyXG4gICAgICAgIG5hdmlnYXRlVG9QcmV2LFxyXG4gICAgICAgIG5hdmlnYXRlVG9TdGFydCxcclxuICAgICAgICBuYXZpZ2F0ZVRvRW5kLFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQWxsb3dzIGZvciB0aGUgc2VsZWN0aW9uIG9mIGEgbWFuYWdlZCBjaGlsZCBieSB0eXBpbmcgdGhlIGdpdmVuIHRleHQgYXNzb2NpYXRlZCB3aXRoIGl0LlxyXG4gKlxyXG4gKiBAc2VlIHVzZUxpc3ROYXZpZ2F0aW9uLCB3aGljaCBwYWNrYWdlcyBldmVyeXRoaW5nIHVwIHRvZ2V0aGVyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVR5cGVhaGVhZE5hdmlnYXRpb24oeyBjb2xsYXRvciwgZ2V0SW5kZXgsIHR5cGVhaGVhZFRpbWVvdXQsIHNldEluZGV4IH0pIHtcclxuICAgIC8vIEZvciB0eXBlYWhlYWQsIGtlZXAgdHJhY2sgb2Ygd2hhdCBvdXIgY3VycmVudCBcInNlYXJjaFwiIHN0cmluZyBpcyAoaWYgd2UgaGF2ZSBvbmUpXHJcbiAgICAvLyBhbmQgYWxzbyBjbGVhciBpdCBldmVyeSAxMDAwIG1zIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgY2hhbmdlZC5cclxuICAgIC8vIE5leHQsIGtlZXAgYSBtYXBwaW5nIG9mIHR5cGVhaGVhZCB2YWx1ZXMgdG8gaW5kaWNlcyBmb3IgZmFzdGVyIHNlYXJjaGluZy5cclxuICAgIC8vIEFuZCwgZm9yIHRoZSB1c2VyJ3Mgc2FrZSwgbGV0IHRoZW0ga25vdyB3aGVuIHRoZWlyIHR5cGVhaGVhZCBjYW4ndCBtYXRjaCBhbnl0aGluZyBhbnltb3JlXHJcbiAgICBjb25zdCBbY3VycmVudFR5cGVhaGVhZCwgc2V0Q3VycmVudFR5cGVhaGVhZCwgZ2V0Q3VycmVudFR5cGVhaGVhZF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIHVzZVRpbWVvdXQoeyB0aW1lb3V0OiB0eXBlYWhlYWRUaW1lb3V0ID8/IDEwMDAsIGNhbGxiYWNrOiAoKSA9PiB7IHNldEN1cnJlbnRUeXBlYWhlYWQobnVsbCk7IHNldEludmFsaWRUeXBlYWhlYWQobnVsbCk7IH0sIHRyaWdnZXJJbmRleDogY3VycmVudFR5cGVhaGVhZCB9KTtcclxuICAgIGNvbnN0IHNvcnRlZFR5cGVhaGVhZEluZm8gPSB1c2VSZWYoW10pO1xyXG4gICAgY29uc3QgW2ludmFsaWRUeXBlYWhlYWQsIHNldEludmFsaWRUeXBlYWhlYWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgLy8gSGFuZGxlIHR5cGVhaGVhZCBmb3IgaW5wdXQgbWV0aG9kIGVkaXRvcnMgYXMgd2VsbFxyXG4gICAgLy8gRXNzZW50aWFsbHksIHdoZW4gYWN0aXZlLCBpZ25vcmUgZnVydGhlciBrZXlzIFxyXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSB3YWl0aW5nIGZvciBhIENvbXBvc2l0aW9uRW5kIGV2ZW50XHJcbiAgICBjb25zdCBbaW1lQWN0aXZlLCBzZXRJbWVBY3RpdmUsIGdldEltZUFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICAvLyBCZWNhdXNlIGNvbXBvc2l0aW9uIGV2ZW50cyBmaXJlICphZnRlcioga2V5ZG93biBldmVudHMgXHJcbiAgICAvLyAoYnV0IHdpdGhpbiB0aGUgc2FtZSB0YXNrLCB3aGljaCwgVE9ETywgY291bGQgYmUgYnJvd3Nlci1kZXBlbmRlbnQpLFxyXG4gICAgLy8gd2UgY2FuIHVzZSB0aGlzIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnQgd2UncmUgbGlzdGVuaW5nIGZvciBvbiB0aGUgZmlyc3Qga2V5ZG93bi5cclxuICAgIGNvbnN0IFtuZXh0VHlwZWFoZWFkQ2hhciwgc2V0TmV4dFR5cGVhaGVhZENoYXJdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChuZXh0VHlwZWFoZWFkQ2hhciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHR5cGVhaGVhZCA9PiAoKHR5cGVhaGVhZCA/PyBcIlwiKSArIG5leHRUeXBlYWhlYWRDaGFyKSk7XHJcbiAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtuZXh0VHlwZWFoZWFkQ2hhcl0pO1xyXG4gICAgY29uc3QgY29tcGFyYXRvciA9IHVzZVN0YWJsZUNhbGxiYWNrKChsaHMsIHJocykgPT4ge1xyXG4gICAgICAgIGxldCBjb21wYXJlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaHMudGV4dCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAvLyBGb3IgdGhlIHB1cnBvc2VzIG9mIHR5cGVhaGVhZCwgb25seSBjb21wYXJlIGEgc3RyaW5nIG9mIHRoZSBzYW1lIHNpemUgYXMgb3VyIGN1cnJlbnRseSB0eXBlZCBzdHJpbmcuXHJcbiAgICAgICAgICAgIC8vIEJ5IG5vcm1hbGl6aW5nIHRoZW0gZmlyc3QsIHdlIGVuc3VyZSB0aGlzIGJ5dGUtYnktYnl0ZSBoYW5kbGluZyBvZiByYXcgY2hhcmFjdGVyIGRhdGEgd29ya3Mgb3V0IG9rYXkuXHJcbiAgICAgICAgICAgIGxldCBzYWZlTGhzID0gbGhzLm5vcm1hbGl6ZShcIk5GRFwiKTtcclxuICAgICAgICAgICAgbGV0IHNhZmVSaHMgPSByaHMudGV4dC5ub3JtYWxpemUoXCJORkRcIikuc3Vic3RyKDAsIHNhZmVMaHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKGNvbGxhdG9yKVxyXG4gICAgICAgICAgICAgICAgY29tcGFyZSA9IGNvbGxhdG9yLmNvbXBhcmUoc2FmZUxocywgc2FmZVJocyk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGNvbXBhcmUgPSBzYWZlTGhzLnRvTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShzYWZlUmhzLnRvTG93ZXJDYXNlKCkgPz8gXCJcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGhzIC0gcmhzO1xyXG4gICAgfSk7XHJcbiAgICAvLyBIYW5kbGUgY2hhbmdlcyBpbiB0eXBlYWhlYWQgdGhhdCBjYXVzZSBjaGFuZ2VzIHRvIHRoZSB0YWJiYWJsZSBpbmRleFxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudFR5cGVhaGVhZCAmJiBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCBzb3J0ZWRUeXBlYWhlYWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIGN1cnJlbnRUeXBlYWhlYWQsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICBpZiAoc29ydGVkVHlwZWFoZWFkSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBoYXMgdHlwZWQgYW4gZW50cnkgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICAvLyAob3IgbW9yZSBzcGVjaWZpY2FsbHkgXCJmb3Igd2hpY2ggdGhlcmUgaXMgbm8gZW50cnkgdGhhdCBzdGFydHMgd2l0aCB0aGF0IGlucHV0XCIpXHJcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0SW52YWxpZFR5cGVhaGVhZChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICBXZSBrbm93IHJvdWdobHkgd2hlcmUsIGluIHRoZSBzb3J0ZWQgYXJyYXkgb2Ygc3RyaW5ncywgb3VyIG5leHQgdHlwZWFoZWFkIGxvY2F0aW9uIGlzLlxyXG4gICAgICAgICAgICAgICAgICBCdXQgcm91Z2hseSBpc24ndCBnb29kIGVub3VnaCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgbWF0Y2hlcy5cclxuICAgICAgICAgICAgICAgICAgVG8gY29udmVydCBvdXIgc29ydGVkIGluZGV4IHRvIHRoZSB1bnNvcnRlZCBpbmRleCB3ZSBuZWVkLCB3ZSBoYXZlIHRvIGZpbmQgdGhlIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHVzICphbmQqIChpZiBhbnkgc3VjaCBleGlzdCkgaXMgKmFmdGVyKiBvdXIgY3VycmVudCBzZWxlY3Rpb24uXHJcblxyXG4gICAgICAgICAgICAgICAgICBJbiBvdGhlciB3b3JkcywgdGhlIG9ubHkgd2F5IHR5cGVhaGVhZCBtb3ZlcyBiYWNrd2FyZHMgcmVsYXRpdmUgdG8gb3VyIGN1cnJlbnRcclxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gaXMgaWYgdGhlIG9ubHkgb3RoZXIgb3B0aW9uIGlzIGJlaGluZCB1cy5cclxuXHJcbiAgICAgICAgICAgICAgICAgIEl0J3Mgbm90IHNwZWNpZmllZCBpbiBXQUktQVJJQSB3aGF0IHRvIGRvIGluIHRoYXQgY2FzZS4gIEkgc3VwcG9zZSB3cmFwIGJhY2sgdG8gdGhlIHN0YXJ0P1xyXG4gICAgICAgICAgICAgICAgICBUaG91Z2ggdGhlcmUncyBhbHNvIGEgY2FzZSBmb3IganVzdCBnb2luZyB1cHdhcmRzIHRvIHRoZSBuZWFyZXN0IHRvIHByZXZlbnQganVtcGluZXNzLlxyXG4gICAgICAgICAgICAgICAgICBCdXQgaWYgeW91J3JlIGFscmVhZHkgZG9pbmcgdHlwZWFoZWFkIG9uIGFuIHVuc29ydGVkIGxpc3QsIGxpa2UsIGp1bXBpbmVzcyBjYW4ndCBiZSBhdm9pZGVkLlxyXG4gICAgICAgICAgICAgICAgICBJIGR1bm5vLiBHb2luZyBiYWNrIHRvIHRoZSBzdGFydCBpcyB0aGUgc2ltcGxpc3QgdGhvdWdoLlxyXG5cclxuICAgICAgICAgICAgICAgICAgQmFzaWNhbGx5IHdoYXQgdGhpcyBkb2VzOiBTdGFydGluZyBmcm9tIHdoZXJlIHdlIGZvdW5kIG91cnNlbHZlcyBhZnRlciBvdXIgYmluYXJ5IHNlYXJjaCxcclxuICAgICAgICAgICAgICAgICAgc2NhbiBiYWNrd2FyZHMgYW5kIGZvcndhcmRzIHRocm91Z2ggYWxsIGFkamFjZW50IGVudHJpZXMgdGhhdCBhbHNvIGNvbXBhcmUgZXF1YWxseSBzbyB0aGF0XHJcbiAgICAgICAgICAgICAgICAgIHdlIGNhbiBmaW5kIHRoZSBvbmUgd2hvc2UgYHVuc29ydGVkSW5kZXhgIGlzIHRoZSBsb3dlc3QgYW1vbmdzdCBhbGwgb3RoZXIgZXF1YWwgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgICAoYW5kIGFsc28gdGhlIGxvd2VzdCBgdW5zb3J0ZWRJbmRleGAgeWFkZGEgeWFkZGEgZXhjZXB0IHRoYXQgaXQgY29tZXMgYWZ0ZXIgdXMpLlxyXG5cclxuICAgICAgICAgICAgICAgICAgVE9ETzogVGhlIGJpbmFyeSBzZWFyY2ggc3RhcnRzIHRoaXMgb2ZmIHdpdGggYSBzb2xpZCBPKGxvZyBuKSwgYnV0IG9uZS1jaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgICAgc2VhcmNoZXMgYXJlLCB0aGFua3MgdG8gcGlnZW9uaG9sZSBwcmluY2lwYWwsIGV2ZW50dWFsbHkgZ3VhcmFudGVlZCB0byBiZWNvbWVcclxuICAgICAgICAgICAgICAgICAgTyhuKmxvZyBuKS4gVGhpcyBpcyBhbm5veWluZyBidXQgcHJvYmFibHkgbm90IGVhc2lseSBzb2x2YWJsZT8gVGhlcmUgY291bGQgYmUgYW5cclxuICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uIGZvciBvbmUtY2hhcmFjdGVyIHN0cmluZ3MsIGJ1dCB0aGF0J3MganVzdCBraWNraW5nIHRoZSBjYW4gZG93blxyXG4gICAgICAgICAgICAgICAgICB0aGUgcm9hZC4gTWF5YmUgb25lIG9yIHR3byBjaGFyYWN0ZXJzIHdvdWxkIGJlIGdvb2QgZW5vdWdoIHRob3VnaC5cclxuICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjYW5kaWRhdGVzJyBwb3NpdGlvbnMgaW4gYm90aCBvdXIgc29ydGVkIGFycmF5IGFuZCB0aGUgdW5zb3J0ZWQgRE9NLlxyXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4QWxsID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSB0d28gYXJlIG9ubHkgc2V0IGZvciBlbGVtZW50cyB0aGF0IGFyZSBhaGVhZCBvZiB1cywgYnV0IHRoZSBwcmluY2lwbGUncyB0aGUgc2FtZSBvdGhlcndpc2VcclxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0U29ydGVkSW5kZXhOZXh0ID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVCZXN0Rml0ID0gKHUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9PSBudWxsIHx8IHUgPCBsb3dlc3RVbnNvcnRlZEluZGV4QWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgPSB1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleEFsbCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPT0gbnVsbCB8fCB1IDwgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQpICYmIHUgPiAoZ2V0SW5kZXgoKSA/PyAtSW5maW5pdHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ID0gdTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U29ydGVkSW5kZXhOZXh0ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgY29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAtLWk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGggJiYgY29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5kZXgoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2xvd2VzdFNvcnRlZEluZGV4TmV4dF0udW5zb3J0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleEFsbF0udW5zb3J0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbY3VycmVudFR5cGVhaGVhZF0pO1xyXG4gICAgY29uc3QgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkID0gdXNlQ2FsbGJhY2soKHsgdGV4dCwgLi4uaSB9KSA9PiB7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRleHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgd2hlcmUgdG8gaW5zZXJ0IHRoaXMgaXRlbS5cclxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgYWxsIGluZGV4IHZhbHVlcyBzaG91bGQgYmUgdW5pcXVlLCB0aGUgcmV0dXJuZWQgc29ydGVkSW5kZXhcclxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBhbHdheXMgcmVmZXIgdG8gYSBuZXcgbG9jYXRpb24gKGkuZS4gYmUgbmVnYXRpdmUpICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgbGV0IHNvcnRlZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgdGV4dCwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDApO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2UoLXNvcnRlZEluZGV4IC0gMSwgMCwgeyB0ZXh0LCB1bnNvcnRlZEluZGV4OiBpLmluZGV4IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVubW91bnRpbmcsIGZpbmQgd2hlcmUgd2Ugd2VyZSBhbmQgcmVtb3ZlIG91cnNlbHZlcy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBZ2Fpbiwgd2Ugc2hvdWxkIGFsd2F5cyBmaW5kIG91cnNlbHZlcyBiZWNhdXNlIHRoZXJlIHNob3VsZCBiZSBubyBkdXBsaWNhdGUgdmFsdWVzIGlmIGVhY2ggaW5kZXggaXMgdW5pcXVlLlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIHRleHQsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4ID49IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2Uoc29ydGVkSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbdGV4dF0pO1xyXG4gICAgICAgIGNvbnN0IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFByb3BzID0gZnVuY3Rpb24gKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcywgZWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgICAgICAgICBjb25zdCBvbkNvbXBvc2l0aW9uU3RhcnQgPSAoZSkgPT4geyBzZXRJbWVBY3RpdmUodHJ1ZSk7IH07XHJcbiAgICAgICAgICAgIGNvbnN0IG9uQ29tcG9zaXRpb25FbmQgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIHNldEltZUFjdGl2ZShmYWxzZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbWVBY3RpdmUgPSBnZXRJbWVBY3RpdmUoKTtcclxuICAgICAgICAgICAgICAgIGxldCBrZXkgPSBlLmtleTtcclxuICAgICAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxyXG4gICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUgJiYgZS5rZXkgPT09IFwiQmFja3NwYWNlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgY2hhcmFjdGVyIGluIGEgd2F5IHRoYXQgZG9lc24ndCBzcGxpdCBVVEYtMTYgc3Vycm9nYXRlcy5cclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHQgPT4gdCA9PT0gbnVsbCA/IG51bGwgOiBbLi4udF0ucmV2ZXJzZSgpLnNsaWNlKDEpLnJldmVyc2UoKS5qb2luKFwiXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUga2V5IHByb3BlcnR5IHJlcHJlc2VudHMgdGhlIHR5cGVkIGNoYXJhY3RlciBPUiB0aGUgXCJuYW1lZCBrZXkgYXR0cmlidXRlXCIgb2YgdGhlIGtleSBwcmVzc2VkLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUncyBubyBkZWZpbml0ZSB3YXkgdG8gdGVsbCB0aGUgZGlmZmVyZW5jZSwgYnV0IGZvciBhbGwgaW50ZW50cyBhbmQgcHVycG9zZXNcclxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBvbmUtY2hhcmFjdGVyIG5hbWVzLCBhbmQgdGhlcmUgYXJlIG5vIG5vbi1BU0NJSS1hbHBoYSBuYW1lcy5cclxuICAgICAgICAgICAgICAgIC8vIFRodXMsIGFueSBvbmUtY2hhcmFjdGVyIG9yIG5vbi1BU0NJSSB2YWx1ZSBmb3IgYGtleWAgaXMgKmFsbW9zdCBjZXJ0YWlubHkqIGEgdHlwZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNDaGFyYWN0ZXJLZXkgPSAoa2V5Lmxlbmd0aCA9PT0gMSB8fCAhL15bQS1aYS16XS8udGVzdChrZXkpKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlcktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gXCIgXCIgJiYgKGdldEN1cnJlbnRUeXBlYWhlYWQoKSA/PyBcIlwiKS50cmltKCkubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgYmVjYXVzZSBhIHNwYWNlYmFyIGNhbid0IGV2ZXIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIGEgdHlwZWFoZWFkLCBvbmx5IGNvbnRpbnVlIG9uZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKFNwZWNpZmljYWxseSwgbGV0IHRoZSBldmVudCBjb250aW51ZSBwcm9wYWdhdGlvbiBpbiB0aGlzIGNhc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdvbid0IGJlIHRydWUgZm9yIHRoZSBmaXJzdCBrZXlkb3duXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJlZm9yZSB1c2VMYXlvdXRFZmZlY3QgaXMgY2FsbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGFjdHVhbGx5IGFwcGx5IHRoZSBjaGFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkodXNlUmVmRWxlbWVudFByb3BzKHsgb25LZXlEb3duLCBvbkNvbXBvc2l0aW9uU3RhcnQsIG9uQ29tcG9zaXRpb25FbmQsIH0pLCBwcm9wcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQcm9wc1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxyXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQsXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBZb3VyIHVzdWFsIGJpbmFyeSBzZWFyY2ggaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIEl0J3MgdXNlZCBoZXJlIHRvIHF1aWNrbHkgZmluZCBhIGdvb2Qgc3BvdCB0byBzdGFydCBzZWFyY2hpbmcgZm9yIG91ciBuZXh0IHR5cGVhaGVhZCBjYW5kaWRhdGUuXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoIHRocm91Z2hcclxuICogQHBhcmFtIHdhbnRlZCBUaGUgdmFsdWUgeW91J2QgbGlrZSB0byBmaW5kXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIENvbXBhcmVzIGB3YW50ZWRgIHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgaW4gYGFycmF5YFxyXG4gKiBAcmV0dXJucyBBIG5vbi1uZWdhdGl2ZSB2YWx1ZSBpZiBgd2FudGVkYCB3YXMgZm91bmQsIGFuZCBhIG5lZ2F0aXZlIG51bWJlciBpZiBub3QuXHJcbiAqIFRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIG51bWJlciwgbWludXMgb25lLCBpcyB3aGVyZSBgd2FudGVkYCAqd291bGQqIGJlIGZvdW5kIGlmIGl0ICp3YXMqIGluIGBhcnJheWBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2goYXJyYXksIHdhbnRlZCwgY29tcGFyYXRvcikge1xyXG4gICAgdmFyIGZpcnN0SW5kZXggPSAwO1xyXG4gICAgdmFyIGxhc3RJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XHJcbiAgICB3aGlsZSAoZmlyc3RJbmRleCA8PSBsYXN0SW5kZXgpIHtcclxuICAgICAgICB2YXIgdGVzdEluZGV4ID0gKGxhc3RJbmRleCArIGZpcnN0SW5kZXgpID4+IDE7XHJcbiAgICAgICAgdmFyIGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJhdG9yKHdhbnRlZCwgYXJyYXlbdGVzdEluZGV4XSk7XHJcbiAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XHJcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSB0ZXN0SW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xyXG4gICAgICAgICAgICBsYXN0SW5kZXggPSB0ZXN0SW5kZXggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRlc3RJbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLWZpcnN0SW5kZXggLSAxO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1rZXlib2FyZC1uYXZpZ2F0aW9uLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1sYXlvdXQtZWZmZWN0XCI7XHJcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuLyoqXHJcbiAqIEFsbG93cyBhIHBhcmVudCBjb21wb25lbnQgdG8gYWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IGNlcnRhaW5cclxuICogY2hpbGQgY29tcG9uZW50cyBvbmNlIHRoZXkgaGF2ZSByZW5kZXJlZC5cclxuICpcclxuICogVGhpcyBob29rIGlzIHNsaWdodGx5IG1vcmUgY29tcGxpY2F0ZWQgaW4gdGhhdCBpdCByZXR1cm5zIGJvdGggYVxyXG4gKiBwcm9wLW1vZGlmeWluZyBob29rLCBidXQgYWxzbyBhIGhvb2sgdGhhdCBlYWNoIGNoaWxkIHdpbGwgbmVlZFxyXG4gKiB0byB1c2U6IGB1c2VNYW5hZ2VkQ2hpbGRgLiAgSXQncyBzdGFibGUgYWNyb3NzIHJlbmRlcnMsIHNvIGp1c3RcclxuICogdG9zcyBpdCBpbnRvIGEgYENvbnRleHRgIHNvIHRoZSBjaGlsZHJlbiBjYW4gaGF2ZSBhY2Nlc3MgdG8gaXQuXHJcbiAqIFRoaXMgZnVuY3Rpb24gcmVnaXN0ZXJzIHRoZSBjaGlsZCB3aXRoIHRoZSBwYXJlbnQgYW5kIHByb3ZpZGVzXHJcbiAqIGl0IHdpdGggYW55IHJlcXVlc3RlZCBpbmZvcm1hdGlvbiwgYnV0IGRvZXNuJ3QgZG8gYW55dGhpbmcgZWxzZVxyXG4gKiB1bnRpbCBpdCB1bm1vdW50cyBhbmQgcmV0cmFjdHMgdGhhdCBpbmZvcm1hdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGlsZE1hbmFnZXIoKSB7XHJcbiAgICAvLyBUaGlzIGlzIGJsaW5kbHkgdXBkYXRlZCBhbnkgdGltZSBhIGNoaWxkIG1vdW50cyBvciB1bm1vdW50cyBpdHNlbGYuXHJcbiAgICAvLyBVc2VkIHRvIG1ha2Ugc3VyZSB0aGF0IGFueSB0aW1lIHRoZSBhcnJheSBvZiBtYW5hZ2VkIGNoaWxkcmVuIHVwZGF0ZXMsXHJcbiAgICAvLyB3ZSBhbHNvIHJlLXJlbmRlci5cclxuICAgIGNvbnN0IFtjaGlsZFVwZGF0ZUluZGV4LCBzZXRDaGlsZFVwZGF0ZUluZGV4XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW3RvdGFsQ2hpbGRyZW5Nb3VudGVkLCBzZXRUb3RhbENoaWxkcmVuTW91bnRlZCwgZ2V0VG90YWxDaGlsZHJlbk1vdW50ZWRdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbdG90YWxDaGlsZHJlblVub3VudGVkLCBzZXRUb3RhbENoaWxkcmVuVW5vdW50ZWQsIGdldFRvdGFsQ2hpbGRyZW5Vbm91bnRlZF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IGNoaWxkcmVuQ3VycmVudGx5TW91bnRlZCA9IHRvdGFsQ2hpbGRyZW5Nb3VudGVkIC0gdG90YWxDaGlsZHJlblVub3VudGVkO1xyXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuID0gdXNlUmVmKFtdIC8qKiBUT0RPOiBBbnkgcHJvYmxlbXMgY2F1c2VkIGJ5IHVzaW5nIGFuIGFycmF5IHdoZW4gaXQgc2hvdWxkIGJlIGFuIG9iamVjdD8gKi8pO1xyXG4gICAgY29uc3QgbW91bnRlZENoaWxkcmVuID0gdXNlUmVmKFtdKTtcclxuICAgIGNvbnN0IG1vdW50T3JkZXIgPSB1c2VSZWYobmV3IE1hcCgpKTtcclxuICAgIGNvbnN0IGluZGljZXNCeUVsZW1lbnQgPSB1c2VSZWYobmV3IE1hcCgpKTtcclxuICAgIGNvbnN0IGdldE1vdW50SW5kZXggPSB1c2VDYWxsYmFjaygoaW5kZXgpID0+IHsgcmV0dXJuIG1vdW50T3JkZXIuY3VycmVudC5nZXQoaW5kZXgpOyB9LCBbXSk7XHJcbiAgICBjb25zdCB1c2VNYW5hZ2VkQ2hpbGQgPSB1c2VDYWxsYmFjaygoaW5mbykgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gZ2V0VG90YWxDaGlsZHJlbk1vdW50ZWQoKTtcclxuICAgICAgICAgICAgbW91bnRPcmRlci5jdXJyZW50LnNldChpbmZvLmluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgICAgIG1vdW50ZWRDaGlsZHJlbi5jdXJyZW50W2luZGV4XSA9IGluZm87XHJcbiAgICAgICAgICAgIHNldFRvdGFsQ2hpbGRyZW5Nb3VudGVkKHQgPT4gKyt0KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgbW91bnRPcmRlci5jdXJyZW50LmRlbGV0ZShpbmZvLmluZGV4KTsgbW91bnRlZENoaWxkcmVuLmN1cnJlbnRbaW5kZXhdID0gbnVsbDsgc2V0VG90YWxDaGlsZHJlblVub3VudGVkKHQgPT4gKyt0KTsgfTtcclxuICAgICAgICB9LCBbaW5mby5pbmRleF0pO1xyXG4gICAgICAgIC8vIEFzIHNvb24gYXMgdGhlIGNvbXBvbmVudCBtb3VudHMsIG5vdGlmeSB0aGUgcGFyZW50IGFuZCByZXF1ZXN0IGEgcmVyZW5kZXIuXHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KChbcHJldkVsZW1lbnQsIHByZXZJbmRleF0sIGNoYW5nZXMpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGluZGljZXNCeUVsZW1lbnQuY3VycmVudC5zZXQoZWxlbWVudCwgaW5mby5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFuYWdlZENoaWxkcmVuLmN1cnJlbnRbaW5mby5pbmRleF0gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoaW5mby5pbmRleCA9PSB1bmRlZmluZWQsIFwiVHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUgaW5kZXggd2VyZSBhZGRlZCwgd2hpY2ggbWF5IHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW9yLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z2dlcjsgLy8gSW50ZW50aW9uYWxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNldENoaWxkVXBkYXRlSW5kZXgoYyA9PiArK2MpO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuLmN1cnJlbnRbaW5mby5pbmRleF0gPSB7IC4uLmluZm8gfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q2hpbGRVcGRhdGVJbmRleChjID0+ICsrYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbi5jdXJyZW50W2luZm8uaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXNCeUVsZW1lbnQuY3VycmVudC5kZWxldGUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW2VsZW1lbnQsIGluZm8uaW5kZXhdKTtcclxuICAgICAgICAvLyBBbnkgdGltZSBvdXIgY2hpbGQgcHJvcHMgY2hhbmdlLCBtYWtlIHRoYXQgaW5mb3JtYXRpb24gYXZhaWxhYmxlIGdlbmVyYWxseS5cclxuICAgICAgICAvLyAqRG9uJ3QgcmUtcmVuZGVyKiwgb3RoZXJ3aXNlIHdlJ2QgYmUgc3R1Y2sgaW4gYW5cclxuICAgICAgICAvLyBpbmZpbml0ZSBsb29wIGV2ZXJ5IHRpbWUgYW4gYW5vbnltb3VzIGZ1bmN0aW9uIGlzIHBhc3NlZC5cclxuICAgICAgICAvLyBJdCBjb21lcyBpbiBmcm9tIHRoZSBwcm9wcyBzbyB0aGUgY2hpbGQgd2FzIGFscmVhZHkgdXBkYXRlZCBieSBpdCAtLVxyXG4gICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdGhlIHBhcmVudCB0byByZS1yZW5kZXIgZXZlcnkgc2luZ2xlIGNoaWxkIGFueSB0aW1lXHJcbiAgICAgICAgLy8gXCJvbkNsaWNrXCIgdXBkYXRlcyBvciB3aGF0ZXZlci4gIFRoZSByZWxldmFudCBjaGlsZCBhbHJlYWR5IGtub3dzLFxyXG4gICAgICAgIC8vIGFuZCB0aGF0J3Mgd2hhdCBtYXR0ZXJzLlxyXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtYW5hZ2VkQ2hpbGRyZW4uY3VycmVudFtpbmZvLmluZGV4XSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4uY3VycmVudFtpbmZvLmluZGV4XSA9IHsgLi4uaW5mbyB9O1xyXG4gICAgICAgIH0sIFsuLi5PYmplY3QuZW50cmllcyhpbmZvKS5mbGF0KCldKTtcclxuICAgICAgICByZXR1cm4geyBlbGVtZW50LCBnZXRFbGVtZW50LCB1c2VNYW5hZ2VkQ2hpbGRQcm9wczogdXNlUmVmRWxlbWVudFByb3BzIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZU1hbmFnZWRDaGlsZCxcclxuICAgICAgICBjaGlsZENvdW50OiBjaGlsZHJlbkN1cnJlbnRseU1vdW50ZWQsXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkQ2hpbGRyZW4uY3VycmVudCxcclxuICAgICAgICBtb3VudGVkQ2hpbGRyZW46IG1vdW50ZWRDaGlsZHJlbi5jdXJyZW50LFxyXG4gICAgICAgIGluZGljZXNCeUVsZW1lbnQ6IGluZGljZXNCeUVsZW1lbnQuY3VycmVudCxcclxuICAgICAgICB0b3RhbENoaWxkcmVuTW91bnRlZCxcclxuICAgICAgICB0b3RhbENoaWxkcmVuVW5vdW50ZWQsXHJcbiAgICAgICAgZ2V0TW91bnRJbmRleFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBsZXR0aW5nIGNoaWxkcmVuIGtub3cgd2hlbiB0aGV5IGFyZSBvciBhcmUgbm90IHRoZVxyXG4gKiBjdXJyZW50IHNlbGVjdGVkL2V4cGFuZGVkL2ZvY3VzZWQvd2hhdGV2ZXIgY2hpbGQuXHJcbiAqXHJcbiAqIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyB3aGVuIGNoaWxkcmVuIGFyZSBtb3VudGVkICYgdW5tb3VudGVkIGFuZCBzdWNoLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aXZhdGVkSW5kZXggV2hhdCBpbmRleCB0aGUgY3VycmVudCBzZWxlY3RlZCAoZXRjLikgY2hpbGQgaXNcclxuICogQHBhcmFtIGxlbmd0aCBIb3cgbWFueSBjaGlsZHJlbiBleGlzdCAoYXMgbWFuYWdlZENoaWxkcmVuLmxlbmd0aClcclxuICogQHBhcmFtIHNldEZsYWcgQSBmdW5jdGlvbiB0aGF0IHByb2JhYmx5IGxvb2tzIGxpa2UgKGksIGZsYWcpID0+IG1hbmFnZWRDaGlsZHJlbltpXS5zZXRBY3RpdmUoZmxhZylcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGlsZEZsYWcoYWN0aXZhdGVkSW5kZXgsIGxlbmd0aCwgc2V0RmxhZykge1xyXG4gICAgY29uc3QgW3ByZXZBY3RpdmF0ZWRJbmRleCwgc2V0UHJldkFjdGl2YXRlZEluZGV4LCBnZXRQcmV2QWN0aXZhdGVkSW5kZXhdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBbcHJldkNoaWxkQ291bnQsIHNldFByZXZDaGlsZENvdW50LCBnZXRQcmV2Q2hpbGRDb3VudF0gPSB1c2VTdGF0ZShsZW5ndGgpO1xyXG4gICAgLy8gQW55IHRpbWUgdGhlIG51bWJlciBvZiBjb21wb25lbnRzIGNoYW5nZXMsXHJcbiAgICAvLyByZXNldCBhbnkgaW5pdGlhbCwgcG9zc2libHkgaW5jb3JyZWN0IHN0YXRlIHRoZXkgbWlnaHQgaGF2ZSBoYWQsIGp1c3QgaW4gY2FzZS5cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gTWF0aC5zaWduKGxlbmd0aCAtIGdldFByZXZDaGlsZENvdW50KCkpO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24gIT09IDApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGdldFByZXZDaGlsZENvdW50KCkgPz8gMDsgaSAhPSBsZW5ndGg7IGkgKz0gZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRGbGFnKGksIGkgPT09IGFjdGl2YXRlZEluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRQcmV2Q2hpbGRDb3VudChsZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtzZXRGbGFnLCBhY3RpdmF0ZWRJbmRleCwgbGVuZ3RoXSk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIC8vIERlYWN0aXZhdGUgdGhlIHByZXZpb3VzbHkgYWN0aXZhdGVkIGNvbXBvbmVudFxyXG4gICAgICAgIGNvbnN0IHByZXZBY3RpdmF0ZWRJbmRleCA9IGdldFByZXZBY3RpdmF0ZWRJbmRleCgpO1xyXG4gICAgICAgIGlmIChwcmV2QWN0aXZhdGVkSW5kZXggIT0gYWN0aXZhdGVkSW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKHByZXZBY3RpdmF0ZWRJbmRleCAhPSBudWxsICYmIHByZXZBY3RpdmF0ZWRJbmRleCA+PSAwICYmIHByZXZBY3RpdmF0ZWRJbmRleCA8IGxlbmd0aClcclxuICAgICAgICAgICAgICAgIHNldEZsYWcocHJldkFjdGl2YXRlZEluZGV4LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFjdGl2YXRlIHRoZSBjdXJyZW50IGNvbXBvbmVudFxyXG4gICAgICAgIGlmIChhY3RpdmF0ZWRJbmRleCAhPSBudWxsICYmIGFjdGl2YXRlZEluZGV4ID49IDAgJiYgYWN0aXZhdGVkSW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgc2V0RmxhZyhhY3RpdmF0ZWRJbmRleCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHNldFByZXZBY3RpdmF0ZWRJbmRleChhY3RpdmF0ZWRJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3NldEZsYWcsIGFjdGl2YXRlZEluZGV4LCBsZW5ndGhdKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtY2hpbGQtbWFuYWdlci5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VDaGlsZE1hbmFnZXIsIHVzZUNoaWxkRmxhZyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGEgcm92aW5nIHRhYmluZGV4IHN5c3RlbSB3aGVyZSBvbmx5IG9uZSBcImZvY3VzYWJsZVwiXHJcbiAqIGNvbXBvbmVudCBpbiBhIHNldCBpcyBhYmxlIHRvIHJlY2VpdmUgYSB0YWIgZm9jdXMuICpXaGljaCpcclxuICogb2YgdGhvc2UgZWxlbWVudHMgcmVjZWl2ZXMgZm9jdXMgaXMgZGV0ZXJtaW5lZCBieSB5b3UsIGJ1dCBpdCdzXHJcbiAqIHJlY29tbWVuZGVkIHRvIG9mZmxvYWQgdGhhdCBsb2dpYyB0aGVuIHRvIGFub3RoZXIgaG9vaywgbGlrZVxyXG4gKiBgdXNlTGluZWFyTmF2aWdhdGlvbmAsIHdoaWNoIGxldHMgeW91IGNoYW5nZSB0aGUgdGFiYmFibGVcclxuICogZWxlbWVudCB3aXRoIHRoZSBhcnJvdyBrZXlzLCBgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbmAsIHdoaWNoXHJcbiAqIGxldHMgeW91IGNoYW5nZSB0aGUgdGFiYmFibGUgaW5kZXggd2l0aCB0eXBlYWhlYWQsIG9yXHJcbiAqIGB1c2VMaXN0TmF2aWdhdGlvbmAgaWYgeW91IGp1c3Qgd2FudCBldmVyeXRoaW5nIGJ1bmRsZWQgdG9nZXRoZXIuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgY2hpbGQgaG9vayByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZFxyXG4gKiBieSBldmVyeSBjaGlsZCB0aGF0IHVzZXMgdGhpcyByb3ZpbmcgdGFiaW5kZXggbG9naWMuICBUaGVcclxuICogcHJvcC1tb2RpZnlpbmcgaG9vayAqdGhhdCogaG9vayByZXR1cm5zIHNob3VsZCB0aGVuIGJlIHVzZWRcclxuICogb24gdGhlIGNoaWxkJ3MgZWxlbWVudCwgYXMgd2VsbCBhcyBhbnkgb3RoZXIgZWxlbWVudHMgeW91J2QgbGlrZVxyXG4gKiB0byBiZSBleHBsaWNpdGx5IG1hZGUgdW50YWJiYWJsZSB0b28uXHJcbiAqXHJcbiAqIGBmb2N1c09uQ2hhbmdlYCBzaG91bGQgYmUgc2V0IHRvIHRydWUgaWYgZm9jdXMgaXNcclxuICogY29udGFpbmVkIHdpdGhpbiB3aGF0ZXZlciBlbGVtZW50IGNvbnRhaW5zIHRoZSByb3ZpbmcgdGFiIGluZGV4LlxyXG4gKiBHZW5lcmFsbHkgYXMgc2ltcGxlIGFzIHRoZSBmb2xsb3dpbmc6XHJcbiAqIGBgYFxyXG4gKiBjb25zdCB7IGZvY3VzZWQsIGZvY3VzZWRJbm5lciwgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8UGFyZW50RWxlbWVudD4oKTtcclxuICogY29uc3QgZm9jdXNPbkNoYW5nZSA9IChmb2N1c2VkSW5uZXIgIT0gZmFsc2UpO1xyXG4gKiBgYGBcclxuICogSXQncyBub3QgaW5jbHVkZWQgaGVyZSBiZWNhdXNlIGB1c2VSb3ZpbmdUYWJJbmRleGAgZG9lc24ndCBrbm93XHJcbiAqIGFueXRoaW5nIGFib3V0IHRoZSBjb250YWluZXIgZWxlbWVudCwgb25seSBjaGlsZHJlbiBlbGVtZW50cy5cclxuICogQW5kIGp1c3QgYXMgd2VsbCEgQ2hpbGRyZW4gc2hvdWxkIGJlIGFsbG93ZWQgYXQgdGhlIHJvb3QsXHJcbiAqIHJlZ2FyZGxlc3Mgb2YgaWYgaXQncyB0aGUgd2hvbGUgYXBwIG9yIGp1c3QgYSBnaXZlbiBjb21wb25lbnQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXgoeyBmb2N1c09uQ2hhbmdlOiBmb2MsIHRhYmJhYmxlSW5kZXggfSkge1xyXG4gICAgY29uc3QgW3JlcmVuZGVyQW5kRm9jdXMsIHNldFJlcmVuZGVyQW5kRm9jdXNdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBnZXRGb2N1c09uQ2hhbmdlID0gdXNlU3RhYmxlR2V0dGVyKGZvYyk7XHJcbiAgICBjb25zdCBnZXRUYWJiYWJsZUluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKHRhYmJhYmxlSW5kZXgpO1xyXG4gICAgY29uc3QgcHJldlRhYmJhYmxlID0gdXNlUmVmKC1JbmZpbml0eSk7XHJcbiAgICAvLyBDYWxsIHRoZSBob29rIHRoYXQgYWxsb3dzIHVzIHRvIGNvbGxlY3QgaW5mb3JtYXRpb24gZnJvbSBjaGlsZHJlbiB3aG8gcHJvdmlkZSBpdFxyXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW4sIGNoaWxkQ291bnQsIHVzZU1hbmFnZWRDaGlsZCwgaW5kaWNlc0J5RWxlbWVudCwgLi4ucmVzdCB9ID0gdXNlQ2hpbGRNYW5hZ2VyKCk7XHJcbiAgICAvLyBBbnkgdGltZSB0aGUgdGFiYmFibGUgaW5kZXggY2hhbmdlcyxcclxuICAgIC8vIG5vdGlmeSB0aGUgcHJldmlvdXMgY2hpbGQgdGhhdCBpdCdzIG5vIGxvbmdlciB0YWJiYWJsZSxcclxuICAgIC8vIGFuZCBub3RpZnkgdGhlIG5leHQgY2hpbGQgdGhhdCBpcyBhbGxvd2VkIHRvIGJlIHRhYmJlZCB0by5cclxuICAgIHVzZUNoaWxkRmxhZyh0YWJiYWJsZUluZGV4LCBjaGlsZENvdW50LCAoaW5kZXgsIHRhYmJhYmxlKSA9PiB7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpXHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbltpbmRleF0/LnNldFRhYmJhYmxlKHRhYmJhYmxlKTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmICh0YWJiYWJsZUluZGV4ICE9IG51bGwpXHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlblt0YWJiYWJsZUluZGV4XS5zZXRUYWJiYWJsZSh0cnVlKTtcclxuICAgIH0sIFt0YWJiYWJsZUluZGV4XSk7XHJcbiAgICBjb25zdCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkID0gdXNlQ2FsbGJhY2soKGluZm8pID0+IHtcclxuICAgICAgICBjb25zdCBbcnJhZkluZGV4LCBzZXRScmFmSW5kZXhdID0gdXNlU3RhdGUoMSk7XHJcbiAgICAgICAgY29uc3QgcmVyZW5kZXJBbmRGb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHsgc2V0UnJhZkluZGV4KGkgPT4gKytpKTsgfSwgW10pO1xyXG4gICAgICAgIGxldCBuZXdJbmZvID0ge1xyXG4gICAgICAgICAgICAuLi5pbmZvLFxyXG4gICAgICAgICAgICByZXJlbmRlckFuZEZvY3VzLFxyXG4gICAgICAgICAgICBzZXRUYWJiYWJsZTogdXNlQ2FsbGJhY2soKHRhYmJhYmxlKSA9PiB7IHNldFRhYmJhYmxlKHRhYmJhYmxlKTsgfSwgW10pXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIGdldEVsZW1lbnQsIHVzZU1hbmFnZWRDaGlsZFByb3BzIH0gPSB1c2VNYW5hZ2VkQ2hpbGQobmV3SW5mbyk7XHJcbiAgICAgICAgLy8gVE9ETzogVXNpbmcgZ2V0VGFiYmFibGVJbmRleCBkdXJpbmcgcmVuZGVyIHBoYXNlIG9uIG1vdW50XHJcbiAgICAgICAgY29uc3QgW3RhYmJhYmxlLCBzZXRUYWJiYWJsZV0gPSB1c2VTdGF0ZShnZXRUYWJiYWJsZUluZGV4KCkgPT0gaW5mby5pbmRleCk7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgdGFiYmFibGUpIHtcclxuICAgICAgICAgICAgICAgIHNldFJlcmVuZGVyQW5kRm9jdXMoXyA9PiByZXJlbmRlckFuZEZvY3VzKTtcclxuICAgICAgICAgICAgICAgIGlmIChnZXRGb2N1c09uQ2hhbmdlKCkgJiYgXCJmb2N1c1wiIGluIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW2VsZW1lbnQsIHRhYmJhYmxlLCBycmFmSW5kZXhdKTtcclxuICAgICAgICBmdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleFNpYmxpbmdQcm9wcyh7IHRhYkluZGV4LCAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgIGlmICh0YWJJbmRleCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFiYmFibGUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoeyB0YWJJbmRleCB9LCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyh7IHRhYkluZGV4LCAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgIGlmICh0YWJJbmRleCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFiYmFibGUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkodXNlTWFuYWdlZENoaWxkUHJvcHMoeyB0YWJJbmRleCB9KSwgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzLFxyXG4gICAgICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleFNpYmxpbmdQcm9wcyxcclxuICAgICAgICAgICAgdGFiYmFibGVcclxuICAgICAgICB9O1xyXG4gICAgfSwgW3VzZU1hbmFnZWRDaGlsZF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLFxyXG4gICAgICAgIGNoaWxkQ291bnQsXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIGluZGljZXNCeUVsZW1lbnQsXHJcbiAgICAgICAgZm9jdXNDdXJyZW50OiByZXJlbmRlckFuZEZvY3VzLFxyXG4gICAgICAgIC4uLnJlc3RcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXJvdmluZy10YWJpbmRleC5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcbmltcG9ydCB7IHVzZVJvdmluZ1RhYkluZGV4IH0gZnJvbSBcIi4vdXNlLXJvdmluZy10YWJpbmRleFwiO1xyXG5pbXBvcnQgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcclxuLyoqXHJcbiAqXHJcbiAqIFRPRE86IFRoaXMgdGFibGUgd2FzIHNjcmFwcGVkIHdoZW4gdGhpcyB3YXMgY2hhbmdlZCB0byBqdXN0IGFjY2VwdCBhIGNvbGxhdG9yIGRpcmVjdGx5LFxyXG4gKiBidXQgaXQncyBub3QgYmFkIGZvciBhIGNvbGxhdGlvbiBjcmFzaCBjb3Vyc2UgYW5kIEkgbWlnaHQgdXNlIGl0IGFnYWluLlxyXG4gKiBFdmVuIGp1c3QgYXMgYSBcInRoaXMgaXMgd2h5IGl0J3MgaW1wb3J0YW50IGFuZCBnb29kIHRvIHVzZSB0aGVzZSB0aGluZ3NcIiB0aGluZy5cclxuICpcclxuICogfExhbmcufFRhcmdldHxVc2VyIGlucHV0fGBiYXNlYHxgYWNjZW50YHxgY2FzZWB8YHZhcmlhbnRgfFxyXG4gKiB8LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXxcclxuICogfEVOfEhpfEhpfOKchXzinIV84pyFfOKchXxcclxuICogfEVOfEhpfO+8qO+9iXzinIV84pyFfOKchXzinYx8XHJcbiAqIHxFTnxIaXxoaXzinIV84pyFfOKdjHzinYx8XHJcbiAqIHxFTnxIaXxIw6984pyFfOKdjHzinYx84p2MfFxyXG4gKiB8RU58SGl8QnllfOKdjHzinYx84p2MfOKdjHxcclxuICogfERBfMOlfGFhfOKchXzinIV84pyFfOKdjHxcclxuICogfERBfMOlfEFBfOKchXzinIV84p2MfOKdjHxcclxuICogfERBfMOlfEFhfOKchXzinIV84p2MfOKdjHxcclxuICogfEVOfMOlfGFhfOKdjHzinYx84p2MfOKdjHxcclxuICogfERBfMOlfGFBfOKdjHzinYx84p2MfOKdjHxcclxuICogfEVOfMOlfGF84pyFfOKchXzinYx84p2MfFxyXG4gKiB8REF8w6V8YXzinIV84pyFfOKdjHzinYx8XHJcbiAqIHxKUHzvqqp8552AfOKchXzinIV84pyFfOKchXxcclxuICogfEpQfOOCq3zvvbZ84pyFfOKchXzinIV84pyFfFxyXG4gKiB8SlB844KrfOOBi3zinIV84pyFfOKchXzinYx8XHJcbiAqIHxKUHzjgqt844O1fOKchXzinIV84pyFfOKdjHxcclxuICogfEpQfOOCq3zji5V84pyFfOKchXzinYx84p2MfFxyXG4gKiB8SlB844KrfOOCrHzinIV84p2MfOKdjHzinYx8XHJcbiAqIHxKUHzjgqt85YqbfOKdjHzinYx84p2MfOKdjHxcclxuICogfFpIfOe0hXznuqJ84p2MfOKdjHzinYx84p2MfFxyXG4gKlxyXG4gKlxyXG4gKiAoTm90ZSB0byBzZWxmOiBBdCBzb21lIHBvaW50LCB0aGlzIGZpbGUgd2lsbCBwcm9iYWJseSBiZSBub3JtYWxpemVkXHJcbiAqIGJ5IHNvbWVib2R5IGFuZCDvqqogd2lsbCB0dXJuIGJhY2sgaW50byDnnYAuKVxyXG4gKlxyXG4gKi9cclxuY29uc3QgZHVtbXkgPSBudWxsO1xyXG4vKipcclxuICogSW1wbGVtZW50cyBwcm9wZXIga2V5Ym9hcmQgbmF2aWdhdGlvbiBmb3IgY29tcG9uZW50cyBsaWtlIGxpc3Rib3hlcywgYnV0dG9uIGdyb3VwcywgbWVudXMsIGV0Yy5cclxuICpcclxuICogSW4gdGhlIGRvY3VtZW50IG9yZGVyLCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIFwiZm9jdXNlZFwiIG9yIFwidGFiYmFibGVcIiBlbGVtZW50LCBtYWtpbmcgaXQgYWN0IG1vcmUgbGlrZSBvbmUgY29tcGxldGUgdW5pdCBpbiBjb21wYXJpc29uIHRvIGV2ZXJ5dGhpbmcgYXJvdW5kIGl0LlxyXG4gKiBOYXZpZ2F0aW5nIGZvcndhcmRzL2JhY2t3YXJkcyBjYW4gYmUgZG9uZSB3aXRoIHRoZSBhcnJvdyBrZXlzLCBIb21lL0VuZCBrZXlzLCBvciBhbnkgYW55IHRleHQgZm9yIHR5cGVhaGVhZCB0byBmb2N1cyB0aGUgbmV4dCBpdGVtIHRoYXQgbWF0Y2hlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbih7IGluaXRpYWxJbmRleCwgZm9jdXNPbkNoYW5nZSwgY29sbGF0b3IsIGtleU5hdmlnYXRpb24gfSkge1xyXG4gICAga2V5TmF2aWdhdGlvbiA/Pz0gXCJlaXRoZXJcIjtcclxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhyZWUgdGhpbmdzIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnRseSB0YWJiYWJsZSBlbGVtZW50J3MgaW5kZXg6XHJcbiAgICAvLyBXaGF0IGl0IGlzLCBhbmQgd2hldGhlciwgd2hlbiB3ZSByZW5kZXIgdGhpcyBjb21wb25lbnQgYW5kIGl0J3MgY2hhbmdlZCwgdG8gYWxzbyBmb2N1cyB0aGUgZWxlbWVudCB0aGF0IHdhcyBtYWRlIHRhYmJhYmxlLlxyXG4gICAgY29uc3QgW3RhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXgsIGdldFRhYmJhYmxlSW5kZXhdID0gdXNlU3RhdGUoaW5pdGlhbEluZGV4ID09PSB1bmRlZmluZWQgPyAwIDogaW5pdGlhbEluZGV4KTtcclxuICAgIGNvbnN0IHNldEluZGV4ID0gdXNlQ2FsbGJhY2soKGluZGV4KSA9PiB7XHJcbiAgICAgICAgc2V0VGFiYmFibGVJbmRleChpbmRleCk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbiwgaW5kaWNlc0J5RWxlbWVudCwgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgZm9jdXNDdXJyZW50LCAuLi5yZXN0IH0gPSB1c2VSb3ZpbmdUYWJJbmRleCh7IGZvY3VzT25DaGFuZ2UsIHRhYmJhYmxlSW5kZXggfSk7XHJcbiAgICBjb25zdCB7IGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQsIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCB9ID0gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbih7IGNvbGxhdG9yLCBnZXRJbmRleDogZ2V0VGFiYmFibGVJbmRleCwgc2V0SW5kZXgsIHR5cGVhaGVhZFRpbWVvdXQ6IDEwMDAgfSk7XHJcbiAgICBjb25zdCB7IG5hdmlnYXRlVG9FbmQsIG5hdmlnYXRlVG9JbmRleCwgbmF2aWdhdGVUb05leHQsIG5hdmlnYXRlVG9QcmV2LCBuYXZpZ2F0ZVRvU3RhcnQsIHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZCB9ID0gdXNlTGluZWFyTmF2aWdhdGlvbih7IG5hdmlnYXRpb25EaXJlY3Rpb246IGtleU5hdmlnYXRpb24sIGdldEluZGV4OiBnZXRUYWJiYWJsZUluZGV4LCBzZXRJbmRleCwgbWFuYWdlZENoaWxkcmVuIH0pO1xyXG4gICAgY29uc3QgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCA9IHVzZUNhbGxiYWNrKChpbmZvKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkKGluZm8pO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkUHJvcHMgfSA9IHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZCgpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzLCB1c2VSb3ZpbmdUYWJJbmRleFNpYmxpbmdQcm9wcywgdGFiYmFibGUgfSA9IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQoaW5mbyk7XHJcbiAgICAgICAgY29uc3QgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzID0gZnVuY3Rpb24gKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHModXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUHJvcHModXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkUHJvcHMoeyBvbkNsaWNrOiByb3ZlVG9TZWxmIH0pKSksIHByb3BzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJvdmVUb1NlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7IG5hdmlnYXRlVG9JbmRleChpbmZvLmluZGV4KTsgfSwgW10pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyxcclxuICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaWJsaW5nUHJvcHM6IHVzZVJvdmluZ1RhYkluZGV4U2libGluZ1Byb3BzLFxyXG4gICAgICAgICAgICB0YWJiYWJsZSxcclxuICAgICAgICAgICAgLy9yb3ZlVG9TZWxmLFxyXG4gICAgICAgICAgICAvL2VsZW1lbnRcclxuICAgICAgICB9O1xyXG4gICAgfSwgW3VzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCwgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkLCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCBuYXZpZ2F0ZVRvSW5kZXhdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxyXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQsXHJcbiAgICAgICAgdGFiYmFibGVJbmRleCxcclxuICAgICAgICBzZXRUYWJiYWJsZUluZGV4LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcclxuICAgICAgICBpbmRpY2VzQnlFbGVtZW50LFxyXG4gICAgICAgIG5hdmlnYXRlVG9JbmRleCxcclxuICAgICAgICBuYXZpZ2F0ZVRvTmV4dCxcclxuICAgICAgICBuYXZpZ2F0ZVRvUHJldixcclxuICAgICAgICBuYXZpZ2F0ZVRvU3RhcnQsXHJcbiAgICAgICAgbmF2aWdhdGVUb0VuZCxcclxuICAgICAgICBmb2N1c0N1cnJlbnQsXHJcbiAgICAgICAgLi4ucmVzdFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbGlzdC1uYXZpZ2F0aW9uLmpzLm1hcCIsImltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuLyoqXHJcbiAqXHJcbiAqIFRoZXJlIGFyZSBzZXZlcmFsIGRpZmZlcmVudCB3YXlzIHRoYXQgYSBmb2N1cyBldmVudCBjYW4gaGFwcGVuLiAgQXNzdW1lXHJcbiAqIHRoZSBmb2xsb3dpbmcgc3RlcHMgaGFwcGVuIGluIG9yZGVyOlxyXG4gKlxyXG4gKiAxLiBUaGUgcGFnZSBsb2Fkcy5cclxuICogICAgKiBOb3RoaW5nIGlzIGZvY3VzZWQsIGJ1dCBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYGJvZHlgLlxyXG4gKiAgICAqIE5vIGZvY3VzIGV2ZW50cyBhcmUgZmlyZWQuXHJcbiAqIDIuIFRoZSB3aW5kb3cgaXMgZm9jdXNlZCwgYW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXHJcbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCByZW1haW5zIGFzIGBib2R5YC5cclxuICogICAgKiBBIGBmb2N1c2AvYGZvY3VzaW5gIGV2ZW50ICpNSUdIVCogYmUgZmlyZWQgZm9yIGBib2R5YC4gRGVwZW5kaW5nIG9uXHJcbiAqICAgICAgdGhlIGJyb3dzZXIsIHRoaXMgZGVwZW5kcyBvbiB3aGV0aGVyIHRoZSBoYW5kbGVyIHdhcyBhdHRhY2hlZCB0byBgd2luZG93YCBvciBgZG9jdW1lbnRgLlxyXG4gKiAgICAgIFByb2JhYmx5IGp1c3QgYmVzdCB0byBub3QgcmVseSBvbiBpdCwgb3IgbGlzdGVuIHRvIGB3aW5kb3dgIGZvY3VzIGV2ZW50cyBkaXJlY3RseS5cclxuICogMy4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXHJcbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gdGhlIG5ldyBlbGVtZW50IGJlZm9yZSBhbnkgZXZlbnQgZXZlbiBmaXJlcy5cclxuICogICAgKiBgZm9jdXNvdXRgIGFuZCBgYmx1cmAgYXJlICpub3QqIGZpcmVkIG9uIGBib2R5YC5cclxuICogICAgKiBgZm9jdXNgIGFuZCBgZm9jdXNpbmAgYXJlIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwuXHJcbiAqIDQuIEEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgZXRjLlxyXG4gKiAgICAqICoqVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gdGhlIGBib2R5YCoqIGJlZm9yZSBhbnkgZXZlbnQgZXZlbiBmaXJlcy5cclxuICogICAgKiBgYmx1cmAgYW5kIGBmb2N1c291dGAgYXJlIGZpcmVkIG9uIHRoZSBvbGQgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBuZXcgZWxlbWVudC5cclxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIG5vdyBzZXQgdG8gdGhlIG5ldyBlbGVtZW50LlxyXG4gKiAgICAqIGBmb2N1c2luYCBpcyBmaXJlZCBvbiB0aGUgbmV3IGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyB0aGUgb2xkIGVsZW1lbnQuXHJcbiAqIDUuIEFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxyXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIGBib2R5YC5cclxuICogICAgKiBgYmx1cmAgYW5kIGBmb2N1c291dGAgYXJlIGZpcmVkIG9uIHRoZSBvbGQgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwuXHJcbiAqICAgICogYGZvY3VzaW5gIGlzICpub3QqIGZpcmVkIG9uIGBib2R5YC5cclxuICpcclxuICpcclxuICogSW4gc3VtbWFyeTpcclxuICogMS4gRm9jdXMgZXZlbnRzICpkbyogbm90aWZ5IHVzIG9mIGFsbCBjaGFuZ2VzIGluIGZvY3VzLCBidXQgdGhlcmUgaXMgbm8gb25lIHNpbmdsZSBjb21wcmVoZW5zaXZlIGV2ZW50IHRoYXQgcHJvdmlkZXMgdXMgd2l0aCBhbGwgYXZhaWxhYmxlIGluZm9ybWF0aW9uLlxyXG4gKiAyLiBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgKmlzIG5vdCogYWx3YXlzIHRoZSBzYW1lIGFzIHdoYXQncyBiZWluZyByZWZlcmVuY2VkIGJ5IGEgZm9jdXMgZXZlbnQuIEluIHBhcnRpY3VsYXIsIGl0IG1heSBiZWNvbWUgYGJvZHlgIGF0IGFueSBhcmJpdHJhcnkgdGltZS5cclxuICogMy4gQSBgYmx1cmAgd2l0aG91dCBhIGBmb2N1c2AgY2FuIGFuZCB3aWxsIG9jY3VyLiBUaGlzIG1lYW5zIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBzb2xlbHkgdXNlIGBmb2N1c2AgdG8gZGV0ZWN0IGFsbCBjaGFuZ2VzLlxyXG4gKiA0LiBBIGBibHVyYCBldmVudCB3aG9zZSBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIGZvbGxvd2luZyBgZm9jdXNgIGV2ZW50LlxyXG4gKlxyXG4gKlxyXG4gKiBAcGFyYW0gY2FsbGJhY2tcclxuICogQHJldHVybnNcclxuICovXHJcbmxldCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCA9IG51bGw7XHJcbmxldCBsYXN0Rm9jdXNlZEVsZW1lbnQgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXRMYXN0Rm9jdXNlZEVsZW1lbnQoKSB7XHJcbiAgICByZXR1cm4gbGFzdEZvY3VzZWRFbGVtZW50O1xyXG59XHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRseUZvY3VzZWRFbGVtZW50KCkge1xyXG4gICAgcmV0dXJuIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50O1xyXG59XHJcbmNvbnN0IHVwZGF0ZXJzID0gbmV3IFNldCgpO1xyXG5mdW5jdGlvbiBmb2N1c291dChlKSB7XHJcbiAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ID09IG51bGwpIHtcclxuICAgICAgICBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQgZiBvZiB1cGRhdGVycykge1xyXG4gICAgICAgICAgICBmKHsgY3VycmVudDogY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQsIGxhc3Q6IGxhc3RGb2N1c2VkRWxlbWVudCwgd2luZG93Rm9jdXNlZCB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBKdXN0IHdhaXQgZm9yIHRoZSBmb2N1c2luIGV2ZW50LlxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZvY3VzaW4oZSkge1xyXG4gICAgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQgPSBsYXN0Rm9jdXNlZEVsZW1lbnQgPSBlLnRhcmdldDtcclxuICAgIGZvciAobGV0IGYgb2YgdXBkYXRlcnMpIHtcclxuICAgICAgICBmKHsgY3VycmVudDogY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQsIGxhc3Q6IGxhc3RGb2N1c2VkRWxlbWVudCwgd2luZG93Rm9jdXNlZCB9KTtcclxuICAgIH1cclxufVxyXG5sZXQgd2luZG93Rm9jdXNlZCA9IHRydWU7XHJcbmZ1bmN0aW9uIHdpbmRvd0ZvY3VzKCkge1xyXG4gICAgd2luZG93Rm9jdXNlZCA9IHRydWU7XHJcbiAgICBmb3IgKGxldCBmIG9mIHVwZGF0ZXJzKSB7XHJcbiAgICAgICAgZih7IGN1cnJlbnQ6IGN1cnJlbnRseUZvY3VzZWRFbGVtZW50LCBsYXN0OiBsYXN0Rm9jdXNlZEVsZW1lbnQsIHdpbmRvd0ZvY3VzZWQgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gd2luZG93Qmx1cigpIHtcclxuICAgIHdpbmRvd0ZvY3VzZWQgPSBmYWxzZTtcclxuICAgIGZvciAobGV0IGYgb2YgdXBkYXRlcnMpIHtcclxuICAgICAgICBmKHsgY3VycmVudDogY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQsIGxhc3Q6IGxhc3RGb2N1c2VkRWxlbWVudCwgd2luZG93Rm9jdXNlZCB9KTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aXZlRWxlbWVudChmaWx0ZXIpIHtcclxuICAgIGNvbnN0IFtpLCBzZXRJXSA9IHVzZVN0YXRlKDApO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBGID0gKGluZm8pID0+IHtcclxuICAgICAgICAgICAgaWYgKGZpbHRlciA9PSBudWxsIHx8IGZpbHRlcihpbmZvKSlcclxuICAgICAgICAgICAgICAgIHNldEkoaSA9PiArK2kpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHVwZGF0ZXJzLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbiwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZm9jdXNvdXQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cywgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1ciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVycy5hZGQoRik7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgdXBkYXRlcnMuZGVsZXRlKEYpO1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlcnMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbik7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZm9jdXNvdXQpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cyk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW2ZpbHRlcl0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhY3RpdmVFbGVtZW50OiBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCxcclxuICAgICAgICBsYXN0QWN0aXZlRWxlbWVudDogbGFzdEZvY3VzZWRFbGVtZW50LFxyXG4gICAgICAgIGdldEFjdGl2ZUVsZW1lbnQ6IGdldEN1cnJlbnRseUZvY3VzZWRFbGVtZW50LFxyXG4gICAgICAgIGdldExhc3RBY3RpdmVFbGVtZW50OiBnZXRMYXN0Rm9jdXNlZEVsZW1lbnQsXHJcbiAgICAgICAgd2luZG93Rm9jdXNlZFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtYWN0aXZlLWVsZW1lbnQuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlTWVtbyB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCB9IGZyb20gXCIuL3VzZS1hY3RpdmUtZWxlbWVudFwiO1xyXG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VIYXNGb2N1cyh7fSA9IHt9KSB7XHJcbiAgICAvLyBUaGVzZSBhcmUgc2xpZ2h0bHkgcmVkdW5kYW50LCBidXQgYW55IHRpbWUgdGhlIGZvY3VzIGNoYW5nZXMsIHdlIG5lZWQgdG8ga25vdyBpZiBpdCdzIFwicmVsZXZhbnRcIiB0byB1cy5cclxuICAgIC8vIEl0J3MgXCJyZWxldmFudFwiIGlmIHRoZSBuZXdseS1mb2N1c2VkIGVsZW1lbnQgaXMgYSBjaGlsZCBvZiB1cyxcclxuICAgIC8vIE9SIGlmIHdlJ3JlIGZvY3VzZWQgYW5kIGZvY3VzIG1vdmVzIE9VVFNJREUgb2YgdXMgb3VyIG91ciBjaGlsZHJlbi5cclxuICAgIC8vIEJlY2F1c2Ugb2YgdGhhdCBzZWNvbmQgYml0LCB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hlcmUgdGhlIGZvY3VzIHdhcyB0aGUgbGFzdCB0aW1lIHdlIGNoZWNrZWQgZm9yIHRoZSBmaWx0ZXIuXHJcbiAgICBjb25zdCBbaGFzRm9jdXMsIHNldEhhc0ZvY3VzLCBnZXRIYXNGb2N1c10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaGFzTGFzdEZvY3VzLCBzZXRIYXNMYXN0Rm9jdXMsIGdldEhhc0xhc3RGb2N1c10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQsIGdldEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgY29uc3QgeyBhY3RpdmVFbGVtZW50LCBsYXN0QWN0aXZlRWxlbWVudCB9ID0gdXNlQWN0aXZlRWxlbWVudCh1c2VDYWxsYmFjaygoeyBjdXJyZW50LCBsYXN0LCB3aW5kb3dGb2N1c2VkIH0pID0+IHtcclxuICAgICAgICAvLyBLZWVwIGluIG1pbmQgdGhhdCBvbmNlIHdlIGdldCBvdXIgZWxlbWVudCwgZXZlbiBpZiB0aGUgaG9vayBhbmQgZmlsdGVyIGZ1bmN0aW9uc1xyXG4gICAgICAgIC8vIGRvbid0IHJlLXJ1biwgdGhlIGN1cnJlbnRseS1mb2N1c2VkIGVsZW1lbnQgd2lsbCBzdGlsbCBiZSByZXR1cm5lZCBiZWxvdywgYW5kLFxyXG4gICAgICAgIC8vIGV2ZW4gaWYgaXQncyBub3QgdXMgb3Igb25lIG9mIG91ciBjaGlsZHJlbiwgd2lsbCBzdGlsbCBiZSBzYWZlbHkgZmlsdGVyZWQgb3V0IGF0IHJlbmRlciB0aW1lLlxyXG4gICAgICAgIGxldCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgIGlmICghZWxlbWVudClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGxldCBoYXNGb2N1c05vdyA9IChlbGVtZW50LmNvbnRhaW5zKGN1cnJlbnQpIHx8IGVsZW1lbnQuY29udGFpbnMobGFzdCkpO1xyXG4gICAgICAgIGlmIChoYXNGb2N1c05vdykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBoYWRGb2N1c0JlZm9yZVRoaXMgPSAoZ2V0SGFzTGFzdEZvY3VzKCkgfHwgZ2V0SGFzRm9jdXMoKSk7XHJcbiAgICAgICAgICAgIGlmIChoYWRGb2N1c0JlZm9yZVRoaXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0cnVlIG9uY2UsIHNvIHRoYXQgdXNlQWN0aXZlRWxlbWVudCB3aWxsIHJldHVybiBvbmUgaW5zdGFuY2Ugb2YgYSBkaWZmZXJlbnQgZWxlbWVudCBoYXZpbmcgZm9jdXMuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVuLCBiYWNrIG91dHNpZGUgdGhpcyBmaWx0ZXIgZnVuY3Rpb24sIHdlJ2xsIGtub3cgdGhhdCB3ZSdyZSBubyBsb25nZXIgZm9jdXNlZC5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSkpO1xyXG4gICAgLy8gVGhlc2UgYXJlIHByaW1hcmlseSB1c2VkIGZvciBib29ra2VlcGluZyBkdXJpbmcgdGhlIGZpbHRlciBmdW5jdGlvbiBhYm92ZS5cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHNldEhhc0ZvY3VzKGVsZW1lbnQ/LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpID8/IGZhbHNlKTsgfSwgW2VsZW1lbnQsIGFjdGl2ZUVsZW1lbnRdKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHNldEhhc0xhc3RGb2N1cyhlbGVtZW50Py5jb250YWlucyhsYXN0QWN0aXZlRWxlbWVudCkgPz8gZmFsc2UpOyB9LCBbZWxlbWVudCwgbGFzdEFjdGl2ZUVsZW1lbnRdKTtcclxuICAgIGNvbnN0IHVzZUhhc0ZvY3VzUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHMpID0+IHsgcmV0dXJuIHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wcyk7IH0sIFt1c2VSZWZFbGVtZW50UHJvcHNdKTtcclxuICAgIGNvbnN0IGZvY3VzZWQgPSB1c2VNZW1vKCgpID0+IHsgcmV0dXJuIGVsZW1lbnQgPT0gYWN0aXZlRWxlbWVudDsgfSwgW2VsZW1lbnQsIGFjdGl2ZUVsZW1lbnRdKTtcclxuICAgIGNvbnN0IGZvY3VzZWRJbm5lciA9IHVzZU1lbW8oKCkgPT4geyByZXR1cm4gZWxlbWVudD8uY29udGFpbnMoYWN0aXZlRWxlbWVudCkgPz8gZmFsc2U7IH0sIFtlbGVtZW50LCBhY3RpdmVFbGVtZW50XSk7XHJcbiAgICBjb25zdCBsYXN0Rm9jdXNlZCA9IHVzZU1lbW8oKCkgPT4geyByZXR1cm4gZWxlbWVudCA9PSBsYXN0QWN0aXZlRWxlbWVudDsgfSwgW2VsZW1lbnQsIGxhc3RBY3RpdmVFbGVtZW50XSk7XHJcbiAgICBjb25zdCBsYXN0Rm9jdXNlZElubmVyID0gdXNlTWVtbygoKSA9PiB7IHJldHVybiBlbGVtZW50Py5jb250YWlucyhsYXN0QWN0aXZlRWxlbWVudCkgPz8gZmFsc2U7IH0sIFtlbGVtZW50LCBsYXN0QWN0aXZlRWxlbWVudF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VIYXNGb2N1c1Byb3BzLFxyXG4gICAgICAgIGZvY3VzZWQsXHJcbiAgICAgICAgZm9jdXNlZElubmVyLFxyXG4gICAgICAgIGxhc3RGb2N1c2VkLFxyXG4gICAgICAgIGxhc3RGb2N1c2VkSW5uZXJcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWhhcy1mb2N1cy5qcy5tYXAiLCJpbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0TmF0aXZlLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbi8qKlxyXG4gKiBXcmFwIHRoZSBuYXRpdmUgYHVzZUVmZmVjdGAgdG8gYWRkIGFyZ3VtZW50c1xyXG4gKiB0aGF0IGFsbG93IGFjY2Vzc2luZyB0aGUgcHJldmlvdXMgdmFsdWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxyXG4gKiBhcyB3ZWxsIGFzIHRoZSBjaGFuZ2VzIHRoYXQgY2F1c2VkIHRoZSBob29rIHRvIGJlIGNhbGxlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWZmZWN0XHJcbiAqIEBwYXJhbSBpbnB1dHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VFZmZlY3QoZWZmZWN0LCBpbnB1dHMpIHtcclxuICAgIGNvbnN0IHByZXZJbnB1dHMgPSB1c2VSZWYoaW5wdXRzKTtcclxuICAgIGNvbnN0IGVmZmVjdDIgPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHByZXZJbnB1dHMuY3VycmVudC5sZW5ndGgsIGlucHV0cy5sZW5ndGgpOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHByZXZJbnB1dHMuY3VycmVudFtpXSAhPSBpbnB1dHNbaV0pXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzW2ldID0geyBmcm9tOiBwcmV2SW5wdXRzLmN1cnJlbnRbaV0sIHRvOiBpbnB1dHNbaV0gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmV0ID0gZWZmZWN0KHByZXZJbnB1dHMuY3VycmVudCwgY2hhbmdlcyk7XHJcbiAgICAgICAgcHJldklucHV0cy5jdXJyZW50ID0gaW5wdXRzO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9O1xyXG4gICAgdXNlRWZmZWN0TmF0aXZlKGVmZmVjdDIsIGlucHV0cyk7XHJcbn1cclxuO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtZWZmZWN0LmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtbGF5b3V0LWVmZmVjdFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlQ2hpbGRGbGFnLCB1c2VDaGlsZE1hbmFnZXIgfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xyXG5pbXBvcnQgeyB1c2VMaXN0TmF2aWdhdGlvbiB9IGZyb20gXCIuL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcclxuaW1wb3J0IHsgdXNlSGFzRm9jdXMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCIuL3VzZS1lZmZlY3RcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uKHsgZm9jdXNPbkNoYW5nZTogZm9jIH0pIHtcclxuICAgIGNvbnN0IGdldEZvY3VzQ2VsbE9uUm93Q2hhbmdlID0gdXNlU3RhYmxlR2V0dGVyKGZvYyk7XHJcbiAgICBjb25zdCBbY3VycmVudFJvdywgc2V0Q3VycmVudFJvdywgZ2V0Q3VycmVudFJvd10gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtsYXN0S25vd25DZWxsSW5kZXgsIHNldExhc3RLbm93bkNlbGxJbmRleCwgZ2V0TGFzdEtub3duQ2VsbEluZGV4XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgdXNlRWZmZWN0KChbcHJldl0pID0+IHsgY29uc29sZS5sb2coYGN1cnJlbnRSb3c6ICR7cHJldn0gLT4gJHtjdXJyZW50Um93fWApOyB9LCBbY3VycmVudFJvd10pO1xyXG4gICAgY29uc3QgeyBjaGlsZENvdW50LCBtYW5hZ2VkQ2hpbGRyZW4sIGluZGljZXNCeUVsZW1lbnQsIGdldE1vdW50SW5kZXgsIG1vdW50ZWRDaGlsZHJlbiwgdG90YWxDaGlsZHJlbk1vdW50ZWQsIHRvdGFsQ2hpbGRyZW5Vbm91bnRlZCwgdXNlTWFuYWdlZENoaWxkIH0gPSB1c2VDaGlsZE1hbmFnZXIoKTtcclxuICAgIGNvbnN0IHsgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkIH0gPSB1c2VMaW5lYXJOYXZpZ2F0aW9uKHsgbWFuYWdlZENoaWxkcmVuLCBnZXRJbmRleDogZ2V0Q3VycmVudFJvdywgc2V0SW5kZXg6IHNldEN1cnJlbnRSb3csIG5hdmlnYXRpb25EaXJlY3Rpb246IFwiYmxvY2tcIiB9KTtcclxuICAgIHVzZUNoaWxkRmxhZyhjdXJyZW50Um93LCBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoLCB1c2VDYWxsYmFjaygoaW5kZXgsIHRhYmJhYmxlKSA9PiBtYW5hZ2VkQ2hpbGRyZW5baW5kZXhdPy5zZXRJc1RhYmJhYmxlUm93KHRhYmJhYmxlLCBsYXN0S25vd25DZWxsSW5kZXgpLCBbbGFzdEtub3duQ2VsbEluZGV4LCBtYW5hZ2VkQ2hpbGRyZW5dKSk7XHJcbiAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvblJvdyA9IHVzZUNhbGxiYWNrKCh7IGluZGV4LCAuLi5pbmZvIH0pID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGxhc3RGb2N1c2VkSW5uZXIgfSA9IHVzZUhhc0ZvY3VzKCk7XHJcbiAgICAgICAgY29uc3QgW2lzVGFiYmFibGVSb3csIHNldElzVGFiYmFibGVSb3ddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgIC8vIEJlc2lkZXMganVzdCBiZWluZyBhIGxpc3QgbmF2IGNoaWxkLCBpdCdzIGFsc28gYSBsaXN0IG5hdiBwYXJlbnRcclxuICAgICAgICAvLyB5YWFhYXl5eVxyXG4gICAgICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogdXNlTGlzdE5hdmlnYXRpb25DaGlsZDIsIGNoaWxkQ291bnQ6IGNlbGxDb3VudCwgaW5kaWNlc0J5RWxlbWVudDogY2VsbEluZGljZXNCeUVsZW1lbnQsIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZENlbGxzLCBuYXZpZ2F0ZVRvSW5kZXg6IHNldENlbGxJbmRleCwgdGFiYmFibGVJbmRleDogdGFiYmFibGVDZWxsLCBmb2N1c0N1cnJlbnQgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uKHsgZm9jdXNPbkNoYW5nZTogKGlzVGFiYmFibGVSb3cgJiYgZ2V0Rm9jdXNDZWxsT25Sb3dDaGFuZ2UoKSksIGtleU5hdmlnYXRpb246IFwiaW5saW5lXCIsIGluaXRpYWxJbmRleDogbnVsbCB9KTtcclxuICAgICAgICAvLyBBbnkgdGltZSB3ZSBiZWNvbWUgdGhlIGN1cnJlbnRseSB0YWJiYWJsZSByb3csXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBjb3JyZWN0IGNlbGwgaXMgc2VsZWN0ZWQgYW5kIGZvY3VzZWQuXHJcbiAgICAgICAgLy8gQW55IG90aGVyIHRpbWUsIG1ha2Ugc3VyZSBubyBjZWxsIGlzIHRhYmJhYmxlLlxyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc1RhYmJhYmxlUm93KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDZWxsSW5kZXgoZ2V0TGFzdEtub3duQ2VsbEluZGV4KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0Q2VsbEluZGV4KG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW2lzVGFiYmFibGVSb3ddKTtcclxuICAgICAgICAvLyBBbnkgdGltZSB3ZSBiZWNvbWUgdGhlIGN1cnJlbnRseSB0YWJiYWJsZSByb3csXHJcbiAgICAgICAgLy8gcmVxdWVzdCB0aGUgY29tcG9uZW50IHJlcmVuZGVyIGFuZCBmb2N1cyBpdHNlbGYuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVGFiYmFibGVSb3cgJiYgZ2V0Rm9jdXNDZWxsT25Sb3dDaGFuZ2UoKSkge1xyXG4gICAgICAgICAgICAgICAgZm9jdXNDdXJyZW50Py4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtmb2N1c0N1cnJlbnQsIGlzVGFiYmFibGVSb3ddKTtcclxuICAgICAgICAvLyBBbnkgdGltZSB0aGUgY3VycmVudCBjZWxsIGNoYW5nZXMgXHJcbiAgICAgICAgLy8gKHByb2JhYmx5IGJlY2F1c2Ugd2UgaW50ZXJhY3RlZCB3aXRoIGl0LCB0aHVzIGZvY3VzaW5nIGl0LCBcclxuICAgICAgICAvLyBjaGFuZ2luZyBpdCBmcm9tIG51bGwgaWYgdGhlIHJvdyB3YXNuJ3QgYWxyZWFkeSBmb2N1c2VkKVxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHRoZSBjdXJyZW50bHkgdGFiYmFibGUgcm93IGlmIHdlIHdlcmVuJ3QgYWxyZWFkeS5cclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGFiYmFibGVDZWxsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRMYXN0S25vd25DZWxsSW5kZXgodGFiYmFibGVDZWxsKTtcclxuICAgICAgICAgICAgICAgIHNldElzVGFiYmFibGVSb3codHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50Um93KGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtpbmRleCwgdGFiYmFibGVDZWxsLCBzZXRMYXN0S25vd25DZWxsSW5kZXhdKTtcclxuICAgICAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZFByb3BzIH0gPSB1c2VNYW5hZ2VkQ2hpbGQoe1xyXG4gICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgc2V0SXNUYWJiYWJsZVJvdzogdXNlQ2FsbGJhY2soKHRhYmJhYmxlLCBuZXdJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhYmJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q2VsbEluZGV4KG5ld0luZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNldElzVGFiYmFibGVSb3codGFiYmFibGUpO1xyXG4gICAgICAgICAgICB9LCBbXSksXHJcbiAgICAgICAgICAgIC4uLmluZm9cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB7IHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZFByb3BzIH0gPSB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGQoKTtcclxuICAgICAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzKSA9PiB1c2VNYW5hZ2VkQ2hpbGRQcm9wcyh1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VIYXNGb2N1c1Byb3BzKHByb3BzKSkpLCBbdXNlTWFuYWdlZENoaWxkUHJvcHNdKTtcclxuICAgICAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvbkNlbGwgPSB1c2VDYWxsYmFjaygoeyBpbmRleCwgdGV4dCwgLi4uaW5mbyB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZDIoeyB0ZXh0LCBpbmRleCwgLi4uaW5mbyB9KTtcclxuICAgICAgICAgICAgY29uc3QgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHMpID0+IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcyksIFt1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHNdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdGFiYmFibGUsIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzIH07XHJcbiAgICAgICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQyXSk7XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcywgdXNlR3JpZE5hdmlnYXRpb25DZWxsLCBjZWxsQ291bnQsIHRhYmJhYmxlQ2VsbCwgaXNUYWJiYWJsZVJvdywgbWFuYWdlZENlbGxzIH07XHJcbiAgICB9LCBbc2V0TGFzdEtub3duQ2VsbEluZGV4LCB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGQsIHVzZU1hbmFnZWRDaGlsZF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvdyxcclxuICAgICAgICByb3dDb3VudDogY2hpbGRDb3VudCxcclxuICAgICAgICBjZWxsSW5kZXg6IGxhc3RLbm93bkNlbGxJbmRleCxcclxuICAgICAgICByb3dJbmRleDogY3VycmVudFJvdyxcclxuICAgICAgICBtYW5hZ2VkUm93czogbWFuYWdlZENoaWxkcmVuXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1ncmlkLW5hdmlnYXRpb24uanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG4vKipcclxuICogQWxsb3dzIGF0dGFjaGluZyBhbiBldmVudCBoYW5kbGVyIHRvIGFueSAqbm9uLVByZWFjdCogZWxlbWVudCwgYW5kIHJlbW92aW5nIGl0IHdoZW4gdGhlIGNvbXBvbmVudCB1c2luZyB0aGUgaG9vayB1bm1vdW50cy4gVGhlIGNhbGxiYWNrIGRvZXMgbm90IG5lZWQgdG8gYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxyXG4gKlxyXG4gKiBEdWUgdG8gdHlwaW5nIGxpbWl0YXRpb25zLCB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGxpa2UgdGhpczpcclxuICpcclxuICogYHVzZUV2ZW50SGFuZGxlcihlbGVtZW50LCBcImlucHV0XCIpPElucHV0RXZlbnQ+KGUgPT4ge30pYFxyXG4gKlxyXG4gKiBUaGUgdHlwZSBhcmd1bWVudCBpcyBvcHRpb25hbCwgYnV0IG5hcnJvd3MgZG93biB0aGUgdHlwZSBmcm9tIFwiYSB1bmlvbiBvZiBhbGwgZXZlbnRzXCIgdG8gd2hhdGV2ZXIgeW91IHNwZWNpZnksIGFuZCBlcnJvcnMgaWYgaXQgZG9lc24ndCBleGlzdC5cclxuICpcclxuICogVGhlcmUgaXMgYSBzZXBhcmF0ZSB2ZXJzaW9uIHRoYXQgYXR0YWNoZXMgZXZlbnQgaGFuZGxlcnMgdG8gYSBzZXQgb2YgcHJvcHMuXHJcbiAqIEl0IHRha2VzIGRpZmZlcmVudCBldmVudCBzdHJpbmcgdHlwZXMgKG9uRXZlbnQgdnMgb25ldmVudCkuXHJcbiAqXHJcbiAqIEBwYXJhbSB0YXJnZXQgQSAqbm9uLVByZWFjdCogbm9kZSB0byBhdHRhY2ggdGhlIGV2ZW50IHRvLlxyXG4gKiBAcmV0dXJuc1xyXG4gKiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlcih0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIC8vIE5vdGUgdG8gc2VsZjogVGhlIHR5cGluZyBkb2Vzbid0IGltcHJvdmUgZXZlbiBpZiB0aGlzIGlzIHNwbGl0IHVwIGludG8gYSBzdWItZnVuY3Rpb24uXHJcbiAgICAvLyBObyBtYXR0ZXIgd2hhdCwgaXQgc2VlbXMgaW1wb3NzaWJsZSB0byBnZXQgdGhlIGhhbmRsZXIncyBldmVudCBvYmplY3QgdHlwZWQgcGVyZmVjdGx5LlxyXG4gICAgLy8gSXQgc2VlbXMgbGlrZSBpdCdzIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIGEgdW5pb24gb2YgYWxsIGF2YWlsYWJsZSB0dXBlcy5cclxuICAgIC8vIEFnYWluLCBubyBtYXR0ZXIgd2hhdCBjb21iaW5hdGlvbiBvZiBzdWItIG9yIHN1Yi1zdWItZnVuY3Rpb25zIHVzZWQuXHJcbiAgICBsZXQgc3RhYmxlSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIgPz8gKCgpID0+IHsgfSkpO1xyXG4gICAgaWYgKGhhbmRsZXIgPT0gbnVsbClcclxuICAgICAgICBzdGFibGVIYW5kbGVyID0gbnVsbDtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbdGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyXSk7XHJcbn1cclxuLyoqXHJcbiAqIEFuIGFsdGVybmF0aXZlIHdheSB0byBhZGQgYW4gZXZlbnQgaGFuZGxlciB0byBhbiBlbGVtZW50LiBVc2VmdWwgcHJpbWFyaWx5IHdoZW4gaW50ZWdyYXRpbmcgM3JkIHBhcnR5IGxpYnJhcmllcyB0aGF0IGV4cGVjdCBhIGdlbmVyaWMgXCJhZGQgZXZlbnQgaGFuZGxlclwiIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgeW91IHRvIG1vZGlmeSBhIHNldCBvZiBwcm9wcyB0byBhcHBseSB0aGlzIGhhbmRsZXIuXHJcbiAqXHJcbiAqIEZvciB0eXBpbmcgcmVhc29ucywgdGhpcyBmdW5jdGlvbiBpcyBzcGxpdCBpbnRvIHR3by4gIFVzYWdlIGlzIGxpa2UgdGhlIGZvbGxvd2luZzpcclxuICpcclxuICogYGBgXHJcbiAqIGNvbnN0IHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9ID0gdXNlTG9jYWxFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+KCkoXCJvbk1vdXNlRG93blwiLCBlID0+IHsgIH0pO1xyXG4gKiBjb25zdCBkaXZQcm9wcyA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMocHJvcHMpO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbEhhbmRsZXIoKSB7XHJcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKHR5cGUsIGhhbmRsZXIpID0+IHtcclxuICAgICAgICBjb25zdCBzdGFibGVIYW5kbGVyID0gdXNlU3RhYmxlQ2FsbGJhY2soaGFuZGxlcik7XHJcbiAgICAgICAgY29uc3QgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wcykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IFt0eXBlXTogc3RhYmxlSGFuZGxlciB9LCBwcm9wcyk7XHJcbiAgICAgICAgfSwgW3R5cGVdKTtcclxuICAgICAgICByZXR1cm4geyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH07XHJcbiAgICB9LCBbXSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWV2ZW50LWhhbmRsZXIuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZUdsb2JhbEhhbmRsZXIgfSBmcm9tIFwiLi91c2UtZXZlbnQtaGFuZGxlclwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJvbUxvY2FsU3RvcmFnZSgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCBjb252ZXJ0ZXIgPSBKU09OLnBhcnNlKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgICAgIGlmICghaXRlbSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZXIoaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGRlYnVnZ2VyOyAvLyBJbnRlbnRpb25hbFxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlVG9Mb2NhbFN0b3JhZ2UoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNvbnZlcnRlciA9IEpTT04uc3RyaW5naWZ5KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBjb252ZXJ0ZXIodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZGVidWdnZXI7IC8vIEludGVudGlvbmFsXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdXNlUGVyc2lzdGVudFN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKChrZXksIGluaXRpYWxWYWx1ZSwgZnJvbVN0cmluZyA9IEpTT04ucGFyc2UsIHRvU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkpID0+IHtcclxuICAgICAgICBjb25zdCBbbG9jYWxDb3B5LCBzZXRMb2NhbENvcHksIGdldExvY2FsQ29weV0gPSB1c2VTdGF0ZShnZXRGcm9tTG9jYWxTdG9yYWdlKCkoa2V5LCBmcm9tU3RyaW5nKSA/PyBpbml0aWFsVmFsdWUpO1xyXG4gICAgICAgIC8vIExpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGlzIHN0b3JhZ2UgaW4gb3RoZXIgYnJvd3NlciB0YWJzXHJcbiAgICAgICAgdXNlR2xvYmFsSGFuZGxlcih3aW5kb3csIFwic3RvcmFnZVwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBlLm5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0TG9jYWxDb3B5KGZyb21TdHJpbmcobmV3VmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHNldFZhbHVlV3JhcHBlciA9IHVzZUNhbGxiYWNrKCh2YWx1ZU9yU2V0dGVyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIHZhbHVlT3JTZXR0ZXIgPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlT3JTZXR0ZXIoZ2V0TG9jYWxDb3B5KCkpIDogdmFsdWVPclNldHRlcjtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoaXMgdXBkYXRlIGlzIGF2YWlsYWJsZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIG5leHQgcmVuZGVyXHJcbiAgICAgICAgICAgIHNldExvY2FsQ29weSh2YWx1ZU9yU2V0dGVyKTtcclxuICAgICAgICAgICAgLy8gQWN0dWFsbHkgc2F2ZSB0aGUgdmFsdWUgdG8gbG9jYWwgc3RvcmFnZS5cclxuICAgICAgICAgICAgc3RvcmVUb0xvY2FsU3RvcmFnZSgpKGtleSwgdmFsdWUsIHRvU3RyaW5nKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoZnJvbVN0cmluZyAhPSBKU09OLnBhcnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtrZXksIHRvU3RyaW5nXSk7XHJcbiAgICAgICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRydWVWYWx1ZSA9IGdldEZyb21Mb2NhbFN0b3JhZ2UoKShrZXksIGZyb21TdHJpbmcpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVZhbHVlID8/IGxvY2FsQ29weTtcclxuICAgICAgICB9LCBba2V5LCBmcm9tU3RyaW5nXSk7XHJcbiAgICAgICAgcmV0dXJuIFtsb2NhbENvcHksIHNldFZhbHVlV3JhcHBlciwgZ2V0VmFsdWVdO1xyXG4gICAgfSwgW10pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1wZXJzaXN0ZW50LXN0YXRlLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG5jb25zdCBUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLVwiO1xyXG5mdW5jdGlvbiBiYXNlNjQodmFsdWUpIHtcclxuICAgIHJldHVybiBUYWJsZVt2YWx1ZV07XHJcbn1cclxuZnVuY3Rpb24gcmFuZG9tNkJpdHMoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMGIxMDAwMDAwKTtcclxufVxyXG5mdW5jdGlvbiByYW5kb202NEJpdHMoKSB7XHJcbiAgICByZXR1cm4gW3JhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCldO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIHdpdGggYW4gb3B0aW9uYWwgcHJlZml4LlxyXG4gKiBOb3RlIHRoYXQgaWYgdGhlIHByZWZpeCBpcyAqZXhwbGljaXRseSogc2V0IHRvIFwiXCIsIHRoZW5cclxuICogSURzIHRoYXQgYXJlIG5vdCB2YWxpZCB1bmRlciBIVE1MNCBtYXkgYmUgZ2VuZXJhdGVkLiBPaCBuby5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeCkge1xyXG4gICAgcmV0dXJuIGAke3ByZWZpeCA/PyBcImlkLVwifSR7cmFuZG9tNjRCaXRzKCkubWFwKG4gPT4gYmFzZTY0KG4pKS5qb2luKFwiXCIpfWA7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBob29rIHRoYXQgbW9kaWZpZXMgYSBzZXQgb2YgcHJvcHMgdG8gcHJvdmlkZSBhIHJhbmRvbWx5LWdlbmVyYXRlZCBJRCBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cclxuICpcclxuICogSWYgeW91J2QgbGlrZSB0byB1c2UgdGhlIElEIGluIGEgcHJvcGVydHkgdGhhdCdzICpub3QqIG5hbWVkIGBpZGAgKGxpa2UgYGZvcmAgb3IgYGFyaWEtbGFiZWxsZWRieWAgb3Igd2hhdG5vdCksIGB1c2VSZWZlcmVuY2VkSWRQcm9wc2AgaXMgYWxzbyBwcm92aWRlZC5cclxuICpcclxuICogQW5kIHRoZSByYW5kb21seS1nZW5lcmF0ZWQgaWQgaXRzZWxmIGlzIGFsc28gcHJvdmlkZWQgaW4gY2FzZSB5b3Ugd2FudCB0byBoYW5kbGUgdGhlIGxvZ2ljIHlvdXJzZWxmIHdpdGhvdXQgYHVzZU1lcmdlZFByb3BzYC5cclxuICpcclxuICogVW5saWtlIG1vc3Qgb3RoZXIgYHVzZSpQcm9wc2AgaG9va3MsIHRoZXNlIGFyZSBtb3N0bHkgc3RhYmxlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJhbmRvbUlkKHsgcHJlZml4IH0gPSB7fSkge1xyXG4gICAgY29uc3QgW3JhbmRvbUlkLCBzZXRSYW5kb21JZF0gPSB1c2VTdGF0ZSgoKSA9PiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeCkpO1xyXG4gICAgY29uc3QgW3dhdGNoUHJlZml4VXBkYXRlcywgc2V0V2F0Y2hQcmVmaXhVcGRhdGVzLCBnZXRXYXRjaFByZWZpeFVwZGF0ZXNdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCB3YXRjaFByZWZpeFVwZGF0ZXMgPSBnZXRXYXRjaFByZWZpeFVwZGF0ZXMoKTtcclxuICAgICAgICBpZiAod2F0Y2hQcmVmaXhVcGRhdGVzKVxyXG4gICAgICAgICAgICBzZXRSYW5kb21JZCgoKSA9PiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeCkpO1xyXG4gICAgICAgIHNldFdhdGNoUHJlZml4VXBkYXRlcyh0cnVlKTtcclxuICAgIH0sIFtwcmVmaXhdKTtcclxuICAgIC8vIFdoYXRldmVyIElEIHdhcyBtb3N0IHJlY2VudGx5IHVzZWQgYnkgdGhlIGFjdHVhbCBcImlkXCIgcHJvcC5cclxuICAgIC8vIFVzZWQgc28gdGhhdCBhbnkgSUQtcmVmZXJlbmNpbmcgcHJvcHMgZG9uJ3QgbmVlZCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlLlxyXG4gICAgLy9cclxuICAgIC8vIFRPRE86IFRoaXMgZG9lcyBtZWFuIHRoYXQgb24gdGhlIGZpcnN0IHJlbmRlciwgaWYganVzdCB0aGUgSUQgaXMgcHJvdmlkZWQsXHJcbiAgICAvLyB0aGVyZSB3aWxsIGJlIGEgdGVtcG9yYXJ5IG1pc21hdGNoLCBidXQgaXQncyBjb3JyZWN0ZWQgYmVmb3JlIHJlbmRlcmluZyBmaW5pc2hlcy5cclxuICAgIC8vIElzIHRoaXMgb2theT9cclxuICAgIGNvbnN0IFt1c2VkSWQsIHNldFVzZWRJZCwgZ2V0VXNlZElkXSA9IHVzZVN0YXRlKHVuZGVmaW5lZCk7XHJcbiAgICBjb25zdCB1c2VSZWZlcmVuY2VkSWRQcm9wcyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVJlZmVyZW5jZWRJZFByb3BzKGlkUHJvcE5hbWUpIHtcclxuICAgICAgICBjb25zdCByZXQgPSBmdW5jdGlvbiAoeyBbaWRQcm9wTmFtZV06IGdpdmVuSWQsIC4uLnByb3BzIH0pIHtcclxuICAgICAgICAgICAgY29uc3QgdXNlZElkMiA9IChnaXZlbklkID8/IHVzZWRJZCA/PyByYW5kb21JZCA/PyB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBpZiAoaWRQcm9wTmFtZSA9PT0gXCJpZFwiKVxyXG4gICAgICAgICAgICAgICAgc2V0VXNlZElkKHVzZWRJZDIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IFtpZFByb3BOYW1lXTogdXNlZElkMiB9LCBwcm9wcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfSwgW3VzZWRJZCwgcmFuZG9tSWRdKTtcclxuICAgIGNvbnN0IHVzZVJhbmRvbUlkUHJvcHMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VSYW5kb21JZFByb3BzKHApIHtcclxuICAgICAgICByZXR1cm4gdXNlUmVmZXJlbmNlZElkUHJvcHMoXCJpZFwiKShwKTtcclxuICAgIH0sIFt1c2VSZWZlcmVuY2VkSWRQcm9wc10pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByYW5kb21JZCxcclxuICAgICAgICBpZDogdXNlZElkLFxyXG4gICAgICAgIGdldElkOiBnZXRVc2VkSWQsXHJcbiAgICAgICAgdXNlUmFuZG9tSWRQcm9wcyxcclxuICAgICAgICB1c2VSZWZlcmVuY2VkSWRQcm9wc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBhY2NlcHRzU3RyaW5nT3JDc3NPclVuZGVmaW5lZCh1KSB7IH1cclxuZnVuY3Rpb24gYWNjZXB0c1N0cmluZ09yQ3NzKHN0cikgeyB9XHJcbmZ1bmN0aW9uIGFjY2VwdHNDc3MocHJvcCkgeyB9XHJcbmZ1bmN0aW9uIHRlc3QocHJvcHMpIHtcclxuICAgIGNvbnN0IHsgaWQsIHJhbmRvbUlkLCB1c2VSYW5kb21JZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoKTtcclxuICAgIC8vY29uc3QgcDFhOiBNZXJnZWRQcm9wczx7IGlkOiBzdHJpbmcgfSwgeyAgfT4gPSB1c2VSYW5kb21JZFByb3BzKHsgaWQ6IHVuZGVmaW5lZCB9KVxyXG4gICAgY29uc3QgcDFiID0gdXNlUmFuZG9tSWRQcm9wcyh7IC4uLnByb3BzLCBpZDogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uc3QgcDJhID0gdXNlUmVmZXJlbmNlZElkUHJvcHMoXCJmb3JcIikoeyBpZDogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uc3QgcDJiID0gdXNlUmVmZXJlbmNlZElkUHJvcHMoXCJmb3JcIikoeyAuLi5wcm9wcywgaWQ6IHVuZGVmaW5lZCB9KTtcclxuICAgIGNvbnN0IHAyYyA9IHVzZVJlZmVyZW5jZWRJZFByb3BzKFwiZm9yXCIpKHByb3BzKTtcclxuICAgIGNvbnN0IHAzYSA9IHVzZVJhbmRvbUlkUHJvcHModXNlUmVmZXJlbmNlZElkUHJvcHMoXCJmb3JcIikoeyBpZDogdW5kZWZpbmVkIH0pKTtcclxuICAgIGNvbnN0IHAzYiA9IHVzZVJhbmRvbUlkUHJvcHModXNlUmVmZXJlbmNlZElkUHJvcHMoXCJmb3JcIikoeyAuLi5wcm9wcywgaWQ6IHVuZGVmaW5lZCB9KSk7XHJcbiAgICBjb25zdCBwNGEgPSB1c2VSZWZlcmVuY2VkSWRQcm9wcyhcImZvclwiKSh1c2VSYW5kb21JZFByb3BzKHsgaWQ6IHVuZGVmaW5lZCB9KSk7XHJcbiAgICBjb25zdCBwNGIgPSB1c2VSZWZlcmVuY2VkSWRQcm9wcyhcImZvclwiKShwMWIpO1xyXG4gICAgLy9wMWEuaWQ7XHJcbiAgICBwMWIuaWQ7XHJcbiAgICBwMmFbXCJmb3JcIl07XHJcbiAgICBwMmJbXCJmb3JcIl07XHJcbiAgICBwMmNbXCJmb3JcIl07XHJcbiAgICBwM2EuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHAzYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDNhW1wiZm9yXCJdPy5jb25jYXQoXCJcIik7XHJcbiAgICBwM2JbXCJmb3JcIl0/LmNvbmNhdChcIlwiKTtcclxuICAgIHA0YVtcImZvclwiXT8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDRiW1wiZm9yXCJdPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNGEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IEl0J3MgYmVjYXVzZSBpdCByZXNvbHZlcyB0byBcImlkOiB1bmRlZmluZWQgJiBzdHJpbmdcIiAtLSB0aGlzIHNob3VsZG4ndCBoYXBwZW5cclxuICAgIHA0Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgYWNjZXB0c1N0cmluZ09yQ3NzT3JVbmRlZmluZWQocDFiLnN0eWxlKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBhY2NlcHRzU3RyaW5nT3JDc3MocDFiLnN0eWxlKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBwMmEuc3R5bGU/LmJhY2tncm91bmRDb2xvcjtcclxuICAgIGFjY2VwdHNTdHJpbmdPckNzc09yVW5kZWZpbmVkKHAyYi5zdHlsZSk7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgYWNjZXB0c1N0cmluZ09yQ3NzKHAyYi5zdHlsZSk7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgcDNhLnN0eWxlPy5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICBhY2NlcHRzU3RyaW5nT3JDc3NPclVuZGVmaW5lZChwM2Iuc3R5bGUpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHA0YS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICBhY2NlcHRzU3RyaW5nT3JDc3NPclVuZGVmaW5lZChwNGIuc3R5bGUpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1yYW5kb20taWQuanMubWFwIiwiLyohXG4qIHRhYmJhYmxlIDUuMi4xXG4qIEBsaWNlbnNlIE1JVCwgaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvdGFiYmFibGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuKi9cbnZhciBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbJ2lucHV0JywgJ3NlbGVjdCcsICd0ZXh0YXJlYScsICdhW2hyZWZdJywgJ2J1dHRvbicsICdbdGFiaW5kZXhdJywgJ2F1ZGlvW2NvbnRyb2xzXScsICd2aWRlb1tjb250cm9sc10nLCAnW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSknLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnLCAnZGV0YWlscyddO1xudmFyIGNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovY2FuZGlkYXRlU2VsZWN0b3JzLmpvaW4oJywnKTtcbnZhciBtYXRjaGVzID0gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnID8gZnVuY3Rpb24gKCkge30gOiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxudmFyIGdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiBnZXRDYW5kaWRhdGVzKGVsLCBpbmNsdWRlQ29udGFpbmVyLCBmaWx0ZXIpIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoZWwucXVlcnlTZWxlY3RvckFsbChjYW5kaWRhdGVTZWxlY3RvcikpO1xuXG4gIGlmIChpbmNsdWRlQ29udGFpbmVyICYmIG1hdGNoZXMuY2FsbChlbCwgY2FuZGlkYXRlU2VsZWN0b3IpKSB7XG4gICAgY2FuZGlkYXRlcy51bnNoaWZ0KGVsKTtcbiAgfVxuXG4gIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcihmaWx0ZXIpO1xuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbnZhciBpc0NvbnRlbnRFZGl0YWJsZSA9IGZ1bmN0aW9uIGlzQ29udGVudEVkaXRhYmxlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZSc7XG59O1xuXG52YXIgZ2V0VGFiaW5kZXggPSBmdW5jdGlvbiBnZXRUYWJpbmRleChub2RlKSB7XG4gIHZhciB0YWJpbmRleEF0dHIgPSBwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApO1xuXG4gIGlmICghaXNOYU4odGFiaW5kZXhBdHRyKSkge1xuICAgIHJldHVybiB0YWJpbmRleEF0dHI7XG4gIH0gLy8gQnJvd3NlcnMgZG8gbm90IHJldHVybiBgdGFiSW5kZXhgIGNvcnJlY3RseSBmb3IgY29udGVudEVkaXRhYmxlIG5vZGVzO1xuICAvLyBzbyBpZiB0aGV5IGRvbid0IGhhdmUgYSB0YWJpbmRleCBhdHRyaWJ1dGUgc3BlY2lmaWNhbGx5IHNldCwgYXNzdW1lIGl0J3MgMC5cblxuXG4gIGlmIChpc0NvbnRlbnRFZGl0YWJsZShub2RlKSkge1xuICAgIHJldHVybiAwO1xuICB9IC8vIGluIENocm9tZSwgPGRldGFpbHMvPiwgPGF1ZGlvIGNvbnRyb2xzLz4gYW5kIDx2aWRlbyBjb250cm9scy8+IGVsZW1lbnRzIGdldCBhIGRlZmF1bHRcbiAgLy8gIGB0YWJJbmRleGAgb2YgLTEgd2hlbiB0aGUgJ3RhYmluZGV4JyBhdHRyaWJ1dGUgaXNuJ3Qgc3BlY2lmaWVkIGluIHRoZSBET00sXG4gIC8vICB5ZXQgdGhleSBhcmUgc3RpbGwgcGFydCBvZiB0aGUgcmVndWxhciB0YWIgb3JkZXI7IGluIEZGLCB0aGV5IGdldCBhIGRlZmF1bHRcbiAgLy8gIGB0YWJJbmRleGAgb2YgMDsgc2luY2UgQ2hyb21lIHN0aWxsIHB1dHMgdGhvc2UgZWxlbWVudHMgaW4gdGhlIHJlZ3VsYXIgdGFiXG4gIC8vICBvcmRlciwgY29uc2lkZXIgdGhlaXIgdGFiIGluZGV4IHRvIGJlIDAuXG5cblxuICBpZiAoKG5vZGUubm9kZU5hbWUgPT09ICdBVURJTycgfHwgbm9kZS5ub2RlTmFtZSA9PT0gJ1ZJREVPJyB8fCBub2RlLm5vZGVOYW1lID09PSAnREVUQUlMUycpICYmIG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gbm9kZS50YWJJbmRleDtcbn07XG5cbnZhciBzb3J0T3JkZXJlZFRhYmJhYmxlcyA9IGZ1bmN0aW9uIHNvcnRPcmRlcmVkVGFiYmFibGVzKGEsIGIpIHtcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXIgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn07XG5cbnZhciBpc0lucHV0ID0gZnVuY3Rpb24gaXNJbnB1dChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdJTlBVVCc7XG59O1xuXG52YXIgaXNIaWRkZW5JbnB1dCA9IGZ1bmN0aW9uIGlzSGlkZGVuSW5wdXQobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdoaWRkZW4nO1xufTtcblxudmFyIGlzRGV0YWlsc1dpdGhTdW1tYXJ5ID0gZnVuY3Rpb24gaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkge1xuICB2YXIgciA9IG5vZGUudGFnTmFtZSA9PT0gJ0RFVEFJTFMnICYmIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlLmNoaWxkcmVuKS5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC50YWdOYW1lID09PSAnU1VNTUFSWSc7XG4gIH0pO1xuICByZXR1cm4gcjtcbn07XG5cbnZhciBnZXRDaGVja2VkUmFkaW8gPSBmdW5jdGlvbiBnZXRDaGVja2VkUmFkaW8obm9kZXMsIGZvcm0pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkICYmIG5vZGVzW2ldLmZvcm0gPT09IGZvcm0pIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpc1RhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiBpc1RhYmJhYmxlUmFkaW8obm9kZSkge1xuICBpZiAoIW5vZGUubmFtZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHJhZGlvU2NvcGUgPSBub2RlLmZvcm0gfHwgbm9kZS5vd25lckRvY3VtZW50O1xuXG4gIHZhciBxdWVyeVJhZGlvcyA9IGZ1bmN0aW9uIHF1ZXJ5UmFkaW9zKG5hbWUpIHtcbiAgICByZXR1cm4gcmFkaW9TY29wZS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBuYW1lICsgJ1wiXScpO1xuICB9O1xuXG4gIHZhciByYWRpb1NldDtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5DU1MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuQ1NTLmVzY2FwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJhZGlvU2V0ID0gcXVlcnlSYWRpb3Mod2luZG93LkNTUy5lc2NhcGUobm9kZS5uYW1lKSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHJhZGlvU2V0ID0gcXVlcnlSYWRpb3Mobm9kZS5uYW1lKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKCdMb29rcyBsaWtlIHlvdSBoYXZlIGEgcmFkaW8gYnV0dG9uIHdpdGggYSBuYW1lIGF0dHJpYnV0ZSBjb250YWluaW5nIGludmFsaWQgQ1NTIHNlbGVjdG9yIGNoYXJhY3RlcnMgYW5kIG5lZWQgdGhlIENTUy5lc2NhcGUgcG9seWZpbGw6ICVzJywgZXJyLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGVja2VkID0gZ2V0Q2hlY2tlZFJhZGlvKHJhZGlvU2V0LCBub2RlLmZvcm0pO1xuICByZXR1cm4gIWNoZWNrZWQgfHwgY2hlY2tlZCA9PT0gbm9kZTtcbn07XG5cbnZhciBpc1JhZGlvID0gZnVuY3Rpb24gaXNSYWRpbyhub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ3JhZGlvJztcbn07XG5cbnZhciBpc05vblRhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiBpc05vblRhYmJhYmxlUmFkaW8obm9kZSkge1xuICByZXR1cm4gaXNSYWRpbyhub2RlKSAmJiAhaXNUYWJiYWJsZVJhZGlvKG5vZGUpO1xufTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gaXNIaWRkZW4obm9kZSwgZGlzcGxheUNoZWNrKSB7XG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgaXNEaXJlY3RTdW1tYXJ5ID0gbWF0Y2hlcy5jYWxsKG5vZGUsICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScpO1xuICB2YXIgbm9kZVVuZGVyRGV0YWlscyA9IGlzRGlyZWN0U3VtbWFyeSA/IG5vZGUucGFyZW50RWxlbWVudCA6IG5vZGU7XG5cbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlVW5kZXJEZXRhaWxzLCAnZGV0YWlsczpub3QoW29wZW5dKSAqJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghZGlzcGxheUNoZWNrIHx8IGRpc3BsYXlDaGVjayA9PT0gJ2Z1bGwnKSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGxheUNoZWNrID09PSAnbm9uLXplcm8tYXJlYScpIHtcbiAgICB2YXIgX25vZGUkZ2V0Qm91bmRpbmdDbGllID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgd2lkdGggPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZS5oZWlnaHQ7XG5cbiAgICByZXR1cm4gd2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTsgLy8gZm9ybSBmaWVsZHMgKG5lc3RlZCkgaW5zaWRlIGEgZGlzYWJsZWQgZmllbGRzZXQgYXJlIG5vdCBmb2N1c2FibGUvdGFiYmFibGVcbi8vICB1bmxlc3MgdGhleSBhcmUgaW4gdGhlIF9maXJzdF8gPGxlZ2VuZD4gZWxlbWVudCBvZiB0aGUgdG9wLW1vc3QgZGlzYWJsZWRcbi8vICBmaWVsZHNldFxuXG5cbnZhciBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0ID0gZnVuY3Rpb24gaXNEaXNhYmxlZEZyb21GaWVsZHNldChub2RlKSB7XG4gIGlmIChpc0lucHV0KG5vZGUpIHx8IG5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCcgfHwgbm9kZS50YWdOYW1lID09PSAnVEVYVEFSRUEnIHx8IG5vZGUudGFnTmFtZSA9PT0gJ0JVVFRPTicpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcblxuICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS50YWdOYW1lID09PSAnRklFTERTRVQnICYmIHBhcmVudE5vZGUuZGlzYWJsZWQpIHtcbiAgICAgICAgLy8gbG9vayBmb3IgdGhlIGZpcnN0IDxsZWdlbmQ+IGFzIGFuIGltbWVkaWF0ZSBjaGlsZCBvZiB0aGUgZGlzYWJsZWRcbiAgICAgICAgLy8gIDxmaWVsZHNldD46IGlmIHRoZSBub2RlIGlzIGluIHRoYXQgbGVnZW5kLCBpdCdsbCBiZSBlbmFibGVkIGV2ZW5cbiAgICAgICAgLy8gIHRob3VnaCB0aGUgZmllbGRzZXQgaXMgZGlzYWJsZWQ7IG90aGVyd2lzZSwgdGhlIG5vZGUgaXMgaW4gYVxuICAgICAgICAvLyAgc2Vjb25kYXJ5L3N1YnNlcXVlbnQgbGVnZW5kLCBvciBzb21ld2hlcmUgZWxzZSB3aXRoaW4gdGhlIGZpZWxkc2V0XG4gICAgICAgIC8vICAoaG93ZXZlciBkZWVwIG5lc3RlZCkgYW5kIGl0J2xsIGJlIGRpc2FibGVkXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IHBhcmVudE5vZGUuY2hpbGRyZW4uaXRlbShpKTtcblxuICAgICAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnTEVHRU5EJykge1xuICAgICAgICAgICAgaWYgKGNoaWxkLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gLy8gdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGZpcnN0IGxlZ2VuZCAoaW4gZG9jIG9yZGVyKSwgc28gbm8gbWF0dGVyXG4gICAgICAgICAgICAvLyAgd2hlcmUgaXQgaXMgbm93LCBpdCdsbCBiZSBkaXNhYmxlZFxuXG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB0aGUgbm9kZSBpc24ndCBpbiBhIGxlZ2VuZCwgc28gbm8gbWF0dGVyIHdoZXJlIGl0IGlzIG5vdywgaXQnbGwgYmUgZGlzYWJsZWRcblxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfSAvLyBlbHNlLCBub2RlJ3MgdGFiYmFibGUvZm9jdXNhYmxlIHN0YXRlIHNob3VsZCBub3QgYmUgYWZmZWN0ZWQgYnkgYSBmaWVsZHNldCdzXG4gIC8vICBlbmFibGVkL2Rpc2FibGVkIHN0YXRlXG5cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSA9IGZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSkge1xuICBpZiAobm9kZS5kaXNhYmxlZCB8fCBpc0hpZGRlbklucHV0KG5vZGUpIHx8IGlzSGlkZGVuKG5vZGUsIG9wdGlvbnMuZGlzcGxheUNoZWNrKSB8fCAvLyBGb3IgYSBkZXRhaWxzIGVsZW1lbnQgd2l0aCBhIHN1bW1hcnksIHRoZSBzdW1tYXJ5IGVsZW1lbnQgZ2V0cyB0aGUgZm9jdXNcbiAgaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkgfHwgaXNEaXNhYmxlZEZyb21GaWVsZHNldChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKSB7XG4gIGlmICghaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKSB8fCBpc05vblRhYmJhYmxlUmFkaW8obm9kZSkgfHwgZ2V0VGFiaW5kZXgobm9kZSkgPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgdGFiYmFibGUgPSBmdW5jdGlvbiB0YWJiYWJsZShlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJlZ3VsYXJUYWJiYWJsZXMgPSBbXTtcbiAgdmFyIG9yZGVyZWRUYWJiYWJsZXMgPSBbXTtcbiAgdmFyIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKGVsLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpKTtcbiAgY2FuZGlkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChjYW5kaWRhdGUsIGkpIHtcbiAgICB2YXIgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRUYWJpbmRleChjYW5kaWRhdGUpO1xuXG4gICAgaWYgKGNhbmRpZGF0ZVRhYmluZGV4ID09PSAwKSB7XG4gICAgICByZWd1bGFyVGFiYmFibGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgZG9jdW1lbnRPcmRlcjogaSxcbiAgICAgICAgdGFiSW5kZXg6IGNhbmRpZGF0ZVRhYmluZGV4LFxuICAgICAgICBub2RlOiBjYW5kaWRhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHZhciB0YWJiYWJsZU5vZGVzID0gb3JkZXJlZFRhYmJhYmxlcy5zb3J0KHNvcnRPcmRlcmVkVGFiYmFibGVzKS5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYS5ub2RlO1xuICB9KS5jb25jYXQocmVndWxhclRhYmJhYmxlcyk7XG4gIHJldHVybiB0YWJiYWJsZU5vZGVzO1xufTtcblxudmFyIGZvY3VzYWJsZSA9IGZ1bmN0aW9uIGZvY3VzYWJsZShlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKGVsLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKSk7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxudmFyIGlzVGFiYmFibGUgPSBmdW5jdGlvbiBpc1RhYmJhYmxlKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cblxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlKG9wdGlvbnMsIG5vZGUpO1xufTtcblxudmFyIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovY2FuZGlkYXRlU2VsZWN0b3JzLmNvbmNhdCgnaWZyYW1lJykuam9pbignLCcpO1xuXG52YXIgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiBpc0ZvY3VzYWJsZShub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICB9XG5cbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5leHBvcnQgeyBmb2N1c2FibGUsIGlzRm9jdXNhYmxlLCBpc1RhYmJhYmxlLCB0YWJiYWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbigoKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBwcm9wZXJ0aWVzICovXG4gICAgY29uc3QgX2Jsb2NraW5nRWxlbWVudHMgPSBTeW1ib2woKTtcbiAgICBjb25zdCBfYWxyZWFkeUluZXJ0RWxlbWVudHMgPSBTeW1ib2woKTtcbiAgICBjb25zdCBfdG9wRWxQYXJlbnRzID0gU3ltYm9sKCk7XG4gICAgY29uc3QgX3NpYmxpbmdzVG9SZXN0b3JlID0gU3ltYm9sKCk7XG4gICAgY29uc3QgX3BhcmVudE1PID0gU3ltYm9sKCk7XG4gICAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBzdGF0aWMgbWV0aG9kcyAqL1xuICAgIGNvbnN0IF90b3BDaGFuZ2VkID0gU3ltYm9sKCk7XG4gICAgY29uc3QgX3N3YXBJbmVydGVkU2libGluZyA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IF9pbmVydFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gICAgY29uc3QgX3Jlc3RvcmVJbmVydGVkU2libGluZ3MgPSBTeW1ib2woKTtcbiAgICBjb25zdCBfZ2V0UGFyZW50cyA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IF9nZXREaXN0cmlidXRlZENoaWxkcmVuID0gU3ltYm9sKCk7XG4gICAgY29uc3QgX2lzSW5lcnRhYmxlID0gU3ltYm9sKCk7XG4gICAgY29uc3QgX2hhbmRsZU11dGF0aW9ucyA9IFN5bWJvbCgpO1xuICAgIGNsYXNzIEJsb2NraW5nRWxlbWVudHNJbXBsIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpc1tfYV0gPSBbXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBwYXJlbnRzIG9mIHRoZSB0b3AgZWxlbWVudCwgZnJvbSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICogaXRzZWxmIHVwIHRvIGJvZHkuIFdoZW4gdG9wIGNoYW5nZXMsIHRoZSBvbGQgdG9wIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICAgKiBmcm9tIHRoZSBkb2N1bWVudCwgc28gd2UgbmVlZCB0byBtZW1vaXplIHRoZSBpbmVydGVkIHBhcmVudHMnIHNpYmxpbmdzXG4gICAgICAgICAgICAgKiBpbiBvcmRlciB0byByZXN0b3JlIHRoZWlyIGluZXJ0ZW5lc3Mgd2hlbiB0b3AgY2hhbmdlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpc1tfYl0gPSBbXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbmVydCBiZWZvcmUgdGhlIGZpcnN0IGJsb2NraW5nIGVsZW1lbnQgaXNcbiAgICAgICAgICAgICAqIHB1c2hlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpc1tfY10gPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgaW5lcnRuZXNzLlxuICAgICAgICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10odGhpc1tfdG9wRWxQYXJlbnRzXSk7XG4gICAgICAgICAgICAvLyBOb3RlIHdlIGRvbid0IHdhbnQgdG8gbWFrZSB0aGVzZSBwcm9wZXJ0aWVzIG51bGxhYmxlIG9uIHRoZSBjbGFzcyxcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZW4gd2UnZCBuZWVkIG5vbi1udWxsIGNhc3RzIGluIG1hbnkgcGxhY2VzLiBDYWxsaW5nIGEgbWV0aG9kIG9uXG4gICAgICAgICAgICAvLyBhIEJsb2NraW5nRWxlbWVudHMgaW5zdGFuY2UgYWZ0ZXIgY2FsbGluZyBkZXN0cnVjdG9yIHdpbGwgcmVzdWx0IGluIGFuXG4gICAgICAgICAgICAvLyBleGNlcHRpb24uXG4gICAgICAgICAgICBjb25zdCBudWxsYWJsZSA9IHRoaXM7XG4gICAgICAgICAgICBudWxsYWJsZVtfYmxvY2tpbmdFbGVtZW50c10gPSBudWxsO1xuICAgICAgICAgICAgbnVsbGFibGVbX3RvcEVsUGFyZW50c10gPSBudWxsO1xuICAgICAgICAgICAgbnVsbGFibGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1zID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c107XG4gICAgICAgICAgICByZXR1cm4gZWxlbXNbZWxlbXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50ID09PSB0aGlzLnRvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgd2UnbGwgYnJpbmcgaXQgdG8gdGhlIHRvcC5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0oZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZShlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIC8vIFRvcCBjaGFuZ2VkIG9ubHkgaWYgdGhlIHJlbW92ZWQgZWxlbWVudCB3YXMgdGhlIHRvcCBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKGkgPT09IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX3RvcENoYW5nZWRdKHRoaXMudG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHBvcCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgdG9wICYmIHRoaXMucmVtb3ZlKHRvcCk7XG4gICAgICAgICAgICByZXR1cm4gdG9wO1xuICAgICAgICB9XG4gICAgICAgIGhhcyhlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgYGluZXJ0YCB0byBhbGwgZG9jdW1lbnQgZWxlbWVudHMgZXhjZXB0IHRoZSBuZXcgdG9wIGVsZW1lbnQsIGl0c1xuICAgICAgICAgKiBwYXJlbnRzLCBhbmQgaXRzIGRpc3RyaWJ1dGVkIGNvbnRlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBbKF9hID0gX2Jsb2NraW5nRWxlbWVudHMsIF9iID0gX3RvcEVsUGFyZW50cywgX2MgPSBfYWxyZWFkeUluZXJ0RWxlbWVudHMsIF90b3BDaGFuZ2VkKV0obmV3VG9wKSB7XG4gICAgICAgICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgICAgICAgIGNvbnN0IG9sZFBhcmVudHMgPSB0aGlzW190b3BFbFBhcmVudHNdO1xuICAgICAgICAgICAgLy8gTm8gbmV3IHRvcCwgcmVzZXQgb2xkIHRvcCBpZiBhbnkuXG4gICAgICAgICAgICBpZiAoIW5ld1RvcCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMpO1xuICAgICAgICAgICAgICAgIHRvS2VlcEluZXJ0LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpc1tfdG9wRWxQYXJlbnRzXSA9IFtdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1BhcmVudHMgPSB0aGlzW19nZXRQYXJlbnRzXShuZXdUb3ApO1xuICAgICAgICAgICAgLy8gTmV3IHRvcCBpcyBub3QgY29udGFpbmVkIGluIHRoZSBtYWluIGRvY3VtZW50IVxuICAgICAgICAgICAgaWYgKG5ld1BhcmVudHNbbmV3UGFyZW50cy5sZW5ndGggLSAxXS5wYXJlbnROb2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ05vbi1jb25uZWN0ZWQgZWxlbWVudCBjYW5ub3QgYmUgYSBibG9ja2luZyBlbGVtZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYXN0IGhlcmUgYmVjYXVzZSB3ZSBrbm93IHdlJ2xsIGNhbGwgX2luZXJ0U2libGluZ3Mgb24gbmV3UGFyZW50c1xuICAgICAgICAgICAgLy8gYmVsb3cuXG4gICAgICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gbmV3UGFyZW50cztcbiAgICAgICAgICAgIGNvbnN0IHRvU2tpcCA9IHRoaXNbX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW5dKG5ld1RvcCk7XG4gICAgICAgICAgICAvLyBObyBwcmV2aW91cyB0b3AgZWxlbWVudC5cbiAgICAgICAgICAgIGlmICghb2xkUGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLCB0b1NraXAsIHRvS2VlcEluZXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaSA9IG9sZFBhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCBqID0gbmV3UGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgLy8gRmluZCBjb21tb24gcGFyZW50LiBJbmRleCAwIGlzIHRoZSBlbGVtZW50IGl0c2VsZiAoc28gc3RvcCBiZWZvcmUgaXQpLlxuICAgICAgICAgICAgd2hpbGUgKGkgPiAwICYmIGogPiAwICYmIG9sZFBhcmVudHNbaV0gPT09IG5ld1BhcmVudHNbal0pIHtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdXAgdGhlIHBhcmVudHMgdHJlZSB0aGVyZSBhcmUgMiBlbGVtZW50cyB0aGF0IGFyZSBzaWJsaW5ncywgc3dhcFxuICAgICAgICAgICAgLy8gdGhlIGluZXJ0ZWQgc2libGluZy5cbiAgICAgICAgICAgIGlmIChvbGRQYXJlbnRzW2ldICE9PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfc3dhcEluZXJ0ZWRTaWJsaW5nXShvbGRQYXJlbnRzW2ldLCBuZXdQYXJlbnRzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlc3RvcmUgb2xkIHBhcmVudHMgc2libGluZ3MgaW5lcnRuZXNzLlxuICAgICAgICAgICAgaSA+IDAgJiYgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cy5zbGljZSgwLCBpKSk7XG4gICAgICAgICAgICAvLyBNYWtlIG5ldyBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0LlxuICAgICAgICAgICAgaiA+IDAgJiYgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cy5zbGljZSgwLCBqKSwgdG9Ta2lwLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3dhcHMgaW5lcnRuZXNzIGJldHdlZW4gdHdvIHNpYmxpbmcgZWxlbWVudHMuXG4gICAgICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICAgICAqL1xuICAgICAgICBbX3N3YXBJbmVydGVkU2libGluZ10ob2xkSW5lcnQsIG5ld0luZXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nc1RvUmVzdG9yZSA9IG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAgICAgICAvLyBvbGRJbmVydCBpcyBub3QgY29udGFpbmVkIGluIHNpYmxpbmdzIHRvIHJlc3RvcmUsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgaW5lcnRhYmxlIGFuZCBpZiBhbHJlYWR5IGluZXJ0LlxuICAgICAgICAgICAgaWYgKHRoaXNbX2lzSW5lcnRhYmxlXShvbGRJbmVydCkgJiYgIW9sZEluZXJ0LmluZXJ0KSB7XG4gICAgICAgICAgICAgICAgb2xkSW5lcnQuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmFkZChvbGRJbmVydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBuZXdJbmVydCB3YXMgYWxyZWFkeSBiZXR3ZWVuIHRoZSBzaWJsaW5ncyB0byByZXN0b3JlLCBpdCBtZWFucyBpdCBpc1xuICAgICAgICAgICAgLy8gaW5lcnRhYmxlIGFuZCBtdXN0IGJlIHJlc3RvcmVkLlxuICAgICAgICAgICAgaWYgKHNpYmxpbmdzVG9SZXN0b3JlLmhhcyhuZXdJbmVydCkpIHtcbiAgICAgICAgICAgICAgICBuZXdJbmVydC5pbmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmRlbGV0ZShuZXdJbmVydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJbmVydFtfcGFyZW50TU9dID0gb2xkSW5lcnRbX3BhcmVudE1PXTtcbiAgICAgICAgICAgIG5ld0luZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBzaWJsaW5nc1RvUmVzdG9yZTtcbiAgICAgICAgICAgIG9sZEluZXJ0W19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBvbGRJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBpbmVydG5lc3MgdG8gdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgICAgICovXG4gICAgICAgIFtfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10oZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vID0gZWxlbWVudFtfcGFyZW50TU9dO1xuICAgICAgICAgICAgICAgIG1vLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50W19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2libGluZ3MgPSBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nIG9mIHNpYmxpbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmVydHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgdGhlIGVsZW1lbnRzIHRvIHNraXAuIFN0b3Jlc1xuICAgICAgICAgKiB0aGUgaW5lcnRlZCBzaWJsaW5ncyBpbnRvIHRoZSBlbGVtZW50J3Mgc3ltYm9sIGBfc2libGluZ3NUb1Jlc3RvcmVgLlxuICAgICAgICAgKiBQYXNzIGB0b0tlZXBJbmVydGAgdG8gY29sbGVjdCB0aGUgYWxyZWFkeSBpbmVydCBlbGVtZW50cy5cbiAgICAgICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgICAgICovXG4gICAgICAgIFtfaW5lcnRTaWJsaW5nc10oZWxlbWVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBlbGVtZW50IGlzIG5vdCBhIERvY3VtZW50LCBzbyBpdCBtdXN0IGhhdmUgYSBwYXJlbnROb2RlLlxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgdGhlIGlucHV0IGVsZW1lbnQsIGlmIG5vdCBpbmVydGFibGUgb3IgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcgPT09IGVsZW1lbnQgfHwgIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRvU2tpcCAmJiB0b1NraXAuaGFzKHNpYmxpbmcpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIGNvbGxlY3RlZCBzaW5jZSBhbHJlYWR5IGluZXJ0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHNpYmxpbmdzIHRoYXQgd2VyZSBpbmVydGVkLlxuICAgICAgICAgICAgICAgIGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IGluZXJ0ZWRTaWJsaW5ncztcbiAgICAgICAgICAgICAgICAvLyBPYnNlcnZlIG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIG11dGF0aW9ucyBvbiB0aGUgcGFyZW50LlxuICAgICAgICAgICAgICAgIGNvbnN0IG1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpc1tfaGFuZGxlTXV0YXRpb25zXS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50W19wYXJlbnRNT10gPSBtbztcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50VG9PYnNlcnZlID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHRoZSBTaGFkeURPTSBwb2x5ZmlsbCwgdGhlbiBvdXIgcGFyZW50IGNvdWxkIGJlIGFcbiAgICAgICAgICAgICAgICAvLyBzaGFkeSByb290LCB3aGljaCBpcyBhbiBvYmplY3QgdGhhdCBhY3RzIGxpa2UgYSBTaGFkb3dSb290LCBidXQgaXNuJ3RcbiAgICAgICAgICAgICAgICAvLyBhY3R1YWxseSBhIG5vZGUgaW4gdGhlIHJlYWwgRE9NLiBPYnNlcnZlIHRoZSByZWFsIERPTSBwYXJlbnQgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXliZVNoYWR5Um9vdCA9IHBhcmVudFRvT2JzZXJ2ZTtcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVTaGFkeVJvb3QuX19zaGFkeSAmJiBtYXliZVNoYWR5Um9vdC5ob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFRvT2JzZXJ2ZSA9IG1heWJlU2hhZHlSb290Lmhvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vLm9ic2VydmUocGFyZW50VG9PYnNlcnZlLCB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBuZXdseSBhZGRlZC9yZW1vdmVkIG5vZGVzIGJ5IHRvZ2dsaW5nIHRoZWlyIGluZXJ0bmVzcy5cbiAgICAgICAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIGN1cnJlbnQgdG9wIEJsb2NraW5nIEVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgICAgICogbm90aWZ5aW5nIGFuZCByZW1vdmluZyBpdC5cbiAgICAgICAgICovXG4gICAgICAgIFtfaGFuZGxlTXV0YXRpb25zXShtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudHMgPSB0aGlzW190b3BFbFBhcmVudHNdO1xuICAgICAgICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBzaGFkb3dSb290LCBnZXQgaXRzIGhvc3QgYXMgd2Ugc2tpcCBzaGFkb3dSb290cyB3aGVuXG4gICAgICAgICAgICAgICAgLy8gY29tcHV0aW5nIF90b3BFbFBhcmVudHMuXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0Lmhvc3QgfHwgbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSA/XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHMubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5pbmRleE9mKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5lcnRlZENoaWxkID0gcGFyZW50c1tpZHggLSAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBpbmVydGVkQ2hpbGRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgICAgICAgICAvLyBUbyByZXN0b3JlLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nID09PSBpbmVydGVkQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnRGV0ZWN0ZWQgcmVtb3ZhbCBvZiB0aGUgdG9wIEJsb2NraW5nIEVsZW1lbnQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmVydGVkU2libGluZ3MuaGFzKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmVydGVkU2libGluZ3MuZGVsZXRlKHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRvIGluZXJ0LlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24uYWRkZWROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgaW5lcnRhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgW19pc0luZXJ0YWJsZV0oZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlID09PSAvXihzdHlsZXx0ZW1wbGF0ZXxzY3JpcHQpJC8udGVzdChlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmV3UGFyZW50cyBvZiBhbiBlbGVtZW50LCBzdGFydGluZyBmcm9tIGVsZW1lbnRcbiAgICAgICAgICogKGluY2x1ZGVkKSB1cCB0byBgZG9jdW1lbnQuYm9keWAgKGV4Y2x1ZGVkKS5cbiAgICAgICAgICovXG4gICAgICAgIFtfZ2V0UGFyZW50c10oZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgLy8gU3RvcCB0byBib2R5LlxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgc2hhZG93IHJvb3RzLlxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNoYWRvd0RvbSB2MVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb2xsZWN0IHNsb3RzIGZyb20gZGVlcGVzdCBzbG90IHRvIHRvcC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPSBjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHRoZSBzZWFyY2ggb24gdGhlIHRvcCBzbG90LlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gcGFyZW50cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5ob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGRpc3RyaWJ1dGVkIGNoaWxkcmVuIG9mIHRoZSBlbGVtZW50J3Mgc2hhZG93IHJvb3QuXG4gICAgICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBzaGFkb3cgcm9vdC5cbiAgICAgICAgICovXG4gICAgICAgIFtfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0oZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgICAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBsZXQgajtcbiAgICAgICAgICAgIGxldCBub2RlcztcbiAgICAgICAgICAgIGNvbnN0IHNsb3RzID0gc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdzbG90Jyk7XG4gICAgICAgICAgICBpZiAoc2xvdHMubGVuZ3RoICYmIHNsb3RzWzBdLmFzc2lnbmVkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMgPSBzbG90c1tpXS5hc3NpZ25lZE5vZGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2Rlc1tqXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKG5vZGVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIHNlYXJjaCBmb3IgPGNvbnRlbnQ+LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb2N1bWVudC4kYmxvY2tpbmdFbGVtZW50cyA9XG4gICAgICAgIG5ldyBCbG9ja2luZ0VsZW1lbnRzSW1wbCgpO1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NraW5nLWVsZW1lbnRzLmpzLm1hcCIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnaW5lcnQnLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIC8qKlxuICAgKiBUaGlzIHdvcmsgaXMgbGljZW5zZWQgdW5kZXIgdGhlIFczQyBTb2Z0d2FyZSBhbmQgRG9jdW1lbnQgTGljZW5zZVxuICAgKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICAgKi9cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgTm9kZUxpc3RzLlxuICAgIC8qKiBAdHlwZSB7dHlwZW9mIEFycmF5LnByb3RvdHlwZS5zbGljZX0gKi9cbiAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICAvKipcbiAgICAgKiBJRSBoYXMgYSBub24tc3RhbmRhcmQgbmFtZSBmb3IgXCJtYXRjaGVzXCIuXG4gICAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgICAqL1xuICAgIHZhciBtYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvcjtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHZhciBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcgPSBbJ2FbaHJlZl0nLCAnYXJlYVtocmVmXScsICdpbnB1dDpub3QoW2Rpc2FibGVkXSknLCAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKScsICd0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSknLCAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKScsICdkZXRhaWxzJywgJ3N1bW1hcnknLCAnaWZyYW1lJywgJ29iamVjdCcsICdlbWJlZCcsICdbY29udGVudGVkaXRhYmxlXSddLmpvaW4oJywnKTtcblxuICAgIC8qKlxuICAgICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgICAqIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtIHRvIGNyZWF0ZSBhbmQgbWFpbnRhaW4gYSBzZXQgb2YgbWFuYWdlZCBgSW5lcnROb2RlYHMsIGluY2x1ZGluZyB3aGVuIG11dGF0aW9ucyBvY2N1ciBpbiB0aGVcbiAgICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICAgKiAgIGVhY2ggZm9jdXNhYmxlIG5vZGUgaW4gdGhlIHN1YnRyZWUgd2l0aCB0aGUgc2luZ2xldG9uIGBJbmVydE1hbmFnZXJgIHdoaWNoIG1hbmFnZXMgYWxsIGtub3duXG4gICAgICogICBmb2N1c2FibGUgbm9kZXMgd2l0aGluIGluZXJ0IHN1YnRyZWVzLiBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWBcbiAgICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAgICpcbiAgICAgKiAtIHRvIG5vdGlmeSBhbGwgbWFuYWdlZCBgSW5lcnROb2RlYHMgd2hlbiB0aGlzIHN1YnRyZWUgc3RvcHMgYmVpbmcgaW5lcnQgKGkuZS4gd2hlbiB0aGUgYGluZXJ0YFxuICAgICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICAgKiAgIGBkZXJlZ2lzdGVyYCBtZXRob2Qgb24gYEluZXJ0TWFuYWdlcmAgZm9yIGVhY2ggbWFuYWdlZCBpbmVydCBub2RlLlxuICAgICAqL1xuXG4gICAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEVsZW1lbnQgYXQgdGhlIHJvb3Qgb2YgdGhlIGluZXJ0IHN1YnRyZWUuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydE1hbmFnZXJ9IGluZXJ0TWFuYWdlciBUaGUgZ2xvYmFsIHNpbmdsZXRvbiBJbmVydE1hbmFnZXIgb2JqZWN0LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydFJvb3Qocm9vdEVsZW1lbnQsIGluZXJ0TWFuYWdlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRSb290KTtcblxuICAgICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IGluZXJ0TWFuYWdlcjtcblxuICAgICAgICAvKiogQHR5cGUgeyFFbGVtZW50fSAqL1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IHJvb3RFbGVtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAgICogQWxsIG1hbmFnZWQgZm9jdXNhYmxlIG5vZGVzIGluIHRoaXMgSW5lcnRSb290J3Mgc3VidHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAvLyBNYWtlIHRoZSBzdWJ0cmVlIGhpZGRlbiBmcm9tIGFzc2lzdGl2ZSB0ZWNobm9sb2d5XG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpIHtcbiAgICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gdGhpcy5fcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUodGhpcy5fcm9vdEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhdGNoIGZvcjpcbiAgICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAgIC8vIC0gYW55IHJlbW92YWxzIGZyb20gdGhlIHN1YnRyZWU6IHJlbW92ZSB0aGVtIGZyb20gdGhpcyBpbmVydCByb290J3MgbWFuYWdlZCBub2Rlc1xuICAgICAgICAvLyAtIGF0dHJpYnV0ZSBjaGFuZ2VzOiBpZiBgdGFiaW5kZXhgIGlzIGFkZGVkLCBvciByZW1vdmVkIGZyb20gYW4gaW50cmluc2ljYWxseSBmb2N1c2FibGVcbiAgICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9vbk11dGF0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX3Jvb3RFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiAgVGhpcyB1bndpbmRzIGFsbCBvZiB0aGUgc3RhdGVcbiAgICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Um9vdCwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1hbmFnZU5vZGUoaW5lcnROb2RlLm5vZGUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gTm90ZSB3ZSBjYXN0IHRoZSBudWxscyB0byB0aGUgQU5ZIHR5cGUgaGVyZSBiZWNhdXNlOlxuICAgICAgICAgIC8vIDEpIFdlIHdhbnQgdGhlIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZGVjbGFyZWQgYXMgbm9uLW51bGwsIG9yIGVsc2Ugd2VcbiAgICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAgIC8vICAgIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCBhbmQgYSBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAgICAgIC8vIDIpIFdlIGRvbid0IHdhbnQgdG8gY2FzdCBcInRoaXNcIiwgYmVjYXVzZSB3ZSB3YW50IHR5cGUtYXdhcmUgb3B0aW1pemF0aW9uc1xuICAgICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHshU2V0PCFJbmVydE5vZGU+fSBBIGNvcHkgb2YgdGhpcyBJbmVydFJvb3QncyBtYW5hZ2VkIG5vZGVzIHNldC5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHN0YXJ0Tm9kZSkge1xuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl92aXNpdE5vZGUobm9kZSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoc3RhcnROb2RlKSkge1xuICAgICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGU7XG4gICAgICAgICAgICAvKiogQHR5cGUgeyFTaGFkb3dSb290fHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgICAgLy8gSW4gSUUxMSwgaWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IGZvY3VzZWQsIGFuZCB0aGVuIHNldCB0byB0YWJpbmRleD0tMVxuICAgICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzIHdlIGNhbGwgZm9jdXMoKSBvbiB0aGUgYm9keSBpbnN0ZWFkLlxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ192aXNpdE5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi9ub2RlO1xuXG4gICAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAgIC8vIHRoaXMgaW5lcnQgcm9vdCwgc28gYWxsIG9mIGl0cyBtYW5hZ2VkIG5vZGVzIG5lZWQgdG8gYmUgYWRvcHRlZCBieSB0aGlzIEluZXJ0Um9vdC5cbiAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIucmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmFkZChpbmVydE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShpbmVydE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBlbnRpcmUgc3VidHJlZSBzdGFydGluZyBhdCBgc3RhcnROb2RlYC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlU3VidHJlZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fdW5tYW5hZ2VOb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgZGVzY2VuZGFudCBub2RlIGlzIGZvdW5kIHdpdGggYW4gYGluZXJ0YCBhdHRyaWJ1dGUsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICAgKiBAcGFyYW0geyFFbGVtZW50fSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19hZG9wdEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRvcHRJbmVydFJvb3Qobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgICAgLy8gRHVyaW5nIGluaXRpYWxpc2F0aW9uIHRoaXMgaW5lcnQgcm9vdCBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIHlldCxcbiAgICAgICAgICAvLyBzbyByZWdpc3RlciBpdCBub3cgaWYgbmVlZCBiZS5cbiAgICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyLnNldEluZXJ0KG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmVydFN1YnJvb3QubWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHNhdmVkSW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHNhdmVkSW5lcnROb2RlLm5vZGUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gc2VsZlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfb25NdXRhdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgIC8vIE1hbmFnZSBhZGRlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShub2RlKTtcbiAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQucmVtb3ZlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5tYW5hZ2VTdWJ0cmVlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICd0YWJpbmRleCcpIHtcbiAgICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAnaW5lcnQnICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgbWFuYWdlZCBub2RlcyBmcm9tIHRoaXMgaW5lcnQgc3Vicm9vdC5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNvbnRhaW5zKG1hbmFnZWROb2RlLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ21hbmFnZWROb2RlcycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuX21hbmFnZWROb2Rlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdoYXNTYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBhcmlhSGlkZGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRSb290O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAgICogQSBub2RlIGlzIGluZXJ0IGlmIGl0IGlzIGEgZGVzY2VuZGFudCBvZiBvbmUgb3IgbW9yZSBpbmVydCByb290IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAgICogZWl0aGVyIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIG9yIHNldHMgaXQgdG8gYC0xYCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGVsZW1lbnRcbiAgICAgKiBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZSBvciBub3QuXG4gICAgICpcbiAgICAgKiBgSW5lcnROb2RlYCBtYWludGFpbnMgYSBzZXQgb2YgYEluZXJ0Um9vdGBzIHdoaWNoIGFyZSBkZXNjZW5kYW50cyBvZiB0aGlzIGBJbmVydE5vZGVgLiBXaGVuIGFuXG4gICAgICogYEluZXJ0Um9vdGAgaXMgZGVzdHJveWVkLCBhbmQgY2FsbHMgYEluZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKClgLCB0aGUgYEluZXJ0TWFuYWdlcmAgbm90aWZpZXMgdGhlXG4gICAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgICAqIHJlbWFpbiBpbiB0aGUgc2V0LiBPbiBkZXN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgcmVpbnN0YXRlcyB0aGUgc3RvcmVkIGB0YWJpbmRleGAgaWYgb25lIGV4aXN0cyxcbiAgICAgKiBvciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBpZiB0aGUgZWxlbWVudCBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZS5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdCBUaGUgaW5lcnQgcm9vdCBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluZXJ0IG5vZGUuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Tm9kZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi9cbiAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydFJvb3Q+fSBUaGUgc2V0IG9mIGRlc2NlbmRhbnQgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqICAgIElmIGFuZCBvbmx5IGlmIHRoaXMgc2V0IGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IFNldChbaW5lcnRSb290XSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgICAgdGhpcy5lbnN1cmVVbnRhYmJhYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS5cbiAgICAgICAqIFRoaXMgbWFrZXMgdGhlIG1hbmFnZWQgbm9kZSBmb2N1c2FibGUgYWdhaW4gYW5kIGRlbGV0ZXMgYWxsIG9mIHRoZSBwcmV2aW91c2x5IHN0b3JlZCBzdGF0ZS5cbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydE5vZGUsIFt7XG4gICAgICAgIGtleTogJ2Rlc3RydWN0b3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fbm9kZSAmJiB0aGlzLl9ub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL3RoaXMuX25vZGU7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYGRlbGV0ZWAgdG8gcmVzdG9yZSBuYXRpdmUgZm9jdXMgbWV0aG9kLlxuICAgICAgICAgICAgaWYgKHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgICB0aGlzLl9ub2RlID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQsIGFueSBhdHRlbXB0IHRvIGFjY2VzcyBpdCB3aWxsIGNhdXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Rocm93SWZEZXN0cm95ZWQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Rocm93SWZEZXN0cm95ZWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgICAgLyoqIFNhdmUgdGhlIGV4aXN0aW5nIHRhYmluZGV4IHZhbHVlIGFuZCBtYWtlIHRoZSBub2RlIHVudGFiYmFibGUgYW5kIHVuZm9jdXNhYmxlICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmVVbnRhYmJhYmxlKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi90aGlzLm5vZGU7XG4gICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpKSB7XG4gICAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGFub3RoZXIgaW5lcnQgcm9vdCB0byB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBJZiB0aGUgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzIGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQsXG4gICAgICAgICAqIHNvIHRoZSBvYmplY3Qgc2hvdWxkIGJlIGRlc3Ryb3llZC5cbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RydWN0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgeyFJbmVydE5vZGV9ICovdGhpcy5fZGVzdHJveWVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7IU5vZGV9ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbm9kZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcGFyYW0gez9udW1iZXJ9IHRhYkluZGV4ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRhYkluZGV4KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSB0YWJJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgICAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleDtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnROb2RlO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEluZXJ0TWFuYWdlciBpcyBhIHBlci1kb2N1bWVudCBzaW5nbGV0b24gb2JqZWN0IHdoaWNoIG1hbmFnZXMgYWxsIGluZXJ0IHJvb3RzIGFuZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICAgKiBwcm9wZXJ0eSBzZXQgdG8gYHRydWVgLCB0aGUgYHNldEluZXJ0YCBtZXRob2QgY3JlYXRlcyBhbiBgSW5lcnRSb290YCBvYmplY3QgZm9yIHRoZSBlbGVtZW50LlxuICAgICAqIFRoZSBgSW5lcnRSb290YCBpbiB0dXJuIHJlZ2lzdGVycyBpdHNlbGYgYXMgbWFuYWdpbmcgYWxsIG9mIHRoZSBlbGVtZW50J3MgZm9jdXNhYmxlIGRlc2NlbmRhbnRcbiAgICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICAgKiBpcyBjcmVhdGVkIGZvciBlYWNoIHN1Y2ggbm9kZSwgdmlhIHRoZSBgX21hbmFnZWROb2Rlc2AgbWFwLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFEb2N1bWVudH0gZG9jdW1lbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRNYW5hZ2VyKGRvY3VtZW50KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE1hbmFnZXIpO1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ7IEluZXJ0TWFuYWdlciBuZWVkcyB0byB3cmFwIGEgZG9jdW1lbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydE5vZGU+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgaW5lcnQgcm9vdHMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT2JzZXJ2ZXIgZm9yIG11dGF0aW9ucyBvbiBgZG9jdW1lbnQuYm9keWAuXG4gICAgICAgICAqIEB0eXBlIHshTXV0YXRpb25PYnNlcnZlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fd2F0Y2hGb3JJbmVydC5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBBZGQgaW5lcnQgc3R5bGUuXG4gICAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgZG9jdW1lbnQgdG8gYmUgbG9hZGVkLlxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fb25Eb2N1bWVudExvYWRlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0TWFuYWdlciwgW3tcbiAgICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5lcnQocm9vdCwgaW5lcnQpIHtcbiAgICAgICAgICBpZiAoaW5lcnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgaW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5lcnRSb290ID0gbmV3IEluZXJ0Um9vdChyb290LCB0aGlzKTtcbiAgICAgICAgICAgIHJvb3Quc2V0QXR0cmlidXRlKCdpbmVydCcsICcnKTtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgICAvLyBJZiBub3QgY29udGFpbmVkIGluIHRoZSBkb2N1bWVudCwgaXQgbXVzdCBiZSBpbiBhIHNoYWRvd1Jvb3QuXG4gICAgICAgICAgICAvLyBFbnN1cmUgaW5lcnQgc3R5bGVzIGFyZSBhZGRlZCB0aGVyZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcm9vdC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICAgIGFkZEluZXJ0U3R5bGUocGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgbm9uLWluZXJ0XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9pbmVydFJvb3QgPSB0aGlzLl9pbmVydFJvb3RzLmdldChyb290KTtcbiAgICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10ocm9vdCk7XG4gICAgICAgICAgICByb290LnJlbW92ZUF0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBlbGVtZW50XG4gICAgICAgICAqIEByZXR1cm4geyFJbmVydFJvb3R8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW5lcnRSb290cy5nZXQoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgICAgICogSW4gdGhlIGNhc2Ugd2hlcmUgdGhlIG5vZGUgaGFzIGEgcHJldmlvdXNseSBleGlzdGluZyBpbmVydCByb290LCB0aGlzIGluZXJ0IHJvb3Qgd2lsbFxuICAgICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5fbWFuYWdlZE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIGFscmVhZHkgaW4gYW4gaW5lcnQgc3VidHJlZVxuICAgICAgICAgICAgaW5lcnROb2RlLmFkZEluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmVydE5vZGUgPSBuZXcgSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZS1yZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBpbmVydCBub2RlLlxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBpbmVydCByb290IGZyb20gdGhlIEluZXJ0Tm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cywgYW5kIHJlbW92ZSB0aGUgaW5lcnRcbiAgICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgICAqIElmIHRoZSBub2RlIGlzIG5vdCBjdXJyZW50bHkgbWFuYWdlZCwgdGhpcyBpcyBlc3NlbnRpYWxseSBhIG5vLW9wLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqIEByZXR1cm4gez9JbmVydE5vZGV9IFRoZSBwb3RlbnRpYWxseSBkZXN0cm95ZWQgSW5lcnROb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIGlmIGFueS5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVyZWdpc3RlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmICghaW5lcnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmVydE5vZGUucmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gZG9jdW1lbnQgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19vbkRvY3VtZW50TG9hZGVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAgIC8vIEZpbmQgYWxsIGluZXJ0IHJvb3RzIGluIGRvY3VtZW50IGFuZCBtYWtlIHRoZW0gYWN0dWFsbHkgaW5lcnQuXG4gICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RvY3VtZW50LmJvZHkgfHwgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIHN1YnRyZWU6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gcmVjb3Jkc1xuICAgICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YXRjaEZvckluZXJ0KHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NoaWxkTGlzdCc6XG4gICAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsICdbaW5lcnRdJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXR0cmlidXRlcyc6XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lICE9PSAnaW5lcnQnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0ID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRJbmVydCh0YXJnZXQsIGluZXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRNYW5hZ2VyO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHdhbGsgdGhlIGNvbXBvc2VkIHRyZWUgZnJvbSB8bm9kZXwuXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uICghRWxlbWVudCkpPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBlYWNoIGVsZW1lbnQgdHJhdmVyc2VkLFxuICAgICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7P1NoYWRvd1Jvb3Q9fSBzaGFkb3dSb290QW5jZXN0b3IgVGhlIG5lYXJlc3QgU2hhZG93Um9vdCBhbmNlc3RvciwgaWYgYW55LlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi9ub2RlO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlc2NlbmQgaW50byBub2RlOlxuICAgICAgICAvLyBJZiBpdCBoYXMgYSBTaGFkb3dSb290LCBpZ25vcmUgYWxsIGNoaWxkIGVsZW1lbnRzIC0gdGhlc2Ugd2lsbCBiZSBwaWNrZWRcbiAgICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgICAvLyBTaGFkb3dSb290LlxuICAgICAgICB2YXIgc2hhZG93Um9vdCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHNoYWRvd1Jvb3QsIGNhbGxiYWNrLCBzaGFkb3dSb290KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyBhIDxjb250ZW50PiBlbGVtZW50LCBkZXNjZW5kIGludG8gZGlzdHJpYnV0ZWQgZWxlbWVudHMgLSB0aGVzZVxuICAgICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSAvKiogQHR5cGUgeyFIVE1MQ29udGVudEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgIHZhciBkaXN0cmlidXRlZE5vZGVzID0gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzID8gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzKCkgOiBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPHNsb3Q+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBhc3NpZ25lZCBub2RlcyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnc2xvdCcpIHtcbiAgICAgICAgICB2YXIgc2xvdCA9IC8qKiBAdHlwZSB7IUhUTUxTbG90RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgIHZhciBfZGlzdHJpYnV0ZWROb2RlcyA9IHNsb3QuYXNzaWduZWROb2RlcyA/IHNsb3QuYXNzaWduZWROb2Rlcyh7IGZsYXR0ZW46IHRydWUgfSkgOiBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2Rpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBuZWl0aGVyIHRoZSBwYXJlbnQgb2YgYSBTaGFkb3dSb290LCBhIDxjb250ZW50PiBlbGVtZW50LCBhIDxzbG90PlxuICAgICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgICAgdmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0eWxlIGVsZW1lbnQgdG8gdGhlIG5vZGUgY29udGFpbmluZyB0aGUgaW5lcnQgc3BlY2lmaWMgc3R5bGVzXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZEluZXJ0U3R5bGUobm9kZSkge1xuICAgICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdpZCcsICdpbmVydC1zdHlsZScpO1xuICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSAnXFxuJyArICdbaW5lcnRdIHtcXG4nICsgJyAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuJyArICcgIGN1cnNvcjogZGVmYXVsdDtcXG4nICsgJ31cXG4nICsgJ1xcbicgKyAnW2luZXJ0XSwgW2luZXJ0XSAqIHtcXG4nICsgJyAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICB1c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJ31cXG4nO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuXG4gICAgaWYgKCFFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgdmFyIGluZXJ0TWFuYWdlciA9IG5ldyBJbmVydE1hbmFnZXIoZG9jdW1lbnQpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWxlbWVudC5wcm90b3R5cGUsICdpbmVydCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgLyoqIEB0aGlzIHshRWxlbWVudH0gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9LFxuICAgICAgICAvKiogQHRoaXMgeyFFbGVtZW50fSAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmVydCkge1xuICAgICAgICAgIGluZXJ0TWFuYWdlci5zZXRJbmVydCh0aGlzLCBpbmVydCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSkoKTtcblxufSkpKTtcbiIsImltcG9ydCBcImJsb2NraW5nLWVsZW1lbnRzXCI7XHJcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IFwid2ljZy1pbmVydFwiO1xyXG5jb25zdCBibG9ja2luZ0VsZW1lbnRzID0gZG9jdW1lbnQuJGJsb2NraW5nRWxlbWVudHM7XHJcbi8qKlxyXG4gKiBBbGxvd3MgYW4gZWxlbWVudCB0byB0cmFwIGZvY3VzIGJ5IGFwcGx5aW5nIHRoZSBcImluZXJ0XCIgYXR0cmlidXRlIHRvIGFsbCBzaWJsaW5nLCBhdW50LCBhbmQgdW5jbGUgbm9kZXMuXHJcbiAqXHJcbiAqIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyBjb25zZWN1dGl2ZSBjYWxscyB3aXRoIGEgbG9vc2VseSBhcHBsaWVkIHN0YWNrIG9wZXJhdGlvblxyXG4gKiAoc3BlY2lmaWNhbGx5IHZpYSBgYmxvY2tpbmdFbGVtZW50c2AsIHdpdGggYSBzbWFsbCBwb2x5ZmlsbCBiZWNhdXNlIEknbSBub3Qgc3VyZSBob3cgbG9uZ1xyXG4gKiBpdCdsbCB0YWtlIHRvIGZpbmQgaXRzIHdheSBpbnRvIHRoZSBzcGVjLCBpZiBldmVyKVxyXG4gKiBAcGFyYW0gdGFyZ2V0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQmxvY2tpbmdFbGVtZW50KHRhcmdldCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBQdXNoL3BvcCB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZ0VsZW1lbnRzIHN0YWNrLlxyXG4gICAgICovXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgYmxvY2tpbmdFbGVtZW50cy5wdXNoKHRhcmdldCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBibG9ja2luZ0VsZW1lbnRzLnJlbW92ZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0YXJnZXRdKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wRWxlbWVudCgpIHtcclxuICAgIHJldHVybiBibG9ja2luZ0VsZW1lbnRzLnRvcDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtYmxvY2tpbmctZWxlbWVudC5qcy5tYXAiLCJpbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGlzRm9jdXNhYmxlIH0gZnJvbSBcInRhYmJhYmxlXCI7XHJcbmltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQgfSBmcm9tIFwiLi91c2UtYWN0aXZlLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgZ2V0VG9wRWxlbWVudCwgdXNlQmxvY2tpbmdFbGVtZW50IH0gZnJvbSBcIi4vdXNlLWJsb2NraW5nLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcclxuY29uc3QgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvID0gbmV3IE1hcCgpO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9jdXNUcmFwKHsgdHJhcEFjdGl2ZSB9KSB7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgY29uc3QgeyBnZXRMYXN0QWN0aXZlRWxlbWVudCB9ID0gdXNlQWN0aXZlRWxlbWVudCgpO1xyXG4gICAgLy8gV2hlbiB0aGUgdHJhcCBiZWNvbWVzIGFjdGl2ZSwgYmVmb3JlIHdlIGxldCB0aGUgYmxvY2tpbmdFbGVtZW50cyBob29rIHJ1bixcclxuICAgIC8vIGtlZXAgdHJhY2sgb2Ygd2hhdGV2ZXIncyBjdXJyZW50bHkgZm9jdXNlZCBhbmQgc2F2ZSBpdC5cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRyYXBBY3RpdmUgJiYgZWxlbWVudCkge1xyXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50XHJcbiAgICAgICAgICAgIC8vIHRvIHdoYXRldmVyJ3MgY3VycmVudGx5IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgICAgICAgIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUby5zZXQoZ2V0VG9wRWxlbWVudCgpLCBnZXRMYXN0QWN0aXZlRWxlbWVudCgpID8/IGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0cmFwQWN0aXZlLCBlbGVtZW50XSk7XHJcbiAgICB1c2VCbG9ja2luZ0VsZW1lbnQodHJhcEFjdGl2ZSA/IGVsZW1lbnQgOiBudWxsKTtcclxuICAgIC8qKlxyXG4gICAgICogQW55IHRpbWUgd2UgYWN0aXZhdGUgb3IgZGVhY3RpdmF0ZSB0aGUgdHJhcCxcclxuICAgICAqIGNoYW5nZSBmb2N1cyB0byBzb21ldGhpbmcgZWxzZSAoc29tZXRoaW5nIGluXHJcbiAgICAgKiB0aGUgdHJhcCBpZiBpdCdzIGFjdGl2ZSwgb3Igd2hhdGV2ZXIgd2UndmVcclxuICAgICAqIHRyYWNrZWQgaW4gZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvIGlmIG5vdClcclxuICAgICAqL1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAodHJhcEFjdGl2ZSAmJiBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGxldCByYWZIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBleHRyYSBxdWV1ZU1pY3JvdGFzayBpcyBuZWVkZWQgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyAuLi5yZWFzb25zP1xyXG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50KT8uZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICByYWZIYW5kbGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhZkhhbmRsZSlcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGZvY3VzIHRvIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgIC8vIHRoYXQgaGFzIHJldHVybmVkIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgICAgICAgIGxldCByYWZIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUby5nZXQoZ2V0VG9wRWxlbWVudCgpKT8uZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICByYWZIYW5kbGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhZkhhbmRsZSlcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0cmFwQWN0aXZlLCBlbGVtZW50XSk7XHJcbiAgICBjb25zdCB1c2VGb2N1c1RyYXBQcm9wcyA9ICgocHJvcHMpID0+IHtcclxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IFwiYXJpYS1tb2RhbFwiOiB0cmFwQWN0aXZlID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSwgdXNlUmVmRWxlbWVudFByb3BzKHByb3BzKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlRm9jdXNUcmFwUHJvcHMsXHJcbiAgICAgICAgZWxlbWVudCxcclxuICAgICAgICBnZXRFbGVtZW50XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBjb250YWluZWQgd2l0aGluIHRoZSBnaXZlbiBub2RlLCBvciBudWxsIGlmIG5vbmUgYXJlIGZvdW5kLlxyXG4gKiBAcGFyYW0gZWxlbWVudFxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50KSB7XHJcbiAgICBjb25zdCB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgeyBhY2NlcHROb2RlOiAobm9kZSkgPT4gKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGlzRm9jdXNhYmxlKG5vZGUpID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUIDogTm9kZUZpbHRlci5GSUxURVJfU0tJUCkgfSk7XHJcbiAgICBjb25zdCBmaXJzdEZvY3VzYWJsZSA9IHRyZWVXYWxrZXIuZmlyc3RDaGlsZCgpO1xyXG4gICAgcmV0dXJuIGZpcnN0Rm9jdXNhYmxlO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1mb2N1cy10cmFwLmpzLm1hcCIsImltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VGb3JjZVVwZGF0ZSgpIHtcclxuICAgIGNvbnN0IFssIHNldF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIHJldHVybiB1c2VSZWYoKCkgPT4gc2V0KGkgPT4gKytpKSkuY3VycmVudDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtZm9yY2UtdXBkYXRlLmpzLm1hcCIsImltcG9ydCB7IHVzZUhhc0ZvY3VzLCB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFUb29sdGlwKHsgbW91c2VvdmVyRGVsYXkgfSkge1xyXG4gICAgbW91c2VvdmVyRGVsYXkgPz89IDQwMDtcclxuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuLCBnZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtoYXNBbnlNb3VzZW92ZXIsIHNldEhhc0FueU1vdXNlb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICAvL2NvbnN0IFttb3VzZW92ZXJJc1ZhbGlkLCBzZXRNb3VzZW92ZXJJc1ZhbGlkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlVG9vbHRpcElkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzOiB1c2VUb29sdGlwSWRSZWZlcmVuY2luZ1Byb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLXRvb2x0aXAtXCIgfSk7XHJcbiAgICBjb25zdCB7IGZvY3VzZWRJbm5lcjogdHJpZ2dlckZvY3VzZWQsIHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzKCk7XHJcbiAgICBjb25zdCBbdHJpZ2dlckhhc01vdXNlb3Zlciwgc2V0VHJpZ2dlckhhc01vdXNlb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdG9vbHRpcEhhc01vdXNlb3Zlciwgc2V0VG9vbHRpcEhhc01vdXNlb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICB1c2VUaW1lb3V0KHtcclxuICAgICAgICB0aW1lb3V0OiBtb3VzZW92ZXJEZWxheSxcclxuICAgICAgICB0cmlnZ2VySW5kZXg6ICgrdHJpZ2dlckhhc01vdXNlb3ZlciArICt0b29sdGlwSGFzTW91c2VvdmVyKSxcclxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHJpZ2dlckhhc01vdXNlb3ZlciB8fCB0b29sdGlwSGFzTW91c2VvdmVyKVxyXG4gICAgICAgICAgICAgICAgc2V0SGFzQW55TW91c2VvdmVyKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdXNlVGltZW91dCh7XHJcbiAgICAgICAgdGltZW91dDogNTAsXHJcbiAgICAgICAgdHJpZ2dlckluZGV4OiAoK3RyaWdnZXJIYXNNb3VzZW92ZXIgKyArdG9vbHRpcEhhc01vdXNlb3ZlciksXHJcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0cmlnZ2VySGFzTW91c2VvdmVyICYmICF0b29sdGlwSGFzTW91c2VvdmVyKVxyXG4gICAgICAgICAgICAgICAgc2V0SGFzQW55TW91c2VvdmVyKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0T3BlbihoYXNBbnlNb3VzZW92ZXIgfHwgdHJpZ2dlckZvY3VzZWQpO1xyXG4gICAgfSwgW2hhc0FueU1vdXNlb3ZlciwgdHJpZ2dlckZvY3VzZWRdKTtcclxuICAgIGNvbnN0IHVzZVRvb2x0aXBUcmlnZ2VyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVG9vbHRpcFRyaWdnZXIoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gb25Qb2ludGVyRW50ZXIoZSkge1xyXG4gICAgICAgICAgICBzZXRUcmlnZ2VySGFzTW91c2VvdmVyKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvblBvaW50ZXJMZWF2ZShlKSB7XHJcbiAgICAgICAgICAgIHNldFRyaWdnZXJIYXNNb3VzZW92ZXIoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiB1c2VUb29sdGlwVHJpZ2dlclByb3BzKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICAvLyBOb3RlOiBUaG91Z2ggaXQncyBpbXBvcnRhbnQgdG8gbWFrZSBzdXJlIHRoYXQgZm9jdXNpbmcgYWN0aXZhdGVzIGEgdG9vbHRpcCxcclxuICAgICAgICAgICAgLy8gaXQncyBwZXJmZWN0bHkgcmVhc29uYWJsZSB0aGF0IGEgY2hpbGQgZWxlbWVudCB3aWxsIGJlIHRoZSBvbmUgdGhhdCdzIGZvY3VzZWQsXHJcbiAgICAgICAgICAgIC8vIG5vdCB0aGlzIG9uZSwgc28gd2UgZG9uJ3Qgc2V0IHRhYkluZGV4PTBcclxuICAgICAgICAgICAgcmV0dXJuIHVzZVRvb2x0aXBJZFJlZmVyZW5jaW5nUHJvcHMoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpKHVzZU1lcmdlZFByb3BzKCkoeyBvblBvaW50ZXJFbnRlciwgb25Qb2ludGVyTGVhdmUgfSwgdXNlSGFzRm9jdXNQcm9wcyhwcm9wcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyB9O1xyXG4gICAgfSwgW3VzZVRvb2x0aXBJZFJlZmVyZW5jaW5nUHJvcHNdKTtcclxuICAgIGNvbnN0IHVzZVRvb2x0aXAgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VUb29sdGlwKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIG9uUG9pbnRlckVudGVyKGUpIHtcclxuICAgICAgICAgICAgc2V0VG9vbHRpcEhhc01vdXNlb3Zlcih0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gb25Qb2ludGVyTGVhdmUoZSkge1xyXG4gICAgICAgICAgICBzZXRUb29sdGlwSGFzTW91c2VvdmVyKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlVG9vbHRpcFByb3BzKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJ0b29sdGlwXCI7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VUb29sdGlwSWRQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHsgb25Qb2ludGVyRW50ZXIsIG9uUG9pbnRlckxlYXZlIH0sIHByb3BzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZVRvb2x0aXBQcm9wcyB9O1xyXG4gICAgfSwgW3VzZVRvb2x0aXBJZFByb3BzXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVRvb2x0aXAsXHJcbiAgICAgICAgdXNlVG9vbHRpcFRyaWdnZXIsXHJcbiAgICAgICAgaXNPcGVuOiBvcGVuLFxyXG4gICAgICAgIGdldElzT3BlbjogZ2V0T3BlblxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtdG9vbHRpcC5qcy5tYXAiLCJpbXBvcnR7dXNlU3RhdGUgYXMgbix1c2VSZWR1Y2VyIGFzIHQsdXNlRWZmZWN0IGFzIGUsdXNlTGF5b3V0RWZmZWN0IGFzIHIsdXNlUmVmIGFzIHUsdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyBvLHVzZU1lbW8gYXMgaSx1c2VDYWxsYmFjayBhcyBsLHVzZUNvbnRleHQgYXMgZix1c2VEZWJ1Z1ZhbHVlIGFzIGN9ZnJvbVwicHJlYWN0L2hvb2tzXCI7ZXhwb3J0KmZyb21cInByZWFjdC9ob29rc1wiO2ltcG9ydHtDb21wb25lbnQgYXMgYSxjcmVhdGVFbGVtZW50IGFzIHMsb3B0aW9ucyBhcyBoLHRvQ2hpbGRBcnJheSBhcyB2LEZyYWdtZW50IGFzIGQscmVuZGVyIGFzIHAsaHlkcmF0ZSBhcyBtLGNsb25lRWxlbWVudCBhcyB5LGNyZWF0ZVJlZiBhcyBiLGNyZWF0ZUNvbnRleHQgYXMgX31mcm9tXCJwcmVhY3RcIjtleHBvcnR7Y3JlYXRlRWxlbWVudCxjcmVhdGVDb250ZXh0LGNyZWF0ZVJlZixGcmFnbWVudCxDb21wb25lbnR9ZnJvbVwicHJlYWN0XCI7ZnVuY3Rpb24gUyhuLHQpe2Zvcih2YXIgZSBpbiB0KW5bZV09dFtlXTtyZXR1cm4gbn1mdW5jdGlvbiBDKG4sdCl7Zm9yKHZhciBlIGluIG4paWYoXCJfX3NvdXJjZVwiIT09ZSYmIShlIGluIHQpKXJldHVybiEwO2Zvcih2YXIgciBpbiB0KWlmKFwiX19zb3VyY2VcIiE9PXImJm5bcl0hPT10W3JdKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIEUobil7dGhpcy5wcm9wcz1ufWZ1bmN0aW9uIGcobix0KXtmdW5jdGlvbiBlKG4pe3ZhciBlPXRoaXMucHJvcHMucmVmLHI9ZT09bi5yZWY7cmV0dXJuIXImJmUmJihlLmNhbGw/ZShudWxsKTplLmN1cnJlbnQ9bnVsbCksdD8hdCh0aGlzLnByb3BzLG4pfHwhcjpDKHRoaXMucHJvcHMsbil9ZnVuY3Rpb24gcih0KXtyZXR1cm4gdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGU9ZSxzKG4sdCl9cmV0dXJuIHIuZGlzcGxheU5hbWU9XCJNZW1vKFwiKyhuLmRpc3BsYXlOYW1lfHxuLm5hbWUpK1wiKVwiLHIucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9ITAsci5fX2Y9ITAscn0oRS5wcm90b3R5cGU9bmV3IGEpLmlzUHVyZVJlYWN0Q29tcG9uZW50PSEwLEUucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mdW5jdGlvbihuLHQpe3JldHVybiBDKHRoaXMucHJvcHMsbil8fEModGhpcy5zdGF0ZSx0KX07dmFyIHc9aC5fX2I7aC5fX2I9ZnVuY3Rpb24obil7bi50eXBlJiZuLnR5cGUuX19mJiZuLnJlZiYmKG4ucHJvcHMucmVmPW4ucmVmLG4ucmVmPW51bGwpLHcmJncobil9O3ZhciBSPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3ImJlN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKXx8MzkxMTtmdW5jdGlvbiB4KG4pe2Z1bmN0aW9uIHQodCxlKXt2YXIgcj1TKHt9LHQpO3JldHVybiBkZWxldGUgci5yZWYsbihyLChlPXQucmVmfHxlKSYmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxcImN1cnJlbnRcImluIGUpP2U6bnVsbCl9cmV0dXJuIHQuJCR0eXBlb2Y9Uix0LnJlbmRlcj10LHQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9dC5fX2Y9ITAsdC5kaXNwbGF5TmFtZT1cIkZvcndhcmRSZWYoXCIrKG4uZGlzcGxheU5hbWV8fG4ubmFtZSkrXCIpXCIsdH12YXIgTj1mdW5jdGlvbihuLHQpe3JldHVybiBudWxsPT1uP251bGw6dih2KG4pLm1hcCh0KSl9LGs9e21hcDpOLGZvckVhY2g6Tixjb3VudDpmdW5jdGlvbihuKXtyZXR1cm4gbj92KG4pLmxlbmd0aDowfSxvbmx5OmZ1bmN0aW9uKG4pe3ZhciB0PXYobik7aWYoMSE9PXQubGVuZ3RoKXRocm93XCJDaGlsZHJlbi5vbmx5XCI7cmV0dXJuIHRbMF19LHRvQXJyYXk6dn0sQT1oLl9fZTtoLl9fZT1mdW5jdGlvbihuLHQsZSl7aWYobi50aGVuKWZvcih2YXIgcix1PXQ7dT11Ll9fOylpZigocj11Ll9fYykmJnIuX19jKXJldHVybiBudWxsPT10Ll9fZSYmKHQuX19lPWUuX19lLHQuX19rPWUuX19rKSxyLl9fYyhuLHQpO0Eobix0LGUpfTt2YXIgTz1oLnVubW91bnQ7ZnVuY3Rpb24gTCgpe3RoaXMuX191PTAsdGhpcy50PW51bGwsdGhpcy5fX2I9bnVsbH1mdW5jdGlvbiBVKG4pe3ZhciB0PW4uX18uX19jO3JldHVybiB0JiZ0Ll9fZSYmdC5fX2Uobil9ZnVuY3Rpb24gRihuKXt2YXIgdCxlLHI7ZnVuY3Rpb24gdSh1KXtpZih0fHwodD1uKCkpLnRoZW4oZnVuY3Rpb24obil7ZT1uLmRlZmF1bHR8fG59LGZ1bmN0aW9uKG4pe3I9bn0pLHIpdGhyb3cgcjtpZighZSl0aHJvdyB0O3JldHVybiBzKGUsdSl9cmV0dXJuIHUuZGlzcGxheU5hbWU9XCJMYXp5XCIsdS5fX2Y9ITAsdX1mdW5jdGlvbiBNKCl7dGhpcy51PW51bGwsdGhpcy5vPW51bGx9aC51bm1vdW50PWZ1bmN0aW9uKG4pe3ZhciB0PW4uX19jO3QmJnQuX19SJiZ0Ll9fUigpLHQmJiEwPT09bi5fX2gmJihuLnR5cGU9bnVsbCksTyYmTyhuKX0sKEwucHJvdG90eXBlPW5ldyBhKS5fX2M9ZnVuY3Rpb24obix0KXt2YXIgZT10Ll9fYyxyPXRoaXM7bnVsbD09ci50JiYoci50PVtdKSxyLnQucHVzaChlKTt2YXIgdT1VKHIuX192KSxvPSExLGk9ZnVuY3Rpb24oKXtvfHwobz0hMCxlLl9fUj1udWxsLHU/dShsKTpsKCkpfTtlLl9fUj1pO3ZhciBsPWZ1bmN0aW9uKCl7aWYoIS0tci5fX3Upe2lmKHIuc3RhdGUuX19lKXt2YXIgbj1yLnN0YXRlLl9fZTtyLl9fdi5fX2tbMF09ZnVuY3Rpb24gbih0LGUscil7cmV0dXJuIHQmJih0Ll9fdj1udWxsLHQuX19rPXQuX19rJiZ0Ll9fay5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG4odCxlLHIpfSksdC5fX2MmJnQuX19jLl9fUD09PWUmJih0Ll9fZSYmci5pbnNlcnRCZWZvcmUodC5fX2UsdC5fX2QpLHQuX19jLl9fZT0hMCx0Ll9fYy5fX1A9cikpLHR9KG4sbi5fX2MuX19QLG4uX19jLl9fTyl9dmFyIHQ7Zm9yKHIuc2V0U3RhdGUoe19fZTpyLl9fYj1udWxsfSk7dD1yLnQucG9wKCk7KXQuZm9yY2VVcGRhdGUoKX19LGY9ITA9PT10Ll9faDtyLl9fdSsrfHxmfHxyLnNldFN0YXRlKHtfX2U6ci5fX2I9ci5fX3YuX19rWzBdfSksbi50aGVuKGksaSl9LEwucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dGhpcy50PVtdfSxMLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24obix0KXtpZih0aGlzLl9fYil7aWYodGhpcy5fX3YuX19rKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHI9dGhpcy5fX3YuX19rWzBdLl9fYzt0aGlzLl9fdi5fX2tbMF09ZnVuY3Rpb24gbih0LGUscil7cmV0dXJuIHQmJih0Ll9fYyYmdC5fX2MuX19IJiYodC5fX2MuX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7XCJmdW5jdGlvblwiPT10eXBlb2Ygbi5fX2MmJm4uX19jKCl9KSx0Ll9fYy5fX0g9bnVsbCksbnVsbCE9KHQ9Uyh7fSx0KSkuX19jJiYodC5fX2MuX19QPT09ciYmKHQuX19jLl9fUD1lKSx0Ll9fYz1udWxsKSx0Ll9faz10Ll9fayYmdC5fX2subWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuKHQsZSxyKX0pKSx0fSh0aGlzLl9fYixlLHIuX19PPXIuX19QKX10aGlzLl9fYj1udWxsfXZhciB1PXQuX19lJiZzKGQsbnVsbCxuLmZhbGxiYWNrKTtyZXR1cm4gdSYmKHUuX19oPW51bGwpLFtzKGQsbnVsbCx0Ll9fZT9udWxsOm4uY2hpbGRyZW4pLHVdfTt2YXIgVD1mdW5jdGlvbihuLHQsZSl7aWYoKytlWzFdPT09ZVswXSYmbi5vLmRlbGV0ZSh0KSxuLnByb3BzLnJldmVhbE9yZGVyJiYoXCJ0XCIhPT1uLnByb3BzLnJldmVhbE9yZGVyWzBdfHwhbi5vLnNpemUpKWZvcihlPW4udTtlOyl7Zm9yKDtlLmxlbmd0aD4zOyllLnBvcCgpKCk7aWYoZVsxXTxlWzBdKWJyZWFrO24udT1lPWVbMl19fTtmdW5jdGlvbiBEKG4pe3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiBuLmNvbnRleHR9LG4uY2hpbGRyZW59ZnVuY3Rpb24gSShuKXt2YXIgdD10aGlzLGU9bi5pO3QuY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXtwKG51bGwsdC5sKSx0Lmw9bnVsbCx0Lmk9bnVsbH0sdC5pJiZ0LmkhPT1lJiZ0LmNvbXBvbmVudFdpbGxVbm1vdW50KCksbi5fX3Y/KHQubHx8KHQuaT1lLHQubD17bm9kZVR5cGU6MSxwYXJlbnROb2RlOmUsY2hpbGROb2RlczpbXSxhcHBlbmRDaGlsZDpmdW5jdGlvbihuKXt0aGlzLmNoaWxkTm9kZXMucHVzaChuKSx0LmkuYXBwZW5kQ2hpbGQobil9LGluc2VydEJlZm9yZTpmdW5jdGlvbihuLGUpe3RoaXMuY2hpbGROb2Rlcy5wdXNoKG4pLHQuaS5hcHBlbmRDaGlsZChuKX0scmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24obil7dGhpcy5jaGlsZE5vZGVzLnNwbGljZSh0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihuKT4+PjEsMSksdC5pLnJlbW92ZUNoaWxkKG4pfX0pLHAocyhELHtjb250ZXh0OnQuY29udGV4dH0sbi5fX3YpLHQubCkpOnQubCYmdC5jb21wb25lbnRXaWxsVW5tb3VudCgpfWZ1bmN0aW9uIFcobix0KXtyZXR1cm4gcyhJLHtfX3Y6bixpOnR9KX0oTS5wcm90b3R5cGU9bmV3IGEpLl9fZT1mdW5jdGlvbihuKXt2YXIgdD10aGlzLGU9VSh0Ll9fdikscj10Lm8uZ2V0KG4pO3JldHVybiByWzBdKyssZnVuY3Rpb24odSl7dmFyIG89ZnVuY3Rpb24oKXt0LnByb3BzLnJldmVhbE9yZGVyPyhyLnB1c2godSksVCh0LG4scikpOnUoKX07ZT9lKG8pOm8oKX19LE0ucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihuKXt0aGlzLnU9bnVsbCx0aGlzLm89bmV3IE1hcDt2YXIgdD12KG4uY2hpbGRyZW4pO24ucmV2ZWFsT3JkZXImJlwiYlwiPT09bi5yZXZlYWxPcmRlclswXSYmdC5yZXZlcnNlKCk7Zm9yKHZhciBlPXQubGVuZ3RoO2UtLTspdGhpcy5vLnNldCh0W2VdLHRoaXMudT1bMSwwLHRoaXMudV0pO3JldHVybiBuLmNoaWxkcmVufSxNLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGU9TS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQ9ZnVuY3Rpb24oKXt2YXIgbj10aGlzO3RoaXMuby5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7VChuLGUsdCl9KX07dmFyIGo9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvciYmU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIil8fDYwMTAzLFA9L14oPzphY2NlbnR8YWxpZ25tZW50fGFyYWJpY3xiYXNlbGluZXxjYXB8Y2xpcCg/IVBhdGhVKXxjb2xvcnxmaWxsfGZsb29kfGZvbnR8Z2x5cGgoPyFSKXxob3JpenxtYXJrZXIoPyFIfFd8VSl8b3ZlcmxpbmV8cGFpbnR8c3RvcHxzdHJpa2V0aHJvdWdofHN0cm9rZXx0ZXh0KD8hTCl8dW5kZXJsaW5lfHVuaWNvZGV8dW5pdHN8dnx2ZWN0b3J8dmVydHx3b3JkfHdyaXRpbmd8eCg/IUMpKVtBLVpdLyxWPWZ1bmN0aW9uKG4pe3JldHVybihcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sKCk/L2ZpbHxjaGV8cmFkL2k6L2ZpbHxjaGV8cmEvaSkudGVzdChuKX07ZnVuY3Rpb24geihuLHQsZSl7cmV0dXJuIG51bGw9PXQuX19rJiYodC50ZXh0Q29udGVudD1cIlwiKSxwKG4sdCksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZSgpLG4/bi5fX2M6bnVsbH1mdW5jdGlvbiBCKG4sdCxlKXtyZXR1cm4gbShuLHQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUoKSxuP24uX19jOm51bGx9YS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fSxbXCJjb21wb25lbnRXaWxsTW91bnRcIixcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIixcImNvbXBvbmVudFdpbGxVcGRhdGVcIl0uZm9yRWFjaChmdW5jdGlvbihuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsbix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW1wiVU5TQUZFX1wiK25dfSxzZXQ6ZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsbix7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KX19KX0pO3ZhciBIPWguZXZlbnQ7ZnVuY3Rpb24gWigpe31mdW5jdGlvbiBZKCl7cmV0dXJuIHRoaXMuY2FuY2VsQnViYmxlfWZ1bmN0aW9uICQoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UHJldmVudGVkfWguZXZlbnQ9ZnVuY3Rpb24obil7cmV0dXJuIEgmJihuPUgobikpLG4ucGVyc2lzdD1aLG4uaXNQcm9wYWdhdGlvblN0b3BwZWQ9WSxuLmlzRGVmYXVsdFByZXZlbnRlZD0kLG4ubmF0aXZlRXZlbnQ9bn07dmFyIHEsRz17Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsYXNzfX0sSj1oLnZub2RlO2gudm5vZGU9ZnVuY3Rpb24obil7dmFyIHQ9bi50eXBlLGU9bi5wcm9wcyxyPWU7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2Zvcih2YXIgdSBpbiByPXt9LGUpe3ZhciBvPWVbdV07XCJ2YWx1ZVwiPT09dSYmXCJkZWZhdWx0VmFsdWVcImluIGUmJm51bGw9PW98fChcImRlZmF1bHRWYWx1ZVwiPT09dSYmXCJ2YWx1ZVwiaW4gZSYmbnVsbD09ZS52YWx1ZT91PVwidmFsdWVcIjpcImRvd25sb2FkXCI9PT11JiYhMD09PW8/bz1cIlwiOi9vbmRvdWJsZWNsaWNrL2kudGVzdCh1KT91PVwib25kYmxjbGlja1wiOi9eb25jaGFuZ2UodGV4dGFyZWF8aW5wdXQpL2kudGVzdCh1K3QpJiYhVihlLnR5cGUpP3U9XCJvbmlucHV0XCI6L15vbihBbml8VHJhfFRvdXxCZWZvcmVJbnApLy50ZXN0KHUpP3U9dS50b0xvd2VyQ2FzZSgpOlAudGVzdCh1KT91PXUucmVwbGFjZSgvW0EtWjAtOV0vLFwiLSQmXCIpLnRvTG93ZXJDYXNlKCk6bnVsbD09PW8mJihvPXZvaWQgMCksclt1XT1vKX1cInNlbGVjdFwiPT10JiZyLm11bHRpcGxlJiZBcnJheS5pc0FycmF5KHIudmFsdWUpJiYoci52YWx1ZT12KGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24obil7bi5wcm9wcy5zZWxlY3RlZD0tMSE9ci52YWx1ZS5pbmRleE9mKG4ucHJvcHMudmFsdWUpfSkpLFwic2VsZWN0XCI9PXQmJm51bGwhPXIuZGVmYXVsdFZhbHVlJiYoci52YWx1ZT12KGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24obil7bi5wcm9wcy5zZWxlY3RlZD1yLm11bHRpcGxlPy0xIT1yLmRlZmF1bHRWYWx1ZS5pbmRleE9mKG4ucHJvcHMudmFsdWUpOnIuZGVmYXVsdFZhbHVlPT1uLnByb3BzLnZhbHVlfSkpLG4ucHJvcHM9cn10JiZlLmNsYXNzIT1lLmNsYXNzTmFtZSYmKEcuZW51bWVyYWJsZT1cImNsYXNzTmFtZVwiaW4gZSxudWxsIT1lLmNsYXNzTmFtZSYmKHIuY2xhc3M9ZS5jbGFzc05hbWUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiY2xhc3NOYW1lXCIsRykpLG4uJCR0eXBlb2Y9aixKJiZKKG4pfTt2YXIgSz1oLl9fcjtoLl9fcj1mdW5jdGlvbihuKXtLJiZLKG4pLHE9bi5fX2N9O3ZhciBRPXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyOntjdXJyZW50OntyZWFkQ29udGV4dDpmdW5jdGlvbihuKXtyZXR1cm4gcS5fX25bbi5fX2NdLnByb3BzLnZhbHVlfX19fSxYPVwiMTcuMC4yXCI7ZnVuY3Rpb24gbm4obil7cmV0dXJuIHMuYmluZChudWxsLG4pfWZ1bmN0aW9uIHRuKG4pe3JldHVybiEhbiYmbi4kJHR5cGVvZj09PWp9ZnVuY3Rpb24gZW4obil7cmV0dXJuIHRuKG4pP3kuYXBwbHkobnVsbCxhcmd1bWVudHMpOm59ZnVuY3Rpb24gcm4obil7cmV0dXJuISFuLl9fayYmKHAobnVsbCxuKSwhMCl9ZnVuY3Rpb24gdW4obil7cmV0dXJuIG4mJihuLmJhc2V8fDE9PT1uLm5vZGVUeXBlJiZuKXx8bnVsbH12YXIgb249ZnVuY3Rpb24obix0KXtyZXR1cm4gbih0KX0sbG49ZnVuY3Rpb24obix0KXtyZXR1cm4gbih0KX0sZm49ZDtleHBvcnQgZGVmYXVsdHt1c2VTdGF0ZTpuLHVzZVJlZHVjZXI6dCx1c2VFZmZlY3Q6ZSx1c2VMYXlvdXRFZmZlY3Q6cix1c2VSZWY6dSx1c2VJbXBlcmF0aXZlSGFuZGxlOm8sdXNlTWVtbzppLHVzZUNhbGxiYWNrOmwsdXNlQ29udGV4dDpmLHVzZURlYnVnVmFsdWU6Yyx2ZXJzaW9uOlwiMTcuMC4yXCIsQ2hpbGRyZW46ayxyZW5kZXI6eixoeWRyYXRlOkIsdW5tb3VudENvbXBvbmVudEF0Tm9kZTpybixjcmVhdGVQb3J0YWw6VyxjcmVhdGVFbGVtZW50OnMsY3JlYXRlQ29udGV4dDpfLGNyZWF0ZUZhY3Rvcnk6bm4sY2xvbmVFbGVtZW50OmVuLGNyZWF0ZVJlZjpiLEZyYWdtZW50OmQsaXNWYWxpZEVsZW1lbnQ6dG4sZmluZERPTU5vZGU6dW4sQ29tcG9uZW50OmEsUHVyZUNvbXBvbmVudDpFLG1lbW86Zyxmb3J3YXJkUmVmOngsZmx1c2hTeW5jOmxuLHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOm9uLFN0cmljdE1vZGU6ZCxTdXNwZW5zZTpMLFN1c3BlbnNlTGlzdDpNLGxhenk6RixfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDpRfTtleHBvcnR7WCBhcyB2ZXJzaW9uLGsgYXMgQ2hpbGRyZW4seiBhcyByZW5kZXIsQiBhcyBoeWRyYXRlLHJuIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUsVyBhcyBjcmVhdGVQb3J0YWwsbm4gYXMgY3JlYXRlRmFjdG9yeSxlbiBhcyBjbG9uZUVsZW1lbnQsdG4gYXMgaXNWYWxpZEVsZW1lbnQsdW4gYXMgZmluZERPTU5vZGUsRSBhcyBQdXJlQ29tcG9uZW50LGcgYXMgbWVtbyx4IGFzIGZvcndhcmRSZWYsbG4gYXMgZmx1c2hTeW5jLG9uIGFzIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLGZuIGFzIFN0cmljdE1vZGUsTCBhcyBTdXNwZW5zZSxNIGFzIFN1c3BlbnNlTGlzdCxGIGFzIGxhenksUSBhcyBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wYXQubW9kdWxlLmpzLm1hcFxuIiwiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbi8qKlxyXG4gKiBTaG9ydGN1dCBmb3IgcHJlYWN0L2NvbXBhdCdzIGBmb3J3YXJkUmVmYCB0aGF0IGF1dG8tYXNzdW1lcyBzb21lIHRoaW5ncyB0aGF0IGFyZSB1c2VmdWwgZm9yIGZvcndhcmRpbmcgcmVmcyB0byBgSFRNTEVsZW1lbnRzYCBzcGVjaWZpY2FsbHkuXHJcbiAqIE5hbWVseSBpdCBpbnZvbHZlcyBkZS1ndW5raW5nIHRoZSB0eXBlIHN5c3RlbSBieSBsZXR0aW5nIHVzIHJldHVybiAqZ2VuZXJpYyogZnVuY3Rpb24gYW5kIHBsYXlpbmcgbmljZSB3aXRoIFJlYWN0LiBJbiBhbGwgb3RoZXIgcmVzcGVjdHMsIGl0IGFjdHMgbGlrZSBgZm9yd2FyZFJlZmAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZEVsZW1lbnRSZWYoQ29tcG9uZW50KSB7XHJcbiAgICBjb25zdCBGb3J3YXJkZWRDb21wb25lbnQgPSBmb3J3YXJkUmVmKENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gRm9yd2FyZGVkQ29tcG9uZW50O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcndhcmQtZWxlbWVudC1yZWYuanMubWFwIiwiaW1wb3J0IHsgZGVmYXVsdCBhcyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgY2xvbmVFbGVtZW50IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VMb2dpY2FsRGlyZWN0aW9uIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxvZ2ljYWwtZGlyZWN0aW9uXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG4vL2ltcG9ydCB7IG1lcmdlU3R5bGVzIH0gZnJvbSBcIi4vbWVyZ2Utc3R5bGVcIjtcclxuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcclxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKGNsYXNzQmFzZSwgb3BlbiwgcGhhc2UpIHtcclxuICAgIGlmIChwaGFzZSlcclxuICAgICAgICByZXR1cm4gYCR7Y2xhc3NCYXNlIHx8IFwidHJhbnNpdGlvblwifS0ke29wZW59LSR7cGhhc2V9YDtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gYCR7Y2xhc3NCYXNlIHx8IFwidHJhbnNpdGlvblwifS0ke29wZW59YDtcclxufVxyXG5sZXQgZHVtbXk7XHJcbmZ1bmN0aW9uIGZvcmNlUmVmbG93KGUpIHtcclxuICAgIC8vIFRyeSByZWFsbHkgaGFyZCB0byBtYWtlIHN1cmUgdGhpcyBpc24ndCBvcHRpbWl6ZWQgb3V0IGJ5IGFueXRoaW5nLlxyXG4gICAgLy8gV2UgbmVlZCBpdCBmb3IgaXRzIGRvY3VtZW50IHJlZmxvdyBzaWRlIGVmZmVjdC5cclxuICAgIGR1bW15ID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHJldHVybiBlO1xyXG59XHJcbi8qKlxyXG4gKiBBIGhvb2sgdGhhdCBhZGRzICYgcmVtb3ZlcyBjbGFzcyBuYW1lcyBpbiBhIHdheSB0aGF0IGZhY2lsaXRhdGVzIHByb3BlciB0cmFuc2l0aW9ucy5cclxuICpcclxuICogVGhlIGZpcnN0IGFyZ3VtZW50IGNvbnRhaW5zIHRoZSBwcm9wcyByZWxhdGVkIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uLlxyXG4gKlxyXG4gKiBUaGUgc2Vjb25kIGFyZ3VtZW50IGNvbnRhaW5zIGFueSBvdGhlciBwcm9wcyB5b3UgbWlnaHQgd2FudCBtZXJnZWQgaW50byB0aGUgZmluYWwgcHJvZHVjdCAodGhlc2UgYXJlIG5vdCByZWFkIG9yIG1hbmlwdWxhdGVkIG9yIGFueXRoaW5nIC0tIGl0J3MgcHVyZWx5IHNob3J0aGFuZCBhbmQgY2FuIGJlIG9taXR0ZWQgd2l0aCBge31gIGFuZCB0aGVuIHlvdXIgb3duIGB1c2VNZXJnZWRQcm9wc2ApLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHMoeyBtZWFzdXJlLCBhbmltYXRlT25Nb3VudCwgY2xhc3NCYXNlLCBvblRyYW5zaXRpb25VcGRhdGUsIGV4aXRWaXNpYmlsaXR5LCBkdXJhdGlvbiwgb3BlbiwgcmVmIH0sIG90aGVyUHJvcHMpIHtcclxuICAgIGNsYXNzQmFzZSA/Pz0gXCJ0cmFuc2l0aW9uXCI7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgY29uc3QgW3BoYXNlLCBzZXRQaGFzZV0gPSB1c2VTdGF0ZShhbmltYXRlT25Nb3VudCA/IFwiaW5pdFwiIDogbnVsbCk7XHJcbiAgICBjb25zdCBbZGlyZWN0aW9uLCBzZXREaXJlY3Rpb25dID0gdXNlU3RhdGUob3BlbiA9PSBudWxsID8gbnVsbCA6IG9wZW4gPyBcImVudGVyXCIgOiBcImV4aXRcIik7XHJcbiAgICBjb25zdCBbc3VyZmFjZVdpZHRoLCBzZXRTdXJmYWNlV2lkdGhdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBbc3VyZmFjZUhlaWdodCwgc2V0U3VyZmFjZUhlaWdodF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtzdXJmYWNlWCwgc2V0U3VyZmFjZVhdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBbc3VyZmFjZVksIHNldFN1cmZhY2VZXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgW3RyYW5zaXRpb25pbmdXaWR0aCwgc2V0VHJhbnNpdGlvbmluZ1dpZHRoXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgW3RyYW5zaXRpb25pbmdIZWlnaHQsIHNldFRyYW5zaXRpb25pbmdIZWlnaHRdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBbdHJhbnNpdGlvbmluZ1gsIHNldFRyYW5zaXRpb25pbmdYXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgW3RyYW5zaXRpb25pbmdZLCBzZXRUcmFuc2l0aW9uaW5nWV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IHsgZ2V0TG9naWNhbERpcmVjdGlvbiB9ID0gdXNlTG9naWNhbERpcmVjdGlvbihlbGVtZW50KTtcclxuICAgIGNvbnN0IGxvZ2ljYWxEaXJlY3Rpb24gPSBnZXRMb2dpY2FsRGlyZWN0aW9uKCk7XHJcbiAgICBjb25zdCBvblRyYW5zaXRpb25VcGRhdGVSZWYgPSB1c2VSZWYob25UcmFuc2l0aW9uVXBkYXRlKTtcclxuICAgIGNvbnN0IHBoYXNlUmVmID0gdXNlUmVmKHBoYXNlKTtcclxuICAgIGNvbnN0IGRpcmVjdGlvblJlZiA9IHVzZVJlZihkaXJlY3Rpb24pO1xyXG4gICAgY29uc3QgZHVyYXRpb25SZWYgPSB1c2VSZWYoZHVyYXRpb24pO1xyXG4gICAgY29uc3QgdG9vRWFybHlUaW1lb3V0UmVmID0gdXNlUmVmKG51bGwpO1xyXG4gICAgY29uc3QgdG9vRWFybHlWYWx1ZVJlZiA9IHVzZVJlZih0cnVlKTtcclxuICAgIGNvbnN0IHRvb0xhdGVUaW1lb3V0UmVmID0gdXNlUmVmKG51bGwpO1xyXG4gICAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcclxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGVsZW1lbnQgJiYgdG9vRWFybHlWYWx1ZVJlZi5jdXJyZW50ID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHNldFBoYXNlKFwiZmluYWxpemVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2VsZW1lbnRdKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IG9uVHJhbnNpdGlvblVwZGF0ZVJlZi5jdXJyZW50ID0gb25UcmFuc2l0aW9uVXBkYXRlOyB9LCBbb25UcmFuc2l0aW9uVXBkYXRlXSk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBwaGFzZVJlZi5jdXJyZW50ID0gcGhhc2U7IH0sIFtwaGFzZV0pO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgZGlyZWN0aW9uUmVmLmN1cnJlbnQgPSBkaXJlY3Rpb247IH0sIFtkaXJlY3Rpb25dKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IGR1cmF0aW9uUmVmLmN1cnJlbnQgPSBkdXJhdGlvbjsgfSwgW2R1cmF0aW9uXSk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiYgcGhhc2UpXHJcbiAgICAgICAgICAgIG9uVHJhbnNpdGlvblVwZGF0ZVJlZi5jdXJyZW50Py4oZGlyZWN0aW9uLCBwaGFzZSk7XHJcbiAgICB9LCBbZGlyZWN0aW9uLCBwaGFzZV0pO1xyXG4gICAgLy8gRXZlcnkgdGltZSB0aGUgcGhhc2UgY2hhbmdlcyB0byBcInRyYW5zaXRpb25cIiwgYWRkIG91ciB0cmFuc2l0aW9uIHRpbWVvdXQgdGltZW91dHNcclxuICAgIC8vIHRvIGNhdGNoIGFueSB0aW1lIG9uVHJhbnNpdGlvbkVuZCBmYWlscyB0byByZXBvcnQgZm9yIHdoYXRldmVyIHJlYXNvbiB0byBiZSBzYWZlXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChwaGFzZSA9PSBcInRyYW5zaXRpb25cIikge1xyXG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0RHVyYXRpb24gPSBkdXJhdGlvblJlZi5jdXJyZW50ID8/IDEwMDA7XHJcbiAgICAgICAgICAgIHRvb0Vhcmx5VGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdG9vRWFybHlWYWx1ZVJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0b29FYXJseVRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sIDUwKTtcclxuICAgICAgICAgICAgdG9vTGF0ZVRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRvb0Vhcmx5VmFsdWVSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0b29MYXRlVGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHNldFBoYXNlKFwiZmluYWxpemVcIik7XHJcbiAgICAgICAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0b29FYXJseVRpbWVvdXRSZWYuY3VycmVudClcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0b29FYXJseVRpbWVvdXRSZWYuY3VycmVudCk7XHJcbiAgICAgICAgICAgIGlmICh0b29MYXRlVGltZW91dFJlZi5jdXJyZW50KVxyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRvb0xhdGVUaW1lb3V0UmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbcGhhc2VdKTtcclxuICAgIC8vIEFueSB0aW1lIFwib3BlblwiIGNoYW5nZXMsIHVwZGF0ZSBvdXIgZGlyZWN0aW9uIGFuZCBwaGFzZS5cclxuICAgIC8vIEluIGFkZGl0aW9uLCBtZWFzdXJlIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IGlmIHJlcXVlc3RlZC5cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgb3BlbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUGhhc2UgPSBwaGFzZVJlZi5jdXJyZW50O1xyXG4gICAgICAgICAgICAvLyBTd2FwIG91ciBkaXJlY3Rpb25cclxuICAgICAgICAgICAgaWYgKG9wZW4pXHJcbiAgICAgICAgICAgICAgICBzZXREaXJlY3Rpb24oXCJlbnRlclwiKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgc2V0RGlyZWN0aW9uKFwiZXhpdFwiKTtcclxuICAgICAgICAgICAgc2V0UGhhc2UocHJldmlvdXNQaGFzZSA9PT0gbnVsbCA/IFwiZmluYWxpemVcIiA6IFwiaW5pdFwiKTtcclxuICAgICAgICAgICAgaWYgKG1lYXN1cmUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U2l6ZVdpdGhUcmFuc2l0aW9uID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGN1cnJlbnRTaXplV2l0aFRyYW5zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbmluZ1goeCArIFwicHhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbmluZ1koeSArIFwicHhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbmluZ1dpZHRoKHdpZHRoICsgXCJweFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uaW5nSGVpZ2h0KGhlaWdodCArIFwicHhcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNQaGFzZSA9PT0gXCJmaW5hbGl6ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gYmUgbWVzc2luZyB3aXRoIHRoZSBhY3R1YWwgZWxlbWVudCdzIGNsYXNzLCBcclxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSdsbCB3YW50IGFuIGVhc3kgd2F5IHRvIHJlc3RvcmUgaXQgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja3VwID0gZWxlbWVudC5jbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGAke2NsYXNzQmFzZX0tbWVhc3VyZWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgJHtjbGFzc0Jhc2V9LWVudGVyYCwgYCR7Y2xhc3NCYXNlfS1lbnRlci1pbml0YCwgYCR7Y2xhc3NCYXNlfS1lbnRlci10cmFuc2l0aW9uYCwgYCR7Y2xhc3NCYXNlfS1lbnRlci1maW5hbGl6ZWAsIGAke2NsYXNzQmFzZX0tZXhpdGAsIGAke2NsYXNzQmFzZX0tZXhpdC1pbml0YCwgYCR7Y2xhc3NCYXNlfS1leGl0LXRyYW5zaXRpb25gLCBgJHtjbGFzc0Jhc2V9LWV4aXQtZmluYWxpemVgKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3JjZVJlZmxvdyhlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaXplV2l0aG91dFRyYW5zaXRpb24gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gc2l6ZVdpdGhvdXRUcmFuc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN1cmZhY2VYKHggKyBcInB4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN1cmZhY2VZKHkgKyBcInB4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN1cmZhY2VXaWR0aCh3aWR0aCArIFwicHhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3VyZmFjZUhlaWdodChoZWlnaHQgKyBcInB4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gYmFja3VwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlUmVmbG93KGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW29wZW4sIGVsZW1lbnQsIG1lYXN1cmUsIGNsYXNzQmFzZV0pO1xyXG4gICAgLy8gQW55IHRpbWUgdGhlIHBoYXNlIGNoYW5nZXMgdG8gaW5pdCwgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBzY3JlZW4gaXMgcGFpbnRlZCxcclxuICAgIC8vIGNoYW5nZSB0aGUgcGhhc2UgdG8gXCJ0cmFuc2l0aW9uXCIgYW5kIHJlLXJlbmRlciAoKS5cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgZGlyZWN0aW9uUmVmLmN1cnJlbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjbGFzc0Jhc2UgPz89IFwidHJhbnNpdGlvblwiO1xyXG4gICAgICAgICAgICBpZiAocGhhc2UgPT09IFwiaW5pdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQcmVhY3QganVzdCBmaW5pc2hlZCByZW5kZXJpbmcgaW5pdFxyXG4gICAgICAgICAgICAgICAgLy8gTm93IHNldCBvdXIgdHJhbnNpdGlvbiBzdHlsZS5cclxuICAgICAgICAgICAgICAgIHNldFBoYXNlKFwidHJhbnNpdGlvblwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VSZWZsb3coZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbcGhhc2UsIG1lYXN1cmUsIGVsZW1lbnRdKTtcclxuICAgIGNvbnN0IGlubGluZURpcmVjdGlvbiA9IGxvZ2ljYWxEaXJlY3Rpb24/LmlubGluZURpcmVjdGlvbjtcclxuICAgIGNvbnN0IGJsb2NrRGlyZWN0aW9uID0gbG9naWNhbERpcmVjdGlvbj8uYmxvY2tEaXJlY3Rpb247XHJcbiAgICBjb25zdCB3cml0aW5nTW9kZUlzSG9yaXpvbnRhbCA9IChpbmxpbmVEaXJlY3Rpb24gPT0gXCJydGxcIiB8fCBpbmxpbmVEaXJlY3Rpb24gPT0gXCJsdHJcIik7XHJcbiAgICBjb25zdCBzdXJmYWNlSW5saW5lSW5zZXQgPSB3cml0aW5nTW9kZUlzSG9yaXpvbnRhbCA/IHN1cmZhY2VYIDogc3VyZmFjZVk7XHJcbiAgICBjb25zdCBzdXJmYWNlQmxvY2tJbnNldCA9IHdyaXRpbmdNb2RlSXNIb3Jpem9udGFsID8gc3VyZmFjZVkgOiBzdXJmYWNlWDtcclxuICAgIGNvbnN0IHN1cmZhY2VJbmxpbmVTaXplID0gd3JpdGluZ01vZGVJc0hvcml6b250YWwgPyBzdXJmYWNlV2lkdGggOiBzdXJmYWNlSGVpZ2h0O1xyXG4gICAgY29uc3Qgc3VyZmFjZUJsb2NrU2l6ZSA9IHdyaXRpbmdNb2RlSXNIb3Jpem9udGFsID8gc3VyZmFjZUhlaWdodCA6IHN1cmZhY2VXaWR0aDtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25pbmdJbmxpbmVJbnNldCA9IHdyaXRpbmdNb2RlSXNIb3Jpem9udGFsID8gdHJhbnNpdGlvbmluZ1ggOiB0cmFuc2l0aW9uaW5nWTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25pbmdCbG9ja0luc2V0ID0gd3JpdGluZ01vZGVJc0hvcml6b250YWwgPyB0cmFuc2l0aW9uaW5nWSA6IHRyYW5zaXRpb25pbmdYO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvbmluZ0lubGluZVNpemUgPSB3cml0aW5nTW9kZUlzSG9yaXpvbnRhbCA/IHRyYW5zaXRpb25pbmdXaWR0aCA6IHRyYW5zaXRpb25pbmdIZWlnaHQ7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uaW5nQmxvY2tTaXplID0gd3JpdGluZ01vZGVJc0hvcml6b250YWwgPyB0cmFuc2l0aW9uaW5nSGVpZ2h0IDogdHJhbnNpdGlvbmluZ1dpZHRoO1xyXG4gICAgbGV0IGFsbW9zdERvbmUgPSB1c2VSZWZFbGVtZW50UHJvcHMoe1xyXG4gICAgICAgIHJlZixcclxuICAgICAgICBzdHlsZTogcmVtb3ZlRW1wdHkoe1xyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWR1cmF0aW9uYF06IGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXN1cmZhY2UteGBdOiBzdXJmYWNlWCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1zdXJmYWNlLXlgXTogc3VyZmFjZVksXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tc3VyZmFjZS13aWR0aGBdOiBzdXJmYWNlV2lkdGgsXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tc3VyZmFjZS1oZWlnaHRgXTogc3VyZmFjZUhlaWdodCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1zdXJmYWNlLWlubGluZS1pbnNldGBdOiBzdXJmYWNlSW5saW5lSW5zZXQsXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tc3VyZmFjZS1ibG9jay1pbnNldGBdOiBzdXJmYWNlQmxvY2tJbnNldCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1zdXJmYWNlLWlubGluZS1zaXplYF06IHN1cmZhY2VJbmxpbmVTaXplLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXN1cmZhY2UtYmxvY2stc2l6ZWBdOiBzdXJmYWNlQmxvY2tTaXplLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXRyYW5zaXRpb25pbmcteGBdOiB0cmFuc2l0aW9uaW5nWCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS10cmFuc2l0aW9uaW5nLXlgXTogdHJhbnNpdGlvbmluZ1ksXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tdHJhbnNpdGlvbmluZy13aWR0aGBdOiB0cmFuc2l0aW9uaW5nV2lkdGgsXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tdHJhbnNpdGlvbmluZy1oZWlnaHRgXTogdHJhbnNpdGlvbmluZ0hlaWdodCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS10cmFuc2l0aW9uaW5nLWlubGluZS1pbnNldGBdOiB0cmFuc2l0aW9uaW5nSW5saW5lSW5zZXQsXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tdHJhbnNpdGlvbmluZy1ibG9jay1pbnNldGBdOiB0cmFuc2l0aW9uaW5nQmxvY2tJbnNldCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS10cmFuc2l0aW9uaW5nLWlubGluZS1zaXplYF06IHRyYW5zaXRpb25pbmdJbmxpbmVTaXplLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXRyYW5zaXRpb25pbmctYmxvY2stc2l6ZWBdOiB0cmFuc2l0aW9uaW5nQmxvY2tTaXplXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgb25UcmFuc2l0aW9uRW5kLFxyXG4gICAgICAgIC4uLih7IFwiYXJpYS1oaWRkZW5cIjogb3BlbiA/IHVuZGVmaW5lZCA6IFwidHJ1ZVwiIH0pLFxyXG4gICAgICAgIGNsYXNzTmFtZTogY2xzeChkaXJlY3Rpb24gJiYgZ2V0Q2xhc3NOYW1lKGNsYXNzQmFzZSwgZGlyZWN0aW9uKSwgZGlyZWN0aW9uICYmIHBoYXNlICYmIGdldENsYXNzTmFtZShjbGFzc0Jhc2UsIGRpcmVjdGlvbiwgcGhhc2UpLCBleGl0VmlzaWJpbGl0eSA9PSBcInJlbW92ZWRcIiAmJiBgJHtjbGFzc0Jhc2V9LXJlbW92ZWQtb24tZXhpdGAsIGV4aXRWaXNpYmlsaXR5ID09IFwidmlzaWJsZVwiICYmIGAke2NsYXNzQmFzZX0tdmlzaWJsZS1vbi1leGl0YCwgYCR7Y2xhc3NCYXNlfS1pbmxpbmUtZGlyZWN0aW9uLSR7aW5saW5lRGlyZWN0aW9uID8/IFwibHRyXCJ9YCwgYCR7Y2xhc3NCYXNlfS1ibG9jay1kaXJlY3Rpb24tJHtibG9ja0RpcmVjdGlvbiA/PyBcInR0YlwifWApLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKShhbG1vc3REb25lLCBvdGhlclByb3BzKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVFbXB0eShvYmopIHtcclxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoKFtfLCB2XSkgPT4gdiAhPSBudWxsKSk7XHJcbn1cclxuLyoqXHJcbiAqIEEgY29tcG9uZW50IHRoYXQgKndyYXBzIGFuIEhUTUxFbGVtZW50IG9yIG90aGVyIHJlZi1mb3J3YXJkaW5nIGNvbXBvbmVudCogYW5kIGFsbG93cyBpdCB0byB1c2UgQ1NTIHRvIHRyYW5zaXRpb24gaW4vb3V0LlxyXG4gKiBDb21iaW5lcyB0aGUgcHJvcHMgcGFzc2VkIHRvIGl0LCB0aGUgcHJvcHMgaXRzIGNoaWxkIGhhcywgYW5kIHRoZSBwcm9wcyBuZWVkZWQgZm9yIHRoZSBDU1MgdHJhbnNpdGlvbiwgYW5kIHBhc3NlcyB0aGVtXHJcbiAqIGFsbCB0byB0aGUgY2hpbGQgZWxlbWVudCB5b3UgcHJvdmlkZS5cclxuICpcclxuICogVGhpcyBpcyB0aGUgbW9zdCBnZW5lcmFsIGNvbXBvbmVudCB0aGF0IG90aGVycyB1c2UgYXMgYSBiYXNlLiBCeSBkZWZhdWx0LCB0aGlzIGNvbXBvbmVudCBieSBpdHNlbGYgZG9lc24ndCBhY3R1YWxseSBhZGQgYW55IENTUyBjbGFzc2VzIHRoYXQgYW5pbWF0ZSBhbnl0aGluZyAobGlrZSBvcGFjaXR5LCBmb3IgZXhhbXBsZSkuXHJcbiAqIEl0IGFkZHMgY2xhc3NlcyBsaWtlIGB0cmFuc2l0aW9uLWVudGVyLWZpbmFsaXplYCwgYnV0IHlvdSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFkZGl0aW9uYWwgZS5nLiBgZmFkZWAgY2xhc3MgdGhhdCByZWFjdHMgdG8gaXQuXHJcbiAqXHJcbiAqIFVzZSB0aGlzIGlmIHRoZSBvdGhlciwgbW9yZSBzcGVjaWFsaXplZCBUcmFuc2l0aW9uIGNvbXBvbmVudHMgZG9uJ3QgZml0IHlvdXIgbmVlZHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlIGA8VHJhbnNpdGlvbmFibGUgb3Blbj17b3Blbn0gey4uLnVzZUNyZWF0ZUZhZGVQcm9wcyguLi4pfT48ZGl2PntjaGlsZHJlbn08L2Rpdj48L1RyYW5zaXRpb25hYmxlPmBcclxuICogQGV4YW1wbGUgYDxUcmFuc2l0aW9uYWJsZSBvcGVuPXtvcGVufT48ZGl2IHsuLi51c2VDcmVhdGVGYWRlUHJvcHMoLi4uKX0+e2NoaWxkcmVufTwvZGl2PjwvVHJhbnNpdGlvbmFibGU+YFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRyYW5zaXRpb25hYmxlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gVHJhbnNpdGlvbih7IGNoaWxkcmVuOiBjaGlsZCwgZHVyYXRpb24sIGNsYXNzQmFzZSwgbWVhc3VyZSwgZXhpdFZpc2liaWxpdHksIG9wZW4sIG9uVHJhbnNpdGlvblVwZGF0ZSwgYW5pbWF0ZU9uTW91bnQsIC4uLnByb3BzIH0sIHIpIHtcclxuICAgIGlmICghY2hpbGRJc1ZOb2RlKGNoaWxkKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgVHJhbnNpdGlvbmFibGUgY29tcG9uZW50IG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjb21wb25lbnQgY2hpbGQgKGUuZy4gYSA8ZGl2PiwgYnV0IG5vdCBcXFwiYSBzdHJpbmdcXFwiKS5cIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uUHJvcHMgPSB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzKHsgY2xhc3NCYXNlLCBkdXJhdGlvbiwgbWVhc3VyZSwgb3BlbiwgYW5pbWF0ZU9uTW91bnQsIG9uVHJhbnNpdGlvblVwZGF0ZSwgcmVmOiByLCBleGl0VmlzaWJpbGl0eSB9LCBwcm9wcyk7XHJcbiAgICBjb25zdCBtZXJnZWRXaXRoQ2hpbGRyZW4gPSB1c2VNZXJnZWRQcm9wcygpKHRyYW5zaXRpb25Qcm9wcywgeyAuLi5jaGlsZC5wcm9wcywgcmVmOiBjaGlsZC5yZWYgfSk7XHJcbiAgICByZXR1cm4gY2xvbmVFbGVtZW50KGNoaWxkLCBtZXJnZWRXaXRoQ2hpbGRyZW4pO1xyXG59KTtcclxuZnVuY3Rpb24gY2hpbGRJc1ZOb2RlKGNoaWxkKSB7XHJcbiAgICBpZiAoIWNoaWxkKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2hpbGQgIT0gXCJvYmplY3RcIilcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gKFwicHJvcHNcIiBpbiBjaGlsZCk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNpdGlvbmFibGUuanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uYWJsZSB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlXCI7XHJcbmltcG9ydCB7IGRlZmF1bHQgYXMgY2xzeCB9IGZyb20gXCJjbHN4XCI7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgQ2xpcCB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXHJcbiAqIEJlIHN1cmUgdG8gbWVyZ2UgdGhlc2UgcmV0dXJuZWQgcHJvcHMgd2l0aCB3aGF0ZXZlciB0aGUgdXNlciBwYXNzZWQgaW4uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlQ2xpcFByb3BzKHsgY2xhc3NCYXNlLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luSW5saW5lLCBjbGlwT3JpZ2luQmxvY2ssIGNsaXBNaW4sIGNsaXBNaW5JbmxpbmUsIGNsaXBNaW5CbG9jayB9LCBvdGhlclByb3BzKSB7XHJcbiAgICBjbGFzc0Jhc2UgPz89IFwidHJhbnNpdGlvblwiO1xyXG4gICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoe1xyXG4gICAgICAgIGNsYXNzTmFtZTogY2xzeChgJHtjbGFzc0Jhc2V9LWNsaXBgKSxcclxuICAgICAgICBjbGFzc0Jhc2UsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1jbGlwLW9yaWdpbi1pbmxpbmVgXTogKGNsaXBPcmlnaW5JbmxpbmUgPz8gY2xpcE9yaWdpbiA/PyAwLjUpLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWNsaXAtb3JpZ2luLWJsb2NrYF06IChjbGlwT3JpZ2luQmxvY2sgPz8gY2xpcE9yaWdpbiA/PyAwKSxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1jbGlwLW1pbi1pbmxpbmVgXTogKGNsaXBNaW5JbmxpbmUgPz8gY2xpcE1pbiA/PyAxKSxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1jbGlwLW1pbi1ibG9ja2BdOiAoY2xpcE1pbkJsb2NrID8/IGNsaXBNaW4gPz8gMCksXHJcbiAgICAgICAgfSxcclxuICAgIH0sIG90aGVyUHJvcHMpO1xyXG59XHJcbjtcclxuZXhwb3J0IGNvbnN0IENsaXAgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDbGlwKHsgY2xhc3NCYXNlLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luSW5saW5lLCBjbGlwT3JpZ2luQmxvY2ssIGNsaXBNaW4sIGNsaXBNaW5JbmxpbmUsIGNsaXBNaW5CbG9jaywgb3BlbiwgLi4ucmVzdCB9LCByZWYpIHtcclxuICAgIHJldHVybiBoKFRyYW5zaXRpb25hYmxlLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZUNsaXBQcm9wcyh7IGNsYXNzQmFzZSwgY2xpcE9yaWdpbiwgY2xpcE9yaWdpbklubGluZSwgY2xpcE9yaWdpbkJsb2NrLCBjbGlwTWluLCBjbGlwTWluSW5saW5lLCBjbGlwTWluQmxvY2sgfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGlwLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vZm9yd2FyZC1lbGVtZW50LXJlZlwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbmFibGUgfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZVwiO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIEZhZGUgdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxyXG4gKiBCZSBzdXJlIHRvIG1lcmdlIHRoZXNlIHJldHVybmVkIHByb3BzIHdpdGggd2hhdGV2ZXIgdGhlIHVzZXIgcGFzc2VkIGluLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNyZWF0ZUZhZGVQcm9wcyh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCB9LCBvdGhlclByb3BzKSB7XHJcbiAgICBjbGFzc0Jhc2UgPz89IFwidHJhbnNpdGlvblwiO1xyXG4gICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoe1xyXG4gICAgICAgIGNsYXNzTmFtZTogYCR7Y2xhc3NCYXNlfS1mYWRlYCxcclxuICAgICAgICBjbGFzc0Jhc2UsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1mYWRlLW1pbmBdOiAoZmFkZU1pbiA/PyAwKSxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1mYWRlLW1heGBdOiAoZmFkZU1heCA/PyAxKSxcclxuICAgICAgICB9XHJcbiAgICB9LCBvdGhlclByb3BzKTtcclxufVxyXG47XHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgRmFkZSBlZmZlY3QuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB3aGlsZSBpdCBpcyBhYnNvbHV0ZWx5IHBvc3NpYmxlIHRvIHdyYXAgYW5vdGhlciB0cmFuc2l0aW9uIHdpdGggYDxGYWRlPmAsXHJcbiAqIHRoZXJlIHdpbGwgYmUgc29tZSBkdXBsaWNhdGUgY29kZSBydW4gYXMgdHdvIGA8VHJhbnNpdGlvbmFibGU+YCBjb21wb25lbnRzIGVuZCB1cCBvcGVyYXRpbmcgb24gdGhlIHNhbWUgZWxlbWVudC5cclxuICogSXQncyBnZW5lcmFsbHkgcmVjb21tZW5kZWQgdG8gZWl0aGVyIHVzZSB0aGUgY29tcG9uZW50cyB0aGF0IGluY2x1ZGUgYSBjb21iaW5lZCBmYWRlIGVmZmVjdCxcclxuICogb3IganVzdCBkaXJlY3RseSBhIGA8VHJhbnNpdGlvbmFibGU+YCBvbiB5b3VyIG93bi5cclxuICpcclxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgRmFkZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEZhZGUoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXgsIG9wZW4sIC4uLnJlc3QgfSwgcmVmKSB7XHJcbiAgICByZXR1cm4gaChUcmFuc2l0aW9uYWJsZSwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVGYWRlUHJvcHMoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXggfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYWRlLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IENsaXAgfSBmcm9tIFwiLi9jbGlwXCI7XHJcbmltcG9ydCB7IHVzZUNyZWF0ZUZhZGVQcm9wcyB9IGZyb20gXCIuL2ZhZGVcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XHJcbjtcclxuZXhwb3J0IGNvbnN0IENsaXBGYWRlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2xpcEZhZGUoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXgsIG9wZW4sIC4uLnJlc3QgfSwgcmVmKSB7XHJcbiAgICByZXR1cm4gaChDbGlwLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZUZhZGVQcm9wcyh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCB9LCB7IC4uLnJlc3QsIHJlZiB9KSB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaXAtZmFkZS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb25hYmxlIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGVcIjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBab29tIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cclxuICogQmUgc3VyZSB0byBtZXJnZSB0aGVzZSByZXR1cm5lZCBwcm9wcyB3aXRoIHdoYXRldmVyIHRoZSB1c2VyIHBhc3NlZCBpbi5cclxuICpcclxuICogSU1QT1JUQU5UOiBJZiB1c2VkIG91dHNpZGUgb2YgYSBgPENvbGxhcHNlIC8+YCwgeW91IG11c3QgaW5jbHVkZSB0aGUgYG1lYXN1cmVgIHByb3Agb24gdGhlIGA8VHJhbnNpdGlvbmFibGU+YCB0aGF0IHlvdSB1c2UuXHJcbiAqXHJcbiAqIEBleGFtcGxlIDxUcmFuc2l0aW9uYWJsZSBtZWFzdXJlIHsuLi51c2VDcmVhdGVDb2xsYXBzZVByb3BzKC4uLil9IC8+XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlQ29sbGFwc2VQcm9wcyh7IGNsYXNzQmFzZSwgbWluQmxvY2tTaXplIH0sIG90aGVyUHJvcHMpIHtcclxuICAgIGNsYXNzQmFzZSA/Pz0gXCJ0cmFuc2l0aW9uXCI7XHJcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgY2xhc3NCYXNlLFxyXG4gICAgICAgIG1lYXN1cmU6IHRydWUsXHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtjbGFzc0Jhc2V9LWNvbGxhcHNlYCxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWNvbGxhcHNlLW1pbi1ibG9ja2BdOiBtaW5CbG9ja1NpemUgPz8gMFxyXG4gICAgICAgIH1cclxuICAgIH0sIG90aGVyUHJvcHMpO1xyXG59XHJcbjtcclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYSBDb2xsYXBzZSBlZmZlY3QuXHJcbiAqXHJcbiAqICpJbXBvcnRhbnQqOiBUaGlzIGNvbXBvbmVudCBpcyAqbm90KiBlZmZpY2llbnQgZm9yIHRoZSBicm93c2VyIHRvIGFuaW1hdGUhXHJcbiAqIE1ha2Ugc3VyZSB5b3UgZG8gdGVzdGluZyBvbiBsb3dlciBwb3dlciBkZXZpY2VzLCBvciBwcmVmZXIgYSBsaWdodGVyXHJcbiAqIGFsdGVybmF0aXZlLCBsaWtlIGA8Q2xpcD5gLlxyXG4gKlxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBDb2xsYXBzZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENvbGxhcHNlKHsgY2xhc3NCYXNlLCBvcGVuLCBtaW5CbG9ja1NpemUsIC4uLnJlc3QgfSwgcmVmKSB7XHJcbiAgICByZXR1cm4gaChUcmFuc2l0aW9uYWJsZSwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVDb2xsYXBzZVByb3BzKHsgY2xhc3NCYXNlLCBtaW5CbG9ja1NpemUgfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsYXBzZS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBDb2xsYXBzZSB9IGZyb20gXCIuL2NvbGxhcHNlXCI7XHJcbmltcG9ydCB7IHVzZUNyZWF0ZUZhZGVQcm9wcyB9IGZyb20gXCIuL2ZhZGVcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XHJcbjtcclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYm90aCBDb2xsYXBzZSBhbmQgRmFkZSBlZmZlY3RzLlxyXG4gKlxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWAgYENvbGxhcHNlYCBgRmFkZWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBDb2xsYXBzZUZhZGUgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDb2xsYXBzZUZhZGUoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXgsIG9wZW4sIC4uLnJlc3QgfSwgcmVmKSB7XHJcbiAgICByZXR1cm4gaChDb2xsYXBzZSwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVGYWRlUHJvcHMoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXggfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsYXBzZS1mYWRlLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb25hYmxlIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGVcIjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBTbGlkZSB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlU2xpZGVQcm9wcyh7IGNsYXNzQmFzZSwgc2xpZGVUYXJnZXRJbmxpbmUsIHNsaWRlVGFyZ2V0QmxvY2sgfSwgb3RoZXJQcm9wcykge1xyXG4gICAgY2xhc3NCYXNlID8/PSBcInRyYW5zaXRpb25cIjtcclxuICAgIGNvbnN0IGxhc3RWYWxpZFRhcmdldElubGluZSA9IHVzZVJlZihzbGlkZVRhcmdldElubGluZSA/PyAxKTtcclxuICAgIGNvbnN0IGxhc3RWYWxpZFRhcmdldEJsb2NrID0gdXNlUmVmKHNsaWRlVGFyZ2V0QmxvY2sgPz8gMCk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4geyBpZiAoc2xpZGVUYXJnZXRJbmxpbmUpXHJcbiAgICAgICAgbGFzdFZhbGlkVGFyZ2V0SW5saW5lLmN1cnJlbnQgPSBzbGlkZVRhcmdldElubGluZTsgfSwgW3NsaWRlVGFyZ2V0SW5saW5lXSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4geyBpZiAoc2xpZGVUYXJnZXRCbG9jaylcclxuICAgICAgICBsYXN0VmFsaWRUYXJnZXRCbG9jay5jdXJyZW50ID0gc2xpZGVUYXJnZXRCbG9jazsgfSwgW3NsaWRlVGFyZ2V0QmxvY2tdKTtcclxuICAgIGlmIChzbGlkZVRhcmdldElubGluZSA9PSAwKVxyXG4gICAgICAgIHNsaWRlVGFyZ2V0SW5saW5lID0gbGFzdFZhbGlkVGFyZ2V0SW5saW5lLmN1cnJlbnQ7XHJcbiAgICBpZiAoc2xpZGVUYXJnZXRCbG9jayA9PSAwKVxyXG4gICAgICAgIHNsaWRlVGFyZ2V0QmxvY2sgPSBsYXN0VmFsaWRUYXJnZXRCbG9jay5jdXJyZW50O1xyXG4gICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoe1xyXG4gICAgICAgIGNsYXNzTmFtZTogYCR7Y2xhc3NCYXNlfS1zbGlkZWAsXHJcbiAgICAgICAgY2xhc3NCYXNlLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tc2xpZGUtdGFyZ2V0LWlubGluZWBdOiBgJHsoc2xpZGVUYXJnZXRJbmxpbmUgPz8gMCl9YCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1zbGlkZS10YXJnZXQtYmxvY2tgXTogYCR7KHNsaWRlVGFyZ2V0QmxvY2sgPz8gMCl9YFxyXG4gICAgICAgIH1cclxuICAgIH0sIG90aGVyUHJvcHMpO1xyXG59XHJcbjtcclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYSBTbGlkZSBlZmZlY3QuXHJcbiAqXHJcbiAqIFByb3ZpZGUgdGhlIGRpcmVjdGlvbiB0aGUgZWxlbWVudCB3aWxsIHRyYXZlbCBpbiB3aXRoIGBzbGlkZUlubGluZWAgYW5kIGBzbGlkZUJsb2NrYCxcclxuICogd2l0aCBgMWAgYmVpbmcgYDEwMCVgIG9mIHRoZSBlbGVtZW50J3Mgd2lkdGggb3IgaGVpZ2h0LlxyXG4gKlxyXG4gKiBBIHZhbHVlIG9mIGAwYCBpcyBoYW5kbGVkIHNwZWNpYWxseSwgZWZmZWN0aXZlbHkgbWVhbmluZyBcInVzZSB0aGUgbGFzdCBub24temVybyB2YWx1ZVwiLFxyXG4gKiB3aGljaCBhbGxvd3MgZm9yIGNvbnZlbmllbnQgc2V0dXBzIGluc2lkZSBvZiBhIGBTd2FwQ29udGFpbmVyYFxyXG4gKiAoYHNsaWRlSW5saW5lPXtpbmRleCAtIHNlbGVjdGVkSW5kZXh9YCBvciBzaW1pbGFyLilcclxuICpcclxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgU2xpZGUgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBTbGlkZSh7IGNsYXNzQmFzZSwgc2xpZGVUYXJnZXRJbmxpbmUsIHNsaWRlVGFyZ2V0QmxvY2ssIG9wZW4sIC4uLnJlc3QgfSwgcmVmKSB7XHJcbiAgICByZXR1cm4gaChUcmFuc2l0aW9uYWJsZSwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVTbGlkZVByb3BzKHsgY2xhc3NCYXNlLCBzbGlkZVRhcmdldElubGluZSwgc2xpZGVUYXJnZXRCbG9jayB9LCB7IC4uLnJlc3QsIHJlZiB9KSB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWRlLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNyZWF0ZUZhZGVQcm9wcyB9IGZyb20gXCIuL2ZhZGVcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XHJcbmltcG9ydCB7IFNsaWRlIH0gZnJvbSBcIi4vc2xpZGVcIjtcclxuO1xyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBib3RoIFNsaWRlIGFuZCBGYWRlIGVmZmVjdHMuXHJcbiAqXHJcbiAqIGBzbGlkZUlubGluZT17KGluZGV4IC0gc2VsZWN0ZWRJbmRleCkgLyAxMH1gIHdvdWxkIG1ha2UgdGhlIGVsZW1lbnQgbG9vayBsaWtlIGl0IGZhZGVzIG91dCBiZWZvcmUgaXQgdHJhdmVscyB0byBpdHMgdGFyZ2V0IGRlc3RpbmF0aW9uLlxyXG4gKlxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWAgYFpvb21gXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgU2xpZGVGYWRlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGVGYWRlKHsgY2xhc3NCYXNlLCBmYWRlTWluLCBmYWRlTWF4LCBvcGVuLCAuLi5yZXN0IH0sIHJlZikge1xyXG4gICAgcmV0dXJuIGgoU2xpZGUsIHsgb3Blbjogb3BlbiwgLi4udXNlQ3JlYXRlRmFkZVByb3BzKHsgY2xhc3NCYXNlLCBmYWRlTWluLCBmYWRlTWF4IH0sIHsgLi4ucmVzdCwgcmVmIH0pIH0pO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2xpZGUtZmFkZS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb25hYmxlIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGVcIjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBab29tIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDcmVhdGVab29tUHJvcHMoeyBjbGFzc0Jhc2UsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5JbmxpbmUsIHpvb21PcmlnaW5CbG9jaywgem9vbU1pbiwgem9vbU1pbklubGluZSwgem9vbU1pbkJsb2NrIH0sIG90aGVyUHJvcHMpIHtcclxuICAgIGNsYXNzQmFzZSA/Pz0gXCJ0cmFuc2l0aW9uXCI7XHJcbiAgICByZXR1cm4gKHVzZU1lcmdlZFByb3BzKCkoe1xyXG4gICAgICAgIGNsYXNzTmFtZTogYCR7Y2xhc3NCYXNlfS16b29tYCxcclxuICAgICAgICBjbGFzc0Jhc2UsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS16b29tLW9yaWdpbi1pbmxpbmVgXTogYCR7KHpvb21PcmlnaW5JbmxpbmUgPz8gem9vbU9yaWdpbiA/PyAwLjUpfWAsXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tem9vbS1vcmlnaW4tYmxvY2tgXTogYCR7KHpvb21PcmlnaW5CbG9jayA/PyB6b29tT3JpZ2luID8/IDAuNSl9YCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS16b29tLW1pbi1pbmxpbmVgXTogYCR7KHpvb21NaW5JbmxpbmUgPz8gem9vbU1pbiA/PyAwKX1gLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXpvb20tbWluLWJsb2NrYF06IGAkeyh6b29tTWluQmxvY2sgPz8gem9vbU1pbiA/PyAwKX1gLFxyXG4gICAgICAgIH0sXHJcbiAgICB9LCBvdGhlclByb3BzKSk7XHJcbn1cclxuO1xyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIFpvb20gZWZmZWN0LlxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWAgYFpvb21GYWRlYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFpvb20gPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBab29tKHsgY2xhc3NCYXNlLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luSW5saW5lLCB6b29tT3JpZ2luQmxvY2ssIHpvb21NaW4sIHpvb21NaW5JbmxpbmUsIHpvb21NaW5CbG9jaywgb3BlbiwgLi4ucmVzdCB9LCByZWYpIHtcclxuICAgIHJldHVybiBoKFRyYW5zaXRpb25hYmxlLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZVpvb21Qcm9wcyh7IGNsYXNzQmFzZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbklubGluZSwgem9vbU9yaWdpbkJsb2NrLCB6b29tTWluLCB6b29tTWluSW5saW5lLCB6b29tTWluQmxvY2sgfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD16b29tLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNyZWF0ZUZhZGVQcm9wcyB9IGZyb20gXCIuL2ZhZGVcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XHJcbmltcG9ydCB7IFpvb20gfSBmcm9tIFwiLi96b29tXCI7XHJcbjtcclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYm90aCBab29tIGFuZCBGYWRlIGVmZmVjdHMuXHJcbiAqXHJcbiAqIFRoaXMgaXMgYW4gaWRlYWwgdGltZSB0byB1c2UgdGhlIG1pbmltdW0gc2l6ZSBab29tIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYCBgWm9vbWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBab29tRmFkZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFpvb21GYWRlKHsgY2xhc3NCYXNlLCBmYWRlTWluLCBmYWRlTWF4LCBvcGVuLCAuLi5yZXN0IH0sIHJlZikge1xyXG4gICAgcmV0dXJuIGgoWm9vbSwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVGYWRlUHJvcHMoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXggfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD16b29tLWZhZGUuanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XHJcbmltcG9ydCB7IFNsaWRlIH0gZnJvbSBcIi4vc2xpZGVcIjtcclxuaW1wb3J0IHsgdXNlQ3JlYXRlWm9vbVByb3BzIH0gZnJvbSBcIi4vem9vbVwiO1xyXG47XHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGJvdGggU2xpZGUgYW5kIFpvb20gZWZmZWN0cy5cclxuICpcclxuICogUHJvYmFibHkgYmVzdCBjb21iaW5lZCB3aXRoIGB1c2VDcmVhdGVGYWRlUHJvcHNgIChvciBqdXN0IHVzaW5nIGEgYFNsaWRlWm9vbUZhZGVgPykuXHJcbiAqXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYCBgU2xpZGVGYWRlWm9vbWAgYFpvb21gIGBGYWRlYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFNsaWRlWm9vbSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFNsaWRlWm9vbSh7IGNsYXNzQmFzZSwgem9vbU1pbiwgem9vbU1pbklubGluZSwgem9vbU1pbkJsb2NrLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luSW5saW5lLCB6b29tT3JpZ2luQmxvY2ssIG9wZW4sIC4uLnJlc3QgfSwgcmVmKSB7XHJcbiAgICByZXR1cm4gaChTbGlkZSwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVab29tUHJvcHMoeyBjbGFzc0Jhc2UsIHpvb21NaW4sIHpvb21NaW5JbmxpbmUsIHpvb21NaW5CbG9jaywgem9vbU9yaWdpbiwgem9vbU9yaWdpbklubGluZSwgem9vbU9yaWdpbkJsb2NrIH0sIHsgLi4ucmVzdCwgcmVmIH0pIH0pO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2xpZGUtem9vbS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDcmVhdGVGYWRlUHJvcHMgfSBmcm9tIFwiLi9mYWRlXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vZm9yd2FyZC1lbGVtZW50LXJlZlwiO1xyXG5pbXBvcnQgeyBTbGlkZVpvb20gfSBmcm9tIFwiLi9zbGlkZS16b29tXCI7XHJcbjtcclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggWm9vbSwgU2xpZGUsIGFuZCBGYWRlIGVmZmVjdHMuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGlzIGlzIGJhc2ljYWxseSBqdXN0IHNob3J0aGFuZCBmb3Igc29tZSBwcm9wIGNyZWF0aW9uIGFuZCBwcm9wIG1lcmdpbmcgZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWAgYFNsaWRlYCBgWm9vbWAgYEZhZGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgU2xpZGVab29tRmFkZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFNsaWRlWm9vbUZhZGUoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXgsIG9wZW4sIC4uLnJlc3QgfSwgcmVmKSB7XHJcbiAgICByZXR1cm4gaChTbGlkZVpvb20sIHsgb3Blbjogb3BlbiwgLi4udXNlQ3JlYXRlRmFkZVByb3BzKHsgY2xhc3NCYXNlLCBmYWRlTWluLCBmYWRlTWF4IH0sIHsgLi4ucmVzdCwgcmVmIH0pIH0pO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2xpZGUtem9vbS1mYWRlLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb25hYmxlIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGVcIjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBGbGlwIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDcmVhdGVGbGlwUHJvcHMoeyBjbGFzc0Jhc2UsIGZsaXBBbmdsZUlubGluZSwgZmxpcEFuZ2xlQmxvY2ssIHBlcnNwZWN0aXZlIH0sIG90aGVyUHJvcHMpIHtcclxuICAgIGNsYXNzQmFzZSA/Pz0gXCJ0cmFuc2l0aW9uXCI7XHJcbiAgICBjb25zdCBsYXN0VmFsaWRUYXJnZXRJbmxpbmUgPSB1c2VSZWYoZmxpcEFuZ2xlSW5saW5lID8/IDE4MCk7XHJcbiAgICBjb25zdCBsYXN0VmFsaWRUYXJnZXRCbG9jayA9IHVzZVJlZihmbGlwQW5nbGVCbG9jayA/PyAwKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7IGlmIChmbGlwQW5nbGVJbmxpbmUpXHJcbiAgICAgICAgbGFzdFZhbGlkVGFyZ2V0SW5saW5lLmN1cnJlbnQgPSBmbGlwQW5nbGVJbmxpbmU7IH0sIFtmbGlwQW5nbGVJbmxpbmVdKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7IGlmIChmbGlwQW5nbGVCbG9jaylcclxuICAgICAgICBsYXN0VmFsaWRUYXJnZXRCbG9jay5jdXJyZW50ID0gZmxpcEFuZ2xlQmxvY2s7IH0sIFtmbGlwQW5nbGVCbG9ja10pO1xyXG4gICAgaWYgKGZsaXBBbmdsZUlubGluZSA9PSAwKVxyXG4gICAgICAgIGZsaXBBbmdsZUlubGluZSA9IGxhc3RWYWxpZFRhcmdldElubGluZS5jdXJyZW50O1xyXG4gICAgaWYgKGZsaXBBbmdsZUJsb2NrID09IDApXHJcbiAgICAgICAgZmxpcEFuZ2xlQmxvY2sgPSBsYXN0VmFsaWRUYXJnZXRCbG9jay5jdXJyZW50O1xyXG4gICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoe1xyXG4gICAgICAgIGNsYXNzTmFtZTogYCR7Y2xhc3NCYXNlfS1mbGlwYCxcclxuICAgICAgICBjbGFzc0Jhc2UsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1mbGlwLWFuZ2xlLWlubGluZWBdOiBgJHsoZmxpcEFuZ2xlSW5saW5lID8/IDApfWRlZ2AsXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tZmxpcC1hbmdsZS1ibG9ja2BdOiBgJHsoZmxpcEFuZ2xlQmxvY2sgPz8gMCl9ZGVnYCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1wZXJzcGVjdGl2ZWBdOiBgJHsocGVyc3BlY3RpdmUgPz8gODAwKX1weGBcclxuICAgICAgICB9XHJcbiAgICB9LCBvdGhlclByb3BzKTtcclxufVxyXG47XHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgRmxpcCBlZmZlY3QuXHJcbiAqXHJcbiAqIFByb3ZpZGUgdGhlIGRpcmVjdGlvbiB0aGUgZWxlbWVudCB3aWxsIHRyYXZlbCBpbiB3aXRoIGBmbGlwSW5saW5lYCBhbmQgYGZsaXBCbG9ja2AsXHJcbiAqIHdpdGggYDFgIGJlaW5nIGAxMDAlYCBvZiB0aGUgZWxlbWVudCdzIHdpZHRoIG9yIGhlaWdodC5cclxuICpcclxuICogQSB2YWx1ZSBvZiBgMGAgaXMgaGFuZGxlZCBzcGVjaWFsbHksIGVmZmVjdGl2ZWx5IG1lYW5pbmcgXCJ1c2UgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWVcIixcclxuICogd2hpY2ggYWxsb3dzIGZvciBjb252ZW5pZW50IHNldHVwcyBpbnNpZGUgb2YgYSBgU3dhcENvbnRhaW5lcmBcclxuICogKGBmbGlwSW5saW5lPXtpbmRleCAtIHNlbGVjdGVkSW5kZXh9YCBvciBzaW1pbGFyLilcclxuICpcclxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgRmxpcCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEZsaXAoeyBjbGFzc0Jhc2UsIGZsaXBBbmdsZUlubGluZSwgZmxpcEFuZ2xlQmxvY2ssIHBlcnNwZWN0aXZlLCBvcGVuLCAuLi5yZXN0IH0sIHJlZikge1xyXG4gICAgcmV0dXJuIGgoVHJhbnNpdGlvbmFibGUsIHsgb3Blbjogb3BlbiwgLi4udXNlQ3JlYXRlRmxpcFByb3BzKHsgY2xhc3NCYXNlLCBmbGlwQW5nbGVJbmxpbmUsIGZsaXBBbmdsZUJsb2NrLCBwZXJzcGVjdGl2ZSB9LCB7IC4uLnJlc3QsIHJlZiB9KSB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZsaXAuanMubWFwIiwiaW1wb3J0IHsgZGVmYXVsdCBhcyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgY2xvbmVFbGVtZW50IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgc3dhcCBjb250YWluZXIuXHJcbiAqIEJlIHN1cmUgdG8gbWVyZ2UgdGhlc2UgcmV0dXJuZWQgcHJvcHMgd2l0aCB3aGF0ZXZlciB0aGUgdXNlciBwYXNzZWQgaW4uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlU3dhcHBhYmxlUHJvcHMoeyBpbmxpbmUsIGNsYXNzQmFzZSB9LCBvdGhlclByb3BzKSB7XHJcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBjbHN4KGAke2NsYXNzQmFzZSA/PyBcInRyYW5zaXRpb25cIn0tc3dhcC1jb250YWluZXJgLCBpbmxpbmUgJiYgYCR7Y2xhc3NCYXNlID8/IFwidHJhbnNpdGlvblwifS1zd2FwLWNvbnRhaW5lci1pbmxpbmVgKVxyXG4gICAgfSwgb3RoZXJQcm9wcyk7XHJcbn1cclxuLyoqXHJcbiAqIEFsbG93cyBhIHNldCBvZiBjaGlsZCA8VHJhbnNpdGlvbmFibGU+IGNvbXBvbmVudHMgdG8gYW5pbWF0ZSBpbiAmIG91dCBpbi1wbGFjZS4gVmVyeSB1c2VmdWwgZm9yLCBlLmcuLCB0YWIgcGFuZWxzLlxyXG4gKlxyXG4gKiBZb3UgbXVzdCBtYW5hZ2UgZWFjaCBjaGlsZCBgPFRyYW5zaXRpb25hYmxlPmAgY29tcG9uZW50J3MgYG9wZW5gIHByb3AgLS0gdGhpcyBjb21wb25lbnQgKmRvZXMgbm90KiBtYW5hZ2UgYW55IHNvcnQgb2Ygc3RhdGUgaW4gdGhhdCByZWdhcmQuXHJcbiAqXHJcbiAqIExpa2UgYDxUcmFuc2l0aW9uYWJsZT5gLCAqdGhpcyB3cmFwcyBhbiBIVE1MRWxlbWVudCAob3Igb3RoZXIgcmVmLWZvcndhcmRpbmcgY29tcG9uZW50KSouIFRoaXMgd2lsbCBiZSB5b3VyIGNvbnRhaW5lciB0aGF0IGhvbGRzIGVhY2ggYDxUcmFuc2l0aW9uYWJsZT5gIChvciBjb21wb25lbnQgdGhhdCB1c2VzIGl0KS4gU3RyaWN0bHkgc3BlYWtpbmcgaXQgY291bGQgYmUgYW55dGhpbmcsIG5vdCBhIGA8VHJhbnNpdGlvbmFibGU+YCwgYnV0IGlmIGl0IGRvZXNudCd0IHRyYW5zaXRpb24gb3V0IHRoZW4gaXQncyBqdXN0IGdvaW5nIHRvIGJlIGhhbmdpbmcgYXJvdW5kIDEwMCUgb2YgdGhlIHRpbWUuXHJcbiAqXHJcbiAqIExvbmcgd2F5IG9mIHNheWluZywgaWYgeW91IGdldCBhIGNyeXB0aWMgZXJyb3Igd2l0aCB0aGlzIGNvbXBvbmVudCwgbWFrZSBzdXJlIGl0IGhhcyBhIHNpbmdsZSBgPGRpdj5gIGNoaWxkIG9yIHNvbWV0aGluZy5cclxuICogQHBhcmFtIHBhcmFtMFxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFN3YXBwYWJsZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFN3YXBwYWJsZSh7IGNoaWxkcmVuLCBjbGFzc0Jhc2UsIGlubGluZSwgLi4ucCB9LCByZWYpIHtcclxuICAgIGlubGluZSA/Pz0gdHlwZW9mIGNoaWxkcmVuLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgaW5saW5lRWxlbWVudHMuaGFzKGNoaWxkcmVuLnR5cGUpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvblByb3BzID0gdXNlQ3JlYXRlU3dhcHBhYmxlUHJvcHMoeyBjbGFzc0Jhc2UsIGlubGluZSB9LCB7IC4uLnAsIHJlZiB9KTtcclxuICAgIGNvbnN0IG1lcmdlZFdpdGhDaGlsZHJlbiA9IHVzZU1lcmdlZFByb3BzKCkodHJhbnNpdGlvblByb3BzLCBjaGlsZHJlbi5wcm9wcyk7XHJcbiAgICByZXR1cm4gY2xvbmVFbGVtZW50KGNoaWxkcmVuLCBtZXJnZWRXaXRoQ2hpbGRyZW4pO1xyXG59KTtcclxuLy8gSWYgXCJpbmxpbmVcIiBpc24ndCBleHBsaWNpdGx5IHByb3ZpZGVkLCB3ZSB0cnkgdG8gaW1wbGljaXRseSBkbyBpdCBiYXNlZCBvbiB0aGUgY2hpbGQncyB0YWcuXHJcbi8vIE5vdCBwZXJmZWN0LCBidXQgaXQncyBub3Qgc3VwcG9zZWQgdG8gYmUuIGBpbmxpbmVgIGlzIGZvciBwZXJmZWN0LlxyXG5jb25zdCBpbmxpbmVFbGVtZW50cyA9IG5ldyBTZXQoW1xyXG4gICAgXCJhXCIsXHJcbiAgICBcImFiYnJcIixcclxuICAgIFwiYWNyb255bVwiLFxyXG4gICAgXCJhdWRpb1wiLFxyXG4gICAgXCJiXCIsXHJcbiAgICBcImJkaVwiLFxyXG4gICAgXCJiZG9cIixcclxuICAgIFwiYmlnXCIsXHJcbiAgICBcImJyXCIsXHJcbiAgICBcImJ1dHRvblwiLFxyXG4gICAgXCJjYW52YXNcIixcclxuICAgIFwiY2l0ZVwiLFxyXG4gICAgXCJjb2RlXCIsXHJcbiAgICBcImRhdGFcIixcclxuICAgIFwiZGF0YWxpc3RcIixcclxuICAgIFwiZGVsXCIsXHJcbiAgICBcImRmblwiLFxyXG4gICAgXCJlbVwiLFxyXG4gICAgXCJlbWJlZFwiLFxyXG4gICAgXCJpXCIsXHJcbiAgICBcImlmcmFtZVwiLFxyXG4gICAgXCJpbWdcIixcclxuICAgIFwiaW5wdXRcIixcclxuICAgIFwiaW5zXCIsXHJcbiAgICBcImtiZFwiLFxyXG4gICAgXCJsYWJlbFwiLFxyXG4gICAgXCJtYXBcIixcclxuICAgIFwibWFya1wiLFxyXG4gICAgXCJtZXRlclwiLFxyXG4gICAgXCJub3NjcmlwdFwiLFxyXG4gICAgXCJvYmplY3RcIixcclxuICAgIFwib3V0cHV0XCIsXHJcbiAgICBcInBpY3R1cmVcIixcclxuICAgIFwicHJvZ3Jlc3NcIixcclxuICAgIFwicVwiLFxyXG4gICAgXCJydWJ5XCIsXHJcbiAgICBcInNcIixcclxuICAgIFwic2FtcFwiLFxyXG4gICAgXCJzY3JpcHRcIixcclxuICAgIFwic2VsZWN0XCIsXHJcbiAgICBcInNsb3RcIixcclxuICAgIFwic21hbGxcIixcclxuICAgIFwic3BhblwiLFxyXG4gICAgXCJzdHJvbmdcIixcclxuICAgIFwic3ViXCIsXHJcbiAgICBcInN1cFwiLFxyXG4gICAgXCJzdmdcIixcclxuICAgIFwidGVtcGxhdGVcIixcclxuICAgIFwidGV4dGFyZWFcIixcclxuICAgIFwidGltZVwiLFxyXG4gICAgXCJ1XCIsXHJcbiAgICBcInR0XCIsXHJcbiAgICBcInZhclwiLFxyXG4gICAgXCJ2aWRlb1wiLFxyXG4gICAgXCJ3YnJcIlxyXG5dKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dhcHBhYmxlLmpzLm1hcCIsImV4cG9ydCBjb25zdCBFdmVudERldGFpbCA9IFN5bWJvbChcImV2ZW50LWRldGFpbFwiKTtcclxuZXhwb3J0IGZ1bmN0aW9uIGVuaGFuY2VFdmVudChlLCBkZXRhaWwpIHtcclxuICAgIGxldCBldmVudCA9IGU7XHJcbiAgICBldmVudFtFdmVudERldGFpbF0gPSBkZXRhaWw7XHJcbiAgICByZXR1cm4gZXZlbnQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcHMuanMubWFwIiwiaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmxldCBwdWxzZSA9IChcInZpYnJhdGVcIiBpbiBuYXZpZ2F0b3IpID8gKCgpID0+IG5hdmlnYXRvci52aWJyYXRlKDEwKSkgOiAoKCkgPT4geyB9KTtcclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZW5hYmxlL2Rpc2FibGUgYnV0dG9uIHZpYnJhdGlvbiBwdWxzZXMgb24gYW4gYXBwLXdpZGUgc2NhbGUuXHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSBmdW5jIFRoZSBmdW5jdGlvbiB0byBydW4gd2hlbiBhIGJ1dHRvbiBpcyB0YXBwZWQuXHJcbiAqIChEZWZhdWx0IGlzIGAoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMClgIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdCwgYSBub29wIG90aGVyd2lzZSlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRCdXR0b25WaWJyYXRlKGZ1bmMpIHtcclxuICAgIHB1bHNlID0gZnVuYztcclxufVxyXG5mdW5jdGlvbiBleGNsdWRlcyh0YWcsIHRhcmdldCwgZXhjbHVkZSkge1xyXG4gICAgaWYgKGV4Y2x1ZGU/Llt0YXJnZXRdKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKHRhcmdldCA9PT0gXCJzcGFjZVwiIHx8IHRhcmdldCA9PT0gXCJlbnRlclwiKVxyXG4gICAgICAgIHJldHVybiB0YWcgPT0gXCJidXR0b25cIjtcclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogRWFzeSB3YXkgdG8gXCJwb2x5ZmlsbFwiIGJ1dHRvbi1saWtlIGludGVyYWN0aW9ucyBvbnRvLCBlLmcuLCBhIGRpdi5cclxuICpcclxuICogQWRkcyBjbGljaywgc3BhY2Ugb24ga2V5RG93biwgYW5kIGVudGVyIG9uIGtleVVwLCBhcyB3ZWxsIGFzIGhhcHRpY1xyXG4gKiBmZWVkYmFjayB2aWEgYSBtb21lbnRhcnkgdmlicmF0aW9uIHB1bHNlIHdoZW4gdGhlcmUncyBhbiBvbkNsaWNrIGhhbmRsZXIgcHJvdmlkZWRcclxuICogKHRoaXMgY2FuIGJlIGRpc2FibGVkIGFwcC13aWRlIHdpdGggYHNldEJ1dHRvblZpYnJhdGVgKS5cclxuICpcclxuICogSW4gYWRkaXRpb24sIHdoZW4gdGhlIENTUyBgOmFjdGl2ZWAgcHNldWRvLWNsYXNzIHdvdWxkIGFwcGx5IHRvIGEgbm9ybWFsIGJ1dHRvblxyXG4gKiAoaS5lLiB3aGVuIGhvbGRpbmcgdGhlIHNwYWNlYmFyIG9yIGR1cmluZyBtb3VzZWRvd24pLCBgeyBcImRhdGEtcHNldWRvLWFjdGl2ZVwiOiBcInRydWVcIiB9YFxyXG4gKiBpcyBhZGRlZCB0byB0aGUgcHJvcHMuICBZb3UgY2FuIGVpdGhlciBsZXQgaXQgcGFzcyB0aHJvdWdoIGFuZCBzdHlsZSBpdCB0aHJvdWdoIG5ldyBDU1MsXHJcbiAqIG9yIGluc3BlY3QgdGhlIHJldHVybmVkIHByb3BzIGZvciBpdCBhbmQgYWRkIGUuZy4gYW4gYC5hY3RpdmVgIGNsYXNzIGZvciBleGlzdGluZyBDU1NcclxuICpcclxuICogQHBhcmFtIG9uQ2xpY2tcclxuICogQHBhcmFtIGV4Y2x1ZGUgV2hldGhlciB0aGUgcG9seWZpbGwgc2hvdWxkIGFwcGx5IChjYW4gc3BlY2lmeSBmb3Igc3BlY2lmaWMgaW50ZXJhY3Rpb25zKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzKHRhZywgb25DbGlja1N5bmMsIGV4Y2x1ZGUpIHtcclxuICAgIGNvbnN0IFthY3RpdmUsIHNldEFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBvbktleVVwID0gZXhjbHVkZXModGFnLCBcInNwYWNlXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGUpID0+IHtcclxuICAgICAgICBpZiAoZS5rZXkgPT0gXCIgXCIgJiYgb25DbGlja1N5bmMpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBvbkNsaWNrU3luYyhlKTtcclxuICAgICAgICAgICAgc2V0QWN0aXZlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSBleGNsdWRlcyh0YWcsIFwiY2xpY2tcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZSkgPT4ge1xyXG4gICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMClcclxuICAgICAgICAgICAgc2V0QWN0aXZlKHRydWUpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG9uTW91c2VVcCA9IGV4Y2x1ZGVzKHRhZywgXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGFjdGl2ZSkge1xyXG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHNldEFjdGl2ZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob25DbGlja1N5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdWxzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2tTeW5jKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9uQmx1cihlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgb25CbHVyID0gKGUpID0+IHtcclxuICAgICAgICBzZXRBY3RpdmUoZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG9uTW91c2VPdXQgPSBleGNsdWRlcyh0YWcsIFwiY2xpY2tcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiBvbkJsdXI7XHJcbiAgICBjb25zdCBvbktleURvd24gPSBleGNsdWRlcyh0YWcsIFwic3BhY2VcIiwgZXhjbHVkZSkgJiYgZXhjbHVkZXModGFnLCBcImVudGVyXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGUpID0+IHtcclxuICAgICAgICBpZiAoZS5rZXkgPT0gXCIgXCIgJiYgb25DbGlja1N5bmMgJiYgIWV4Y2x1ZGVzKHRhZywgXCJzcGFjZVwiLCBleGNsdWRlKSkge1xyXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBhY3RpdmF0ZSBpdCBvbiBhIHNwYWNlIGtleWRvd25cclxuICAgICAgICAgICAgLy8gYnV0IHdlIGRvIHByZXZlbnREZWZhdWx0IHRvIHN0b3AgdGhlIHBhZ2UgZnJvbSBzY3JvbGxpbmcuXHJcbiAgICAgICAgICAgIHNldEFjdGl2ZSh0cnVlKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZS5rZXkgPT0gXCJFbnRlclwiICYmIG9uQ2xpY2tTeW5jICYmICFleGNsdWRlcyh0YWcsIFwiZW50ZXJcIiwgZXhjbHVkZSkpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBvbkNsaWNrU3luYyhlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIChwcm9wcykgPT4gdXNlTWVyZ2VkUHJvcHMoKSh7IG9uS2V5RG93biwgb25LZXlVcCwgb25CbHVyLCBvbk1vdXNlRG93biwgb25Nb3VzZVVwLCBvbk1vdXNlT3V0LCAuLi57IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IGFjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gfSwgcHJvcHMpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhQnV0dG9uKHsgdGFnLCBwcmVzc2VkLCBvbkNsaWNrIH0pIHtcclxuICAgIGZ1bmN0aW9uIHVzZUFyaWFCdXR0b25Qcm9wcyh7IFwiYXJpYS1wcmVzc2VkXCI6IGFyaWFQcmVzc2VkLCB0YWJJbmRleCwgcm9sZSwgLi4ucCB9KSB7XHJcbiAgICAgICAgY29uc3QgcHJvcHMgPSB1c2VCdXR0b25MaWtlRXZlbnRIYW5kbGVycyh0YWcsIChlKSA9PiBvbkNsaWNrPy4oZW5oYW5jZUV2ZW50KGUsIHsgcHJlc3NlZDogcHJlc3NlZCA9PSBudWxsID8gbnVsbCA6ICFwcmVzc2VkIH0pKSwgdW5kZWZpbmVkKShwKTtcclxuICAgICAgICBjb25zdCBidXR0b25Qcm9wcyA9IHsgcm9sZSwgdGFiSW5kZXgsIFwiYXJpYS1wcmVzc2VkXCI6IGFyaWFQcmVzc2VkID8/IChwcmVzc2VkID09PSB0cnVlID8gXCJ0cnVlXCIgOiBwcmVzc2VkID09PSBmYWxzZSA/IFwiZmFsc2VcIiA6IHVuZGVmaW5lZCkgfTtcclxuICAgICAgICBjb25zdCBkaXZQcm9wcyA9IHsgLi4uYnV0dG9uUHJvcHMsIHRhYkluZGV4OiB0YWJJbmRleCA/PyAwLCByb2xlOiByb2xlID8/IFwiYnV0dG9uXCIgfTtcclxuICAgICAgICBjb25zdCBhbmNob3JQcm9wcyA9IHsgLi4uZGl2UHJvcHMgfTtcclxuICAgICAgICBzd2l0Y2ggKHRhZykge1xyXG4gICAgICAgICAgICBjYXNlIFwiYnV0dG9uXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKShidXR0b25Qcm9wcywgcHJvcHMpO1xyXG4gICAgICAgICAgICBjYXNlIFwiYVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoYW5jaG9yUHJvcHMsIHByb3BzKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKGRpdlByb3BzLCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VBcmlhQnV0dG9uUHJvcHNcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWJ1dHRvbi5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDaGlsZEZsYWcsIHVzZUNoaWxkTWFuYWdlciwgdXNlTGF5b3V0RWZmZWN0LCB1c2VMaW5lYXJOYXZpZ2F0aW9uLCB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VCdXR0b25MaWtlRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFBY2NvcmRpb24oeyBleHBhbmRlZEluZGV4LCBzZXRFeHBhbmRlZEluZGV4IH0pIHtcclxuICAgIGNvbnN0IFtsYXN0Rm9jdXNlZEluZGV4LCBzZXRMYXN0Rm9jdXNlZEluZGV4LCBnZXRMYXN0Rm9jdXNlZEluZGV4XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3Qgc3RhYmxlU2V0RXhwYW5kZWRJbmRleCA9IHVzZVN0YWJsZUNhbGxiYWNrKHNldEV4cGFuZGVkSW5kZXggPz8gKCgpID0+IHsgfSkpO1xyXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRBY2NvcmRpb25TZWN0aW9ucywgdXNlTWFuYWdlZENoaWxkOiB1c2VNYW5hZ2VkQ2hpbGRTZWN0aW9uIH0gPSB1c2VDaGlsZE1hbmFnZXIoKTtcclxuICAgIGNvbnN0IHsgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkIH0gPSB1c2VMaW5lYXJOYXZpZ2F0aW9uKHsgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkQWNjb3JkaW9uU2VjdGlvbnMsIG5hdmlnYXRpb25EaXJlY3Rpb246IFwiYmxvY2tcIiwgZ2V0SW5kZXg6IGdldExhc3RGb2N1c2VkSW5kZXgsIHNldEluZGV4OiBzZXRMYXN0Rm9jdXNlZEluZGV4IH0pO1xyXG4gICAgLy8gQW55IHRpbWUgbGlzdCBtYW5hZ2VtZW50IGNoYW5nZXMgdGhlIGZvY3VzZWQgaW5kZXgsIG1hbnVhbGx5IGZvY3VzIHRoZSBjaGlsZFxyXG4gICAgLy8gVE9ETzogQ2FuIHRoaXMgYmUgY3V0P1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAobGFzdEZvY3VzZWRJbmRleCAhPSBudWxsICYmIGxhc3RGb2N1c2VkSW5kZXggPj0gMClcclxuICAgICAgICAgICAgbWFuYWdlZEFjY29yZGlvblNlY3Rpb25zW2xhc3RGb2N1c2VkSW5kZXhdPy5mb2N1cygpO1xyXG4gICAgfSwgW2xhc3RGb2N1c2VkSW5kZXhdKTtcclxuICAgIHVzZUNoaWxkRmxhZyhleHBhbmRlZEluZGV4LCBtYW5hZ2VkQWNjb3JkaW9uU2VjdGlvbnMubGVuZ3RoLCAoaSwgb3BlbikgPT4gbWFuYWdlZEFjY29yZGlvblNlY3Rpb25zW2ldPy5zZXRPcGVuRnJvbVBhcmVudChvcGVuKSk7XHJcbiAgICBjb25zdCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbiA9IHVzZUNhbGxiYWNrKChhcmdzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgW29wZW5Gcm9tUGFyZW50LCBzZXRPcGVuRnJvbVBhcmVudCwgZ2V0T3BlbkZyb21QYXJlbnRdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICAgICAgY29uc3QgeyByYW5kb21JZDogYm9keVJhbmRvbUlkLCB1c2VSYW5kb21JZFByb3BzOiB1c2VCb2R5UmFuZG9tSWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRCb2R5SWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1hY2NvcmRpb24tc2VjdGlvbi1ib2R5LVwiIH0pO1xyXG4gICAgICAgIGNvbnN0IHsgcmFuZG9tSWQ6IGhlYWRSYW5kb21JZCwgdXNlUmFuZG9tSWRQcm9wczogdXNlSGVhZFJhbmRvbUlkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzOiB1c2VSZWZlcmVuY2VkSGVhZElkUHJvcHMgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtYWNjb3JkaW9uLXNlY3Rpb24taGVhZGVyLVwiIH0pO1xyXG4gICAgICAgIGxldCBvcGVuID0gKChhcmdzLm9wZW4gPz8gb3BlbkZyb21QYXJlbnQpID8/IG51bGwpO1xyXG4gICAgICAgIC8vIFRPRE86IENvbnZlcnQgdG8gdXNlIHVzZU1hbmFnZWRDaGlsZCBzbyB0aGF0IHRoaXMgaG9vayBcclxuICAgICAgICAvLyBpcyBzdGFibGUgd2l0aG91dCAoZGlyZWN0bHkpIGRlcGVuZGluZyBvbiB0aGUgb3BlbiBzdGF0ZS5cclxuICAgICAgICBjb25zdCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyKHsgdGFnIH0pIHtcclxuICAgICAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7IGVsZW1lbnQ/LmZvY3VzKCk7IH0sIFtlbGVtZW50XSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlTWFuYWdlZENoaWxkUHJvcHMgfSA9IHVzZU1hbmFnZWRDaGlsZFNlY3Rpb24oeyBpbmRleDogYXJncy5pbmRleCwgb3Blbjogb3Blbiwgc2V0T3BlbkZyb21QYXJlbnQsIGZvY3VzIH0pO1xyXG4gICAgICAgICAgICBjb25zdCB7IHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZFByb3BzIH0gPSB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGQoKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcyh7IFtcImFyaWEtZXhwYW5kZWRcIl06IGFyaWFFeHBhbmRlZCwgW1wiYXJpYS1kaXNhYmxlZFwiXTogYXJpYURpc2FibGVkLCAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbkZvY3VzID0gKCkgPT4geyBzZXRMYXN0Rm9jdXNlZEluZGV4KGFyZ3MuaW5kZXgpOyB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IG9uQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldE9wZW5Gcm9tUGFyZW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWJsZVNldEV4cGFuZGVkSW5kZXgobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFibGVTZXRFeHBhbmRlZEluZGV4KGFyZ3MuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGxldCByZXRCID0gdXNlTWVyZ2VkUHJvcHMoKSh7IHRhYkluZGV4OiAwIH0sIHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzKHRhZywgb25DbGljaywgdW5kZWZpbmVkKShwcm9wcykpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJldDMgPSB1c2VNZXJnZWRQcm9wcygpKHVzZUhlYWRSYW5kb21JZFByb3BzKHVzZVJlZmVyZW5jZWRCb2R5SWRQcm9wcyhcImFyaWEtY29udHJvbHNcIikoe1xyXG4gICAgICAgICAgICAgICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiAoYXJpYUV4cGFuZGVkID8/ICghIW9wZW4pLnRvU3RyaW5nKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiAoYXJpYURpc2FibGVkID8/IChvcGVuID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQpKSxcclxuICAgICAgICAgICAgICAgICAgICAuLi51c2VSZWZFbGVtZW50UHJvcHModXNlTWFuYWdlZENoaWxkUHJvcHMocmV0QikpXHJcbiAgICAgICAgICAgICAgICB9KSksIHsgb25Gb2N1cyB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRQcm9wcyhyZXQzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHMgfTtcclxuICAgICAgICB9LCBbb3Blbl0pO1xyXG4gICAgICAgIGNvbnN0IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keSgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHMoeyByb2xlLCAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmV0MSA9IHVzZVJlZmVyZW5jZWRIZWFkSWRQcm9wcyhcImFyaWEtbGFiZWxsZWRieVwiKSh7IHJvbGU6IHJvbGUgPz8gXCJyZWdpb25cIiwgLi4ucHJvcHMgfSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmV0MiA9IHVzZUJvZHlSYW5kb21JZFByb3BzKHJldDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZXhwYW5kZWQ6IG9wZW4sXHJcbiAgICAgICAgICAgIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyLFxyXG4gICAgICAgICAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHksXHJcbiAgICAgICAgfTtcclxuICAgIH0sIFt1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25cclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWFjY29yZGlvbi5qcy5tYXAiLCJpbXBvcnQgeyB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcbi8qKlxyXG4gKiBBZGRzIGFuIElEIGFuZCBcImFyaWEtbGFiZWxsZWRieVwiIGZvciB0d28gZWxlbWVudHMsIGFuIFwiaW5wdXRcIiBlbGVtZW50IGFuZCBhIFwibGFiZWxcIiBlbGVtZW50LlxyXG4gKlxyXG4gKiBSZXR1cm5zIHRoZSBgdXNlUmVmZXJlbmNlZElkUHJvcHNgIGhvb2tzIGlmIHlvdSBuZWVkIHRvIGFsc28gYWRkIG90aGVyIElELXJlZmVyZW5jaW5nIGF0dHJpYnV0ZXMsIGxpa2UgYGZvcmBcclxuICpcclxuICogQHNlZSB1c2VJbnB1dExhYmVsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlR2VuZXJpY0xhYmVsKHsgbGFiZWxQcmVmaXgsIGlucHV0UHJlZml4LCBiYWNrdXBUZXh0IH0gPSB7IGxhYmVsUHJlZml4OiBcImxhYmVsLVwiLCBpbnB1dFByZWZpeDogXCJpbnB1dC1cIiB9KSB7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGxhYmVsRWxlbWVudCwgZ2V0RWxlbWVudDogZ2V0TGFiZWxFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUxhYmVsUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGlucHV0RWxlbWVudCwgZ2V0RWxlbWVudDogZ2V0SW5wdXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUlucHV0UmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUHJvcHM6IHVzZUxhYmVsUmFuZG9tSWRQcm9wcywgaWQ6IGxhYmVsSWQsIHJhbmRvbUlkOiBsYWJlbFJhbmRvbUlkLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlUmVmZXJlbmNlZExhYmVsSWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IGxhYmVsUHJlZml4IH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VJbnB1dFJhbmRvbUlkUHJvcHMsIGlkOiBpbnB1dElkLCByYW5kb21JZDogaW5wdXRSYW5kb21JZCwgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBpbnB1dFByZWZpeCB9KTtcclxuICAgIGNvbnN0IGxhYmVsSGFzTW91bnRlZCA9ICEhKGxhYmVsRWxlbWVudCk7XHJcbiAgICBjb25zdCBpbnB1dEhhc01vdW50ZWQgPSAhIShpbnB1dEVsZW1lbnQpO1xyXG4gICAgY29uc3QgdXNlR2VuZXJpY0xhYmVsTGFiZWwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VHZW5lcmljTGFiZWxMYWJlbCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VHZW5lcmljTGFiZWxMYWJlbFByb3BzOiAocHJvcHMpID0+IHsgcmV0dXJuIHVzZUxhYmVsUmFuZG9tSWRQcm9wcyh1c2VMYWJlbFJlZkVsZW1lbnRQcm9wcyhwcm9wcykpOyB9XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHVzZUdlbmVyaWNMYWJlbElucHV0ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlR2VuZXJpY0xhYmVsSW5wdXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlR2VuZXJpY0xhYmVsSW5wdXRQcm9wczogKHsgXCJhcmlhLWxhYmVsbGVkYnlcIjogYXJpYUxhYmVsbGVkYnksIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsIC4uLnByb3BzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodXNlSW5wdXRSYW5kb21JZFByb3BzKHVzZVJlZmVyZW5jZWRMYWJlbElkUHJvcHMoXCJhcmlhLWxhYmVsbGVkYnlcIikodXNlSW5wdXRSZWZFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IFwiYXJpYS1sYWJlbFwiOiAoIWxhYmVsSGFzTW91bnRlZCA/IGJhY2t1cFRleHQgOiBhcmlhTGFiZWwpID8/IGFyaWFMYWJlbCB9LCBwcm9wcykpKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtsYWJlbEhhc01vdW50ZWRdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlR2VuZXJpY0xhYmVsSW5wdXQsXHJcbiAgICAgICAgdXNlR2VuZXJpY0xhYmVsTGFiZWwsXHJcbiAgICAgICAgdXNlUmVmZXJlbmNlZExhYmVsSWRQcm9wcyxcclxuICAgICAgICB1c2VSZWZlcmVuY2VkSW5wdXRJZFByb3BzLFxyXG4gICAgICAgIGxhYmVsSWQsXHJcbiAgICAgICAgaW5wdXRJZCxcclxuICAgICAgICBsYWJlbEVsZW1lbnQsXHJcbiAgICAgICAgaW5wdXRFbGVtZW50LFxyXG4gICAgICAgIGdldExhYmVsRWxlbWVudCxcclxuICAgICAgICBnZXRJbnB1dEVsZW1lbnQsXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBIYW5kbGVzIHRoZSBhdHRyaWJ1dGVzIGBpZGAsIGBmb3JgLCBhbmQgYGFyaWEtbGFiZWxsZWRieWAgZm9yIHRvIHJlbGF0ZWQgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEl0J3MgYXNzdW1lZCB0aGF0IHRoZSBsYWJlbCBpcyBhbiBgSFRNTExhYmVsRWxlbWVudGAsIGFuZCB0aGUgaW5wdXQgaXMgc29tZXRoaW5nIGZvciB3aGljaFxyXG4gKiB0aGUgYGZvcmAgYXR0cmlidXRlIGNhbiByZWZlcmVuY2UuXHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5wdXRMYWJlbCh7IGxhYmVsUHJlZml4LCBpbnB1dFByZWZpeCB9ID0geyBsYWJlbFByZWZpeDogXCJsYWJlbC1cIiwgaW5wdXRQcmVmaXg6IFwiaW5wdXQtXCIgfSkge1xyXG4gICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxJbnB1dCwgdXNlR2VuZXJpY0xhYmVsTGFiZWwsIHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMsIHVzZVJlZmVyZW5jZWRMYWJlbElkUHJvcHMsIGlucHV0SWQsIGxhYmVsSWQsIGlucHV0RWxlbWVudCwgZ2V0SW5wdXRFbGVtZW50LCBsYWJlbEVsZW1lbnQsIGdldExhYmVsRWxlbWVudCB9ID0gdXNlR2VuZXJpY0xhYmVsKHsgbGFiZWxQcmVmaXgsIGlucHV0UHJlZml4IH0pO1xyXG4gICAgY29uc3QgdXNlSW5wdXRMYWJlbExhYmVsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlSW5wdXRMYWJlbExhYmVsKHsgdGFnIH0pIHtcclxuICAgICAgICBjb25zdCB7IHVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUdlbmVyaWNMYWJlbExhYmVsKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlSW5wdXRMYWJlbExhYmVsUHJvcHMocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdpdGhGb3IgPSB1c2VSZWZlcmVuY2VkSW5wdXRJZFByb3BzKFwiZm9yXCIpKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdpdGhvdXRGb3IgPSBwcm9wcztcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VHZW5lcmljTGFiZWxMYWJlbFByb3BzKHRhZyA9PSBcImxhYmVsXCIgPyB3aXRoRm9yIDogd2l0aG91dEZvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW3VzZUdlbmVyaWNMYWJlbElucHV0XSk7XHJcbiAgICBjb25zdCB1c2VJbnB1dExhYmVsSW5wdXQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VJbnB1dExhYmVsSW5wdXQoKSB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VHZW5lcmljTGFiZWxJbnB1dCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUlucHV0TGFiZWxJbnB1dFByb3BzKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlR2VuZXJpY0xhYmVsSW5wdXRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW3VzZUdlbmVyaWNMYWJlbExhYmVsXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUlucHV0TGFiZWxMYWJlbCxcclxuICAgICAgICB1c2VJbnB1dExhYmVsSW5wdXQsXHJcbiAgICAgICAgbGFiZWxJZCxcclxuICAgICAgICBpbnB1dElkLFxyXG4gICAgICAgIGlucHV0RWxlbWVudCxcclxuICAgICAgICBsYWJlbEVsZW1lbnQsXHJcbiAgICAgICAgZ2V0SW5wdXRFbGVtZW50LFxyXG4gICAgICAgIGdldExhYmVsRWxlbWVudFxyXG4gICAgfTtcclxufVxyXG5jb25zdCBoYW5kbGVzSW5wdXQgPSAodGFnLCBsYWJlbFBvc2l0aW9uLCB3aGljaCkgPT4ge1xyXG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT09IFwic2VwYXJhdGVcIikge1xyXG4gICAgICAgIGlmICh3aGljaCA9PT0gXCJpbnB1dC1lbGVtZW50XCIpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGVsc2UgaWYgKHdoaWNoID09PSBcImxhYmVsLWVsZW1lbnRcIilcclxuICAgICAgICAgICAgcmV0dXJuIHRhZyAhPSBcImlucHV0XCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsYWJlbFBvc2l0aW9uID09PSBcIndyYXBwaW5nXCIpIHtcclxuICAgICAgICBpZiAod2hpY2ggPT09IFwiaW5wdXQtZWxlbWVudFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHdoaWNoID09IFwibGFiZWwtZWxlbWVudFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEhhbmRsZXMgbGFiZWwgdHlwZSAod3JhcHBpbmcgb3Igc2VwYXJhdGUpIGZvciBjaGVja2JveGVzLCByYWRpb3MsIHN3aXRjaGVzLCBldGMuXHJcbiAqIEBwYXJhbSBwYXJhbTBcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGVja2JveExpa2UoeyBjaGVja2VkLCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgb25JbnB1dCwgcm9sZSB9KSB7XHJcbiAgICBjb25zdCBzdGFibGVPbklucHV0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKGUpID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBvbklucHV0Py4oZSk7IH0pO1xyXG4gICAgY29uc3QgeyBpbnB1dElkLCBsYWJlbElkLCB1c2VJbnB1dExhYmVsSW5wdXQ6IHVzZUlMSW5wdXQsIHVzZUlucHV0TGFiZWxMYWJlbDogdXNlSUxMYWJlbCwgZ2V0TGFiZWxFbGVtZW50LCBnZXRJbnB1dEVsZW1lbnQgfSA9IHVzZUlucHV0TGFiZWwoeyBsYWJlbFByZWZpeDogXCJhcmlhLWNoZWNrYm94LWxhYmVsLVwiLCBpbnB1dFByZWZpeDogXCJhcmlhLWNoZWNrYm94LWlucHV0LVwiIH0pO1xyXG4gICAgY29uc3QgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoeyB0YWcgfSkge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlSW5wdXRMYWJlbElucHV0UHJvcHM6IHVzZUlMSW5wdXRQcm9wcyB9ID0gdXNlSUxJbnB1dCgpO1xyXG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICAgICAgLy8gb25DbGljayBhbmQgb25DaGFuZ2UgYXJlIGEgYml0IG1lc3N5LCBzbyB3ZSBuZWVkIHRvXHJcbiAgICAgICAgLy8gKmFsd2F5cyogbWFrZSBzdXJlIHRoYXQgdGhlIHZpc2libGUgc3RhdGUgaXMgY29ycmVjdFxyXG4gICAgICAgIC8vIGFmdGVyIGFsbCB0aGUgZXZlbnQgZHVzdCBzZXR0bGVzLlxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8yNzQ1LFxyXG4gICAgICAgIC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8xODk5I2lzc3VlY29tbWVudC01MjU2OTAxOTRcclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiB0YWcgPT0gXCJpbnB1dFwiKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNoZWNrZWQgPSBjaGVja2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW3RhZywgZWxlbWVudCwgY2hlY2tlZF0pO1xyXG4gICAgICAgIHJldHVybiB7IGlucHV0RWxlbWVudDogZWxlbWVudCwgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMgfTtcclxuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyh7IC4uLnAwIH0pIHtcclxuICAgICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBDaHJvbWUgd29uJ3QgZmlyZSBvbklucHV0IGV2ZW50cyBmb3IgcmFkaW8gYnV0dG9ucyB0aGF0IGFyZSB0YWJJbmRleD0tMT8/XHJcbiAgICAgICAgICAgIC8vIE5lZWRzIGludmVzdGlnYXRpbmcsIGJ1dCBvbklucHV0IHdvcmtzIGZpbmUgaW4gRmlyZWZveFxyXG4gICAgICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgICAgIGxldCBwcm9wcyA9IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzKHRhZywgZGlzYWJsZWQgfHwgIWhhbmRsZXNJbnB1dCh0YWcsIGxhYmVsUG9zaXRpb24sIFwiaW5wdXQtZWxlbWVudFwiKSA/IHVuZGVmaW5lZCA6IHN0YWJsZU9uSW5wdXQsIHVuZGVmaW5lZCkoe30pO1xyXG4gICAgICAgICAgICBpZiAodGFnID09IFwiaW5wdXRcIilcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uSW5wdXQgPSAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBwcm9wcyA9IHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VJTElucHV0UHJvcHMocHJvcHMpKTtcclxuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSB3cmFwcGVkIGxhYmVsIGhhbmRsZXMgYWxsIGludGVyYWN0aW9ucyxcclxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoaXMgZWxlbWVudCBjYW4ndCBiZSBpbnRlcmFjdGVkIHdpdGhcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgaXQncyBhbiBpbnB1dCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgcHJvcHMuaW5lcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uRm9jdXMgPSBlID0+IGdldExhYmVsRWxlbWVudCgpLmZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnID09PSBcImlucHV0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jaGVja2VkID0gY2hlY2tlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnJvbGUgPSByb2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtY2hlY2tlZFwiXSA9IGNoZWNrZWQgPyBcInRydWVcIiA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IGRpc2FibGVkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbGFiZWwgY2xpY2tzIGNhbid0IGFmZmVjdCB0aGUgY2hlY2tib3ggd2hpbGUgaXQncyBkaXNhYmxlZFxyXG4gICAgICAgICAgICBwcm9wcy5vbkNsaWNrID0gZGlzYWJsZWQgPyAoKGUpID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9KSA6IHByb3BzLm9uQ2xpY2s7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHAwLCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3VzZUlMSW5wdXQsIHJvbGUsIGxhYmVsUG9zaXRpb24sIGRpc2FibGVkLCBjaGVja2VkXSk7XHJcbiAgICBjb25zdCB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VDaGVja2JveExhYmVsRWxlbWVudCh7IHRhZyB9KSB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VJbnB1dExhYmVsTGFiZWxQcm9wczogdXNlSUxMYWJlbFByb3BzIH0gPSB1c2VJTExhYmVsKHsgdGFnIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzKHsgLi4ucDAgfSkge1xyXG4gICAgICAgICAgICBsZXQgbmV3UHJvcHMgPSB1c2VCdXR0b25MaWtlRXZlbnRIYW5kbGVycyhcImRpdlwiLCBkaXNhYmxlZCB8fCAhaGFuZGxlc0lucHV0KHRhZywgbGFiZWxQb3NpdGlvbiwgXCJsYWJlbC1lbGVtZW50XCIpID8gdW5kZWZpbmVkIDogc3RhYmxlT25JbnB1dCwgdW5kZWZpbmVkKSh7fSk7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgbmV3UHJvcHMudGFiSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgbmV3UHJvcHMucm9sZSA9IHJvbGU7XHJcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBkaXNhYmxlZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbXCJhcmlhLWNoZWNrZWRcIl0gPSBjaGVja2VkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgb25lIGNhc2Ugd2hlcmUgdGhlcmUncyBhbG1vc3Qgbm90aGluZyB0byBkb1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1vc3Qgbm9ybWFsIGNhc2Ugd2hlcmUgZXZlcnl0aGluZyBhY3RzIGFjY29yZGluZyBub3JtYWwgSFRNTCBtZWNoYW5pY3MuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSnVzdCBtYWtlIHN1cmUgdGhhdCBsYWJlbCBjbGlja3MgY2FuJ3QgYWZmZWN0IHRoZSBjaGVja2JveCB3aGlsZSBpdCdzIGRpc2FibGVkXHJcbiAgICAgICAgICAgIG5ld1Byb3BzLm9uQ2xpY2sgPSBkaXNhYmxlZCA/ICgoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCk7IH0pIDogbmV3UHJvcHMub25DbGljaztcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkobmV3UHJvcHMsIHVzZUlMTGFiZWxQcm9wcyhwMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyB9O1xyXG4gICAgfSwgW3VzZUlMTGFiZWwsIGRpc2FibGVkLCBjaGVja2VkLCByb2xlLCBsYWJlbFBvc2l0aW9uXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCxcclxuICAgICAgICB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsXHJcbiAgICAgICAgZ2V0TGFiZWxFbGVtZW50LFxyXG4gICAgICAgIGdldElucHV0RWxlbWVudFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbGFiZWwuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZUNoZWNrYm94TGlrZSB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYUNoZWNrYm94KHsgbGFiZWxQb3NpdGlvbiwgY2hlY2tlZCwgb25JbnB1dCwgZGlzYWJsZWQgfSkge1xyXG4gICAgY29uc3Qgb25JbnB1dEVuaGFuY2VkID0gKGUpID0+IG9uSW5wdXQ/LihlbmhhbmNlRXZlbnQoZSwgeyBjaGVja2VkOiAhY2hlY2tlZCB9KSk7XHJcbiAgICBjb25zdCB7IGdldElucHV0RWxlbWVudCwgZ2V0TGFiZWxFbGVtZW50LCB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCB9ID0gdXNlQ2hlY2tib3hMaWtlKHsgY2hlY2tlZDogISFjaGVja2VkLCBsYWJlbFBvc2l0aW9uLCByb2xlOiBcImNoZWNrYm94XCIsIGRpc2FibGVkLCBvbklucHV0OiBvbklucHV0RW5oYW5jZWQgfSk7XHJcbiAgICBjb25zdCB1c2VDaGVja2JveElucHV0RWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KHsgdGFnIH0pIHtcclxuICAgICAgICBjb25zdCB7IGlucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCh7IHRhZyB9KTtcclxuICAgICAgICBjb25zdCBpc01peGVkID0gKGNoZWNrZWQgPT0gXCJtaXhlZFwiKTtcclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaW5wdXRFbGVtZW50ICYmIHRhZyA9PT0gXCJpbnB1dFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQuaW5kZXRlcm1pbmF0ZSA9IGlzTWl4ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbaW5wdXRFbGVtZW50LCBpc01peGVkLCB0YWddKTtcclxuICAgICAgICByZXR1cm4geyB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzIH07XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyh7IC4uLnAwIH0pIHtcclxuICAgICAgICAgICAgbGV0IHByb3BzID0gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMocDApO1xyXG4gICAgICAgICAgICBwcm9wcy5jaGVja2VkID8/PSAhIWNoZWNrZWQ7XHJcbiAgICAgICAgICAgIGlmICh0YWcgPT0gXCJpbnB1dFwiKVxyXG4gICAgICAgICAgICAgICAgcHJvcHMudHlwZSA9IFwiY2hlY2tib3hcIjtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtjaGVja2VkLCBsYWJlbFBvc2l0aW9uLCBkaXNhYmxlZF0pO1xyXG4gICAgY29uc3QgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VDaGVja2JveExhYmVsRWxlbWVudCh7IHRhZyB9KSB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50KHsgdGFnIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMoeyAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICByZXR1cm4geyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIH07XHJcbiAgICB9LCBbdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50LCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbl0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VDaGVja2JveElucHV0RWxlbWVudCxcclxuICAgICAgICB1c2VDaGVja2JveExhYmVsRWxlbWVudFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtY2hlY2tib3guanMubWFwIiwiaW1wb3J0IHsgdXNlRm9jdXNUcmFwLCB1c2VHbG9iYWxIYW5kbGVyLCB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbi8qKlxyXG4gKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBhIG1vZGFsLWxpa2Ugc29mdC1kaXNtaXNzIGludGVyYWN0aW9uLlxyXG4gKlxyXG4gKiBUaGF0IGlzLCBhbnkgY2xpY2tzIG9yIHRhcHMgb3V0c2lkZSBvZiB0aGUgZ2l2ZW4gY29tcG9uZW50LFxyXG4gKiBvciBhbnkgdGltZSB0aGUgRXNjYXBlIGtleSBpcyBwcmVzc2VkIHdpdGhpbiB0aGUgY29tcG9uZW50LFxyXG4gKiAod2l0aCB2YXJpb3VzIGJyb3dzZXIgb2RkaXRpZXMgcmVnYXJkaW5nIGNsaWNrcyBvbiBibGFuayBvciBpbmVydCBhcmVhcyBoYW5kbGVkKVxyXG4gKiB0aGUgY29tcG9uZW50IHdpbGwgcmVxdWVzdCB0byBjbG9zZSBpdHNlbGYuXHJcbiAqXHJcbiAqIE9mIGNvdXJzZSwgaWYgeW91IGRvbid0IGRvIGFueXRoaW5nIGluIHRoZSBgb25DbG9zZWAgZnVuY3Rpb24sXHJcbiAqIGl0IHdvbid0IGJlIGEgc29mdCBkaXNtaXNzIGFueW1vcmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXJhbTBcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTb2Z0RGlzbWlzcyh7IG9uQ2xvc2UgfSkge1xyXG4gICAgY29uc3QgeyBlbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgIGZ1bmN0aW9uIG9uQmFja2Ryb3BDbGljayhlKSB7XHJcbiAgICAgICAgLy8gQmFzaWNhbGx5LCBcIndhcyB0aGlzIGV2ZW50IGZpcmVkIG9uIHRoZSByb290LW1vc3QgZWxlbWVudCwgb3IgYXQgbGVhc3QgYW4gZWxlbWVudCBub3QgY29udGFpbmVkIGJ5IHRoZSBtb2RhbD9cIlxyXG4gICAgICAgIC8vIEVpdGhlciBjb3VsZCBiZSBob3cgdGhlIGJyb3dzZXIgaGFuZGxlcyB0aGVzZSBzb3J0cyBvZiBcImludGVyYWN0aW5nIHdpdGggbm90aGluZ1wiIGV2ZW50cy5cclxuICAgICAgICBpZiAoZS50YXJnZXQgPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8ICEoZWxlbWVudCAmJiBlLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpKSB7XHJcbiAgICAgICAgICAgIG9uQ2xvc2UoXCJiYWNrZHJvcFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBTaW5jZSBldmVyeXRoaW5nIGVsc2UgaXMgaW5lcnQsIHdlIGxpc3RlbiBmb3IgY2FwdHVyZWQgY2xpY2tzIG9uIHRoZSB3aW5kb3dcclxuICAgIC8vICh3ZSBkb24ndCB1c2Ugb25DbGljayBzaW5jZSB0aGF0IGRvZXNuJ3QgZmlyZSB3aGVuIGNsaWNrZWQgb24gZW1wdHkvaW5lcnQgYXJlYXMpXHJcbiAgICAvLyBOb3RlOiBXZSBuZWVkIGEgKnNlcGFyYXRlKiB0b3VjaCBldmVudCBvbiBtb2JpbGUgU2FmYXJpLCBiZWNhdXNlXHJcbiAgICAvLyBpdCBkb2Vzbid0IGxldCBjbGljayBldmVudHMgYnViYmxlIG9yIGJlIGNhcHR1cmVkIGZyb20gdHJhZGl0aW9uYWxseSBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsXHJcbiAgICAvLyBidXQgdG91Y2ggZXZlbnRzIHdvcmsgYXMgZXhwZWN0ZWQuXHJcbiAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJtb3VzZWRvd25cIiwgIW9wZW4gPyBudWxsIDogb25CYWNrZHJvcENsaWNrLCB7IGNhcHR1cmU6IHRydWUgfSk7XHJcbiAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJ0b3VjaHN0YXJ0XCIsICFvcGVuID8gbnVsbCA6IG9uQmFja2Ryb3BDbGljaywgeyBjYXB0dXJlOiB0cnVlIH0pO1xyXG4gICAgY29uc3Qgb25LZXlEb3duID0gKGUpID0+IHtcclxuICAgICAgICBpZiAoZS5rZXkgPT09IFwiRXNjYXBlXCIpIHtcclxuICAgICAgICAgICAgb25DbG9zZShcImVzY2FwZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHsgdXNlU29mdERpc21pc3NQcm9wczogKHByb3BzKSA9PiB1c2VNZXJnZWRQcm9wcygpKHVzZVJlZkVsZW1lbnRQcm9wcyh7IG9uS2V5RG93biB9KSwgcHJvcHMpIH07XHJcbn1cclxuLyoqXHJcbiAqIEEgZ2VuZXJpYyBtb2RhbCBob29rLCB1c2VkIGJ5IG1vZGFsIGRpYWxvZ3MsIGJ1dCBjYW4gYWxzb1xyXG4gKiBiZSB1c2VkIGJ5IGFueXRoaW5nIHRoYXQncyBtb2RhbCB3aXRoIGEgYmFja2Ryb3AuXHJcbiAqIEBwYXJhbSBwYXJhbTBcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhTW9kYWwoeyBvcGVuLCBvbkNsb3NlIH0pIHtcclxuICAgIGNvbnN0IHN0YWJsZU9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjayhvbkNsb3NlKTtcclxuICAgIGNvbnN0IFttb2RhbERlc2NyaWJlZEJ5Qm9keSwgc2V0TW9kYWxEZXNjcmliZWRCeUJvZHldID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgdXNlSGlkZVNjcm9sbChvcGVuKTtcclxuICAgIGNvbnN0IHsgaWQ6IG1vZGFsSWQsIHVzZVJhbmRvbUlkUHJvcHM6IHVzZU1vZGFsSWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZU1vZGFsUmVmZXJlbmNpbmdJZFByb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLW1vZGFsLVwiIH0pO1xyXG4gICAgY29uc3QgeyBpZDogYm9keUlkLCB1c2VSYW5kb21JZFByb3BzOiB1c2VCb2R5SWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZUJvZHlSZWZlcmVuY2luZ0lkUHJvcHMgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtbW9kYWwtYm9keS1cIiB9KTtcclxuICAgIGNvbnN0IHsgaWQ6IHRpdGxlSWQsIHVzZVJhbmRvbUlkUHJvcHM6IHVzZVRpdGxlSWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVRpdGxlUmVmZXJlbmNpbmdJZFByb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLW1vZGFsLXRpdGxlLVwiIH0pO1xyXG4gICAgY29uc3QgeyB1c2VTb2Z0RGlzbWlzc1Byb3BzIH0gPSB1c2VTb2Z0RGlzbWlzcyh7IG9uQ2xvc2U6IHN0YWJsZU9uQ2xvc2UgfSk7XHJcbiAgICBjb25zdCB1c2VNb2RhbEJhY2tkcm9wID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTW9kYWxCYWNrZHJvcCgpIHtcclxuICAgICAgICBmdW5jdGlvbiB1c2VNb2RhbEJhY2tkcm9wUHJvcHMocHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoeyBvblBvaW50ZXJVcDogKCkgPT4gc3RhYmxlT25DbG9zZShcImJhY2tkcm9wXCIpIH0sIHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTW9kYWxCYWNrZHJvcFByb3BzIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCB1c2VNb2RhbFByb3BzID0gZnVuY3Rpb24gKHsgXCJhcmlhLW1vZGFsXCI6IGFyaWFNb2RhbCwgcm9sZSwgLi4ucDAgfSkge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlRm9jdXNUcmFwUHJvcHMgfSA9IHVzZUZvY3VzVHJhcCh7IHRyYXBBY3RpdmU6IG9wZW4gfSk7XHJcbiAgICAgICAgY29uc3QgcDEgPSB1c2VUaXRsZVJlZmVyZW5jaW5nSWRQcm9wcyhcImFyaWEtbGFiZWxsZWRieVwiKShwMCk7XHJcbiAgICAgICAgY29uc3QgcDIgPSB1c2VNb2RhbElkUHJvcHMocDEpO1xyXG4gICAgICAgIGNvbnN0IHBGaW5hbCA9IHVzZUJvZHlSZWZlcmVuY2luZ0lkUHJvcHMoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpKHAyKTtcclxuICAgICAgICByZXR1cm4gdXNlRm9jdXNUcmFwUHJvcHModXNlTWVyZ2VkUHJvcHMoKSh1c2VTb2Z0RGlzbWlzc1Byb3BzKHsgcm9sZTogXCJkaWFsb2dcIiB9KSwgbW9kYWxEZXNjcmliZWRCeUJvZHkgPyBwRmluYWwgOiBwMikpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVzZU1vZGFsVGl0bGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VNb2RhbFRpdGxlKCkge1xyXG4gICAgICAgIGNvbnN0IHVzZU1vZGFsVGl0bGVQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlVGl0bGVJZFByb3BzKHByb3BzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB7IHVzZU1vZGFsVGl0bGVQcm9wcyB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3QgdXNlTW9kYWxCb2R5ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTW9kYWxCb2R5KHsgZGVzY3JpcHRpdmUgfSkge1xyXG4gICAgICAgIHNldE1vZGFsRGVzY3JpYmVkQnlCb2R5KGRlc2NyaXB0aXZlKTtcclxuICAgICAgICBjb25zdCB1c2VNb2RhbEJvZHlQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlQm9keUlkUHJvcHMocHJvcHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTW9kYWxCb2R5UHJvcHMgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTW9kYWxQcm9wcyxcclxuICAgICAgICB1c2VNb2RhbFRpdGxlLFxyXG4gICAgICAgIHVzZU1vZGFsQm9keSxcclxuICAgICAgICB1c2VNb2RhbEJhY2tkcm9wXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBBbGxvd3MgZm9yIGhpZGluZyB0aGUgc2Nyb2xsIGJhciBvZiB0aGUgcm9vdCBIVE1MIGVsZW1lbnRcclxuICogd2l0aG91dCBzaGlmdGluZyB0aGUgbGF5b3V0IG9mIHRoZSBwYWdlIG1vcmUgdGhhbiBhZGRpbmcgYSBmb3cgcGl4ZWxzXHJcbiAqIG9mIHBhZGRpbmcgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBuZWNlc3NhcnkuXHJcbiAqIEBwYXJhbSBoaWRlU2Nyb2xsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlSGlkZVNjcm9sbChoaWRlU2Nyb2xsKSB7XHJcbiAgICBjb25zdCBbc2Nyb2xsYmFyV2lkdGgsIHNldFNjcm9sbGJhcldpZHRoLCBnZXRTY3JvbGxiYXJXaWR0aF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGhpZGVTY3JvbGwpIHtcclxuICAgICAgICAgICAgbGV0IHdpZHRoV2l0aFNjcm9sbEJhciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkb2N1bWVudC1zY3JvbGwtaGlkZGVuXCIpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSA9ICgrKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdIHx8IFwiMFwiKSArIDEpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGxldCB3aWR0aFdpdGhvdXRTY3JvbGxCYXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XHJcbiAgICAgICAgICAgIGxldCBzY3JvbGxiYXJXaWR0aCA9ICh3aWR0aFdpdGhvdXRTY3JvbGxCYXIgLSB3aWR0aFdpdGhTY3JvbGxCYXIpO1xyXG4gICAgICAgICAgICAvLyBGYWlsc2FmZSAtLSBpZiB0aGlzIG1lYXN1cmluZyB0cmljayBkb2VzIHNvbWV0aGluZyB1bmV4cGVjdGVkLCBqdXN0IGlnbm9yZSBpdFxyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFyV2lkdGggPiA4MClcclxuICAgICAgICAgICAgICAgIHNjcm9sbGJhcldpZHRoID0gMDtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1zY3JvbGxiYXItd2lkdGhcIiwgYCR7c2Nyb2xsYmFyV2lkdGh9cHhgKTtcclxuICAgICAgICAgICAgc2V0U2Nyb2xsYmFyV2lkdGgoc2Nyb2xsYmFyV2lkdGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gPSAoKyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSB8fCBcIjBcIikgLSAxKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdID09IFwiMFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2Nyb2xsLWhpZGVyc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImRvY3VtZW50LXNjcm9sbC1oaWRkZW5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2hpZGVTY3JvbGxdKTtcclxuICAgIHJldHVybiB7IHNjcm9sbGJhcldpZHRoLCBnZXRTY3JvbGxiYXJXaWR0aCB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1tb2RhbC5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlQXJpYU1vZGFsIH0gZnJvbSBcIi4vdXNlLW1vZGFsXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhRGlhbG9nKHsgb3Blbiwgb25DbG9zZSB9KSB7XHJcbiAgICAvLyBUT0RPOiBEaWZmZXJlbmNlcyBiZXR3ZWVuIGRpYWxvZyBhbmQgbW9kYWwgZ28gaGVyZSwgcHJlc3VtYWJseS5cclxuICAgIC8vIE5vbi1tb2RhbCBkaWFsb2dzIG5lZWQgdG8gYmUgYWJsZSB0byBiZSByZXBvc2l0aW9uZWQsIGV0Yy5cclxuICAgIGNvbnN0IHsgdXNlTW9kYWxCYWNrZHJvcCwgdXNlTW9kYWxCb2R5LCB1c2VNb2RhbFByb3BzLCB1c2VNb2RhbFRpdGxlIH0gPSB1c2VBcmlhTW9kYWwoeyBvcGVuLCBvbkNsb3NlIH0pO1xyXG4gICAgY29uc3QgdXNlRGlhbG9nQmFja2Ryb3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VNb2RhbEJhY2tkcm9wUHJvcHMgfSA9IHVzZU1vZGFsQmFja2Ryb3AoKTtcclxuICAgICAgICByZXR1cm4geyB1c2VEaWFsb2dCYWNrZHJvcFByb3BzOiB1c2VNb2RhbEJhY2tkcm9wUHJvcHMgfTtcclxuICAgIH0sIFt1c2VNb2RhbEJhY2tkcm9wXSk7XHJcbiAgICBjb25zdCB1c2VEaWFsb2dCb2R5ID0gdXNlQ2FsbGJhY2soKHsgZGVzY3JpcHRpdmUgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxCb2R5UHJvcHMgfSA9IHVzZU1vZGFsQm9keSh7IGRlc2NyaXB0aXZlIH0pO1xyXG4gICAgICAgIHJldHVybiB7IHVzZURpYWxvZ0JvZHlQcm9wczogdXNlTW9kYWxCb2R5UHJvcHMgfTtcclxuICAgIH0sIFt1c2VNb2RhbEJhY2tkcm9wXSk7XHJcbiAgICBjb25zdCB1c2VEaWFsb2dQcm9wcyA9IHVzZU1vZGFsUHJvcHM7XHJcbiAgICBjb25zdCB1c2VEaWFsb2dUaXRsZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZU1vZGFsVGl0bGVQcm9wcyB9ID0gdXNlTW9kYWxUaXRsZSgpO1xyXG4gICAgICAgIHJldHVybiB7IHVzZURpYWxvZ1RpdGxlUHJvcHM6IHVzZU1vZGFsVGl0bGVQcm9wcyB9O1xyXG4gICAgfSwgW3VzZU1vZGFsVGl0bGVdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlRGlhbG9nUHJvcHMsXHJcbiAgICAgICAgdXNlRGlhbG9nVGl0bGUsXHJcbiAgICAgICAgdXNlRGlhbG9nQm9keSxcclxuICAgICAgICB1c2VEaWFsb2dCYWNrZHJvcFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtZGlhbG9nLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VBcmlhTW9kYWwgfSBmcm9tIFwiLi91c2UtbW9kYWxcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZURyYXdlcih7IG9wZW4sIG9uQ2xvc2UgfSkge1xyXG4gICAgLy8gVE9ETzogRHJhd2VycyBhcmUgbm90IGFsd2F5cyBtb2RhbC5cclxuICAgIGNvbnN0IHsgdXNlTW9kYWxCYWNrZHJvcCwgdXNlTW9kYWxCb2R5LCB1c2VNb2RhbFByb3BzLCB1c2VNb2RhbFRpdGxlIH0gPSB1c2VBcmlhTW9kYWwoeyBvcGVuLCBvbkNsb3NlIH0pO1xyXG4gICAgY29uc3QgdXNlRHJhd2VyQmFja2Ryb3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VNb2RhbEJhY2tkcm9wUHJvcHMgfSA9IHVzZU1vZGFsQmFja2Ryb3AoKTtcclxuICAgICAgICByZXR1cm4geyB1c2VEcmF3ZXJCYWNrZHJvcFByb3BzOiB1c2VNb2RhbEJhY2tkcm9wUHJvcHMgfTtcclxuICAgIH0sIFt1c2VNb2RhbEJhY2tkcm9wXSk7XHJcbiAgICBjb25zdCB1c2VEcmF3ZXJCb2R5ID0gdXNlQ2FsbGJhY2soKHsgZGVzY3JpcHRpdmUgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxCb2R5UHJvcHMgfSA9IHVzZU1vZGFsQm9keSh7IGRlc2NyaXB0aXZlIH0pO1xyXG4gICAgICAgIHJldHVybiB7IHVzZURyYXdlckJvZHlQcm9wczogdXNlTW9kYWxCb2R5UHJvcHMgfTtcclxuICAgIH0sIFt1c2VNb2RhbEJhY2tkcm9wXSk7XHJcbiAgICBjb25zdCB1c2VEcmF3ZXJQcm9wcyA9IHVzZU1vZGFsUHJvcHM7XHJcbiAgICBjb25zdCB1c2VEcmF3ZXJUaXRsZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZU1vZGFsVGl0bGVQcm9wcyB9ID0gdXNlTW9kYWxUaXRsZSgpO1xyXG4gICAgICAgIHJldHVybiB7IHVzZURyYXdlclRpdGxlUHJvcHM6IHVzZU1vZGFsVGl0bGVQcm9wcyB9O1xyXG4gICAgfSwgW3VzZU1vZGFsVGl0bGVdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlRHJhd2VyUHJvcHMsXHJcbiAgICAgICAgdXNlRHJhd2VyVGl0bGUsXHJcbiAgICAgICAgdXNlRHJhd2VyQm9keSxcclxuICAgICAgICB1c2VEcmF3ZXJCYWNrZHJvcFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtZHJhd2VyLmpzLm1hcCIsImltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQsIHVzZUNoaWxkRmxhZywgdXNlSGFzRm9jdXMsIHVzZUxheW91dEVmZmVjdCwgdXNlTGlzdE5hdmlnYXRpb24sIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFdmVudERldGFpbCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzIH0gZnJvbSBcIi4vdXNlLWJ1dHRvblwiO1xyXG5pbXBvcnQgeyB1c2VHZW5lcmljTGFiZWwgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFMaXN0Ym94U2luZ2xlKHsgc2VsZWN0ZWRJbmRleCwgb25TZWxlY3QsIHNlbGVjdGlvbk1vZGUsIC4uLmFyZ3MgfSkge1xyXG4gICAgY29uc3QgeyBsYXN0Rm9jdXNlZElubmVyLCB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1cygpO1xyXG4gICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxJbnB1dCwgdXNlR2VuZXJpY0xhYmVsTGFiZWwsIHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMsIHVzZVJlZmVyZW5jZWRMYWJlbElkUHJvcHMsIGlucHV0RWxlbWVudCB9ID0gdXNlR2VuZXJpY0xhYmVsKHsgbGFiZWxQcmVmaXg6IFwiYXJpYS1saXN0Ym94LWxhYmVsLVwiLCBpbnB1dFByZWZpeDogXCJhcmlhLWxpc3Rib3gtXCIgfSk7XHJcbiAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsIG5hdmlnYXRlVG9JbmRleCwgbWFuYWdlZENoaWxkcmVuLCBzZXRUYWJiYWJsZUluZGV4LCB0YWJiYWJsZUluZGV4LCBmb2N1c0N1cnJlbnQsIGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uKHsgLi4uYXJncywgZm9jdXNPbkNoYW5nZTogbGFzdEZvY3VzZWRJbm5lciB9KTtcclxuICAgIGNvbnN0IHsgdXNlR2VuZXJpY0xhYmVsSW5wdXRQcm9wcyB9ID0gdXNlR2VuZXJpY0xhYmVsSW5wdXQoKTtcclxuICAgIGNvbnN0IHN0YWJsZU9uU2VsZWN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sob25TZWxlY3QgPz8gKCgpID0+IHsgfSkpO1xyXG4gICAgdXNlQ2hpbGRGbGFnKHNlbGVjdGVkSW5kZXgsIG1hbmFnZWRDaGlsZHJlbi5sZW5ndGgsIChpLCBzZWxlY3RlZCkgPT4gbWFuYWdlZENoaWxkcmVuW2ldPy5zZXRTZWxlY3RlZChzZWxlY3RlZCkpO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KChbXSkgPT4ge1xyXG4gICAgICAgIG5hdmlnYXRlVG9JbmRleChzZWxlY3RlZEluZGV4KTtcclxuICAgIH0sIFtzZWxlY3RlZEluZGV4LCBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoXSk7XHJcbiAgICBjb25zdCBjaGlsZENvdW50ID0gbWFuYWdlZENoaWxkcmVuLmxlbmd0aDtcclxuICAgIGNvbnN0IHsgbGFzdEFjdGl2ZUVsZW1lbnQgfSA9IHVzZUFjdGl2ZUVsZW1lbnQoKTtcclxuICAgIGxldCBhbnlSYWRpb3NGb2N1c2VkID0gKCEhaW5wdXRFbGVtZW50Py5jb250YWlucyhsYXN0QWN0aXZlRWxlbWVudCkpO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWFueVJhZGlvc0ZvY3VzZWQpXHJcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoc2VsZWN0ZWRJbmRleCk7XHJcbiAgICB9LCBbYW55UmFkaW9zRm9jdXNlZCwgc2VsZWN0ZWRJbmRleCwgc2V0VGFiYmFibGVJbmRleF0pO1xyXG4gICAgY29uc3QgdXNlTGlzdGJveFNpbmdsZUl0ZW0gPSB1c2VDYWxsYmFjaygoaW5mbykgPT4ge1xyXG4gICAgICAgIGNvbnN0IFtzZWxlY3RlZCwgc2V0U2VsZWN0ZWQsIGdldFNlbGVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgICAgICBjb25zdCB7IHRhYmJhYmxlLCB1c2VMaXN0TmF2aWdhdGlvblNpYmxpbmdQcm9wcywgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzIH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHsgc2V0U2VsZWN0ZWQsIC4uLmluZm8gfSk7XHJcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGluZm8uaW5kZXg7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgdGFiYmFibGUgJiYgc2VsZWN0aW9uTW9kZSA9PSBcImZvY3VzXCIpIHtcclxuICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyB0YXJnZXQ6IGVsZW1lbnQsIGN1cnJlbnRUYXJnZXQ6IGVsZW1lbnQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogaW5kZXggfSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtlbGVtZW50LCB0YWJiYWJsZSwgc2VsZWN0aW9uTW9kZSwgaW5kZXhdKTtcclxuICAgICAgICByZXR1cm4geyB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzLCB0YWJiYWJsZSwgc2VsZWN0ZWQsIGdldFNlbGVjdGVkIH07XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyhwcm9wcykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzKGluZm8udGFnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGluZm8uaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlT25TZWxlY3Q/Lih7IHRhcmdldDogZWxlbWVudCwgY3VycmVudFRhcmdldDogZWxlbWVudCwgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBpbmRleCB9IH0pO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQpKHt9KTtcclxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwib3B0aW9uXCI7XHJcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1zZXRzaXplXCJdID0gKGNoaWxkQ291bnQpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1wb3NpbnNldFwiXSA9IChpbmZvLmluZGV4ICsgMSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXNlbGVjdGVkXCJdID0gc2VsZWN0ZWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VNZXJnZWRQcm9wcygpKG5ld1Byb3BzLCB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsIHNlbGVjdGlvbk1vZGUsIGNoaWxkQ291bnRdKTtcclxuICAgIGNvbnN0IHVzZUxpc3Rib3hTaW5nbGVMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCgpIHtcclxuICAgICAgICBmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcyhwcm9wcykge1xyXG4gICAgICAgICAgICBjb25zdCB7IHVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUdlbmVyaWNMYWJlbExhYmVsKCk7XHJcbiAgICAgICAgICAgIHVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHMocHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcyB9O1xyXG4gICAgfSwgW3VzZUdlbmVyaWNMYWJlbExhYmVsXSk7XHJcbiAgICByZXR1cm4geyB1c2VMaXN0Ym94U2luZ2xlSXRlbSwgdXNlTGlzdGJveFNpbmdsZVByb3BzLCB1c2VMaXN0Ym94U2luZ2xlTGFiZWwsIHRhYmJhYmxlSW5kZXgsIGZvY3VzOiBmb2N1c0N1cnJlbnQsIGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQgfTtcclxuICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVQcm9wcyhwcm9wcykge1xyXG4gICAgICAgIHByb3BzLnJvbGUgPSBcImxpc3Rib3hcIjtcclxuICAgICAgICByZXR1cm4gdXNlSGFzRm9jdXNQcm9wcyh1c2VHZW5lcmljTGFiZWxJbnB1dFByb3BzKHByb3BzKSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWxpc3Rib3gtc2luZ2xlLmpzLm1hcCIsImltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQsIHVzZUhhc0ZvY3VzLCB1c2VMYXlvdXRFZmZlY3QsIHVzZUxpc3ROYXZpZ2F0aW9uLCB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VTb2Z0RGlzbWlzcyB9IGZyb20gXCIuL3VzZS1tb2RhbFwiO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYU1lbnUoeyBjb2xsYXRvciwga2V5TmF2aWdhdGlvbiwgbm9UeXBlYWhlYWQsIG5vV3JhcCwgdHlwZWFoZWFkVGltZW91dCwgLi4uYXJncyB9KSB7XHJcbiAgICBjb25zdCBbZm9jdXNUcmFwQWN0aXZlLCBzZXRGb2N1c1RyYXBBY3RpdmVdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBsZXQgb25DbG9zZSA9IGFyZ3Mub25DbG9zZTtcclxuICAgIGxldCBvbk9wZW4gPSBhcmdzLm9uT3BlbjtcclxuICAgIGxldCBtZW51YmFyID0gYXJncy5tZW51YmFyO1xyXG4gICAgbGV0IG9wZW4gPSAobWVudWJhciA/IHRydWUgOiBhcmdzLm9wZW4pO1xyXG4gICAgY29uc3Qgc3RhYmxlT25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UgPz8gKCgpID0+IHsgfSkpO1xyXG4gICAgLy8gVE9ETzogSXQncyBhd2t3YXJkIHRoYXQgdGhlIGJ1dHRvbiBmb2N1cyBwcm9wcyBhcmUgb3V0IGhlcmUgd2hlcmUgd2UgZG9uJ3QgaGF2ZSBpdHMgdHlwZSxcclxuICAgIC8vIGJ1dCBmb2N1cyBtYW5hZ2VtZW50IGlzIHN1cGVyIHNlbnNpdGl2ZSwgYW5kIGV2ZW4gd2FpdGluZyBmb3IgYSB1c2VMYXlvdXRFZmZlY3QgdG8gc3luYyBzdGF0ZSBoZXJlXHJcbiAgICAvLyB3b3VsZCBiZSB0b28gbGF0ZSwgc28gaXQgd291bGQgbG9vayBsaWtlIHRoZXJlJ3MgYSBtb21lbnQgYmV0d2VlbiBtZW51IGZvY3VzIGxvc3QgYW5kIGJ1dHRvbiBmb2N1cyBnYWluZWRcclxuICAgIC8vIHdoZXJlIG5vdGhpbmcgaXMgZm9jdXNlZC4gXHJcbiAgICBjb25zdCB7IGZvY3VzZWRJbm5lcjogbWVudUhhc0ZvY3VzLCB1c2VIYXNGb2N1c1Byb3BzOiB1c2VNZW51SGFzRm9jdXNQcm9wcywgfSA9IHVzZUhhc0ZvY3VzKCk7XHJcbiAgICBjb25zdCB7IGZvY3VzZWRJbm5lcjogYnV0dG9uSGFzRm9jdXMsIHVzZUhhc0ZvY3VzUHJvcHM6IHVzZUJ1dHRvbkhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzKCk7XHJcbiAgICBjb25zdCB7IGFjdGl2ZUVsZW1lbnQsIGxhc3RBY3RpdmVFbGVtZW50LCB3aW5kb3dGb2N1c2VkIH0gPSB1c2VBY3RpdmVFbGVtZW50KCk7XHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbiwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCwgdGFiYmFibGVJbmRleCwgZm9jdXNDdXJyZW50OiBmb2N1c01lbnUgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uKHsgY29sbGF0b3IsIGtleU5hdmlnYXRpb24sIG5vVHlwZWFoZWFkLCBub1dyYXAsIHR5cGVhaGVhZFRpbWVvdXQsIGZvY3VzT25DaGFuZ2U6IChtZW51SGFzRm9jdXMgfHwgYnV0dG9uSGFzRm9jdXMpIH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VNZW51SWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZU1lbnVJZFJlZmVyZW5jaW5nUHJvcHMgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtbWVudS1cIiB9KTtcclxuICAgIGNvbnN0IFtvcGVuZXJFbGVtZW50LCBzZXRPcGVuZXJFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgeyB1c2VTb2Z0RGlzbWlzc1Byb3BzIH0gPSB1c2VTb2Z0RGlzbWlzcyh7IG9uQ2xvc2U6IHN0YWJsZU9uQ2xvc2UgfSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldEZvY3VzVHJhcEFjdGl2ZShvcGVuKTtcclxuICAgIH0sIFtvcGVuXSk7XHJcbiAgICBjb25zdCBmb2N1c01lbnVTdGFibGUgPSB1c2VTdGFibGVDYWxsYmFjayhmb2N1c01lbnUgPz8gKCgpID0+IHsgfSkpO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoZm9jdXNUcmFwQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGZvY3VzTWVudVN0YWJsZT8uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZvY3VzVHJhcEFjdGl2ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgb3BlbmVyRWxlbWVudD8uZm9jdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG51bGwsIHNvIHdlJ3ZlIG9ubHkganVzdCBtb3VudGVkIGFuZCBzaG91bGRuJ3QgZm9jdXMgb3Vyc2VsdmVzLlxyXG4gICAgICAgIH1cclxuICAgIH0sIFtmb2N1c1RyYXBBY3RpdmVdKTtcclxuICAgIC8vIEZvY3VzIG1hbmFnZW1lbnQgaXMgcmVhbGx5IGZpbmlja3ksIGFuZCB0aGVyZSdzIGFsd2F5cyBnb2luZyB0byBiZSBcclxuICAgIC8vIGFuIGVkZ2UgY2FzZSB3aGVyZSBub3RoaW5nJ3MgZm9jdXNlZCBmb3IgdHdvIGNvbnNlY3V0aXZlIGZyYW1lcyBcclxuICAgIC8vIG9uIGlPUyBvciB3aGF0ZXZlciwgd2hpY2ggd291bGQgaW1tZWRpYXRlbHkgY2xvc2UgdGhlIG1lbnUgXHJcbiAgICAvLyBhbnkgdGltZSBpdCdzIGJlZW4gb3BlbmVkLiBTbyBhbnkgdGltZSBpdCAqbG9va3MqIGxpa2Ugd2Ugc2hvdWxkIGNsb3NlLFxyXG4gICAgLy8gdHJ5IHdhaXRpbmcgMTAwbXMuIElmIGl0J3Mgc3RpbGwgdHJ1ZSB0aGVuLCB0aGVuIHllYWgsIHdlIHNob3VsZCBjbG9zZS5cclxuICAgIGxldCBzaG91bGRDbG9zZSA9IChmb2N1c1RyYXBBY3RpdmUgJiYgd2luZG93Rm9jdXNlZCAmJiAhbWVudUhhc0ZvY3VzICYmICFidXR0b25IYXNGb2N1cyk7XHJcbiAgICB1c2VUaW1lb3V0KHtcclxuICAgICAgICB0aW1lb3V0OiAxMDAsXHJcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHNob3VsZENsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICBvbkNsb3NlPy4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJpZ2dlckluZGV4OiBgJHtzaG91bGRDbG9zZX1gXHJcbiAgICB9KTtcclxuICAgIC8vIEEgbWVudSBzZW50aW5hbCBpcyBhIGhpZGRlbiBidXQgZm9jdXNhYmxlIGVsZW1lbnQgdGhhdCBjb21lcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBlbGVtZW50XHJcbiAgICAvLyB0aGF0LCB3aGVuIGFjdGl2YXRlZCBvciBmb2N1c2VkIG92ZXIsIGNsb3NlcyB0aGUgbWVudS5cclxuICAgIC8vIChpZiBmb2N1c2VkIHdpdGhpbiAxMDBtcyBvZiB0aGUgb3BlbiBwcm9wIGNoYW5naW5nLCBpbnN0ZWFkIG9mXHJcbiAgICAvLyBjbG9zaW5nIHRoZSBtZW51LCBmb2N1c2luZyB0aGUgc2VudGluZWwgaW1tZWRpYXRlbHkgYXNrcyB0aGUgbWVudSB0byBmb2N1cyBpdHNlbGYpLlxyXG4gICAgLy8gVGhpcyBleGlzdHMgYmVjYXVzZSB3aGlsZSBtb3VzZSB1c2VycyBjYW4gY2xpY2sgb3V0IG9mIGEgbWVudVxyXG4gICAgLy8gYW5kIGtleWJvYXJkIHVzZXJzIGNhbiBlc2NhcGUgdG8gY2xvc2UgdGhlIG1lbnUsXHJcbiAgICAvLyBzY3JlZW4gcmVhZGVycyBhbmQgb3RoZXIgaW5wdXQgbWV0aG9kcyB0aGF0IGRvbid0IHVzZSB0aG9zZSB0d28gYmVjb21lIHN0dWNrLlxyXG4gICAgY29uc3QgdXNlTWVudVNlbnRpbmVsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IFtmaXJzdFNlbnRpbmVsSXNBY3RpdmUsIHNldEZpcnN0U2VudGluZWxJc0FjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICAgICAgdXNlVGltZW91dCh7IGNhbGxiYWNrOiAoKSA9PiB7IHNldEZpcnN0U2VudGluZWxJc0FjdGl2ZShvcGVuKTsgfSwgdGltZW91dDogMTAwLCB0cmlnZ2VySW5kZXg6IGAke2ZpcnN0U2VudGluZWxJc0FjdGl2ZX1gIH0pO1xyXG4gICAgICAgIGNvbnN0IG9uRm9jdXMgPSBmaXJzdFNlbnRpbmVsSXNBY3RpdmUgPyAoKCkgPT4gc3RhYmxlT25DbG9zZSgpKSA6ICgoKSA9PiBmb2N1c01lbnU/LigpKTtcclxuICAgICAgICBjb25zdCBvbkNsaWNrID0gKCkgPT4gc3RhYmxlT25DbG9zZSgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZU1lbnVTZW50aW5lbFByb3BzOiBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoeyBvbkZvY3VzLCBvbkNsaWNrIH0sIHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtmb2N1c01lbnUsIG9wZW5dKTtcclxuICAgIGNvbnN0IHVzZU1lbnVCdXR0b24gPSB1c2VDYWxsYmFjaygoeyB0YWcgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgc2V0T3BlbmVyRWxlbWVudChlbGVtZW50KTsgfSwgW2VsZW1lbnRdKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VNZW51QnV0dG9uUHJvcHM6IGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcHJvcHMgPSB1c2VSZWZFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IG9uQ2xpY2s6ICgpID0+IHsgcmV0dXJuIG9wZW4gPyBvbkNsb3NlPy4oKSA6IG9uT3Blbj8uKCk7IH0gfSwgdXNlTWVudUlkUmVmZXJlbmNpbmdQcm9wcyhcImFyaWEtY29udHJvbHNcIikodXNlQnV0dG9uSGFzRm9jdXNQcm9wcyhwKSkpKTtcclxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1oYXNwb3B1cFwiXSA9IFwibWVudVwiO1xyXG4gICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWV4cGFuZGVkXCJdID0gb3BlbiA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtvcGVuLCBvbkNsb3NlLCBvbk9wZW4sIHVzZU1lbnVJZFJlZmVyZW5jaW5nUHJvcHNdKTtcclxuICAgIGNvbnN0IHVzZU1lbnVTdWJtZW51SXRlbSA9IHVzZUNhbGxiYWNrKChhcmdzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VNZW51UHJvcHMsIHVzZU1lbnVCdXR0b24gfSA9IHVzZUFyaWFNZW51KGFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTWVudUJ1dHRvblByb3BzIH0gPSB1c2VNZW51QnV0dG9uKHsgdGFnOiBcImxpXCIgfSk7XHJcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBzZXRPcGVuZXJFbGVtZW50KGVsZW1lbnQpOyB9LCBbZWxlbWVudF0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQsXHJcbiAgICAgICAgICAgIGdldEVsZW1lbnQsXHJcbiAgICAgICAgICAgIHVzZU1lbnVQcm9wcyxcclxuICAgICAgICAgICAgdXNlTWVudVN1Ym1lbnVJdGVtUHJvcHM6IGZ1bmN0aW9uICh7IC4uLnByb3BzIH0pIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcIm1lbnVpdGVtXCI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlUmVmRWxlbWVudFByb3BzKHVzZU1lbnVCdXR0b25Qcm9wcyh1c2VNZW51SWRSZWZlcmVuY2luZ1Byb3BzKFwiYXJpYS1jb250cm9sc1wiKShwcm9wcykpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCB1c2VNZW51SXRlbSA9IHVzZUNhbGxiYWNrKChhcmdzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoYXJncyk7XHJcbiAgICAgICAgLy8gY29uc3QgeyBnZXRTeW5jSGFuZGxlciwgLi4uYXN5bmNJbmZvIH0gPSB1c2VBc3luY0hhbmRsZXI8RT4oKSh7IGNhcHR1cmU6IF8gPT4gdm9pZCAoMCkgfSk7XHJcbiAgICAgICAgLy8gY29uc3Qgb25DbGljayA9IGdldFN5bmNIYW5kbGVyKGFzeW5jSW5mby5wZW5kaW5nID8gbnVsbCA6IChhcmdzLm9uQ2xpY2sgPz8gbnVsbCkpO1xyXG4gICAgICAgIGNvbnN0IG9uQ2xpY2sgPSBhcmdzLm9uQ2xpY2s7XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlTWVudUl0ZW1Qcm9wcyh7IC4uLnByb3BzIH0pIHtcclxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwibWVudWl0ZW1cIjtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoeyBvbkNsaWNrIH0sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1c2VNZW51SXRlbVByb3BzIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCB1c2VNZW51SXRlbUNoZWNrYm94ID0gdXNlQ2FsbGJhY2soKGFyZ3MpID0+IHtcclxuICAgICAgICAvL2NvbnN0IHsgZ2V0U3luY0hhbmRsZXIsIC4uLmFzeW5jSW5mbyB9ID0gdXNlQXN5bmNIYW5kbGVyPEU+KCkoeyBjYXB0dXJlOiBfID0+ICFhcmdzLmNoZWNrZWQgfSk7XHJcbiAgICAgICAgLy9jb25zdCBvbkNsaWNrID0gZ2V0U3luY0hhbmRsZXIoYXN5bmNJbmZvLnBlbmRpbmcgPyBudWxsIDogYXJncy5vbkNoYW5nZSk7XHJcbiAgICAgICAgY29uc3Qgb25DbGljayA9IChlKSA9PiBhcmdzLm9uQ2hhbmdlKGVuaGFuY2VFdmVudChlLCB7IGNoZWNrZWQ6ICFhcmdzLmNoZWNrZWQgfSkpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZU1lbnVJdGVtUHJvcHMoeyAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcIm1lbnVpdGVtY2hlY2tib3hcIjtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoeyBvbkNsaWNrIH0sIHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTWVudUl0ZW1Qcm9wcyB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgZnVuY3Rpb24gdXNlTWVudVByb3BzKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgIHByb3BzLnJvbGUgPSBcIm1lbnVcIjtcclxuICAgICAgICBmdW5jdGlvbiBvbktleURvd24oZSkge1xyXG4gICAgICAgICAgICBpZiAoZS5rZXkgPT0gXCJFc2NhcGVcIiAmJiBvbkNsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVzZU1lbnVJZFByb3BzKHVzZU1lbnVIYXNGb2N1c1Byb3BzKHVzZU1lcmdlZFByb3BzKCkoeyBvbktleURvd24gfSwgdXNlU29mdERpc21pc3NQcm9wcyhwcm9wcykpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZU1lbnVQcm9wcyxcclxuICAgICAgICB1c2VNZW51QnV0dG9uLFxyXG4gICAgICAgIHVzZU1lbnVJdGVtLFxyXG4gICAgICAgIHVzZU1lbnVTZW50aW5lbCxcclxuICAgICAgICB1c2VNZW51SXRlbUNoZWNrYm94LFxyXG4gICAgICAgIHVzZU1lbnVTdWJtZW51SXRlbSxcclxuICAgICAgICBmb2N1c01lbnVcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW1lbnUuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2hpbGRGbGFnLCB1c2VDaGlsZE1hbmFnZXIsIHVzZUhhc0ZvY3VzLCB1c2VMYXlvdXRFZmZlY3QsIHVzZUxpc3ROYXZpZ2F0aW9uLCB1c2VMb2dpY2FsRGlyZWN0aW9uLCB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzIH0gZnJvbSBcIi4vdXNlLWJ1dHRvblwiO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYVRhYnMoeyBzZWxlY3Rpb25Nb2RlLCBzZWxlY3RlZEluZGV4LCBvblNlbGVjdCwgb3JpZW50YXRpb246IGxvZ2ljYWxPcmllbnRhdGlvbiwgLi4uYXJncyB9KSB7XHJcbiAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHM6IHVzZVRhYkxpc3RIYXNGb2N1c1Byb3BzLCBmb2N1c2VkSW5uZXI6IHRhYkxpc3RGb2N1c2VkIH0gPSB1c2VIYXNGb2N1cygpO1xyXG4gICAgY29uc3QgeyBlbGVtZW50OiBsaXN0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICBjb25zdCB7IGdldExvZ2ljYWxEaXJlY3Rpb24sIGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb24gfSA9IHVzZUxvZ2ljYWxEaXJlY3Rpb24obGlzdEVsZW1lbnQpO1xyXG4gICAgY29uc3QgcGh5c2ljYWxPcmllbnRhdGlvbiA9IGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb24obG9naWNhbE9yaWVudGF0aW9uKTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlVGFiTGlzdElkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzOiB1c2VSZWZlcmVuY2VkVGFiTGlzdElkIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLXRhYi1saXN0LVwiIH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VUYWJMYWJlbElkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzOiB1c2VSZWZlcmVuY2VkVGFiTGFiZWxJZCB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS10YWItbGFiZWwtXCIgfSk7XHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZFRhYnMsIG5hdmlnYXRlVG9JbmRleCwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCwgdGFiYmFibGVJbmRleCwgaW52YWxpZFR5cGVhaGVhZCwgY3VycmVudFR5cGVhaGVhZCwgZm9jdXNDdXJyZW50IH0gPSB1c2VMaXN0TmF2aWdhdGlvbih7IC4uLmFyZ3MsIGZvY3VzT25DaGFuZ2U6IHRhYkxpc3RGb2N1c2VkLCBrZXlOYXZpZ2F0aW9uOiBsb2dpY2FsT3JpZW50YXRpb24gfSk7XHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZFBhbmVscywgdXNlTWFuYWdlZENoaWxkOiB1c2VNYW5hZ2VkVGFiUGFuZWwgfSA9IHVzZUNoaWxkTWFuYWdlcigpO1xyXG4gICAgY29uc3Qgc3RhYmxlT25TZWxlY3QgPSB1c2VTdGFibGVDYWxsYmFjayhvblNlbGVjdCk7XHJcbiAgICBjb25zdCBjaGlsZENvdW50ID0gbWFuYWdlZFRhYnMubGVuZ3RoO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBtYW5hZ2VkVGFicylcclxuICAgICAgICAgICAgY2hpbGQuc2V0U2VsZWN0aW9uTW9kZShzZWxlY3Rpb25Nb2RlKTtcclxuICAgIH0sIFtzZWxlY3Rpb25Nb2RlXSk7XHJcbiAgICB1c2VDaGlsZEZsYWcoc2VsZWN0ZWRJbmRleCwgbWFuYWdlZFRhYnMubGVuZ3RoLCAoaSwgc2VsZWN0ZWQpID0+IG1hbmFnZWRUYWJzW2ldPy5zZXRTZWxlY3RlZChzZWxlY3RlZCkpO1xyXG4gICAgdXNlQ2hpbGRGbGFnKHNlbGVjdGVkSW5kZXgsIG1hbmFnZWRQYW5lbHMubGVuZ3RoLCAoaSwgdmlzaWJsZSkgPT4gbWFuYWdlZFBhbmVsc1tpXT8uc2V0VmlzaWJsZSh2aXNpYmxlKSk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKFtwcmV2Q2hpbGRDb3VudCwgcHJldlNlbGVjdGVkSW5kZXhdKSA9PiB7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCAmJiBzZWxlY3Rpb25Nb2RlID09IFwiYWN0aXZhdGVcIikge1xyXG4gICAgICAgICAgICBtYW5hZ2VkUGFuZWxzW3NlbGVjdGVkSW5kZXhdPy5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtjaGlsZENvdW50LCBzZWxlY3RlZEluZGV4LCBzZWxlY3Rpb25Nb2RlXSk7XHJcbiAgICBjb25zdCBnZXRUYWJMaXN0SXNGb2N1c2VkID0gdXNlU3RhYmxlR2V0dGVyKHRhYkxpc3RGb2N1c2VkKTtcclxuICAgIGNvbnN0IHVzZVRhYiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVRhYihpbmZvKSB7XHJcbiAgICAgICAgLy9jb25zdCBbc2VsZWN0ZWRUYWJJZCwgc2V0U2VsZWN0ZWRUYWJJZCwgZ2V0U2VsZWN0ZWRUYWJJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgY29uc3QgW3NlbGVjdGlvbk1vZGVMLCBzZXRTZWxlY3Rpb25Nb2RlTF0gPSB1c2VTdGF0ZShzZWxlY3Rpb25Nb2RlKTtcclxuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgICAgIGNvbnN0IFt0YWJQYW5lbElkLCBzZXRUYWJQYW5lbElkXSA9IHVzZVN0YXRlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VUYWJJZFByb3BzLCBpZDogdGFiSWQsIGdldElkOiBnZXRUYWJJZCB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS10YWItXCIgfSk7XHJcbiAgICAgICAgY29uc3QgW3NlbGVjdGVkLCBzZXRTZWxlY3RlZCwgZ2V0U2VsZWN0ZWRdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICAgICAgY29uc3QgeyB0YWJiYWJsZSwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLCB1c2VMaXN0TmF2aWdhdGlvblNpYmxpbmdQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7IC4uLmluZm8sIHNldFNlbGVjdGVkLCB0YWJJZCwgc2V0VGFiUGFuZWxJZCwgc2V0U2VsZWN0aW9uTW9kZTogc2V0U2VsZWN0aW9uTW9kZUwgfSk7XHJcbiAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VTdGFibGVHZXR0ZXIoaW5mby5pbmRleCk7XHJcbiAgICAgICAgLy8gY29uc3QgeyBnZXRTeW5jSGFuZGxlciwgLi4uYXN5bmNJbmZvIH0gPSB1c2VBc3luY0hhbmRsZXI8RWxlbWVudD4oKSh7IGNhcHR1cmU6IChlOiB1bmtub3duKSA9PiBpbmZvLmluZGV4IH0pO1xyXG4gICAgICAgIC8vIGNvbnN0IG9uU2VsZWN0ID0gZ2V0U3luY0hhbmRsZXIoYXN5bmNJbmZvLnBlbmRpbmc/IG51bGwgOiAoc3RhYmxlQXN5bmNPblNlbGVjdCA/PyBudWxsKSk7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRhYmJhYmxlICYmIHNlbGVjdGlvbk1vZGVMID09IFwiZm9jdXNcIikge1xyXG4gICAgICAgICAgICAgICAgb25TZWxlY3QoeyB0YXJnZXQ6IGVsZW1lbnQsIGN1cnJlbnRUYXJnZXQ6IGVsZW1lbnQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogZ2V0SW5kZXgoKSB9IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW3RhYmJhYmxlLCBzZWxlY3Rpb25Nb2RlTCwgZWxlbWVudF0pO1xyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7IG1hbmFnZWRQYW5lbHNbaW5mby5pbmRleF0/LnNldFRhYklkKHRhYklkKTsgfSwgW3RhYklkLCBpbmZvLmluZGV4XSk7XHJcbiAgICAgICAgLyp1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpXHJcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZFRhYklkKHRhYklkKTtcclxuICAgICAgICB9LCBbc2VsZWN0ZWQsIHRhYklkXSkqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVRhYlByb3BzKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzKGluZm8udGFnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGluZm8uaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgb25TZWxlY3Q/LihlbmhhbmNlRXZlbnQoZSwgeyBzZWxlY3RlZEluZGV4OiBnZXRJbmRleCgpIH0pKTtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkKShwcm9wcyk7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzLnJvbGUgPSBcInRhYlwiO1xyXG4gICAgICAgICAgICBuZXdQcm9wc1tcImFyaWEtc2VsZWN0ZWRcIl0gPSAoc2VsZWN0ZWQgPz8gZmFsc2UpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1jb250cm9sc1wiXSA9IHRhYlBhbmVsSWQ7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHt9LCB1c2VUYWJJZFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VSZWZFbGVtZW50UHJvcHMobmV3UHJvcHMpKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1c2VUYWJQcm9wcywgc2VsZWN0ZWQgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHVzZVRhYlBhbmVsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlUGFuZWwoaW5mbykge1xyXG4gICAgICAgIC8vY29uc3QgW3NlbGVjdGVkVGFiUGFuZWxJZCwgc2V0U2VsZWN0ZWRUYWJQYW5lbElkLCBnZXRTZWxlY3RlZFRhYlBhbmVsSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG4gICAgICAgIGNvbnN0IFtzaG91bGRGb2N1cywgc2V0U2hvdWxkRm9jdXNdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IFt0YWJJZCwgc2V0VGFiSWRdID0gdXNlU3RhdGUodW5kZWZpbmVkKTtcclxuICAgICAgICBjb25zdCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkLCBnZXRTZWxlY3RlZF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUHJvcHM6IHVzZVBhbmVsSWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRQYW5lbElkLCBpZDogdGFiUGFuZWxJZCB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS10YWItcGFuZWwtXCIgfSk7XHJcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCB1c2VNYW5hZ2VkQ2hpbGRQcm9wcyB9ID0gdXNlTWFuYWdlZFRhYlBhbmVsKHsgLi4uaW5mbywgdGFiUGFuZWxJZCwgc2V0VGFiSWQsIGZvY3VzLCBzZXRWaXNpYmxlOiBzZXRTZWxlY3RlZCB9KTtcclxuICAgICAgICBmdW5jdGlvbiBmb2N1cygpIHtcclxuICAgICAgICAgICAgaWYgKGdldFRhYkxpc3RJc0ZvY3VzZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0U2hvdWxkRm9jdXModHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHNob3VsZEZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50Py5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgc2V0U2hvdWxkRm9jdXMoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW2VsZW1lbnQsIHNob3VsZEZvY3VzXSk7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHsgbWFuYWdlZFRhYnNbaW5mby5pbmRleF0/LnNldFRhYlBhbmVsSWQodGFiUGFuZWxJZCk7IH0sIFt0YWJQYW5lbElkLCBpbmZvLmluZGV4XSk7XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlVGFiUGFuZWxQcm9wcyh7IC4uLnByb3BzIH0pIHtcclxuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWxhYmVsbGVkYnlcIl0gPSBtYW5hZ2VkVGFic1tpbmZvLmluZGV4XT8udGFiSWQ7XHJcbiAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcInRhYnBhbmVsXCI7XHJcbiAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID8/PSAtMTsgLy8gTWFrZSBzdXJlIHRoZSB0YWIgcGFuZWwgaXMgdGFiYmFibGUuXHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHt9LCB1c2VQYW5lbElkUHJvcHModXNlTWFuYWdlZENoaWxkUHJvcHMocHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZVRhYlBhbmVsUHJvcHMsIHNlbGVjdGVkIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCB1c2VUYWJzTGlzdCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVRhYkxpc3QoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlVGFiTGlzdFByb3BzKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJ0YWJsaXN0XCI7XHJcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1vcmllbnRhdGlvblwiXSA9IHBoeXNpY2FsT3JpZW50YXRpb247XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VSZWZlcmVuY2VkVGFiTGFiZWxJZChcImFyaWEtbGFiZWxsZWRieVwiKSh1c2VUYWJMaXN0SGFzRm9jdXNQcm9wcyh1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZVRhYkxpc3RQcm9wcyB9O1xyXG4gICAgfSwgW3BoeXNpY2FsT3JpZW50YXRpb25dKTtcclxuICAgIGNvbnN0IHVzZVRhYnNMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVRhYnNMYWJlbCgpIHtcclxuICAgICAgICBmdW5jdGlvbiB1c2VUYWJzTGFiZWxQcm9wcyh7IC4uLnByb3BzIH0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZVRhYkxhYmVsSWRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZVRhYnNMYWJlbFByb3BzIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4geyB1c2VUYWIsIHVzZVRhYlBhbmVsLCB1c2VUYWJzTGlzdCwgdXNlVGFic0xhYmVsLCB0YWJiYWJsZUluZGV4LCBmb2N1c1RhYkxpc3Q6IGZvY3VzQ3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS10YWJzLmpzLm1hcCIsImltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQsIHVzZUNoaWxkRmxhZywgdXNlSGFzRm9jdXMsIHVzZUxpc3ROYXZpZ2F0aW9uLCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VDaGVja2JveExpa2UgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFSYWRpb0dyb3VwKHsgbmFtZSwgc2VsZWN0ZWRWYWx1ZSwgb25JbnB1dCB9KSB7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgY29uc3QgW3NlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXgsIGdldFNlbGVjdGVkSW5kZXhdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBieU5hbWUgPSB1c2VSZWYobmV3IE1hcCgpKTtcclxuICAgIGNvbnN0IHN0YWJsZU9uSW5wdXQgPSB1c2VTdGFibGVDYWxsYmFjayhvbklucHV0KTtcclxuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgbGFzdEZvY3VzZWRJbm5lciB9ID0gdXNlSGFzRm9jdXMoKTtcclxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCBzZXRUYWJiYWJsZUluZGV4LCB0YWJiYWJsZUluZGV4LCBmb2N1c0N1cnJlbnQsIGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uKHsgZm9jdXNPbkNoYW5nZTogbGFzdEZvY3VzZWRJbm5lciB9KTtcclxuICAgIGNvbnN0IHVzZVJhZGlvR3JvdXBQcm9wcyA9IHVzZUNhbGxiYWNrKCh7IC4uLnByb3BzIH0pID0+IHtcclxuICAgICAgICBwcm9wcy5yb2xlID0gXCJyYWRpb2dyb3VwXCI7XHJcbiAgICAgICAgcmV0dXJuIHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VIYXNGb2N1c1Byb3BzKHByb3BzKSk7XHJcbiAgICB9LCBbdXNlSGFzRm9jdXNQcm9wcywgdXNlUmVmRWxlbWVudFByb3BzXSk7XHJcbiAgICB1c2VDaGlsZEZsYWcoc2VsZWN0ZWRJbmRleCwgbWFuYWdlZENoaWxkcmVuLmxlbmd0aCwgKGksIGNoZWNrZWQpID0+IG1hbmFnZWRDaGlsZHJlbltpXT8uc2V0Q2hlY2tlZChjaGVja2VkKSk7XHJcbiAgICBjb25zdCB7IGxhc3RBY3RpdmVFbGVtZW50IH0gPSB1c2VBY3RpdmVFbGVtZW50KCk7XHJcbiAgICBsZXQgYW55UmFkaW9zRm9jdXNlZCA9ICghIWVsZW1lbnQ/LmNvbnRhaW5zKGxhc3RBY3RpdmVFbGVtZW50KSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICghYW55UmFkaW9zRm9jdXNlZCAmJiBzZWxlY3RlZEluZGV4ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoc2VsZWN0ZWRJbmRleCk7XHJcbiAgICB9LCBbYW55UmFkaW9zRm9jdXNlZCwgc2VsZWN0ZWRJbmRleCwgc2V0VGFiYmFibGVJbmRleF0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBsZXQgb2xkSW5kZXggPSBnZXRTZWxlY3RlZEluZGV4KCk7XHJcbiAgICAgICAgbGV0IG5ld0luZGV4ID0gYnlOYW1lLmN1cnJlbnQuZ2V0KHNlbGVjdGVkVmFsdWUpO1xyXG4gICAgICAgIHNldFNlbGVjdGVkSW5kZXgobmV3SW5kZXgpO1xyXG4gICAgfSwgW3NlbGVjdGVkVmFsdWVdKTtcclxuICAgIGNvbnN0IHVzZVJhZGlvID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQXJpYVJhZGlvKHsgdmFsdWUsIGluZGV4LCB0ZXh0LCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgLi4ucmVzdCB9KSB7XHJcbiAgICAgICAgY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IG9uSW5wdXQgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xyXG4gICAgICAgICAgICBzdGFibGVPbklucHV0KGVuaGFuY2VFdmVudChlLCB7IHNlbGVjdGVkVmFsdWU6IHZhbHVlIH0pKTtcclxuICAgICAgICB9LCBbc3RhYmxlT25JbnB1dCwgdmFsdWUsIGluZGV4XSk7XHJcbiAgICAgICAgY29uc3QgeyBnZXRJbnB1dEVsZW1lbnQsIGdldExhYmVsRWxlbWVudCwgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQgfSA9IHVzZUNoZWNrYm94TGlrZSh7IGNoZWNrZWQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCBvbklucHV0LCByb2xlOiBcInJhZGlvXCIgfSk7XHJcbiAgICAgICAgLy9jb25zdCB7fSA9IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCh7ICB9KVxyXG4gICAgICAgIGNvbnN0IGJ5TmFtZTIgPSBieU5hbWUuY3VycmVudDtcclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCghYnlOYW1lMi5oYXModmFsdWUpKTtcclxuICAgICAgICAgICAgYnlOYW1lMi5zZXQodmFsdWUsIGluZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgYnlOYW1lMi5kZWxldGUodmFsdWUpOyB9O1xyXG4gICAgICAgIH0sIFt2YWx1ZSwgaW5kZXhdKTtcclxuICAgICAgICBjb25zdCB7IHRhYmJhYmxlLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsIHVzZUxpc3ROYXZpZ2F0aW9uU2libGluZ1Byb3BzIH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHsgaW5kZXgsIHNldENoZWNrZWQsIHRleHQsIC4uLnJlc3QgfSk7XHJcbiAgICAgICAgY29uc3QgdXNlUmFkaW9JbnB1dCA9ICh7IHRhZyB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZVJhZGlvSW5wdXRQcm9wcyA9IChwcm9wcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PSBcImlucHV0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jaGVja2VkID0gY2hlY2tlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1jaGVja2VkXCJdID0gY2hlY2tlZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50KHsgdGFnIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh1c2VNZXJnZWRQcm9wcygpKHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcygodXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMoe30pKSksIHByb3BzKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1c2VSYWRpb0lucHV0UHJvcHNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHVzZVJhZGlvTGFiZWwgPSB1c2VDYWxsYmFjaygoeyB0YWcgfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VSYWRpb0xhYmVsUHJvcHMgPSAocHJvcHMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCh7IHRhZyB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHt9LCBwcm9wcykpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdXNlUmFkaW9MYWJlbFByb3BzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSwgW3VzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudF0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZVJhZGlvSW5wdXQsXHJcbiAgICAgICAgICAgIHVzZVJhZGlvTGFiZWwsXHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtieU5hbWUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlUmFkaW8sXHJcbiAgICAgICAgdXNlUmFkaW9Hcm91cFByb3BzLFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcclxuICAgICAgICBnZXRJbmRleDogdXNlQ2FsbGJhY2soKHZhbHVlKSA9PiB7IHJldHVybiBieU5hbWUuY3VycmVudC5nZXQodmFsdWUpOyB9LCBbYnlOYW1lXSksXHJcbiAgICAgICAgdGFiYmFibGVJbmRleCxcclxuICAgICAgICBmb2N1c1JhZGlvOiBmb2N1c0N1cnJlbnQsXHJcbiAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcclxuICAgICAgICBpbnZhbGlkVHlwZWFoZWFkXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1yYWRpby1ncm91cC5qcy5tYXAiLCJpbXBvcnQgeyBmaW5kRmlyc3RGb2N1c2FibGUsIHVzZUNoaWxkRmxhZywgdXNlQ2hpbGRNYW5hZ2VyLCB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlVG9hc3RzKHt9KSB7XHJcbiAgICAvLyBcIlBvaW50ZXJcIiB0byB3aGF0ZXZlciBpbmRleCB0b2FzdCBpcyBjdXJyZW50bHkgYmVpbmcgc2hvd24uXHJcbiAgICAvLyBFLmcuIGl0J3MgMCB3aGVuIHRoZSBmaXJzdCB0b2FzdCBpcyBzaG93biwgdGhlbiB3aGVuIGRpc21pc3NlZCwgaXQgYmVjb21lcyAxLlxyXG4gICAgLy8gV2hlbiB0aGUgc2Vjb25kIHRvYXN0IGlzIHNob3duLCBpdCBzdGF5cyBhdCAxIHVudGlsIGRpc21pc3NlZCwgd2hlbiBpdCB0aGVuIGJlY29tZXMgMiwgZXRjLlxyXG4gICAgLy8gQmVjYXVzZSB0b2FzdHMgY2FuIHBvdGVudGlhbGx5IGJlIGRpc21pc3NlZCBvdXQgb2Ygb3JkZXIsIHRoaXMgcmVwcmVzZW50cyB0aGUgXCJvbGRlc3RcIiB0b2FzdCB0aGF0IHN0aWxsIGhhc24ndCBiZWVuIGRpc21pc3NlZCxcclxuICAgIC8vIGV2ZW4gaWYgXCJ5b3VuZ2VyXCIgb25lcyBoYXZlLlxyXG4gICAgY29uc3QgW2FjdGl2ZVRvYXN0SW5kZXgsIHNldEFjdGl2ZVRvYXN0SW5kZXgsIGdldEFjdGl2ZVRvYXN0SW5kZXhdID0gdXNlU3RhdGUoLTEpO1xyXG4gICAgY29uc3QgW3BvbGl0ZW5lc3MsIHNldFBvbGl0ZW5lc3NdID0gdXNlU3RhdGUoXCJwb2xpdGVcIik7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQsIGdldEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgY29uc3QgeyBpbmRpY2VzQnlFbGVtZW50LCBtYW5hZ2VkQ2hpbGRyZW4sIG1vdW50ZWRDaGlsZHJlbjogdG9hc3RRdWV1ZSwgdXNlTWFuYWdlZENoaWxkLCBnZXRNb3VudEluZGV4IH0gPSB1c2VDaGlsZE1hbmFnZXIoKTtcclxuICAgIC8vIEFueSB0aW1lIGEgbmV3IHRvYXN0IG1vdW50cywgdXBkYXRlIG91ciBib3R0b21tb3N0VG9hc3RJbmRleCB0byBwb2ludCB0byBpdCBpZiBuZWNlc3NhcnlcclxuICAgIC8vIChcIm5lY2Vzc2FyeVwiIGp1c3QgbWVhbmluZyBpZiBpdCdzIHRoZSBmaXJzdCB0b2FzdCBldmVyIG9yIGFsbCBwcmlvciB0b2FzdHMgaGF2ZSBiZWVuIGRpc21pc3NlZClcclxuICAgIGNvbnN0IG9uQW55VG9hc3RNb3VudGVkID0gdXNlQ2FsbGJhY2soKGluZGV4KSA9PiB7XHJcbiAgICAgICAgbGV0IGJvdHRvbSA9IGdldEFjdGl2ZVRvYXN0SW5kZXgoKTtcclxuICAgICAgICB3aGlsZSAoYm90dG9tIDwgdG9hc3RRdWV1ZS5sZW5ndGggJiYgKGJvdHRvbSA8IDAgfHwgdG9hc3RRdWV1ZVtib3R0b21dPy5kaXNtaXNzZWQpKSB7XHJcbiAgICAgICAgICAgICsrYm90dG9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRBY3RpdmVUb2FzdEluZGV4KGJvdHRvbSk7XHJcbiAgICB9LCBbc2V0QWN0aXZlVG9hc3RJbmRleF0pO1xyXG4gICAgLy8gQW55IHRpbWUgYSB0b2FzdCBpcyBkaXNtaXNzZWQsIHVwZGF0ZSBvdXIgYm90dG9tbW9zdFRvYXN0SW5kZXggdG8gcG9pbnQgdG8gdGhlIG5leHQgdG9hc3QgaW4gdGhlIHF1ZXVlLCBpZiBvbmUgZXhpc3RzLlxyXG4gICAgY29uc3Qgb25BbnlUb2FzdERpc21pc3NlZCA9IHVzZUNhbGxiYWNrKChpbmRleCkgPT4ge1xyXG4gICAgICAgIGxldCBib3R0b20gPSBnZXRBY3RpdmVUb2FzdEluZGV4KCk7XHJcbiAgICAgICAgd2hpbGUgKGJvdHRvbSA8IHRvYXN0UXVldWUubGVuZ3RoICYmIChib3R0b20gPCAwIHx8IGJvdHRvbSA9PT0gaW5kZXggfHwgdG9hc3RRdWV1ZVtib3R0b21dPy5kaXNtaXNzZWQpKSB7XHJcbiAgICAgICAgICAgICsrYm90dG9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRBY3RpdmVUb2FzdEluZGV4KGJvdHRvbSk7XHJcbiAgICAgICAgaWYgKGdldEVsZW1lbnQoKT8uY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpXHJcbiAgICAgICAgICAgIHRvYXN0UXVldWVbYm90dG9tXT8uZm9jdXMoKTtcclxuICAgIH0sIFtzZXRBY3RpdmVUb2FzdEluZGV4XSk7XHJcbiAgICAvLyBBbnkgdGltZSB0aGUgaW5kZXggcG9pbnRpbmcgdG8gdGhlIGN1cnJlbnRseS1zaG93aW5nIHRvYXN0IGNoYW5nZXMsXHJcbiAgICAvLyB1cGRhdGUgdGhlIHJlbGV2YW50IGNoaWxkcmVuIGFuZCBsZXQgdGhlbSBrbm93IHRoYXQgdGhleSdyZSBub3cgZWl0aGVyIGFjdGl2ZSBvciBkaXNtaXNzZWQuXHJcbiAgICB1c2VDaGlsZEZsYWcoYWN0aXZlVG9hc3RJbmRleCwgdG9hc3RRdWV1ZS5sZW5ndGgsICgoaSwgc2V0KSA9PiB7XHJcbiAgICAgICAgaWYgKHNldClcclxuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoaSA8PSBnZXRBY3RpdmVUb2FzdEluZGV4KCkpO1xyXG4gICAgICAgIHRvYXN0UXVldWVbaV0/LnNldFN0YXR1cyhzZXQgPyBcImFjdGl2ZVwiIDogKGkgPCBnZXRBY3RpdmVUb2FzdEluZGV4KCkgPyBcImRpc21pc3NlZFwiIDogXCJwZW5kaW5nXCIpKTtcclxuICAgIH0pKTtcclxuICAgIGNvbnN0IHVzZVRvYXN0ID0gdXNlQ2FsbGJhY2soKHsgcG9saXRlbmVzcywgdGltZW91dCB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzLCBnZXRTdGF0dXNdID0gdXNlU3RhdGUoXCJwZW5kaW5nXCIpO1xyXG4gICAgICAgIGNvbnN0IGRpc21pc3NlZCA9IChzdGF0dXMgPT09IFwiZGlzbWlzc2VkXCIpO1xyXG4gICAgICAgIGNvbnN0IGRpc21pc3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7IHNldFN0YXR1cyhcImRpc21pc3NlZFwiKTsgfSwgW10pO1xyXG4gICAgICAgIGNvbnN0IHsgcmFuZG9tSWQ6IHRvYXN0SWQgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcInRvYXN0LVwiIH0pO1xyXG4gICAgICAgIC8vY29uc3QgW3RvYXN0SWQsIHNldFRvYXN0SWRdID0gdXNlU3RhdGUoKCkgPT4gZ2VuZXJhdGVSYW5kb21JZChcInRvYXN0LVwiKSk7XHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgc2V0UG9saXRlbmVzcyhwb2xpdGVuZXNzID8/IFwicG9saXRlXCIpOyB9LCBbcG9saXRlbmVzc10pO1xyXG4gICAgICAgIGNvbnN0IGZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RGb2N1c2FibGUgPSBmaW5kRmlyc3RGb2N1c2FibGUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBmaXJzdEZvY3VzYWJsZT8uZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtdKTtcclxuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIHVzZU1hbmFnZWRDaGlsZFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VNYW5hZ2VkQ2hpbGQoeyBkaXNtaXNzZWQsIGluZGV4OiB0b2FzdElkLCBzZXRTdGF0dXMsIGZvY3VzIH0pO1xyXG4gICAgICAgIGNvbnN0IGlzQWN0aXZlID0gKHN0YXR1cyA9PT0gXCJhY3RpdmVcIik7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgb25BbnlUb2FzdE1vdW50ZWQoZ2V0TW91bnRJbmRleCh0b2FzdElkKSk7XHJcbiAgICAgICAgfSwgW10pO1xyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkaXNtaXNzZWQpXHJcbiAgICAgICAgICAgICAgICBvbkFueVRvYXN0RGlzbWlzc2VkKGdldE1vdW50SW5kZXgodG9hc3RJZCkpO1xyXG4gICAgICAgIH0sIFtkaXNtaXNzZWRdKTtcclxuICAgICAgICB1c2VUaW1lb3V0KHtcclxuICAgICAgICAgICAgdGltZW91dCxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0FjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMoXCJkaXNtaXNzZWRcIik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRyaWdnZXJJbmRleDogaXNBY3RpdmVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgICAgIGdldFN0YXR1cyxcclxuICAgICAgICAgICAgZGlzbWlzcyxcclxuICAgICAgICAgICAgdXNlVG9hc3RQcm9wczogZnVuY3Rpb24gKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkodXNlTWFuYWdlZENoaWxkUHJvcHMoe30pLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgZnVuY3Rpb24gdXNlVG9hc3RDb250YWluZXJQcm9wcyh7IHJvbGUsIFwiYXJpYS1saXZlXCI6IGFyaWFMaXZlLCBcImFyaWEtcmVsZXZhbnRcIjogYXJpYVJlbGV2YW50LCAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkodXNlUmVmRWxlbWVudFByb3BzKHsgY2xhc3M6IFwidG9hc3RzLWNvbnRhaW5lclwiLCByb2xlOiBcInN0YXR1c1wiLCBcImFyaWEtbGl2ZVwiOiBwb2xpdGVuZXNzID8/IGFyaWFMaXZlID8/IFwicG9saXRlXCIsIFwiYXJpYS1yZWxldmFudFwiOiBhcmlhUmVsZXZhbnQgPz8gXCJhZGRpdGlvbnNcIiB9KSwgcHJvcHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgdXNlVG9hc3QsIHVzZVRvYXN0Q29udGFpbmVyUHJvcHMgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtdG9hc3RzLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IGZvcndhcmRSZWYsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlVGltZW91dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkRWxlbWVudFJlZihjb21wb25lbnQpIHtcclxuICAgIHJldHVybiBmb3J3YXJkUmVmKGNvbXBvbmVudCk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBzZXVkb0FjdGl2ZSh7IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IGFjdGl2ZSwgLi4ucHJvcHMgfSkge1xyXG4gICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzc05hbWU6IGNsc3goKGFjdGl2ZSA9PSB0cnVlIHx8IGFjdGl2ZSA9PSBcInRydWVcIikgJiYgXCJhY3RpdmVcIikgfSwgcHJvcHMpO1xyXG59XHJcbmNvbnN0IFNwaW5uZXJEZWxheUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KDEwMDApO1xyXG5leHBvcnQgZnVuY3Rpb24gUHJvdmlkZVNwaW5uZXJEZWxheSh7IGNoaWxkcmVuLCB0aW1lb3V0IH0pIHtcclxuICAgIHJldHVybiBoKFNwaW5uZXJEZWxheUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRpbWVvdXQgfSwgY2hpbGRyZW4pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTcGlubmVyRGVsYXkocGVuZGluZywgdGltZW91dCkge1xyXG4gICAgY29uc3QgW3Nob3dTcGlubmVyLCBzZXRTaG93U3Bpbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICghcGVuZGluZykge1xyXG4gICAgICAgICAgICBzZXRTaG93U3Bpbm5lcihmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3BlbmRpbmddKTtcclxuICAgIGNvbnN0IGRlZmF1bHREZWxheSA9IHVzZUNvbnRleHQoU3Bpbm5lckRlbGF5Q29udGV4dCk7XHJcbiAgICB1c2VUaW1lb3V0KHtcclxuICAgICAgICB0aW1lb3V0OiB0aW1lb3V0ID8/IGRlZmF1bHREZWxheSA/PyAxMDAwLFxyXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFNob3dTcGlubmVyKHBlbmRpbmcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJpZ2dlckluZGV4OiBwZW5kaW5nXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzaG93U3Bpbm5lcjtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wcy5qcy5tYXAiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VBcmlhQWNjb3JkaW9uIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHNcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IENvbGxhcHNlIH0gZnJvbSBcInByZWFjdC10cmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4uL3Byb3BzXCI7XHJcbmNvbnN0IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmV4cG9ydCBjb25zdCBBY2NvcmRpb24gPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBBY2NvcmRpb24oeyBleHBhbmRlZEluZGV4LCBzZXRFeHBhbmRlZEluZGV4LCBjaGlsZHJlbiwgLi4ucHJvcHMgfSwgcmVmKSB7XHJcbiAgICBjb25zdCB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uIH0gPSB1c2VBcmlhQWNjb3JkaW9uKHsgZXhwYW5kZWRJbmRleCwgc2V0RXhwYW5kZWRJbmRleCB9KTtcclxuICAgIHJldHVybiAoaChcImRpdlwiLCB7IC4uLnVzZU1lcmdlZFByb3BzKCkoeyByZWYsIGNsYXNzTmFtZTogXCJhY2NvcmRpYW5cIiB9LCBwcm9wcykgfSxcclxuICAgICAgICBoKFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlQXJpYUFjY29yZGlvblNlY3Rpb24gfSwgY2hpbGRyZW4pKSk7XHJcbn0pO1xyXG5leHBvcnQgY29uc3QgQWNjb3JkaW9uU2VjdGlvbiA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEFjY29yZGlvblNlY3Rpb24oeyBpbmRleCwgb3BlbiwgaGVhZGVyLCBoZWFkZXJMZXZlbCwgY2hpbGRyZW4sIFRyYW5zaXRpb24sIC4uLnByb3BzIH0sIHJlZikge1xyXG4gICAgY29uc3QgdXNlQXJpYUFjY29yZGlvblNlY3Rpb24gPSB1c2VDb250ZXh0KFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQ29udGV4dCk7XHJcbiAgICBjb25zdCB7IGV4cGFuZGVkLCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlciwgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5IH0gPSB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbih7IGluZGV4LCBvcGVuIH0pO1xyXG4gICAgY29uc3QgeyB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzIH0gPSB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlcih7IHRhZzogXCJidXR0b25cIiB9KTtcclxuICAgIGNvbnN0IHsgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHMgfSA9IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keSgpO1xyXG4gICAgVHJhbnNpdGlvbiA/Pz0gQ29sbGFwc2U7XHJcbiAgICBoZWFkZXJMZXZlbCA/Pz0gMjtcclxuICAgIGNvbnNvbGUubG9nKGAke2luZGV4fTogJHtleHBhbmRlZD8udG9TdHJpbmcoKX1gKTtcclxuICAgIGNvbnN0IGhlYWRlckJ1dHRvblByb3BzID0gdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcyh7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzOiBjbHN4KFwiYWNjb3JkaW9uLWJ1dHRvblwiLCAhZXhwYW5kZWQgPyBcIiBjb2xsYXBzZWRcIiA6IFwiXCIpIH0pO1xyXG4gICAgY29uc3QgaGVhZGVyUHJvcHMgPSAoeyBjbGFzczogXCJhY2NvcmRpb24taGVhZGVyXCIsIGNoaWxkcmVuOiBoKFwiYnV0dG9uXCIsIHsgLi4uaGVhZGVyQnV0dG9uUHJvcHMgfSwgaGVhZGVyKSB9KTtcclxuICAgIGNvbnN0IGhlYWRlckpzeCA9IGhlYWRlckxldmVsID49IDEgJiYgaGVhZGVyTGV2ZWwgPD0gNiA/IGgoYGgke2hlYWRlckxldmVsfWAsIGhlYWRlclByb3BzKSA6IGgoXCJkaXZcIiwgdXNlTWVyZ2VkUHJvcHMoKShoZWFkZXJQcm9wcywgeyByb2xlOiBcImhlYWRpbmdcIiwgXCJhcmlhLWxldmVsXCI6IGAke2hlYWRlckxldmVsfWAgfSkpO1xyXG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgLi4ueyByZWYsIGNsYXNzOiBcImFjY29yZGlvbi1pdGVtXCIgfSB9LFxyXG4gICAgICAgIGhlYWRlckpzeCxcclxuICAgICAgICBoKFRyYW5zaXRpb24sIHsgb3BlbjogZXhwYW5kZWQsIC4uLnVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzKHVzZU1lcmdlZFByb3BzKCkocHJvcHMsIHsgY2xhc3M6IFwiXCIgfSkpIH0sXHJcbiAgICAgICAgICAgIGgoXCJkaXZcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJhY2NvcmRpb24tYm9keVwiIH0sIGNoaWxkcmVuKSkpKSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2NvcmRpb24uanMubWFwIiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgdXNlU3RhdGUsIHVzZVRpbWVvdXQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBnZXRGcm9tTG9jYWxTdG9yYWdlLCBzdG9yZVRvTG9jYWxTdG9yYWdlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXBlcnNpc3RlbnQtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiwgdXNlU3Bpbm5lckRlbGF5IH0gZnJvbSBcIi4uL3Byb3BzXCI7XHJcbmltcG9ydCB7IEZhZGUgfSBmcm9tIFwicHJlYWN0LXRyYW5zaXRpb24vZmFkZVwiO1xyXG5pbXBvcnQgeyBTd2FwcGFibGUgfSBmcm9tIFwicHJlYWN0LXRyYW5zaXRpb25cIjtcclxuLy8gSXQncyBwb3NzaWJsZSB0byBkbyB0aGlzIGFzIHVzZUVmZmVjdCwgYnV0IGRvaW5nIHNvIHNjcmV3cyB1cCB0aGUgYW5pbWF0aW9uIGluIENocm9tZSBzb21ldGltZXNcclxuLy8gcmVzdW1hYmx5IGJlY2F1c2UgdGhlIG51bWJlciBvZiBlbGVtZW50cyBjaGFuZ2VzLiBcclxuLy8gKGFuZCBpbiByZWFsbHkgd2VpcmQgd2F5cyAtLSBjaGFuZ2luZyB0aGUgYW5pbWF0aW9uIHNwZWVkIGluIHRoZSBjb25zb2xlIGZpeGVzIGl0IHVudGlsIHlvdSBwdXQgaXQgYmFjayBhdCAxMDAlIHNwZWVkPz8/KS5cclxuLy8gQXNzdW1pbmcgdGhhdCdzIHRoZSBjYXNlLCBpdCdzIGVhc2llciB0byBqdXN0IHRha2UgY2FyZSBvZiB0aGUgZWxlbWVudCBjb3VudCBvbiBwYWdlIGxvYWQuXHJcbmxldCBnaW1taWNrQ291bnQgPSA4O1xyXG4oKCkgPT4ge1xyXG4gICAgbGV0IGxhc3RTZXQgPSAoZ2V0RnJvbUxvY2FsU3RvcmFnZSgpKFwiY2lyY3VsYXItcHJvZ3Jlc3MtZ2ltbWljay1sYXN0LXNldFwiLCBzdHIgPT4gbmV3IERhdGUoc3RyKSkgPz8gbmV3IERhdGUoMTk3MCwgMCwgMSkpO1xyXG4gICAgY29uc3QgZGF5c1NpbmNlTGFzdEdpbW1pY2tTZXQgPSBNYXRoLmZsb29yKCgrKG5ldyBEYXRlKCkpIC0gK2xhc3RTZXQpIC8gMTAwMCAvIDYwIC8gNjAgLyAyNCk7XHJcbiAgICBpZiAoZGF5c1NpbmNlTGFzdEdpbW1pY2tTZXQgPiAwKSB7XHJcbiAgICAgICAgbGV0IG5ld0NvdW50ID0gNCArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDIgKyBNYXRoLnJhbmRvbSgpICogMik7XHJcbiAgICAgICAgZ2ltbWlja0NvdW50ID0gbmV3Q291bnQ7XHJcbiAgICAgICAgc3RvcmVUb0xvY2FsU3RvcmFnZSgpKFwiY2lyY3VsYXItcHJvZ3Jlc3MtZ2ltbWljay1sYXN0LXNldFwiLCBuZXcgRGF0ZSgpLCBkID0+IGQudG9JU09TdHJpbmcoKSk7XHJcbiAgICAgICAgc3RvcmVUb0xvY2FsU3RvcmFnZSgpKFwiY2lyY3VsYXItcHJvZ3Jlc3MtZ2ltbWljay1jb3VudFwiLCBnaW1taWNrQ291bnQsIEpTT04uc3RyaW5naWZ5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdpbW1pY2tDb3VudCA9IChnZXRGcm9tTG9jYWxTdG9yYWdlKCkoXCJjaXJjdWxhci1wcm9ncmVzcy1naW1taWNrLWNvdW50XCIsIEpTT04ucGFyc2UpID8/IDgpO1xyXG4gICAgfVxyXG59KSgpO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYVByb2dyZXNzQmFyKHsgdGFnLCBtYXgsIHZhbHVlLCB2YWx1ZVRleHQgfSkge1xyXG4gICAgLy9jb25zdCB7IGlucHV0SWQsIGxhYmVsSWQsIHVzZUdlbmVyaWNMYWJlbElucHV0LCB1c2VHZW5lcmljTGFiZWxMYWJlbCwgdXNlUmVmZXJlbmNlZElucHV0SWRQcm9wcywgdXNlUmVmZXJlbmNlZExhYmVsSWRQcm9wcyB9ID0gdXNlR2VuZXJpY0xhYmVsKHsgaW5wdXRQcmVmaXg6IFwicHJvZ3Jlc3NiYXItXCIsIGxhYmVsUHJlZml4OiBcInByb2dyZXNzYmFyLXJlZmVyZW5jZS1cIiB9KTtcclxuICAgIGNvbnN0IHsgaWQ6IHByb2dyZXNzQmFySWQsIGdldElkLCB1c2VSYW5kb21JZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwicHJvZ3Jlc3NiYXItXCIgfSk7XHJcbiAgICBmdW5jdGlvbiB1c2VQcm9ncmVzc1Byb3BzKHsgXCJhcmlhLXZhbHVlbWF4XCI6IGFyaWFWYWx1ZU1heCwgXCJhcmlhLXZhbHVlbm93XCI6IGFyaWFWYWx1ZU5vdywgXCJhcmlhLXZhbHVldGV4dFwiOiBhcmlhVmFsdWVUZXh0LCByb2xlLCAuLi5wIH0pIHtcclxuICAgICAgICBjb25zdCBleHRyYVByb3BzID0gdGFnID09PSBcInByb2dyZXNzXCIgP1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtYXgsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogKHZhbHVlID8/IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICBcImFyaWEtdmFsdWVtaW5cIjogXCIwXCIsXHJcbiAgICAgICAgICAgICAgICBcImFyaWEtdmFsdWVub3dcIjogdmFsdWUgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGAke3ZhbHVlfWAsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiYXJpYS12YWx1ZW1pblwiOiBcIjBcIixcclxuICAgICAgICAgICAgICAgICAgICBcImFyaWEtdmFsdWVtYXhcIjogbWF4ID09IG51bGwgPyB1bmRlZmluZWQgOiBgJHttYXh9YCxcclxuICAgICAgICAgICAgICAgICAgICBcImFyaWEtdmFsdWV0ZXh0XCI6IHZhbHVlVGV4dCA9PSBudWxsID8gdW5kZWZpbmVkIDogYCR7dmFsdWVUZXh0fWAsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhcmlhLXZhbHVlbm93XCI6IHZhbHVlID09IG51bGwgPyB1bmRlZmluZWQgOiBgJHt2YWx1ZX1gLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwicHJvZ3Jlc3NiYXJcIlxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRQcm9wcyh1c2VNZXJnZWRQcm9wcygpKGV4dHJhUHJvcHMsIHApKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHVzZVJlZmVyZW5jZWRFbGVtZW50ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlUmVmZXJlbmNlZEVsZW1lbnQoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlUmVmZXJlbmNlZFByb3BzKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VSZWZlcmVuY2VkSWRQcm9wcyhcImFyaWEtY29udHJvbHNcIikocHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1c2VSZWZlcmVuY2VkUHJvcHMgfTtcclxuICAgIH0sIFt1c2VSZWZlcmVuY2VkSWRQcm9wc10pO1xyXG4gICAgcmV0dXJuIHsgdXNlUHJvZ3Jlc3NQcm9wcywgdXNlUmVmZXJlbmNlZEVsZW1lbnQgfTtcclxufVxyXG5leHBvcnQgY29uc3QgUHJvZ3Jlc3NBc0NoaWxkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcclxuY29uc3QgUHJvZ3Jlc3NNYXhDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xyXG5jb25zdCBQcm9ncmVzc1ZhbHVlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcclxuY29uc3QgUHJvZ3Jlc3NWYWx1ZVRleHRDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xyXG4vKipcclxuICogQSBwcm9ncmVzcyBiYXIgY2FuIGVpdGhlciB0YWtlIGl0cyB2YWx1ZSAmIG1heCBhcmd1bWVudHMgZGlyZWN0bHksXHJcbiAqIG9yIGhhdmUgdGhlbSBwcm92aWRlZCBieSBhIHBhcmVudCB2aWEgdmFyaW9ucyBDb250ZXh0IG9iamVjdHMuXHJcbiAqXHJcbiAqIFByb3BzIHdpbGwgYmUgcHJpb3JpdGl6ZWQgb3ZlciBjb250ZXh0IGlmIGJvdGggYXJlIGdpdmVuLlxyXG4gKiBAcGFyYW0gcGFyYW0wXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gUHJvZ3Jlc3NMaW5lYXIoeyBjb2xvciwgbWF4OiBtYXhQcm9wLCB2YWx1ZTogdmFsdWVQcm9wLCB2YWx1ZVRleHQ6IHZhbHVlVGV4dFByb3AsIHN0cmlwZWQsIHZhcmlhbnQsIC4uLnJlc3QgfSkge1xyXG4gICAgbGV0IHZhbHVlID0gKHVzZUNvbnRleHQoUHJvZ3Jlc3NWYWx1ZUNvbnRleHQpKTtcclxuICAgIGxldCBtYXggPSB1c2VDb250ZXh0KFByb2dyZXNzTWF4Q29udGV4dCk7XHJcbiAgICBsZXQgdmFsdWVUZXh0ID0gdXNlQ29udGV4dChQcm9ncmVzc1ZhbHVlVGV4dENvbnRleHQpO1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVByb3A7XHJcbiAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgbWF4ID0gbWF4UHJvcDtcclxuICAgIGlmICh2YWx1ZVRleHQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB2YWx1ZVRleHQgPSB2YWx1ZVRleHRQcm9wO1xyXG4gICAgY29uc3QgcHJvdmlkZVBhcmVudFdpdGhIb29rID0gdXNlQ29udGV4dChQcm9ncmVzc0FzQ2hpbGRDb250ZXh0KTtcclxuICAgIGNvbnN0IHsgdXNlUHJvZ3Jlc3NQcm9wcywgdXNlUmVmZXJlbmNlZEVsZW1lbnQgfSA9IHVzZUFyaWFQcm9ncmVzc0Jhcih7IHZhbHVlLCB2YWx1ZVRleHQsIG1heCwgdGFnOiBcInByb2dyZXNzXCIgfSk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBwcm92aWRlUGFyZW50V2l0aEhvb2s/Lih1c2VSZWZlcmVuY2VkRWxlbWVudCk7IH0sIFt1c2VSZWZlcmVuY2VkRWxlbWVudCwgcHJvdmlkZVBhcmVudFdpdGhIb29rXSk7XHJcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyAuLi51c2VNZXJnZWRQcm9wcygpKHsgY2xhc3NOYW1lOiBjbHN4KFwicHJvZ3Jlc3NcIiwgYGJnLSR7Y29sb3IgPz8gXCJwcmltYXJ5XCJ9YCkgfSwgcmVzdCkgfSxcclxuICAgICAgICBoKFwicHJvZ3Jlc3NcIiwgeyAuLi51c2VQcm9ncmVzc1Byb3BzKHsgY2xhc3NOYW1lOiBcInByb2dyZXNzLWJhclwiIH0pIH0pKSk7XHJcbn1cclxuLy8gOilcclxuY29uc3QgUiA9ICgobmV3IERhdGUoKSkuZ2V0RGF0ZSgpICUgMik7XHJcbmZ1bmN0aW9uIENoZWNrKCkge1xyXG4gICAgcmV0dXJuIChoKFwiaVwiLCB7IGNsYXNzOiBcImJpIGJpLWNoZWNrXCIgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIENyb3NzKCkge1xyXG4gICAgcmV0dXJuIChoKFwiaVwiLCB7IGNsYXNzOiBcImJpIGJpLXhcIiB9KSk7XHJcbn1cclxuZnVuY3Rpb24gc2FmZVBhcnNlSW50KHN0cikge1xyXG4gICAgbGV0IHJldCA9IHBhcnNlSW50KHN0cik7XHJcbiAgICBpZiAoIWlzRmluaXRlKHJldCkgfHwgaXNOYU4ocmV0KSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZXhwb3J0IGNvbnN0IFByb2dyZXNzQ2lyY3VsYXIgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiAoeyBsb2FkaW5nTGFiZWwsIHNwaW5uZXJUaW1lb3V0LCBtb2RlLCBjb2xvckZpbGwsIGNoaWxkcmVuUG9zaXRpb24sIGNoaWxkcmVuLCBjb2xvciwgLi4ucCB9LCByZWYpIHtcclxuICAgIGxvYWRpbmdMYWJlbCA/Pz0gXCJPcGVyYXRpb24gcGVuZGluZ1wiO1xyXG4gICAgY29uc3QgeyB1c2VQcm9ncmVzc1Byb3BzLCB1c2VSZWZlcmVuY2VkRWxlbWVudCB9ID0gdXNlQXJpYVByb2dyZXNzQmFyKHsgdmFsdWU6IG51bGwsIHZhbHVlVGV4dDogbG9hZGluZ0xhYmVsLCBtYXg6IDEsIHRhZzogXCJkaXZcIiB9KTtcclxuICAgIC8vdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgcHJvdmlkZVBhcmVudFdpdGhIb29rPy4odXNlUmVmZXJlbmNlZEVsZW1lbnQpIH0sIFt1c2VSZWZlcmVuY2VkRWxlbWVudCwgcHJvdmlkZVBhcmVudFdpdGhIb29rXSlcclxuICAgIGNvbnN0IHsgdXNlUmVmZXJlbmNlZFByb3BzIH0gPSB1c2VSZWZlcmVuY2VkRWxlbWVudCgpO1xyXG4gICAgY29uc3Qgc2hvd1NwaW5uZXIgPSB1c2VTcGlubmVyRGVsYXkobW9kZSA9PT0gXCJwZW5kaW5nXCIsIHNwaW5uZXJUaW1lb3V0KTtcclxuICAgIC8vY29uc3QgW3NwaW5uZXJTaG93Q291bnQsIHNldFNwaW5uZXJTaG93Q291bnRdID0gdXNlU3RhdGUoMCk7XHJcbiAgICAvL3VzZUVmZmVjdCgoKSA9PiB7IHNldFNwaW5uZXJTaG93Q291bnQocyA9PiArK3MpIH0sIFtzaG93U3Bpbm5lcl0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHsgc2V0U2hvd25TdGF0dXNMb25nRW5vdWdoKGZhbHNlKTsgfSwgW21vZGVdKTtcclxuICAgIGNvbnN0IFtzaG93blN0YXR1c0xvbmdFbm91Z2gsIHNldFNob3duU3RhdHVzTG9uZ0Vub3VnaF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICB1c2VUaW1lb3V0KHtcclxuICAgICAgICBjYWxsYmFjazogKCkgPT4geyBpZiAobW9kZSA9PSBcImZhaWxlZFwiIHx8IChtb2RlID09IFwic3VjY2VlZGVkXCIpKVxyXG4gICAgICAgICAgICBzZXRTaG93blN0YXR1c0xvbmdFbm91Z2godHJ1ZSk7IH0sXHJcbiAgICAgICAgdGltZW91dDogMTAwMCxcclxuICAgICAgICB0cmlnZ2VySW5kZXg6IG1vZGVcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcHJvZ3Jlc3NQcm9wcyA9IHVzZVByb2dyZXNzUHJvcHMoeyBcImFyaWEtaGlkZGVuXCI6IGAke21vZGUgIT0gXCJwZW5kaW5nXCJ9YCB9KTtcclxuICAgIGNvbnN0IHByb2dyZXNzRWxlbWVudCA9IChoKFwiZGl2XCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKSh7IHJlZiwgY2xhc3NOYW1lOiBjbHN4KFwiY2lyY3VsYXItcHJvZ3Jlc3MtY29udGFpbmVyXCIpIH0sIHVzZU1lcmdlZFByb3BzKCkocHJvZ3Jlc3NQcm9wcywgcCkpIH0sXHJcbiAgICAgICAgbW9kZSA9PT0gXCJwZW5kaW5nXCIgJiYgISFsb2FkaW5nTGFiZWwgJiYgaChcImRpdlwiLCB7IHJvbGU6IFwiYWxlcnRcIiwgXCJhcmlhLWxpdmVcIjogXCJhc3NlcnRpdmVcIiwgY2xhc3M6IFwidmlzdWFsbHktaGlkZGVuXCIgfSwgbG9hZGluZ0xhYmVsKSxcclxuICAgICAgICBoKFN3YXBwYWJsZSwgbnVsbCxcclxuICAgICAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaXJjdWxhci1wcm9ncmVzcy1zd2FwcGFibGVcIiB9LFxyXG4gICAgICAgICAgICAgICAgaChGYWRlLCB7IG9wZW46IG1vZGUgPT09IFwicGVuZGluZ1wiICYmIHNob3dTcGlubmVyIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IHN0eWxlOiB7IFwiLS1jb3VudFwiOiBnaW1taWNrQ291bnQgfSwgY2xhc3NOYW1lOiBjbHN4KFwiY2lyY3VsYXItcHJvZ3Jlc3NcIiwgY29sb3IgPyBgY2lyY3VsYXItcHJvZ3Jlc3MtJHtjb2xvcn1gIDogdW5kZWZpbmVkLCBjb2xvckZpbGwgPT0gXCJmb3JlZ3JvdW5kXCIgJiYgXCJpbnZlcnNlLWZpbGxcIiwgY29sb3JGaWxsID09PSBcImZvcmVncm91bmQtb25seVwiICYmIFwibm8tZmlsbFwiKSB9LCBBcnJheS5mcm9tKGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2ltbWlja0NvdW50OyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBoKFwiZGl2XCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSgpKSkpLFxyXG4gICAgICAgICAgICAgICAgaChGYWRlLCB7IG9wZW46ICFzaG93blN0YXR1c0xvbmdFbm91Z2ggJiYgbW9kZSA9PT0gXCJzdWNjZWVkZWRcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJjaXJjdWxhci1wcm9ncmVzcy1zdWNjZWVkZWRcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoKENoZWNrLCBudWxsKSkpLFxyXG4gICAgICAgICAgICAgICAgaChGYWRlLCB7IG9wZW46ICFzaG93blN0YXR1c0xvbmdFbm91Z2ggJiYgbW9kZSA9PT0gXCJmYWlsZWRcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJjaXJjdWxhci1wcm9ncmVzcy1mYWlsZWRcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoKENyb3NzLCBudWxsKSkpKSkpKTtcclxuICAgIGNoaWxkcmVuUG9zaXRpb24gPz89IFwiYWZ0ZXJcIjtcclxuICAgIHJldHVybiAoaChGcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBjaGlsZHJlblBvc2l0aW9uID09IFwiYmVmb3JlXCIgJiYgcHJvZ3Jlc3NFbGVtZW50LFxyXG4gICAgICAgIGNoaWxkcmVuICYmIGNyZWF0ZUVsZW1lbnQoY2hpbGRyZW4udHlwZSwgdXNlTWVyZ2VkUHJvcHMoKSh7IGNoaWxkcmVuOiBjaGlsZHJlblBvc2l0aW9uID09PSBcImNoaWxkXCIgPyBwcm9ncmVzc0VsZW1lbnQgOiB1bmRlZmluZWQsIHJlZjogY2hpbGRyZW4ucmVmIH0sIHVzZVJlZmVyZW5jZWRQcm9wcyhjaGlsZHJlbi5wcm9wcykpKSxcclxuICAgICAgICBjaGlsZHJlblBvc2l0aW9uID09IFwiYWZ0ZXJcIiAmJiBwcm9ncmVzc0VsZW1lbnQpKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmVhci5qcy5tYXAiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmV4cG9ydCBjb25zdCBVc2VCdXR0b25Hcm91cENoaWxkID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuY29uc3QgRGVmYXVsdEZpbGxTdHlsZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KFwiZmlsbFwiKTtcclxuY29uc3QgRGVmYXVsdENvbG9yU3R5bGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcInByaW1hcnlcIik7XHJcbmNvbnN0IERlZmF1bHRTaXplQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoXCJtZFwiKTtcclxuY29uc3QgRGVmYXVsdERpc2FibGVkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoZmFsc2UpO1xyXG5leHBvcnQgY29uc3QgUHJvdmlkZURlZmF1bHRCdXR0b25GaWxsID0gbWVtbyhmdW5jdGlvbiBQcm92aWRlRGVmYXVsdEJ1dHRvbkZpbGwoeyB2YWx1ZSwgY2hpbGRyZW4gfSkgeyByZXR1cm4gaChEZWZhdWx0RmlsbFN0eWxlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdmFsdWUgfSwgY2hpbGRyZW4pOyB9KTtcclxuZXhwb3J0IGNvbnN0IFByb3ZpZGVEZWZhdWx0QnV0dG9uQ29sb3IgPSBtZW1vKGZ1bmN0aW9uIFByb3ZpZGVEZWZhdWx0QnV0dG9uQ29sb3IoeyB2YWx1ZSwgY2hpbGRyZW4gfSkgeyByZXR1cm4gaChEZWZhdWx0Q29sb3JTdHlsZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHZhbHVlIH0sIGNoaWxkcmVuKTsgfSk7XHJcbmV4cG9ydCBjb25zdCBQcm92aWRlRGVmYXVsdEJ1dHRvblNpemUgPSBtZW1vKGZ1bmN0aW9uIFByb3ZpZGVEZWZhdWx0QnV0dG9uU2l6ZSh7IHZhbHVlLCBjaGlsZHJlbiB9KSB7IHJldHVybiBoKERlZmF1bHRTaXplQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdmFsdWUgfSwgY2hpbGRyZW4pOyB9KTtcclxuZXhwb3J0IGNvbnN0IFByb3ZpZGVEZWZhdWx0QnV0dG9uRGlzYWJsZWQgPSBtZW1vKGZ1bmN0aW9uIFByb3ZpZGVEZWZhdWx0QnV0dG9uRGlzYWJsZWQoeyB2YWx1ZSwgY2hpbGRyZW4gfSkgeyByZXR1cm4gaChEZWZhdWx0RGlzYWJsZWRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSB9LCBjaGlsZHJlbik7IH0pO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQnV0dG9uRmlsbFZhcmlhbnQocHJvdmlkZWRWYWx1ZSkge1xyXG4gICAgY29uc3QgZGVmYXVsdEZpbGwgPSB1c2VDb250ZXh0KERlZmF1bHRGaWxsU3R5bGVDb250ZXh0KTtcclxuICAgIHJldHVybiBwcm92aWRlZFZhbHVlID8/IGRlZmF1bHRGaWxsO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCdXR0b25Db2xvclZhcmlhbnQocHJvdmlkZWRWYWx1ZSkge1xyXG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gdXNlQ29udGV4dChEZWZhdWx0Q29sb3JTdHlsZUNvbnRleHQpO1xyXG4gICAgcmV0dXJuIHByb3ZpZGVkVmFsdWUgPz8gZGVmYXVsdENvbG9yO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCdXR0b25TaXplKHByb3ZpZGVkVmFsdWUpIHtcclxuICAgIGNvbnN0IGRlZmF1bHRTaXplID0gdXNlQ29udGV4dChEZWZhdWx0U2l6ZUNvbnRleHQpO1xyXG4gICAgcmV0dXJuIHByb3ZpZGVkVmFsdWUgPz8gZGVmYXVsdFNpemU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJ1dHRvbkRpc2FibGVkKHByb3ZpZGVkVmFsdWUpIHtcclxuICAgIGNvbnN0IGRlZmF1bHREaXNhYmxlZCA9IHVzZUNvbnRleHQoRGVmYXVsdERpc2FibGVkQ29udGV4dCk7XHJcbiAgICByZXR1cm4gcHJvdmlkZWRWYWx1ZSA/PyBkZWZhdWx0RGlzYWJsZWQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJ1dHRvblN0eWxlcyhwKSB7XHJcbiAgICBsZXQgeyBjb2xvclZhcmlhbnQsIHNpemUsIGZpbGxWYXJpYW50LCBkaXNhYmxlZCB9ID0gcDtcclxuICAgIGNvbG9yVmFyaWFudCA9IHVzZUJ1dHRvbkNvbG9yVmFyaWFudChjb2xvclZhcmlhbnQpO1xyXG4gICAgc2l6ZSA9IHVzZUJ1dHRvblNpemUoc2l6ZSk7XHJcbiAgICBmaWxsVmFyaWFudCA9IHVzZUJ1dHRvbkZpbGxWYXJpYW50KGZpbGxWYXJpYW50KTtcclxuICAgIGRpc2FibGVkID0gdXNlQnV0dG9uRGlzYWJsZWQoZGlzYWJsZWQpO1xyXG4gICAgY29uc3QgdXNlQnV0dG9uU3R5bGVzUHJvcHMgPSAocHJvcHMpID0+IHVzZU1lcmdlZFByb3BzKCkoeyBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPyBcInRydWVcIiA6IHVuZGVmaW5lZCwgY2xhc3NOYW1lOiBjbHN4KGRpc2FibGVkICYmIFwiZGlzYWJsZWRcIiwgXCJidG5cIiwgYGJ0bi0ke2ZpbGxWYXJpYW50ID09IFwib3V0bGluZVwiID8gYG91dGxpbmUtYCA6IGBgfSR7Y29sb3JWYXJpYW50fWAsIGBidG4tJHtzaXplfWAsIGRpc2FibGVkICYmIFwiZGlzYWJsZWRcIikgfSwgcHJvcHMpO1xyXG4gICAgcmV0dXJuIHsgY29sb3JWYXJpYW50LCBzaXplLCBmaWxsVmFyaWFudCwgZGlzYWJsZWQsIHVzZUJ1dHRvblN0eWxlc1Byb3BzIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdHMuanMubWFwIiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQXJpYUJ1dHRvbiB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1idXR0b25cIjtcclxuaW1wb3J0IHsgdXNlQXN5bmNIYW5kbGVyLCB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IFByb2dyZXNzQ2lyY3VsYXIgfSBmcm9tIFwiLi4vcHJvZ3Jlc3NcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgVXNlQnV0dG9uR3JvdXBDaGlsZCwgdXNlQnV0dG9uU3R5bGVzIH0gZnJvbSBcIi4vZGVmYXVsdHNcIjtcclxuZnVuY3Rpb24gQnV0dG9uUihwLCByZWYpIHtcclxuICAgIGlmIChwLnRhZz8udG9Mb3dlckNhc2UoKSA9PT0gXCJhXCIgfHwgISFwLmhyZWYpXHJcbiAgICAgICAgcmV0dXJuIGgoQW5jaG9yQnV0dG9uLCB7IHJlZjogcmVmLCAuLi5wIH0pO1xyXG4gICAgZWxzZSBpZiAocC5wcmVzc2VkICE9IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIGgoVG9nZ2xlQnV0dG9uLCB7IHJlZjogcmVmLCAuLi5wIH0pO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBoKEJ1dHRvbkJ1dHRvbiwgeyByZWY6IHJlZiwgLi4ucCB9KTtcclxufVxyXG5jb25zdCBBbmNob3JCdXR0b24gPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBBbmNob3JCdXR0b24ocCwgcmVmKSB7XHJcbiAgICBsZXQgeyBjb2xvclZhcmlhbnQsIHNpemUsIGZpbGxWYXJpYW50LCBkaXNhYmxlZCwgLi4ucHJvcHMgfSA9IHA7XHJcbiAgICBjb25zdCBidXR0b25TdHlsZUluZm8gPSB1c2VCdXR0b25TdHlsZXMoeyBjb2xvclZhcmlhbnQsIHNpemUsIGZpbGxWYXJpYW50LCBkaXNhYmxlZCB9KTtcclxuICAgIGRpc2FibGVkID0gYnV0dG9uU3R5bGVJbmZvLmRpc2FibGVkO1xyXG4gICAgY29sb3JWYXJpYW50ID0gYnV0dG9uU3R5bGVJbmZvLmNvbG9yVmFyaWFudDtcclxuICAgIHNpemUgPSBidXR0b25TdHlsZUluZm8uc2l6ZTtcclxuICAgIGZpbGxWYXJpYW50ID0gYnV0dG9uU3R5bGVJbmZvLmZpbGxWYXJpYW50O1xyXG4gICAgY29uc3QgdXNlQnV0dG9uU3R5bGVzUHJvcHMgPSBidXR0b25TdHlsZUluZm8udXNlQnV0dG9uU3R5bGVzUHJvcHM7XHJcbiAgICByZXR1cm4gaChcImFcIiwgeyAuLi4odXNlQnV0dG9uU3R5bGVzUHJvcHMoeyAuLi5wcm9wcywgcmVmIH0pKSB9KTtcclxufSk7XHJcbmNvbnN0IEJ1dHRvbkJ1dHRvbiA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEJ1dHRvbkJ1dHRvbihwLCByZWYpIHtcclxuICAgIGxldCB7IGNvbG9yVmFyaWFudCwgc2l6ZSwgZmlsbFZhcmlhbnQsIGRpc2FibGVkLCBkZWJvdW5jZSwgc2hvd0FzeW5jU3VjY2Vzcywgb25DbGljazogb25DbGlja0FzeW5jLCAuLi5wcm9wcyB9ID0gcDtcclxuICAgIGNvbnN0IHsgZ2V0U3luY0hhbmRsZXIsIHBlbmRpbmcsIHNldHRsZUNvdW50LCBoYXNFcnJvciB9ID0gdXNlQXN5bmNIYW5kbGVyKCkoeyBkZWJvdW5jZSwgY2FwdHVyZTogdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gdW5kZWZpbmVkOyB9LCBbXSkgfSk7XHJcbiAgICBkaXNhYmxlZCB8fD0gcGVuZGluZztcclxuICAgIGNvbnN0IHsgdXNlQXJpYUJ1dHRvblByb3BzIH0gPSB1c2VBcmlhQnV0dG9uKHsgdGFnOiBcImJ1dHRvblwiIH0pO1xyXG4gICAgY29uc3QgYnV0dG9uU3R5bGVJbmZvID0gdXNlQnV0dG9uU3R5bGVzKHsgY29sb3JWYXJpYW50LCBzaXplLCBmaWxsVmFyaWFudCwgZGlzYWJsZWQgfSk7XHJcbiAgICBkaXNhYmxlZCA9IGJ1dHRvblN0eWxlSW5mby5kaXNhYmxlZDtcclxuICAgIGNvbG9yVmFyaWFudCA9IGJ1dHRvblN0eWxlSW5mby5jb2xvclZhcmlhbnQ7XHJcbiAgICBzaXplID0gYnV0dG9uU3R5bGVJbmZvLnNpemU7XHJcbiAgICBmaWxsVmFyaWFudCA9IGJ1dHRvblN0eWxlSW5mby5maWxsVmFyaWFudDtcclxuICAgIGNvbnN0IHVzZUJ1dHRvblN0eWxlc1Byb3BzID0gYnV0dG9uU3R5bGVJbmZvLnVzZUJ1dHRvblN0eWxlc1Byb3BzO1xyXG4gICAgY29uc3Qgb25DbGljayA9IGdldFN5bmNIYW5kbGVyKHBlbmRpbmcgPyBudWxsIDogb25DbGlja0FzeW5jKTtcclxuICAgIHJldHVybiAoaChQcm9ncmVzc0NpcmN1bGFyLCB7IG1vZGU6IGhhc0Vycm9yID8gXCJmYWlsZWRcIiA6IHBlbmRpbmcgPyBcInBlbmRpbmdcIiA6IChzZXR0bGVDb3VudCAmJiBzaG93QXN5bmNTdWNjZXNzKSA/IFwic3VjY2VlZGVkXCIgOiBudWxsLCBjaGlsZHJlblBvc2l0aW9uOiBcImNoaWxkXCIsIGNvbG9yRmlsbDogZmlsbFZhcmlhbnQgPT0gXCJmaWxsXCIgPyBcImZvcmVncm91bmRcIiA6IFwiYmFja2dyb3VuZFwiIH0sXHJcbiAgICAgICAgaChcImJ1dHRvblwiLCB7IC4uLnVzZUFyaWFCdXR0b25Qcm9wcyh1c2VCdXR0b25TdHlsZXNQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHsgY2xhc3NOYW1lOiBjbHN4KHBlbmRpbmcgJiYgXCJwZW5kaW5nIGFjdGl2ZVwiLCBkaXNhYmxlZCAmJiBcImRpc2FibGVkXCIpIH0sIHsgLi4ucHJvcHMsIG9uQ2xpY2ssIHJlZiB9KSkpIH0pKSk7XHJcbn0pO1xyXG5leHBvcnQgY29uc3QgVG9nZ2xlQnV0dG9uID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gVG9nZ2xlQnV0dG9uKHAsIHJlZikge1xyXG4gICAgbGV0IHsgY29sb3JWYXJpYW50LCBzaXplLCBkaXNhYmxlZCwgcHJlc3NlZCwgZGVib3VuY2UsIG9uSW5wdXQ6IG9uUHJlc3NBc3luYywgc2hvd0FzeW5jU3VjY2VzcywgLi4ucHJvcHMgfSA9IHA7XHJcbiAgICBjb25zdCBmaWxsVmFyaWFudCA9IHByZXNzZWQgPyBcImZpbGxcIiA6IFwib3V0bGluZVwiO1xyXG4gICAgY29uc3QgaW5CdXR0b25Hcm91cCA9ICEhdXNlQ29udGV4dChVc2VCdXR0b25Hcm91cENoaWxkKTtcclxuICAgIGNvbnN0IGdldFByZXNzZWQgPSB1c2VTdGFibGVHZXR0ZXIocHJlc3NlZCk7XHJcbiAgICBjb25zdCB7IGdldFN5bmNIYW5kbGVyLCBwZW5kaW5nLCBoYXNFcnJvciwgc2V0dGxlQ291bnQsIGhhc0NhcHR1cmUsIGN1cnJlbnRDYXB0dXJlIH0gPSB1c2VBc3luY0hhbmRsZXIoKSh7IGRlYm91bmNlLCBjYXB0dXJlOiB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiAhZ2V0UHJlc3NlZCgpOyB9LCBbXSkgfSk7XHJcbiAgICBkaXNhYmxlZCB8fD0gcGVuZGluZztcclxuICAgIGlmIChoYXNDYXB0dXJlICYmIHBlbmRpbmcpXHJcbiAgICAgICAgcHJlc3NlZCA9IGN1cnJlbnRDYXB0dXJlO1xyXG4gICAgY29uc3QgeyB1c2VBcmlhQnV0dG9uUHJvcHMgfSA9IHVzZUFyaWFCdXR0b24oeyB0YWc6IFwiYnV0dG9uXCIsIHByZXNzZWQgfSk7XHJcbiAgICBjb25zdCBidXR0b25TdHlsZUluZm8gPSB1c2VCdXR0b25TdHlsZXMoeyBjb2xvclZhcmlhbnQsIHNpemUsIGZpbGxWYXJpYW50LCBkaXNhYmxlZCB9KTtcclxuICAgIGRpc2FibGVkID0gYnV0dG9uU3R5bGVJbmZvLmRpc2FibGVkO1xyXG4gICAgY29sb3JWYXJpYW50ID0gYnV0dG9uU3R5bGVJbmZvLmNvbG9yVmFyaWFudDtcclxuICAgIHNpemUgPSBidXR0b25TdHlsZUluZm8uc2l6ZTtcclxuICAgIGNvbnN0IHVzZUJ1dHRvblN0eWxlc1Byb3BzID0gYnV0dG9uU3R5bGVJbmZvLnVzZUJ1dHRvblN0eWxlc1Byb3BzO1xyXG4gICAgY29uc3Qgb25DbGljayA9IGdldFN5bmNIYW5kbGVyKHBlbmRpbmcgPyBudWxsIDogb25QcmVzc0FzeW5jKTtcclxuICAgIHJldHVybiAoaChQcm9ncmVzc0NpcmN1bGFyLCB7IG1vZGU6IGhhc0Vycm9yID8gXCJmYWlsZWRcIiA6IHBlbmRpbmcgPyBcInBlbmRpbmdcIiA6IChzZXR0bGVDb3VudCAmJiBzaG93QXN5bmNTdWNjZXNzKSA/IFwic3VjY2VlZGVkXCIgOiBudWxsLCBjaGlsZHJlblBvc2l0aW9uOiBcImNoaWxkXCIsIGNvbG9yRmlsbDogZmlsbFZhcmlhbnQgPT0gXCJmaWxsXCIgPyBcImZvcmVncm91bmRcIiA6IFwiYmFja2dyb3VuZFwiIH0sXHJcbiAgICAgICAgaChcImJ1dHRvblwiLCB7IC4uLnVzZUFyaWFCdXR0b25Qcm9wcyh1c2VCdXR0b25TdHlsZXNQcm9wcyh7IC4uLnVzZU1lcmdlZFByb3BzKCkoeyBjbGFzc05hbWU6IGNsc3goXCJ0b2dnbGUtYnV0dG9uXCIsIChwZW5kaW5nIHx8IChpbkJ1dHRvbkdyb3VwICYmIHByZXNzZWQpKSAmJiBcImFjdGl2ZVwiKSwgb25DbGljaywgcmVmIH0sIHByb3BzKSB9KSkgfSkpKTtcclxufSk7XHJcbmV4cG9ydCBjb25zdCBCdXR0b24gPSBmb3J3YXJkRWxlbWVudFJlZihCdXR0b25SKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLmpzLm1hcCIsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUhhc0ZvY3VzLCB1c2VMaXN0TmF2aWdhdGlvbiwgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VCdXR0b25Db2xvclZhcmlhbnQsIHVzZUJ1dHRvbkRpc2FibGVkLCB1c2VCdXR0b25GaWxsVmFyaWFudCwgVXNlQnV0dG9uR3JvdXBDaGlsZCwgdXNlQnV0dG9uU2l6ZSB9IGZyb20gXCIuL2RlZmF1bHRzXCI7XHJcbmltcG9ydCB7IFByb3ZpZGVEZWZhdWx0QnV0dG9uQ29sb3IsIFByb3ZpZGVEZWZhdWx0QnV0dG9uU2l6ZSwgUHJvdmlkZURlZmF1bHRCdXR0b25EaXNhYmxlZCwgUHJvdmlkZURlZmF1bHRCdXR0b25GaWxsIH0gZnJvbSBcIi4vZGVmYXVsdHNcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tIFwiLi9idXR0b25cIjtcclxuZXhwb3J0IGNvbnN0IEJ1dHRvbkdyb3VwID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQnV0dG9uR3JvdXAocCwgcmVmKSB7XHJcbiAgICBjb25zdCB7IGxhc3RGb2N1c2VkSW5uZXIsIHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzKCk7XHJcbiAgICBjb25zdCB7IGluZGljZXNCeUVsZW1lbnQsIG1hbmFnZWRDaGlsZHJlbiwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCwgbmF2aWdhdGVUb0luZGV4LCBjaGlsZENvdW50IH0gPSB1c2VMaXN0TmF2aWdhdGlvbih7IGZvY3VzT25DaGFuZ2U6IGxhc3RGb2N1c2VkSW5uZXIgfSk7XHJcbiAgICAvLyBTdHlsaW5nIHByb3BzXHJcbiAgICBsZXQgeyBjb2xvclZhcmlhbnQsIGZpbGxWYXJpYW50LCBzaXplLCBkaXNhYmxlZCwgc2VsZWN0ZWRJbmRleCwgd3JhcCwgY2hpbGRyZW4sIC4uLnAzIH0gPSBwO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAhPSBudWxsKVxyXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoc2VsZWN0ZWRJbmRleCk7XHJcbiAgICB9LCBbc2VsZWN0ZWRJbmRleF0pO1xyXG4gICAgLy8gQnVpbGQgbmV3IERPTSBwcm9wcyB0byBtZXJnZSBiYXNlZCBvZmYgdGhlIHN0eWxpbmcgcHJvcHNcclxuICAgIGNvbG9yVmFyaWFudCA9IHVzZUJ1dHRvbkNvbG9yVmFyaWFudChjb2xvclZhcmlhbnQpO1xyXG4gICAgc2l6ZSA9IHVzZUJ1dHRvblNpemUoc2l6ZSk7XHJcbiAgICBmaWxsVmFyaWFudCA9IHVzZUJ1dHRvbkZpbGxWYXJpYW50KGZpbGxWYXJpYW50KTtcclxuICAgIGRpc2FibGVkID0gdXNlQnV0dG9uRGlzYWJsZWQoZGlzYWJsZWQpO1xyXG4gICAgY29uc3Qgb3V0ZXJEb21Qcm9wcyA9IHVzZUhhc0ZvY3VzUHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IHJlZiwgcm9sZTogXCJncmlkXCIsIGNsYXNzOiBcImJ0bi1ncm91cC1hcmlhLWdyaWRyb3dcIiB9LCBwMykpO1xyXG4gICAgY29uc3QgaW5uZXJEb21Qcm9wcyA9IHsgcm9sZTogXCJncmlkcm93XCIsIGRpc2FibGVkLCBjbGFzc05hbWU6IGNsc3goXCJidG4tZ3JvdXBcIiwgd3JhcCAmJiBcIndyYXBcIikgfTtcclxuICAgIC8vIFJlbWFpbmluZyBwcm9wcywgZm9yd2FyZGVkIG9udG8gdGhlIERPTVxyXG4gICAgLy9jb25zdCBkb21Qcm9wcyA9bmV3RG9tUHJvcHMsIHAzKSk7XHJcbiAgICBvdXRlckRvbVByb3BzW1wiZGF0YS1jaGlsZC1jb3VudFwiXSA9IGAke2NoaWxkQ291bnR9YDtcclxuICAgIHJldHVybiAoaChVc2VCdXR0b25Hcm91cENoaWxkLlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkIH0sXHJcbiAgICAgICAgaChQcm92aWRlRGVmYXVsdEJ1dHRvbkNvbG9yLCB7IHZhbHVlOiBjb2xvclZhcmlhbnQgfSxcclxuICAgICAgICAgICAgaChQcm92aWRlRGVmYXVsdEJ1dHRvbkZpbGwsIHsgdmFsdWU6IGZpbGxWYXJpYW50IH0sXHJcbiAgICAgICAgICAgICAgICBoKFByb3ZpZGVEZWZhdWx0QnV0dG9uU2l6ZSwgeyB2YWx1ZTogc2l6ZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGgoUHJvdmlkZURlZmF1bHRCdXR0b25EaXNhYmxlZCwgeyB2YWx1ZTogZGlzYWJsZWQgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IC4uLm91dGVyRG9tUHJvcHMgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi5pbm5lckRvbVByb3BzIH0sIGNoaWxkcmVuKSkpKSkpKSk7XHJcbn0pO1xyXG5leHBvcnQgY29uc3QgQnV0dG9uR3JvdXBDaGlsZCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEJ1dHRvbkdyb3VwQ2hpbGQxKHsgaW5kZXgsIC4uLmJ1dHRvblByb3BzIH0sIHJlZikge1xyXG4gICAgLy8gVGhpcyBpcyBtb3JlLW9yLWxlc3MgZm9yY2VkIHRvIGJlIGEgc2VwYXJhdGUgY29tcG9uZW50IGJlY2F1c2Ugb2YgdGhlIGluZGV4IHByb3AuXHJcbiAgICAvLyBJdCB3b3VsZCBiZSByZWFsbHkgbmljZSB0byBmaW5kIGEgd2F5IHRvIG1ha2UgdGhhdCBpbXBsaWNpdCBiYXNlZCBvbiBET00gbG9jYXRpb24sXHJcbiAgICAvLyBzcGVjaWZpY2FsbHkgZm9yIHNtYWxsIHRoaW5ncyBsaWtlIGJ1dHRvbiBncm91cHMuLi5cclxuICAgIGNvbnN0IHVzZUJ1dHRvbkdyb3VwQ2hpbGQgPSB1c2VDb250ZXh0KFVzZUJ1dHRvbkdyb3VwQ2hpbGQpO1xyXG4gICAgY29uc3QgeyB0YWJiYWJsZSwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLCB1c2VMaXN0TmF2aWdhdGlvblNpYmxpbmdQcm9wcyB9ID0gdXNlQnV0dG9uR3JvdXBDaGlsZCh7IGluZGV4LCB0ZXh0OiBudWxsIH0pO1xyXG4gICAgLy8gVE9ETzogSXQncyBraW5kYSBmcmFnaWxlIGhlcmUgaG93IHRoZSBzeW5jIG9uQ2xpY2sgb2YgbGlzdE5hdmlnYXRpb24gXHJcbiAgICAvLyBhbmQgdGhlIGFzeW5jIG9uQ2xpY2sgb2YgYnV0dG9uIGFyZSBtaXhpbmcuXHJcbiAgICBjb25zdCBwID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHsgcmVmLCByb2xlOiBcImdyaWRjZWxsXCIsIC4uLmJ1dHRvblByb3BzIH0pO1xyXG4gICAgcmV0dXJuIGgoQnV0dG9uLCB7IC4uLnAgfSk7XHJcbn0pO1xyXG4oKSA9PiB7XHJcbiAgICBoKEJ1dHRvbkdyb3VwQ2hpbGQsIHsgaW5kZXg6IDAsIHByZXNzZWQ6IHRydWUsIG9uSW5wdXQ6IGIgPT4geyB9IH0pO1xyXG4gICAgaChCdXR0b25Hcm91cENoaWxkLCB7IGluZGV4OiAwLCB0YWc6IFwiYVwiLCBocmVmOiBcIiBcIiB9KTtcclxuICAgIGgoQnV0dG9uR3JvdXBDaGlsZCwgeyBpbmRleDogMCwgb25DbGljazogKG4sIGUpID0+IHsgfSB9KTtcclxuICAgIGgoQnV0dG9uR3JvdXBDaGlsZCwgeyB0YWc6IFwiYnV0dG9uXCIsIGluZGV4OiAwIH0pO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIGgoQnV0dG9uR3JvdXBDaGlsZCwgeyB0YWc6IFwiYnV0dG9uXCIgfSk7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgaChCdXR0b25Hcm91cENoaWxkLCB7IHRhZzogXCJidXR0b25cIiwgaW5kZXg6IDAsIHByZXNzZWQ6IHRydWUsIG9uQ2xpY2s6IGIgPT4geyB9IH0pO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIGgoQnV0dG9uR3JvdXBDaGlsZCwgeyB0YWc6IFwiYVwiLCBpbmRleDogMCwgcHJlc3NlZDogdHJ1ZSwgb25DbGljazogYiA9PiB7IH0gfSk7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgaChCdXR0b25Hcm91cENoaWxkLCB7IHRhZzogXCJhXCIsIGluZGV4OiAwLCBvbkNsaWNrOiBiID0+IHsgfSB9KTtcclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLWdyb3VwLmpzLm1hcCIsImltcG9ydCB7IGdlbmVyYXRlUmFuZG9tSWQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtcmFuZG9tLWlkXCI7XHJcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuY29uc3QgYmFzZUlkID0gZ2VuZXJhdGVSYW5kb21JZChcInJlbmRlci1wb3J0YWwtY29udGFpbmVyLVwiKTtcclxuZXhwb3J0IGZ1bmN0aW9uIEJvZHlQb3J0YWwoeyBjaGlsZHJlbiB9KSB7XHJcbiAgICBjb25zdCBpZCA9IHVzZVJlZihudWxsKTtcclxuICAgIGNvbnN0IFtwb3J0YWxFbGVtZW50LCBzZXRQb3J0YWxFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoaWQuY3VycmVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlkLmN1cnJlbnQgPSBnZW5lcmF0ZVJhbmRvbUlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChiYXNlSWQpO1xyXG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5pZCA9IGJhc2VJZDtcclxuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiYm9keS1wb3J0YWwtY29udGFpbmVyXCI7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZC5jdXJyZW50KTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJib2R5LXBvcnRhbFwiO1xyXG4gICAgICAgICAgICBlbGVtZW50LmlkID0gaWQuY3VycmVudDtcclxuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRQb3J0YWxFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVDaGlsZChlbGVtZW50KTtcclxuICAgIH0sIFtdKTtcclxuICAgIGlmIChwb3J0YWxFbGVtZW50KVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHBvcnRhbEVsZW1lbnQpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IEJvZHlQb3J0YWwgfSBmcm9tIFwiLi4vcG9ydGFsXCI7XHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUFyaWFEaWFsb2cgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0c1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyBGYWRlIH0gZnJvbSBcInByZWFjdC10cmFuc2l0aW9uL2ZhZGVcIjtcclxuaW1wb3J0IFwid2ljZy1pbmVydFwiO1xyXG5leHBvcnQgY29uc3QgRGlhbG9nID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gRGlhbG9nKHsgb25DbG9zZSwgb3BlbiwgZGVzY3JpcHRpdmUsIHRpdGxlLCBmb290ZXIsIFRyYW5zaXRpb24sIGNoaWxkcmVuLCAuLi5yZXN0IH0sIHJlZikge1xyXG4gICAgY29uc3QgeyB1c2VEaWFsb2dCYWNrZHJvcCwgdXNlRGlhbG9nQm9keSwgdXNlRGlhbG9nUHJvcHMsIHVzZURpYWxvZ1RpdGxlIH0gPSB1c2VBcmlhRGlhbG9nKHsgb3Blbiwgb25DbG9zZSB9KTtcclxuICAgIGNvbnN0IHsgdXNlRGlhbG9nQmFja2Ryb3BQcm9wcyB9ID0gdXNlRGlhbG9nQmFja2Ryb3AoKTtcclxuICAgIGNvbnN0IHsgdXNlRGlhbG9nQm9keVByb3BzLCB9ID0gdXNlRGlhbG9nQm9keSh7IGRlc2NyaXB0aXZlIH0pO1xyXG4gICAgY29uc3QgeyB1c2VEaWFsb2dUaXRsZVByb3BzIH0gPSB1c2VEaWFsb2dUaXRsZSgpO1xyXG4gICAgcmV0dXJuIChoKEJvZHlQb3J0YWwsIG51bGwsXHJcbiAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzOiBcIm1vZGFsLXBvcnRhbC1jb250YWluZXJcIiB9LFxyXG4gICAgICAgICAgICBoKEZhZGUsIHsgb3Blbjogb3BlbiB9LFxyXG4gICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IC4uLnVzZURpYWxvZ0JhY2tkcm9wUHJvcHMoeyBjbGFzczogXCJtb2RhbC1iYWNrZHJvcCAgYmFja2Ryb3AtZmlsdGVyLXRyYW5zaXRpb25cIiB9KSB9KSksXHJcbiAgICAgICAgICAgIGgoVHJhbnNpdGlvbiwgeyAuLi57IHJlZiwgb3BlbiwgLi4ucmVzdCB9IH0sXHJcbiAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlRGlhbG9nUHJvcHMoeyBjbGFzczogXCJtb2RhbC1kaWFsb2cgbW9kYWwtZGlhbG9nLXNjcm9sbGFibGVcIiB9KSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJtb2RhbC1jb250ZW50IFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlICE9IG51bGwgJiYgaChcImRpdlwiLCB7IC4uLnVzZURpYWxvZ1RpdGxlUHJvcHMoeyBjbGFzczogXCJtb2RhbC1oZWFkZXJcIiB9KSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaChcImgxXCIsIHsgY2xhc3M6IFwibW9kYWwtdGl0bGVcIiB9LCB0aXRsZSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlRGlhbG9nQm9keVByb3BzKHsgY2xhc3M6IFwibW9kYWwtYm9keVwiIH0pIH0sIGNoaWxkcmVuKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyICE9IG51bGwgJiYgaChcImRpdlwiLCB7IGNsYXNzOiBcIm1vZGFsLWZvb3RlclwiIH0sIGZvb3RlcikpKSkpKSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaWFsb2cuanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgQm9keVBvcnRhbCB9IGZyb20gXCIuLi9wb3J0YWxcIjtcclxuaW1wb3J0IHsgRmFkZSB9IGZyb20gXCJwcmVhY3QtdHJhbnNpdGlvbi9mYWRlXCI7XHJcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gXCIuLi9idXR0b25cIjtcclxuaW1wb3J0IHsgdXNlRHJhd2VyIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWRyYXdlclwiO1xyXG5leHBvcnQgZnVuY3Rpb24gRHJhd2VyKHsgb25DbG9zZSwgb3BlbiwgZGVzY3JpcHRpdmUsIHRpdGxlLCBmb290ZXIsIFRyYW5zaXRpb24sIGNoaWxkcmVuLCAuLi5yZXN0IH0pIHtcclxuICAgIGNvbnN0IHsgdXNlRHJhd2VyQmFja2Ryb3AsIHVzZURyYXdlckJvZHksIHVzZURyYXdlclByb3BzLCB1c2VEcmF3ZXJUaXRsZSB9ID0gdXNlRHJhd2VyKHsgb3Blbiwgb25DbG9zZSB9KTtcclxuICAgIGNvbnN0IHsgdXNlRHJhd2VyQmFja2Ryb3BQcm9wcyB9ID0gdXNlRHJhd2VyQmFja2Ryb3AoKTtcclxuICAgIGNvbnN0IHsgdXNlRHJhd2VyQm9keVByb3BzLCB9ID0gdXNlRHJhd2VyQm9keSh7IGRlc2NyaXB0aXZlIH0pO1xyXG4gICAgY29uc3QgeyB1c2VEcmF3ZXJUaXRsZVByb3BzIH0gPSB1c2VEcmF3ZXJUaXRsZSgpO1xyXG4gICAgcmV0dXJuIChoKEJvZHlQb3J0YWwsIG51bGwsXHJcbiAgICAgICAgaChcImRpdlwiLCBudWxsLFxyXG4gICAgICAgICAgICBoKEZhZGUsIHsgb3Blbjogb3BlbiB9LFxyXG4gICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IC4uLnVzZURyYXdlckJhY2tkcm9wUHJvcHMoeyBjbGFzczogXCJvZmZjYW52YXMtYmFja2Ryb3AgYmFja2Ryb3AtZmlsdGVyLXRyYW5zaXRpb25cIiB9KSB9KSksXHJcbiAgICAgICAgICAgIGgoVHJhbnNpdGlvbiwgeyAuLi57IG9wZW4sIC4uLnJlc3QgfSB9LFxyXG4gICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IC4uLnVzZURyYXdlclByb3BzKHsgY2xhc3M6IFwib2ZmY2FudmFzIG9mZmNhbnZhcy1zdGFydFwiLCB0YWJpbmRleDogLTEgfSkgfSxcclxuICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3M6IFwib2ZmY2FudmFzLWhlYWRlclwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoXCJoNVwiLCB7IC4uLnVzZURyYXdlclRpdGxlUHJvcHMoeyBjbGFzczogXCJvZmZjYW52YXMtdGl0bGVcIiB9KSB9LCBcIkRyYXdlclwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaChCdXR0b24sIHsgdGFnOiBcImJ1dHRvblwiLCBjbGFzczogXCJidG4tY2xvc2UgdGV4dC1yZXNldFwiLCBcImFyaWEtbGFiZWxcIjogXCJDbG9zZVwiLCBvbkNsaWNrOiAoKSA9PiBvbkNsb3NlKFwiZXNjYXBlXCIpIH0pKSxcclxuICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlRHJhd2VyQm9keVByb3BzKHsgY2xhc3M6IFwib2ZmY2FudmFzLWJvZHlcIiB9KSB9LCBjaGlsZHJlbikpKSkpKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmF3ZXIuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmV4cG9ydCBjb25zdCBJbklucHV0R3JvdXBDb250ZXh0ID0gY3JlYXRlQ29udGV4dChmYWxzZSk7XHJcbmV4cG9ydCBjb25zdCBJbklucHV0R3JpZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KDApO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5wdXRDYXB0dXJlcyh0eXBlKSB7XHJcbiAgICBjb25zdCBjYXB0dXJlID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZTtcclxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcjtcclxuICAgICAgICB9XHJcbiAgICB9LCBbdHlwZV0pO1xyXG4gICAgY29uc3QgdW5jYXB0dXJlID0gdXNlQ2FsbGJhY2soKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0eXBlXSk7XHJcbiAgICByZXR1cm4geyBjYXB0dXJlLCB1bmNhcHR1cmUgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wcy5qcy5tYXAiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4uL3Byb3BzXCI7XHJcbmltcG9ydCB7IEluSW5wdXRHcmlkQ29udGV4dCwgSW5JbnB1dEdyb3VwQ29udGV4dCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmV4cG9ydCBjb25zdCBJbnB1dEdyaWQgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBJbnB1dEdyaWQoeyB0YWcsIGNoaWxkcmVuLCAuLi5wcm9wcyB9LCByZWYpIHtcclxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZyA/PyBcImRpdlwiLCB1c2VNZXJnZWRQcm9wcygpKHsgY2xhc3M6IFwiaW5wdXQtZ3JpZFwiLCByZWYgfSwgcHJvcHMpLCBoKEluSW5wdXRHcmlkQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlQ29udGV4dChJbklucHV0R3JpZENvbnRleHQpICsgMSB9LCBjaGlsZHJlbikpO1xyXG59KTtcclxuLyoqXHJcbiAqIEFuIElucHV0R3JvdXAsIHRoYXQgcHV0cyBhbiBJbnB1dCBhbmQgaXRzIExhYmVsIHRvZ2V0aGVyLCB2aXN1YWxseSwgaW50byBvbmUgY29tcG9uZW50LlxyXG4gKlxyXG4gKiBBbGwgSW5wdXQtdHlwZSBjb21wb25lbnRzIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHdoZW4gdGhleSdyZSBpbiBhbiBJbnB1dEdyb3VwIGFuZCByZW5kZXIgZGlmZmVyZW50IGFjY29yZGluZ2x5LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IElucHV0R3JvdXAgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBJbnB1dEdyb3VwKHsgY2hpbGRyZW4sIHRhZywgLi4ucHJvcHMgfSwgcmVmKSB7XHJcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQodGFnID8/IFwiZGl2XCIsIHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzczogXCJpbnB1dC1ncm91cFwiLCByZWYgfSwgcHJvcHMpLCBoKEluSW5wdXRHcm91cENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRydWUgfSwgY2hpbGRyZW4pKSk7XHJcbn0pO1xyXG4vKipcclxuICogTm90IGdlbmVyYWxseSBuZWVkZWQsIHNpbmNlIG1vc3QgaW5wdXQgY29tcG9uZW50cyBjb21lIHdpdGggbGFiZWxzIHRoYXQgZG8gdGhpcyBmb3IgeW91LlxyXG4gKlxyXG4gKiBUaGF0IGJlaW5nIHNhaWQsIGlmIHlvdSBqdXN0IG5lZWQgYSBzdGF0aWMgYmxvY2sgb2YgdGV4dCBub3QgaG9va2VkIHVwIHRvIGFueSBpbnB1dCBlbGVtZW50LCB0aGlzIGlzIHlvdXIgY29tcG9uZW50LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IElucHV0R3JvdXBUZXh0ID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gSW5wdXRHcm91cFRleHQoeyB0YWcsIGNoaWxkcmVuLCBkaXNhYmxlZCwgLi4ucHJvcHMgfSwgcmVmKSB7XHJcbiAgICAvKlxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIGNsb25lRWxlbWVudChjaGlsZHJlbixcclxuICAgICAgICAgICAgICAgIHVzZU1lcmdlZFByb3BzPGFueT4oKSh7IGNsYXNzOiBcImlucHV0LWdyb3VwXCIsIHJlZiB9LCBjaGlsZHJlbi5wcm9wcyksXHJcbiAgICAgICAgICAgICAgICA8SW5JbnB1dEdyb3VwQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dHJ1ZX0+XHJcbiAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgPC9JbklucHV0R3JvdXBDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKTsqL1xyXG4gICAgLypjb25zdCBpbklucHV0R3JpZCA9ICEhdXNlQ29udGV4dChJbklucHV0R3JpZENvbnRleHQpO1xyXG4gICAgaWYgKGluSW5wdXRHcmlkKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSA8ZGl2IGNsYXNzPVwiZm9ybS1jb250cm9sIGZhdXgtZm9ybS1jb250cm9sXCI+e2NoaWxkcmVufTwvZGl2PlxyXG4gICAgfSovXHJcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWcgPz8gXCJkaXZcIiwgdXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzOiBjbHN4KGRpc2FibGVkICYmIFwiZGlzYWJsZWRcIiwgXCJpbnB1dC1ncm91cC10ZXh0XCIpLCByZWYgfSwgcHJvcHMpLCBjaGlsZHJlbik7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnB1dC1ncm91cC5qcy5tYXAiLCJpbXBvcnQgeyBGcmFnbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlSW5wdXRMYWJlbCB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1sYWJlbFwiO1xyXG5pbXBvcnQgeyB1c2VBc3luY0hhbmRsZXIsIHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgUHJvZ3Jlc3NDaXJjdWxhciB9IGZyb20gXCIuLi9wcm9ncmVzc1wiO1xyXG5pbXBvcnQgeyBJbklucHV0R3JvdXBDb250ZXh0LCB1c2VJbnB1dENhcHR1cmVzLCBJbklucHV0R3JpZENvbnRleHQgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyB1c2VIYXNGb2N1cyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmZ1bmN0aW9uIFVubGFiZWxsZWRJbnB1dCh7IHR5cGUsIGRpc2FibGVkLCB2YWx1ZSwgb25JbnB1dDogb25JbnB1dEFzeW5jLCAuLi5wcm9wcyB9KSB7XHJcbiAgICBjb25zdCB7IGNhcHR1cmUsIHVuY2FwdHVyZSB9ID0gdXNlSW5wdXRDYXB0dXJlcyh0eXBlKTtcclxuICAgIGNvbnN0IHsgZm9jdXNlZElubmVyLCB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1cygpO1xyXG4gICAgY29uc3QgeyBnZXRTeW5jSGFuZGxlciwgY3VycmVudENhcHR1cmUsIHBlbmRpbmcsIGhhc0Vycm9yLCBzZXR0bGVDb3VudCwgZmx1c2hEZWJvdW5jZWRQcm9taXNlLCBjdXJyZW50VHlwZSwgLi4uYXN5bmNJbmZvIH0gPSB1c2VBc3luY0hhbmRsZXIoKSh7IGNhcHR1cmUsIGRlYm91bmNlOiAxNTAwIH0pO1xyXG4gICAgY29uc3Qgb25JbnB1dCA9IGdldFN5bmNIYW5kbGVyKGRpc2FibGVkID8gbnVsbCA6IG9uSW5wdXRBc3luYyk7XHJcbiAgICBjb25zdCBhc3luY1N0YXRlID0gKGhhc0Vycm9yID8gXCJmYWlsZWRcIiA6IHBlbmRpbmcgPyBcInBlbmRpbmdcIiA6IHNldHRsZUNvdW50ID8gXCJzdWNjZWVkZWRcIiA6IG51bGwpO1xyXG4gICAgY29uc3Qgb25CbHVyID0gZmx1c2hEZWJvdW5jZWRQcm9taXNlO1xyXG4gICAgcmV0dXJuIChoKFByb2dyZXNzQ2lyY3VsYXIsIHsgc3Bpbm5lclRpbWVvdXQ6IDEwLCBtb2RlOiBjdXJyZW50VHlwZSA9PT0gXCJhc3luY1wiID8gYXN5bmNTdGF0ZSA6IG51bGwsIGNoaWxkcmVuUG9zaXRpb246IFwiYWZ0ZXJcIiwgY29sb3I6IFwiaW5mb1wiIH0sXHJcbiAgICAgICAgaChcImlucHV0XCIsIHsgLi4udXNlSGFzRm9jdXNQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHByb3BzLCB7XHJcbiAgICAgICAgICAgICAgICBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPyBcInRydWVcIiA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiBkaXNhYmxlZCxcclxuICAgICAgICAgICAgICAgIG9uQmx1cixcclxuICAgICAgICAgICAgICAgIGNsYXNzOiBjbHN4KGBmb3JtLWNvbnRyb2xgLCBkaXNhYmxlZCAmJiBcImRpc2FibGVkXCIsIHBlbmRpbmcgJiYgXCJ3aXRoLWVuZC1pY29uXCIpLFxyXG4gICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiAocGVuZGluZyB8fCBmb2N1c2VkSW5uZXIpID8gY3VycmVudENhcHR1cmUgOiB1bmNhcHR1cmUodmFsdWUpLCBvbklucHV0XHJcbiAgICAgICAgICAgIH0pKSB9KSkpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBJbnB1dCh7IGNoaWxkcmVuLCB3aWR0aCwgbGFiZWxQb3NpdGlvbiwgLi4ucHJvcHMgfSkge1xyXG4gICAgbGFiZWxQb3NpdGlvbiA/Pz0gXCJzdGFydFwiO1xyXG4gICAgY29uc3QgeyBpbnB1dElkLCBsYWJlbElkLCB1c2VJbnB1dExhYmVsSW5wdXQsIHVzZUlucHV0TGFiZWxMYWJlbCB9ID0gdXNlSW5wdXRMYWJlbCh7IGlucHV0UHJlZml4OiBcImlucHV0LVwiLCBsYWJlbFByZWZpeDogXCJpbnB1dC1sYWJlbC1cIiB9KTtcclxuICAgIGNvbnN0IHsgdXNlSW5wdXRMYWJlbElucHV0UHJvcHMgfSA9IHVzZUlucHV0TGFiZWxJbnB1dCgpO1xyXG4gICAgY29uc3QgeyB1c2VJbnB1dExhYmVsTGFiZWxQcm9wcyB9ID0gdXNlSW5wdXRMYWJlbExhYmVsKHsgdGFnOiBcImxhYmVsXCIgfSk7XHJcbiAgICBjb25zdCBpc0luSW5wdXRHcm91cCA9IHVzZUNvbnRleHQoSW5JbnB1dEdyb3VwQ29udGV4dCk7XHJcbiAgICBjb25zdCBpc0luSW5wdXRHcmlkID0gdXNlQ29udGV4dChJbklucHV0R3JpZENvbnRleHQpO1xyXG4gICAgbGV0IHN0cmluZ0xhYmVsID0gYCR7Y2hpbGRyZW59YDtcclxuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGxhYmVsUG9zaXRpb24gPT09IFwiaGlkZGVuXCIpIHtcclxuICAgICAgICBpZiAoIVtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0uaW5jbHVkZXModHlwZW9mIGNoaWxkcmVuKSlcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSGlkZGVuIGxhYmVscyByZXF1aXJlIGEgc3RyaW5nLWJhc2VkIGxhYmVsIGZvciB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUuYCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBwcm9wc1tcImFyaWEtbGFiZWxcIl0gPSBzdHJpbmdMYWJlbDtcclxuICAgIH1cclxuICAgIGNvbnN0IGxhYmVsSnN4ID0gaChcImxhYmVsXCIsIHsgLi4udXNlSW5wdXRMYWJlbExhYmVsUHJvcHMoeyBjbGFzczogY2xzeChwcm9wcy5kaXNhYmxlZCAmJiBcImRpc2FibGVkXCIsIGlzSW5JbnB1dEdyb3VwID8gXCJpbnB1dC1ncm91cC10ZXh0XCIgOiBsYWJlbFBvc2l0aW9uICE9IFwiZmxvYXRpbmdcIiA/IFwiZm9ybS1sYWJlbFwiIDogXCJcIikgfSkgfSwgY2hpbGRyZW4pO1xyXG4gICAgbGV0IGlucHV0SnN4ID0gaChVbmxhYmVsbGVkSW5wdXQsIHsgLi4udXNlSW5wdXRMYWJlbElucHV0UHJvcHMocHJvcHMpIH0pO1xyXG4gICAgaWYgKGlzSW5JbnB1dEdyaWQpIHtcclxuICAgICAgICBpbnB1dEpzeCA9IGgoXCJkaXZcIiwgeyBjbGFzczogXCJmb3JtLWNvbnRyb2wgZmF1eC1mb3JtLWNvbnRyb2xcIiwgc3R5bGU6IHdpZHRoPy5lbmRzV2l0aChcImNoXCIpID8geyBcIi0tZm9ybS1jb250cm9sLXdpZHRoXCI6ICh3aWR0aCA/PyBcIjIwY2hcIikgfSA6IHdpZHRoID8geyB3aWR0aCB9IDogdW5kZWZpbmVkIH0sIGlucHV0SnN4KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGlucHV0V2l0aExhYmVsID0gKGgoRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgbGFiZWxQb3NpdGlvbiA9PT0gXCJzdGFydFwiICYmIGxhYmVsSnN4LFxyXG4gICAgICAgIGlucHV0SnN4LFxyXG4gICAgICAgIChsYWJlbFBvc2l0aW9uID09PSBcImVuZFwiIHx8IGxhYmVsUG9zaXRpb24gPT0gXCJmbG9hdGluZ1wiKSAmJiBsYWJlbEpzeCkpO1xyXG4gICAgaWYgKGxhYmVsUG9zaXRpb24gIT09IFwiZmxvYXRpbmdcIilcclxuICAgICAgICByZXR1cm4gaW5wdXRXaXRoTGFiZWw7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGgoXCJkaXZcIiwgeyBjbGFzczogXCJmb3JtLWZsb2F0aW5nXCIgfSwgaW5wdXRKc3gpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0LXRleHQuanMubWFwIiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUFyaWFDaGVja2JveCwgdXNlQ2hlY2tib3hHcm91cCB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzXCI7XHJcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHMvcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQXN5bmNIYW5kbGVyLCB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBQcm9ncmVzc0NpcmN1bGFyIH0gZnJvbSBcIi4uL3Byb2dyZXNzL2xpbmVhclwiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyBJbnB1dEdyb3VwVGV4dCB9IGZyb20gXCIuL2lucHV0LWdyb3VwXCI7XHJcbmltcG9ydCB7IEluSW5wdXRHcmlkQ29udGV4dCwgSW5JbnB1dEdyb3VwQ29udGV4dCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmZ1bmN0aW9uIGNhcHR1cmUoZSkge1xyXG4gICAgcmV0dXJuIGVbRXZlbnREZXRhaWxdLmNoZWNrZWQ7XHJcbn1cclxuLyoqXHJcbiAqIFRPRE86IFdoZW4gaW5zaWRlIGFuIElucHV0R3JvdXAsIENoZWNrYm94ZXMgZG9uJ3QgZm9yd2FyZCBhbnkgcHJvcGVydGllcyBvciByZWZzIGJlY2F1c2UgdGhlcmUncyBubyBvbmUgRE9NIGVsZW1lbnQgdG8gYXR0YWNoIHRvLlxyXG4gKlxyXG4gKiBQcm9iYWJseSBuZWVkIHNlcGFyYXRlIGBpbnB1dFJlZmAgJiBgbGFiZWxSZWZgIHByb3BlcnRpZXMgZm9yIHRoYXQsXHJcbiAqIGJ1dCBnaXZlbiB0aGVyZSdzIGFsc28gbm8gZWFzeSB3YXkgdG8gZm9yd2FyZCBwcm9wcyB0byBqdXN0IHRoZW0gYSBzb2x1dGlvbiBsaWtlIHRoYXQgZmVlbHMgaW5jb21wbGV0ZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBDaGVja2JveCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENoZWNrYm94KHsgY2hlY2tlZCwgZGlzYWJsZWQsIG9uSW5wdXQ6IG9uSW5wdXRBc3luYywgbGFiZWxQb3NpdGlvbiwgY2hpbGRyZW46IGxhYmVsLCAuLi5wcm9wcyB9LCByZWYpIHtcclxuICAgIGxhYmVsUG9zaXRpb24gPz89IFwiZW5kXCI7XHJcbiAgICBjb25zdCB7IGdldFN5bmNIYW5kbGVyLCBwZW5kaW5nLCBoYXNFcnJvciwgc2V0dGxlQ291bnQsIGhhc0NhcHR1cmUsIGN1cnJlbnRDYXB0dXJlLCBjdXJyZW50VHlwZSB9ID0gdXNlQXN5bmNIYW5kbGVyKCkoeyBjYXB0dXJlIH0pO1xyXG4gICAgZGlzYWJsZWQgfHw9IHBlbmRpbmc7XHJcbiAgICBjb25zdCBvbklucHV0ID0gZ2V0U3luY0hhbmRsZXIob25JbnB1dEFzeW5jKTtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50IH0gPSB1c2VBcmlhQ2hlY2tib3goeyBjaGVja2VkOiBwZW5kaW5nID8gY3VycmVudENhcHR1cmUgOiAoY2hlY2tlZCA9PT0gXCJpbmRldGVybWluYXRlXCIgPyBcIm1peGVkXCIgOiBjaGVja2VkKSwgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlLCBvbklucHV0LCBsYWJlbFBvc2l0aW9uOiBcInNlcGFyYXRlXCIgfSk7XHJcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KHsgdGFnOiBcImlucHV0XCIgfSk7XHJcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KHsgdGFnOiBcImxhYmVsXCIgfSk7XHJcbiAgICBjb25zdCBpbklucHV0R3JvdXAgPSB1c2VDb250ZXh0KEluSW5wdXRHcm91cENvbnRleHQpO1xyXG4gICAgbGV0IHN0cmluZ0xhYmVsID0gYCR7bGFiZWx9YDtcclxuICAgIGlmIChsYWJlbCAhPSBudWxsICYmIGxhYmVsUG9zaXRpb24gPT09IFwiaGlkZGVuXCIgJiYgIVtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0uaW5jbHVkZXModHlwZW9mIGxhYmVsKSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEhpZGRlbiBsYWJlbHMgcmVxdWlyZSBhIHN0cmluZy1iYXNlZCBsYWJlbCBmb3IgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXN5bmNTdGF0ZSA9IChoYXNFcnJvciA/IFwiZmFpbGVkXCIgOiBwZW5kaW5nID8gXCJwZW5kaW5nXCIgOiBzZXR0bGVDb3VudCA/IFwic3VjY2VlZGVkXCIgOiBudWxsKTtcclxuICAgIGNvbnN0IHAgPSB1c2VNZXJnZWRQcm9wcygpKHByb3BzLCB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKHsgcmVmLCB0eXBlOiBcImNoZWNrYm94XCIsIGNsYXNzTmFtZTogY2xzeChcImZvcm0tY2hlY2staW5wdXRcIiwgcGVuZGluZyAmJiBcInBlbmRpbmdcIiwgZGlzYWJsZWQgJiYgXCJkaXNhYmxlZFwiLCBpbklucHV0R3JvdXAgJiYgXCJtdC0wXCIpLCBcImFyaWEtbGFiZWxcIjogbGFiZWxQb3NpdGlvbiA9PT0gXCJoaWRkZW5cIiA/IHN0cmluZ0xhYmVsIDogdW5kZWZpbmVkIH0pKTtcclxuICAgIGNvbnN0IGlucHV0RWxlbWVudCA9IGgoT3B0aW9uYWxseUlucHV0R3JvdXAsIHsgaXNJbnB1dDogdHJ1ZSwgdGFnOiBpbklucHV0R3JvdXAgPyBcImxhYmVsXCIgOiBudWxsLCB0YWJJbmRleDogLTEsIGRpc2FibGVkOiBkaXNhYmxlZCB9LFxyXG4gICAgICAgIGgoUHJvZ3Jlc3NDaXJjdWxhciwgeyBjaGlsZHJlblBvc2l0aW9uOiBcImFmdGVyXCIsIGNvbG9yRmlsbDogXCJmb3JlZ3JvdW5kLW9ubHlcIiwgbW9kZTogY3VycmVudFR5cGUgPT09IFwiYXN5bmNcIiA/IGFzeW5jU3RhdGUgOiBudWxsLCBjb2xvcjogXCJpbmZvXCIgfSxcclxuICAgICAgICAgICAgaChcImlucHV0XCIsIHsgLi4ucCB9KSkpO1xyXG4gICAgY29uc3QgbGFiZWxFbGVtZW50ID0gaChGcmFnbWVudCwgbnVsbCwgbGFiZWwgIT0gbnVsbCAmJiBoKE9wdGlvbmFsbHlJbnB1dEdyb3VwLCB7IGlzSW5wdXQ6IGZhbHNlLCB0YWc6IFwibGFiZWxcIiwgLi4udXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyh7IGNsYXNzTmFtZTogY2xzeChwZW5kaW5nICYmIFwicGVuZGluZ1wiLCBkaXNhYmxlZCAmJiBcImRpc2FibGVkXCIsIFwiZm9ybS1jaGVjay1sYWJlbFwiKSwgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9KSB9LCBsYWJlbCkpO1xyXG4gICAgY29uc3QgcmV0ID0gKGgoRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgbGFiZWxQb3NpdGlvbiA9PSBcInN0YXJ0XCIgJiYgbGFiZWxFbGVtZW50LFxyXG4gICAgICAgIGlucHV0RWxlbWVudCxcclxuICAgICAgICBsYWJlbFBvc2l0aW9uID09IFwiZW5kXCIgJiYgbGFiZWxFbGVtZW50KSk7XHJcbiAgICBpZiAoIWluSW5wdXRHcm91cClcclxuICAgICAgICByZXR1cm4gaChcImRpdlwiLCB7IC4uLnVzZU1lcmdlZFByb3BzKCkoe30sIHsgY2xhc3M6IFwiZm9ybS1jaGVja1wiIH0pIH0sIHJldCk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59KTtcclxuY29uc3QgQ2hlY2tib3hHcm91cFBhcmVudENoZWNrYm94UHJvcHNDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuY29uc3QgQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmV4cG9ydCBmdW5jdGlvbiBDaGVja2JveEdyb3VwKHsgY2hpbGRyZW4gfSkge1xyXG4gICAgY29uc3QgeyBwZXJjZW50Q2hlY2tlZCwgc2VsZklzQ2hlY2tlZCwgb25DaGVja2JveEdyb3VwSW5wdXQsIHVzZUNoZWNrYm94R3JvdXBDaGVja2JveFByb3BzLCB1c2VDaGVja2JveEdyb3VwQ2hpbGQgfSA9IHVzZUNoZWNrYm94R3JvdXAoe30pO1xyXG4gICAgcmV0dXJuIChoKEZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIGgoQ2hlY2tib3hHcm91cFBhcmVudENoZWNrYm94UHJvcHNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VDaGVja2JveEdyb3VwQ2hlY2tib3hQcm9wcyB9LFxyXG4gICAgICAgICAgICBoKENoZWNrYm94LCB7IGNsYXNzTmFtZTogXCJjaGVja2JveC1ncm91cC1wYXJlbnRcIiwgY2hlY2tlZDogc2VsZklzQ2hlY2tlZCwgb25JbnB1dDogdXNlQ2FsbGJhY2soKGNoZWNrZWQsIGUpID0+IHsgb25DaGVja2JveEdyb3VwSW5wdXQoZSk7IH0sIFtvbkNoZWNrYm94R3JvdXBJbnB1dF0pIH0pKSxcclxuICAgICAgICBoKENoZWNrYm94R3JvdXBDaGlsZENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHVzZUNoZWNrYm94R3JvdXBDaGlsZCB9LCBjaGlsZHJlbikpKTtcclxufVxyXG47XHJcbmV4cG9ydCBmdW5jdGlvbiBPcHRpb25hbGx5SW5wdXRHcm91cCh7IHRhZywgY2hpbGRyZW4sIGlzSW5wdXQsIC4uLnByb3BzIH0pIHtcclxuICAgIGNvbnN0IGluSW5wdXRHcm91cCA9IHVzZUNvbnRleHQoSW5JbnB1dEdyb3VwQ29udGV4dCk7XHJcbiAgICBjb25zdCBpbklucHV0R3JpZCA9ICEhdXNlQ29udGV4dChJbklucHV0R3JpZENvbnRleHQpO1xyXG4gICAgaWYgKCFpbklucHV0R3JvdXApXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnID8/IEZyYWdtZW50LCBwcm9wcywgY2hpbGRyZW4pO1xyXG4gICAgLy8gSWYgd2UncmUgaW4gYW4gSW5wdXRHcmlkJ3MgSW5wdXRHcm91cCwgdGhlbiBjcmVhdGUgYSBcclxuICAgIC8vIG5ldyBjaGlsZCB0aGF0J3MsIENTUy13aXNlLCB0aGUgXCJ0cnVlXCIgaW5wdXQuXHJcbiAgICAvLyBUaGUgb3RoZXIgb25lIGlzIHVzZWQgZm9yIGl0cyBib3JkZXIgc3R5bGVzIGFuZCByZWxhdGl2ZSBwb3NpdGlvbmluZy5cclxuICAgIGlmIChpbklucHV0R3JpZCAmJiBpc0lucHV0KVxyXG4gICAgICAgIGNoaWxkcmVuID0gaChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJpbnB1dC1ncm91cC10ZXh0XCIgfSwgY2hpbGRyZW4pO1xyXG4gICAgcmV0dXJuIGgoSW5wdXRHcm91cFRleHQsIHsgdGFnOiB0YWcgPz8gXCJkaXZcIiwgLi4udXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzTmFtZTogY2xzeChpc0lucHV0ICYmIGluSW5wdXRHcmlkICYmIFwiZmF1eC1pbnB1dC1ncm91cC10ZXh0XCIpIH0sIHByb3BzKSB9LCBjaGlsZHJlbik7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5wdXQtY2hlY2suanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUFyaWFDaGVja2JveCB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzXCI7XHJcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHMvcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQXN5bmNIYW5kbGVyLCB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEluSW5wdXRHcmlkQ29udGV4dCwgSW5JbnB1dEdyb3VwQ29udGV4dCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IFByb2dyZXNzQ2lyY3VsYXIgfSBmcm9tIFwiLi4vcHJvZ3Jlc3MvbGluZWFyXCI7XHJcbmltcG9ydCB7IElucHV0R3JvdXBUZXh0IH0gZnJvbSBcIi4vaW5wdXQtZ3JvdXBcIjtcclxuLyoqXHJcbiAqIEBzZWUgQ2hlY2tib3hcclxuICogQHBhcmFtIHJlZlxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFN3aXRjaCh7IGNoZWNrZWQsIGRpc2FibGVkLCBvbklucHV0OiBvbklucHV0QXN5bmMsIGNoaWxkcmVuOiBsYWJlbCwgbGFiZWxQb3NpdGlvbiwgLi4ucmVzdCB9LCByZWYpIHtcclxuICAgIGxhYmVsUG9zaXRpb24gPz89IFwiZW5kXCI7XHJcbiAgICBjb25zdCB7IGdldFN5bmNIYW5kbGVyLCBwZW5kaW5nLCBjdXJyZW50VHlwZSwgaGFzRXJyb3IsIHNldHRsZUNvdW50LCBjdXJyZW50Q2FwdHVyZSB9ID0gdXNlQXN5bmNIYW5kbGVyKCkoeyBjYXB0dXJlOiAoZSkgPT4gZVtFdmVudERldGFpbF0uY2hlY2tlZCB9KTtcclxuICAgIGNvbnN0IGFzeW5jU3RhdGUgPSAoaGFzRXJyb3IgPyBcImZhaWxlZFwiIDogcGVuZGluZyA/IFwicGVuZGluZ1wiIDogc2V0dGxlQ291bnQgPyBcInN1Y2NlZWRlZFwiIDogbnVsbCk7XHJcbiAgICBkaXNhYmxlZCB8fD0gcGVuZGluZztcclxuICAgIGNvbnN0IG9uSW5wdXQgPSBnZXRTeW5jSGFuZGxlcihvbklucHV0QXN5bmMpO1xyXG4gICAgY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudDogdXNlU3dpdGNoSW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExhYmVsRWxlbWVudDogdXNlU3dpdGNoTGFiZWxFbGVtZW50IH0gPSB1c2VBcmlhQ2hlY2tib3goeyBjaGVja2VkOiBwZW5kaW5nID8gY3VycmVudENhcHR1cmUgOiBjaGVja2VkLCBkaXNhYmxlZDogZGlzYWJsZWQgPz8gZmFsc2UsIG9uSW5wdXQsIGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIiB9KTtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wczogdXNlU3dpdGNoSW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZVN3aXRjaElucHV0RWxlbWVudCh7IHRhZzogXCJpbnB1dFwiIH0pO1xyXG4gICAgY29uc3QgeyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzOiB1c2VTd2l0Y2hMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlU3dpdGNoTGFiZWxFbGVtZW50KHsgdGFnOiBcImxhYmVsXCIgfSk7XHJcbiAgICBjb25zdCBpbklucHV0R3JvdXAgPSB1c2VDb250ZXh0KEluSW5wdXRHcm91cENvbnRleHQpO1xyXG4gICAgbGV0IHN0cmluZ0xhYmVsID0gYCR7bGFiZWx9YDtcclxuICAgIGlmIChsYWJlbCAhPSBudWxsICYmIGxhYmVsUG9zaXRpb24gPT09IFwiaGlkZGVuXCIgJiYgIVtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0uaW5jbHVkZXModHlwZW9mIGxhYmVsKSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEhpZGRlbiBsYWJlbHMgcmVxdWlyZSBhIHN0cmluZy1iYXNlZCBsYWJlbCBmb3IgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5wdXRFbGVtZW50ID0gaChPcHRpb25hbGx5SW5wdXRHcm91cCwgeyB0YWc6IGluSW5wdXRHcm91cCA/IFwibGFiZWxcIiA6IG51bGwsIGRpc2FibGVkOiBkaXNhYmxlZCwgdGFiSW5kZXg6IC0xLCBpc0lucHV0OiB0cnVlIH0sXHJcbiAgICAgICAgaChQcm9ncmVzc0NpcmN1bGFyLCB7IGNoaWxkcmVuUG9zaXRpb246IFwiYWZ0ZXJcIiwgY29sb3JGaWxsOiBcImZvcmVncm91bmQtb25seVwiLCBtb2RlOiBjdXJyZW50VHlwZSA9PT0gXCJhc3luY1wiID8gYXN5bmNTdGF0ZSA6IG51bGwsIGNvbG9yOiBcImluZm9cIiB9LFxyXG4gICAgICAgICAgICBoKFwiaW5wdXRcIiwgeyAuLi51c2VTd2l0Y2hJbnB1dEVsZW1lbnRQcm9wcyh7IHR5cGU6IFwiY2hlY2tib3hcIiwgY2xhc3NOYW1lOiBjbHN4KHBlbmRpbmcgJiYgXCJwZW5kaW5nXCIsIFwiZm9ybS1jaGVjay1pbnB1dFwiLCBkaXNhYmxlZCAmJiBcImRpc2FibGVkXCIpLCBcImFyaWEtbGFiZWxcIjogbGFiZWxQb3NpdGlvbiA9PT0gXCJoaWRkZW5cIiA/IHN0cmluZ0xhYmVsIDogdW5kZWZpbmVkIH0pIH0pKSk7XHJcbiAgICBjb25zdCBsYWJlbEVsZW1lbnQgPSBoKEZyYWdtZW50LCBudWxsLCBsYWJlbCAhPSBudWxsICYmIGgoT3B0aW9uYWxseUlucHV0R3JvdXAsIHsgdGFnOiBcImxhYmVsXCIsIGlzSW5wdXQ6IGZhbHNlLCAuLi51c2VTd2l0Y2hMYWJlbEVsZW1lbnRQcm9wcyh7IGNsYXNzTmFtZTogY2xzeChwZW5kaW5nICYmIFwicGVuZGluZ1wiLCBcImZvcm0tY2hlY2stbGFiZWxcIiwgZGlzYWJsZWQgJiYgXCJkaXNhYmxlZFwiKSwgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9KSB9LCBsYWJlbCkpO1xyXG4gICAgY29uc3QgcmV0ID0gKGgoRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgbGFiZWxQb3NpdGlvbiA9PSBcInN0YXJ0XCIgJiYgbGFiZWxFbGVtZW50LFxyXG4gICAgICAgIGlucHV0RWxlbWVudCxcclxuICAgICAgICBsYWJlbFBvc2l0aW9uID09IFwiZW5kXCIgJiYgbGFiZWxFbGVtZW50KSk7XHJcbiAgICBpZiAoIWluSW5wdXRHcm91cClcclxuICAgICAgICByZXR1cm4gaChcImRpdlwiLCB7IC4uLnVzZU1lcmdlZFByb3BzKCkocmVzdCwgeyByZWYsIGNsYXNzOiBcImZvcm0tY2hlY2sgZm9ybS1zd2l0Y2hcIiB9KSB9LCByZXQpO1xyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG4vLyBOb3RlOiBTbGlnaHRseSBkaWZmZXJlbnQgZnJvbSB0aGUgb3RoZXJzXHJcbi8vICheXl5eIEknbSByZWFsbHkgZ2xhZCBJIGxlZnQgdGhhdCB0aGVyZSlcclxuZnVuY3Rpb24gT3B0aW9uYWxseUlucHV0R3JvdXAoeyB0YWcsIGlzSW5wdXQsIGNoaWxkcmVuLCAuLi5wcm9wcyB9KSB7XHJcbiAgICBjb25zdCBpbklucHV0R3JvdXAgPSB1c2VDb250ZXh0KEluSW5wdXRHcm91cENvbnRleHQpO1xyXG4gICAgY29uc3QgaW5JbnB1dEdyaWQgPSB1c2VDb250ZXh0KEluSW5wdXRHcmlkQ29udGV4dCk7XHJcbiAgICBpZiAoIWluSW5wdXRHcm91cClcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWcgPz8gRnJhZ21lbnQsIHByb3BzLCBjaGlsZHJlbik7XHJcbiAgICBpZiAoaW5JbnB1dEdyaWQgJiYgaXNJbnB1dClcclxuICAgICAgICBjaGlsZHJlbiA9IGgoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goaXNJbnB1dCAmJiBpbklucHV0R3JpZCAmJiBcImZvcm0tc3dpdGNoXCIsIFwiaW5wdXQtZ3JvdXAtdGV4dFwiKSB9LCBjaGlsZHJlbik7XHJcbiAgICByZXR1cm4gKGgoSW5wdXRHcm91cFRleHQsIHsgdGFnOiB0YWcgPz8gXCJkaXZcIiwgLi4udXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzTmFtZTogY2xzeChcImlucHV0LWdyb3VwLXRleHRcIiwgaXNJbnB1dCAmJiAhaW5JbnB1dEdyaWQgJiYgXCJmb3JtLXN3aXRjaFwiLCBpc0lucHV0ICYmIGluSW5wdXRHcmlkICYmIFwiZmF1eC1pbnB1dC1ncm91cC10ZXh0XCIpIH0sIHByb3BzKSB9LCBjaGlsZHJlbikpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0LXN3aXRjaC5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBGcmFnbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgRXZlbnREZXRhaWwgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VHZW5lcmljTGFiZWwgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtbGFiZWxcIjtcclxuaW1wb3J0IHsgdXNlQXJpYVJhZGlvR3JvdXAgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtcmFkaW8tZ3JvdXBcIjtcclxuaW1wb3J0IHsgdXNlQXN5bmNIYW5kbGVyLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNoaWxkRmxhZyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgUHJvZ3Jlc3NDaXJjdWxhciB9IGZyb20gXCIuLi9wcm9ncmVzc1wiO1xyXG5pbXBvcnQgeyBJbklucHV0R3JvdXBDb250ZXh0IH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgT3B0aW9uYWxseUlucHV0R3JvdXAgfSBmcm9tIFwiLi9pbnB1dC1jaGVja1wiO1xyXG5jb25zdCBrbm93bk5hbWVzID0gbmV3IFNldCgpO1xyXG5jb25zdCBDdXJyZW50SGFuZGxlclR5cGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcInN5bmNcIik7XHJcbmNvbnN0IFJhZGlvR3JvdXBDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuZXhwb3J0IGZ1bmN0aW9uIFJhZGlvR3JvdXAoeyBjaGlsZHJlbiwgbmFtZSwgc2VsZWN0ZWRWYWx1ZSwgbGFiZWwsIGxhYmVsUG9zaXRpb24sIG9uSW5wdXQ6IG9uSW5wdXRBc3luYyB9KSB7XHJcbiAgICBjb25zdCB7IGdldFN5bmNIYW5kbGVyLCBwZW5kaW5nLCBoYXNFcnJvciwgc2V0dGxlQ291bnQsIGN1cnJlbnRDYXB0dXJlLCBjdXJyZW50VHlwZSB9ID0gdXNlQXN5bmNIYW5kbGVyKCkoeyBjYXB0dXJlOiAoZSkgPT4gZVtFdmVudERldGFpbF0uc2VsZWN0ZWRWYWx1ZSB9KTtcclxuICAgIGNvbnN0IG9uSW5wdXQgPSBnZXRTeW5jSGFuZGxlcihvbklucHV0QXN5bmMpO1xyXG4gICAgY29uc3QgeyB1c2VSYWRpbywgdXNlUmFkaW9Hcm91cFByb3BzLCBtYW5hZ2VkQ2hpbGRyZW4sIGdldEluZGV4IH0gPSB1c2VBcmlhUmFkaW9Hcm91cCh7IG5hbWUsIHNlbGVjdGVkVmFsdWU6IHBlbmRpbmcgPyBjdXJyZW50Q2FwdHVyZSA6IHNlbGVjdGVkVmFsdWUsIG9uSW5wdXQ6IG9uSW5wdXQgfSk7XHJcbiAgICBsZXQgc3RyaW5nTGFiZWwgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAobGFiZWxQb3NpdGlvbiA9PT0gXCJoaWRkZW5cIikge1xyXG4gICAgICAgIGlmIChsYWJlbCAhPSBudWxsICYmICFbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdLmluY2x1ZGVzKHR5cGVvZiBsYWJlbCkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSGlkZGVuIGxhYmVscyByZXF1aXJlIGEgc3RyaW5nLWJhc2VkIGxhYmVsIGZvciB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdHJpbmdMYWJlbCA9IGAke2xhYmVsfWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRGVidWdnaW5nIGNoZWNrIC0tIG11bHRpcGxlIGdyb3VwcyB3aXRoIHRoZSBzYW1lIG5hbWUgY2FuIGNhdXNlIHdlaXJkIGdsaXRjaGVzIGZyb20gbmF0aXZlIHJhZGlvIHNlbGVjdGlvbiBiZWhhdmlvci5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGtub3duTmFtZXMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYE11bHRpcGxlIHJhZGlvIGdyb3VwcyB3aXRoIHRoZSBuYW1lIFwiJHtuYW1lfVwiIGV4aXN0IG9uIHRoZSBzYW1lIHBhZ2UgYXQgdGhlIHNhbWUgdGltZSFgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAga25vd25OYW1lcy5hZGQobmFtZSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IGtub3duTmFtZXMuZGVsZXRlKG5hbWUpO1xyXG4gICAgfSwgW25hbWVdKTtcclxuICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBnZXRJbmRleChjdXJyZW50Q2FwdHVyZSA/PyBzZWxlY3RlZFZhbHVlKTtcclxuICAgIC8vY29uc3QgY2FwdHVyZWRJbmRleCA9IGdldEluZGV4KGN1cnJlbnRDYXB0dXJlISk7XHJcbiAgICB1c2VDaGlsZEZsYWcoc2VsZWN0ZWRJbmRleCwgbWFuYWdlZENoaWxkcmVuLmxlbmd0aCwgKGluZGV4LCBpc1NlbGVjdGVkKSA9PiBtYW5hZ2VkQ2hpbGRyZW5baW5kZXhdLnNldEFzeW5jU3RhdGUoaXNTZWxlY3RlZCA/IChoYXNFcnJvciA/IFwiZmFpbGVkXCIgOiBwZW5kaW5nID8gXCJwZW5kaW5nXCIgOiBcInN1Y2NlZWRlZFwiKSA6IG51bGwpKTtcclxuICAgIC8vIHVzZUNoaWxkRmxhZyhwZW5kaW5nID8gY2FwdHVyZWRJbmRleCA6IG51bGwsIG1hbmFnZWRDaGlsZHJlbi5sZW5ndGgsIHVzZUNhbGxiYWNrKChpbmRleCwgaXNDYXB0dXJlZCkgPT4gbWFuYWdlZENoaWxkcmVuW2luZGV4XS5zZXRQZW5kaW5nKGlzQ2FwdHVyZWQ/IFwiaW5cIiA6IGZhbHNlKSwgW10pKTtcclxuICAgIGNvbnN0IHsgdXNlR2VuZXJpY0xhYmVsTGFiZWwsIHVzZUdlbmVyaWNMYWJlbElucHV0IH0gPSB1c2VHZW5lcmljTGFiZWwoeyBpbnB1dFByZWZpeDogXCJhcmlhLXJhZGlvZ3JvdXBcIiwgbGFiZWxQcmVmaXg6IFwiYXJpYS1yYWRpb2dyb3VwLWxhYmVsXCIsIGJhY2t1cFRleHQ6IHN0cmluZ0xhYmVsIH0pO1xyXG4gICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VHZW5lcmljTGFiZWxJbnB1dCgpO1xyXG4gICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxMYWJlbFByb3BzIH0gPSB1c2VHZW5lcmljTGFiZWxMYWJlbCgpO1xyXG4gICAgbGV0IGxhYmVsSnN4ID0gaChcImRpdlwiLCB7IC4uLnVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHMoe30pIH0pO1xyXG4gICAgbGV0IGdyb3VwSnN4ID0gKGgoXCJkaXZcIiwgeyAuLi51c2VHZW5lcmljTGFiZWxJbnB1dFByb3BzKHVzZVJhZGlvR3JvdXBQcm9wcyh7IFwiYXJpYS1sYWJlbFwiOiBsYWJlbFBvc2l0aW9uID09PSBcImhpZGRlblwiID8gc3RyaW5nTGFiZWwgOiB1bmRlZmluZWQgfSkpIH0sIGNoaWxkcmVuKSk7XHJcbiAgICByZXR1cm4gKGgoQ3VycmVudEhhbmRsZXJUeXBlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY3VycmVudFR5cGUgPz8gXCJzeW5jXCIgfSxcclxuICAgICAgICBoKFJhZGlvR3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VSYWRpbyB9LFxyXG4gICAgICAgICAgICBsYWJlbFBvc2l0aW9uID09IFwic3RhcnRcIiAmJiBsYWJlbEpzeCxcclxuICAgICAgICAgICAgZ3JvdXBKc3gsXHJcbiAgICAgICAgICAgIGxhYmVsUG9zaXRpb24gPT0gXCJlbmRcIiAmJiBsYWJlbEpzeCkpKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gUmFkaW8oeyBkaXNhYmxlZCwgY2hpbGRyZW46IGxhYmVsLCBpbmRleCwgdmFsdWUsIGxhYmVsUG9zaXRpb24gfSkge1xyXG4gICAgY29uc3QgdXNlQXJpYVJhZGlvID0gdXNlQ29udGV4dChSYWRpb0dyb3VwQ29udGV4dCk7XHJcbiAgICBsYWJlbFBvc2l0aW9uID8/PSBcImVuZFwiO1xyXG4gICAgY29uc3QgdGV4dCA9IG51bGw7XHJcbiAgICBjb25zdCBjdXJyZW50SGFuZGxlclR5cGUgPSB1c2VDb250ZXh0KEN1cnJlbnRIYW5kbGVyVHlwZUNvbnRleHQpO1xyXG4gICAgY29uc3QgW2FzeW5jU3RhdGUsIHNldEFzeW5jU3RhdGVdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBkaXNhYmxlZCB8fD0gKGFzeW5jU3RhdGUgPT09IFwicGVuZGluZ1wiKTtcclxuICAgIGNvbnN0IHsgdXNlUmFkaW9JbnB1dCwgdXNlUmFkaW9MYWJlbCB9ID0gdXNlQXJpYVJhZGlvKHsgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlLCBsYWJlbFBvc2l0aW9uOiBcInNlcGFyYXRlXCIsIGluZGV4LCB0ZXh0LCB2YWx1ZSwgc2V0QXN5bmNTdGF0ZSB9KTtcclxuICAgIGNvbnN0IHsgdXNlUmFkaW9JbnB1dFByb3BzIH0gPSB1c2VSYWRpb0lucHV0KHsgdGFnOiBcImlucHV0XCIgfSk7XHJcbiAgICBjb25zdCB7IHVzZVJhZGlvTGFiZWxQcm9wcyB9ID0gdXNlUmFkaW9MYWJlbCh7IHRhZzogXCJsYWJlbFwiIH0pO1xyXG4gICAgY29uc3QgaW5JbnB1dEdyb3VwID0gdXNlQ29udGV4dChJbklucHV0R3JvdXBDb250ZXh0KTtcclxuICAgIGxhYmVsID8/PSB2YWx1ZTtcclxuICAgIGxldCBzdHJpbmdMYWJlbCA9IGAke2xhYmVsfWA7XHJcbiAgICBpZiAobGFiZWwgIT0gbnVsbCAmJiBsYWJlbFBvc2l0aW9uID09PSBcImhpZGRlblwiICYmICFbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdLmluY2x1ZGVzKHR5cGVvZiBsYWJlbCkpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBIaWRkZW4gbGFiZWxzIHJlcXVpcmUgYSBzdHJpbmctYmFzZWQgbGFiZWwgZm9yIHRoZSBhcmlhLWxhYmVsIGF0dHJpYnV0ZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGlucHV0RWxlbWVudCA9IGgoT3B0aW9uYWxseUlucHV0R3JvdXAsIHsgaXNJbnB1dDogdHJ1ZSwgdGFnOiBpbklucHV0R3JvdXAgPyBcImxhYmVsXCIgOiBudWxsLCBkaXNhYmxlZDogZGlzYWJsZWQsIHRhYkluZGV4OiAtMSB9LFxyXG4gICAgICAgIGgoUHJvZ3Jlc3NDaXJjdWxhciwgeyBjaGlsZHJlblBvc2l0aW9uOiBcImFmdGVyXCIsIGNvbG9yRmlsbDogXCJmb3JlZ3JvdW5kLW9ubHlcIiwgbW9kZTogY3VycmVudEhhbmRsZXJUeXBlID09IFwiYXN5bmNcIiA/IGFzeW5jU3RhdGUgOiBudWxsLCBjb2xvcjogXCJpbmZvXCIgfSxcclxuICAgICAgICAgICAgaChcImlucHV0XCIsIHsgLi4udXNlUmFkaW9JbnB1dFByb3BzKHsgdHlwZTogXCJyYWRpb1wiLCBjbGFzc05hbWU6IGNsc3goYXN5bmNTdGF0ZSA9PT0gXCJwZW5kaW5nXCIgJiYgXCJwZW5kaW5nXCIsIGRpc2FibGVkICYmIFwiZGlzYWJsZWRcIiwgXCJmb3JtLWNoZWNrLWlucHV0XCIpLCBcImFyaWEtbGFiZWxcIjogbGFiZWxQb3NpdGlvbiA9PT0gXCJoaWRkZW5cIiA/IHN0cmluZ0xhYmVsIDogdW5kZWZpbmVkIH0pIH0pKSk7XHJcbiAgICBjb25zdCBsYWJlbEVsZW1lbnQgPSBoKEZyYWdtZW50LCBudWxsLCBsYWJlbCAhPSBudWxsICYmIGgoT3B0aW9uYWxseUlucHV0R3JvdXAsIHsgaXNJbnB1dDogZmFsc2UsIHRhZzogXCJsYWJlbFwiLCAuLi51c2VSYWRpb0xhYmVsUHJvcHMoeyBjbGFzc05hbWU6IGNsc3goYXN5bmNTdGF0ZSA9PT0gXCJwZW5kaW5nXCIgJiYgXCJwZW5kaW5nXCIsIGRpc2FibGVkICYmIFwiZGlzYWJsZWRcIiwgXCJmb3JtLWNoZWNrLWxhYmVsXCIpLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0pIH0sIGxhYmVsKSk7XHJcbiAgICBjb25zdCByZXQgPSAoaChGcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBsYWJlbFBvc2l0aW9uID09IFwic3RhcnRcIiAmJiBsYWJlbEVsZW1lbnQsXHJcbiAgICAgICAgaW5wdXRFbGVtZW50LFxyXG4gICAgICAgIGxhYmVsUG9zaXRpb24gPT0gXCJlbmRcIiAmJiBsYWJlbEVsZW1lbnQpKTtcclxuICAgIGlmICghaW5JbnB1dEdyb3VwKVxyXG4gICAgICAgIHJldHVybiBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiZm9ybS1jaGVja1wiIH0sIHJldCk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0LXJhZGlvLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi4vcHJvcHNcIjtcclxuLyoqXHJcbiAqIFZlcnkgc2ltcGxlLCBlYXN5IHJlc3BvbnNpdmUgZ3JpZCB0aGF0IGd1YXJhbnRlZXMgZWFjaCBjb2x1bW4gaXMgdGhlIG1pbmltdW0gc2l6ZS5cclxuICpcclxuICogRWFzeSBvbmUtbGluZXJzIGFsbCBhcm91bmQgaGVyZSFcclxuICovXHJcbmV4cG9ydCBjb25zdCBHcmlkUmVzcG9uc2l2ZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFJlc3BvbnNpdmVHcmlkKHsgdGFnLCBtaW5XaWR0aCwgY2hpbGRyZW4sIC4uLnByb3BzIH0sIHJlZikge1xyXG4gICAgcmV0dXJuIChoKHRhZyA/PyBcImRpdlwiLCB1c2VNZXJnZWRQcm9wcygpKHsgY2xhc3NOYW1lOiBcInJlc3BvbnNpdmUtZ3JpZFwiLCBzdHlsZTogbWluV2lkdGggPyB7IFwiLS1ncmlkLW1pbi13aWR0aFwiOiBgJHttaW5XaWR0aH1gIH0gOiB7fSwgcmVmIH0sIHByb3BzKSwgY2hpbGRyZW4pKTtcclxufSk7XHJcbi8qKlxyXG4gKiBWZXJ5IHNpbXBsZSwgZWFzeSBzdGF0aWMgZ3JpZCB0aGF0IGd1YXJhbnRlZXMgdGhlIG51bWJlciBvZiBjb2x1bW5zIGlzIGRpc3BsYXllZCxcclxuICogbm8gbWF0dGVyIGhvdyBqYW5reSBpdCBsb29rcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBHcmlkU3RhdGljID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gUmVzcG9uc2l2ZUdyaWQoeyB0YWcsIGNvbHVtbnMsIGNoaWxkcmVuLCAuLi5wcm9wcyB9LCByZWYpIHtcclxuICAgIHJldHVybiAoaCh0YWcgPz8gXCJkaXZcIiwgdXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzTmFtZTogXCJzdGF0aWMtZ3JpZFwiLCBzdHlsZTogdHlwZW9mIGNvbHVtbnMgPT09IFwic3RyaW5nXCIgPyB7IFwiLS1zdGF0aWMtZ3JpZC1jb2x1bW5zXCI6IGNvbHVtbnMgfSA6IHsgXCItLWdyaWQtY29sdW1uLWNvdW50XCI6IGNvbHVtbnMgfSwgcmVmIH0sIHByb3BzKSwgY2hpbGRyZW4pKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyaWQuanMubWFwIiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQXJpYUxpc3Rib3hTaW5nbGUgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0c1wiO1xyXG5pbXBvcnQgeyBFdmVudERldGFpbCB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZUFzeW5jSGFuZGxlciwgdXNlTWVyZ2VkUHJvcHMsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VQc2V1ZG9BY3RpdmUgfSBmcm9tIFwiLi4vcHJvcHNcIjtcclxuZXhwb3J0IGNvbnN0IFVzZUxpc3Rib3hTaW5nbGVJdGVtQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmV4cG9ydCBmdW5jdGlvbiBMaXN0U2luZ2xlKHByb3BzLCByZWYpIHtcclxuICAgIGNvbnN0IHsgb25TZWxlY3Q6IG9uU2VsZWN0QXN5bmMsIHNlbGVjdGVkSW5kZXgsIHNlbGVjdGlvbk1vZGUsIGNvbGxhdG9yLCBrZXlOYXZpZ2F0aW9uLCBub1R5cGVhaGVhZCwgbm9XcmFwLCB0eXBlYWhlYWRUaW1lb3V0LCB0YWcsIHNlbGVjdCwgLi4uZG9tUHJvcHMgfSA9IHByb3BzO1xyXG4gICAgY29uc3QgeyBnZXRTeW5jSGFuZGxlciB9ID0gdXNlQXN5bmNIYW5kbGVyKCkoeyBjYXB0dXJlOiAoZSkgPT4gZVtFdmVudERldGFpbF0uc2VsZWN0ZWRJbmRleCB9KTtcclxuICAgIGNvbnN0IG9uU2VsZWN0ID0gZ2V0U3luY0hhbmRsZXIob25TZWxlY3RBc3luYyk7XHJcbiAgICBjb25zdCB7IHVzZUxpc3Rib3hTaW5nbGVJdGVtLCB1c2VMaXN0Ym94U2luZ2xlTGFiZWwsIHVzZUxpc3Rib3hTaW5nbGVQcm9wcyB9ID0gdXNlQXJpYUxpc3Rib3hTaW5nbGUoeyBvblNlbGVjdCwgc2VsZWN0ZWRJbmRleCwgc2VsZWN0aW9uTW9kZSwgdHlwZWFoZWFkVGltZW91dCwgbm9XcmFwLCBub1R5cGVhaGVhZCwga2V5TmF2aWdhdGlvbiwgY29sbGF0b3IgfSk7XHJcbiAgICByZXR1cm4gaChVc2VMaXN0Ym94U2luZ2xlSXRlbUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHVzZUxpc3Rib3hTaW5nbGVJdGVtIH0sIGgodGFnLCB1c2VNZXJnZWRQcm9wcygpKHsgY2xhc3M6IFwibGlzdC1ncm91cFwiLCByZWYgfSwgdXNlTGlzdGJveFNpbmdsZVByb3BzKGRvbVByb3BzKSkpKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gTGlzdEl0ZW1TaW5nbGUocHJvcHMsIHJlZikge1xyXG4gICAgY29uc3QgdXNlTGlzdEl0ZW1TaW5nbGUgPSB1c2VDb250ZXh0KFVzZUxpc3Rib3hTaW5nbGVJdGVtQ29udGV4dCk7XHJcbiAgICBjb25zdCB7IGluZGV4LCAuLi5kb21Qcm9wcyB9ID0geyAuLi5wcm9wcywgcmVmIH07XHJcbiAgICBjb25zdCBbdGV4dCwgc2V0VGV4dF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBlbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChlbGVtZW50KVxyXG4gICAgICAgICAgICBzZXRUZXh0KGVsZW1lbnQuaW5uZXJUZXh0KTtcclxuICAgIH0sIFtlbGVtZW50XSk7XHJcbiAgICBjb25zdCB7IGdldFNlbGVjdGVkLCB0YWJiYWJsZSwgc2VsZWN0ZWQsIHVzZUxpc3Rib3hTaW5nbGVJdGVtUHJvcHMgfSA9IHVzZUxpc3RJdGVtU2luZ2xlKHsgaW5kZXgsIHRleHQsIHRhZzogXCJsaVwiIH0pO1xyXG4gICAgcmV0dXJuIGgoXCJsaVwiLCB7IC4uLnVzZVBzZXVkb0FjdGl2ZSh1c2VNZXJnZWRQcm9wcygpKHsgY2xhc3M6IGNsc3goXCJsaXN0LWdyb3VwLWl0ZW1cIiwgXCJsaXN0LWdyb3VwLWl0ZW0tYWN0aW9uXCIsIHNlbGVjdGVkICYmIFwiYWN0aXZlXCIpIH0sIHVzZUxpc3Rib3hTaW5nbGVJdGVtUHJvcHModXNlUmVmRWxlbWVudFByb3BzKGRvbVByb3BzKSkpKSB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0LXNpbmdsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuZ2xvYmFsVGhpcy5wcm9jZXNzID8/PSB7fTtcclxuZ2xvYmFsVGhpcy5wcm9jZXNzLmVudiA/Pz0ge307XHJcbmdsb2JhbFRoaXMucHJvY2Vzcy5lbnYuTk9ERV9FTlYgPz89IFwiZGV2ZWxvcG1lbnRcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLWNvbmZpZy5qcy5tYXAiLCJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTsiLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07IiwiaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufSIsImltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnQpICYmIGluY2x1ZGVTY2FsZSkge1xuICAgIHZhciBvZmZzZXRIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB2YXIgb2Zmc2V0V2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoOyAvLyBEbyBub3QgYXR0ZW1wdCB0byBkaXZpZGUgYnkgMCwgb3RoZXJ3aXNlIHdlIGdldCBgSW5maW5pdHlgIGFzIHNjYWxlXG4gICAgLy8gRmFsbGJhY2sgdG8gMSBpbiBjYXNlIGJvdGggdmFsdWVzIGFyZSBgMGBcblxuICAgIGlmIChvZmZzZXRXaWR0aCA+IDApIHtcbiAgICAgIHNjYWxlWCA9IHJlY3Qud2lkdGggLyBvZmZzZXRXaWR0aCB8fCAxO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXRIZWlnaHQgPiAwKSB7XG4gICAgICBzY2FsZVkgPSByZWN0LmhlaWdodCAvIG9mZnNldEhlaWdodCB8fCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJvdW5kKHJlY3Qud2lkdGggLyBzY2FsZVgpLFxuICAgIGhlaWdodDogcm91bmQocmVjdC5oZWlnaHQgLyBzY2FsZVkpLFxuICAgIHRvcDogcm91bmQocmVjdC50b3AgLyBzY2FsZVkpLFxuICAgIHJpZ2h0OiByb3VuZChyZWN0LnJpZ2h0IC8gc2NhbGVYKSxcbiAgICBib3R0b206IHJvdW5kKHJlY3QuYm90dG9tIC8gc2NhbGVZKSxcbiAgICBsZWZ0OiByb3VuZChyZWN0LmxlZnQgLyBzY2FsZVgpLFxuICAgIHg6IHJvdW5kKHJlY3QubGVmdCAvIHNjYWxlWCksXG4gICAgeTogcm91bmQocmVjdC50b3AgLyBzY2FsZVkpXG4gIH07XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjsgLy8gUmV0dXJucyB0aGUgbGF5b3V0IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LiBMYXlvdXRcbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gIHZhciBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpOyAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cbiAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMjIzXG5cbiAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LndpZHRoIC0gd2lkdGgpIDw9IDEpIHtcbiAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC5oZWlnaHQgLSBoZWlnaHQpIDw9IDEpIHtcbiAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufSIsImltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbn0iLCJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGlzVGFibGVFbGVtZW50IGZyb20gXCIuL2lzVGFibGVFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgdmFyIGlzRmlyZWZveCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xuICB2YXIgaXNJRSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpICE9PSAtMTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcbiAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59IiwiZXhwb3J0IHZhciBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCB2YXIgbWluID0gTWF0aC5taW47XG5leHBvcnQgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDsiLCJpbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KSB7XG4gIHJldHVybiBtYXRoTWF4KG1pbiwgbWF0aE1pbih2YWx1ZSwgbWF4KSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSIsImltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4vZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuLi9kb20tdXRpbHMvY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHdpdGhpbiBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuLi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4uL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qc1wiO1xuaW1wb3J0IHsgbGVmdCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB0b3AsIGJvdHRvbSB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHBhZGRpbmc7XG4gIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xufTtcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcbiAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENTUyBzZWxlY3RvclxuXG5cbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNIVE1MRWxlbWVudChhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgZWxlbWVudCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50IChub3QgYW4gU1ZHRWxlbWVudCkuJywgJ1RvIHVzZSBhbiBTVkcgYXJyb3csIHdyYXAgaXQgaW4gYW4gSFRNTEVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMnLCAndGhlIGFycm93LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgbW9kaWZpZXJcXCdzIGBlbGVtZW50YCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIHBvcHBlcicsICdlbGVtZW50LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn0iLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQocm91bmQoeCAqIGRwcikgLyBkcHIpIHx8IDAsXG4gICAgeTogcm91bmQocm91bmQoeSAqIGRwcikgLyBkcHIpIHx8IDBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgdmFyaWF0aW9uID0gX3JlZjIudmFyaWF0aW9uLFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cztcblxuICB2YXIgX3JlZjMgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUihvZmZzZXRzKSA6IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMob2Zmc2V0cykgOiBvZmZzZXRzLFxuICAgICAgX3JlZjMkeCA9IF9yZWYzLngsXG4gICAgICB4ID0gX3JlZjMkeCA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJHgsXG4gICAgICBfcmVmMyR5ID0gX3JlZjMueSxcbiAgICAgIHkgPSBfcmVmMyR5ID09PSB2b2lkIDAgPyAwIDogX3JlZjMkeTtcblxuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgICAgIHkgLT0gb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0IHx8IChwbGFjZW1lbnQgPT09IHRvcCB8fCBwbGFjZW1lbnQgPT09IGJvdHRvbSkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gICAgICB4IC09IG9mZnNldFBhcmVudFt3aWR0aFByb3BdIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjQpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjQuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjQub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxuICAgICAgX29wdGlvbnMkcm91bmRPZmZzZXRzID0gb3B0aW9ucy5yb3VuZE9mZnNldHMsXG4gICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciB0cmFuc2l0aW9uUHJvcGVydHkgPSBnZXRDb21wdXRlZFN0eWxlKHN0YXRlLmVsZW1lbnRzLnBvcHBlcikudHJhbnNpdGlvblByb3BlcnR5IHx8ICcnO1xuXG4gICAgaWYgKGFkYXB0aXZlICYmIFsndHJhbnNmb3JtJywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLnNvbWUoZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvblByb3BlcnR5LmluZGV4T2YocHJvcGVydHkpID49IDA7XG4gICAgfSkpIHtcbiAgICAgIGNvbnNvbGUud2FybihbJ1BvcHBlcjogRGV0ZWN0ZWQgQ1NTIHRyYW5zaXRpb25zIG9uIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nJywgJ0NTUyBwcm9wZXJ0aWVzOiBcInRyYW5zZm9ybVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLicsICdcXG5cXG4nLCAnRGlzYWJsZSB0aGUgXCJjb21wdXRlU3R5bGVzXCIgbW9kaWZpZXJcXCdzIGBhZGFwdGl2ZWAgb3B0aW9uIHRvIGFsbG93JywgJ2ZvciBzbW9vdGggdHJhbnNpdGlvbnMsIG9yIHJlbW92ZSB0aGVzZSBwcm9wZXJ0aWVzIGZyb20gdGhlIENTUycsICd0cmFuc2l0aW9uIGRlY2xhcmF0aW9uIG9uIHRoZSBwb3BwZXIgZWxlbWVudCBpZiBvbmx5IHRyYW5zaXRpb25pbmcnLCAnb3BhY2l0eSBvciBiYWNrZ3JvdW5kLWNvbG9yIGZvciBleGFtcGxlLicsICdcXG5cXG4nLCAnV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBwb3BwZXIgZWxlbWVudCBhcyBhIHdyYXBwZXIgYXJvdW5kIGFuIGlubmVyJywgJ2VsZW1lbnQgdGhhdCBjYW4gaGF2ZSBhbnkgQ1NTIHByb3BlcnR5IHRyYW5zaXRpb25lZCBmb3IgYW5pbWF0aW9ucy4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSB7XG4gICAgcGxhY2VtZW50OiBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCksXG4gICAgdmFyaWF0aW9uOiBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb25cbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHBhc3NpdmUgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXG4gIGVmZmVjdDogZWZmZWN0LFxuICBkYXRhOiB7fVxufTsiLCJ2YXIgaGFzaCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJ2YXIgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwOyAvLyBOQjogVGhpcyBpc24ndCBzdXBwb3J0ZWQgb24gaU9TIDw9IDEyLiBJZiB0aGUga2V5Ym9hcmQgaXMgb3BlbiwgdGhlIHBvcHBlclxuICAvLyBjYW4gYmUgb2JzY3VyZWQgdW5kZXJuZWF0aCBpdC5cbiAgLy8gQWxzbywgYGh0bWwuY2xpZW50SGVpZ2h0YCBhZGRzIHRoZSBib3R0b20gYmFyIGhlaWdodCBpbiBTYWZhcmkgaU9TLCBldmVuXG4gIC8vIGlmIGl0IGlzbid0IG9wZW4sIHNvIGlmIHRoaXMgaXNuJ3QgYXZhaWxhYmxlLCB0aGUgcG9wcGVyIHdpbGwgYmUgZGV0ZWN0ZWRcbiAgLy8gdG8gb3ZlcmZsb3cgdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIHRvbyBlYXJseS5cblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDsgLy8gVXNlcyBMYXlvdXQgVmlld3BvcnQgKGxpa2UgQ2hyb21lOyBTYWZhcmkgZG9lcyBub3QgY3VycmVudGx5KVxuICAgIC8vIEluIENocm9tZSwgaXQgcmV0dXJucyBhIHZhbHVlIHZlcnkgY2xvc2UgdG8gMCAoKy8tKSBidXQgY29udGFpbnMgcm91bmRpbmdcbiAgICAvLyBlcnJvcnMgZHVlIHRvIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIHNvIHdlIG5lZWQgdG8gY2hlY2sgcHJlY2lzaW9uLlxuICAgIC8vIFNhZmFyaSByZXR1cm5zIGEgbnVtYmVyIDw9IDAsIHVzdWFsbHkgPCAtMSB3aGVuIHBpbmNoLXpvb21lZFxuICAgIC8vIEZlYXR1cmUgZGV0ZWN0aW9uIGZhaWxzIGluIG1vYmlsZSBlbXVsYXRpb24gbW9kZSBpbiBDaHJvbWUuXG4gICAgLy8gTWF0aC5hYnMod2luLmlubmVyV2lkdGggLyB2aXN1YWxWaWV3cG9ydC5zY2FsZSAtIHZpc3VhbFZpZXdwb3J0LndpZHRoKSA8XG4gICAgLy8gMC4wMDFcbiAgICAvLyBGYWxsYmFjayBoZXJlOiBcIk5vdCBTYWZhcmlcIiB1c2VyQWdlbnRcblxuICAgIGlmICghL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn0iLCJpbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufSIsImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn0iLCJpbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tIFwiLi9nZXRWaWV3cG9ydFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudFJlY3QgZnJvbSBcIi4vZ2V0RG9jdW1lbnRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi4vdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpO1xuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkpIDogaXNIVE1MRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbn0gLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIG92ZXJmbG93aW5nIGVsZW1lbnRzIHdpdGggYSBwb3NpdGlvbiBkaWZmZXJlbnQgZnJvbVxuLy8gYGluaXRpYWxgXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xuICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xuICB2YXIgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzE0MTRcblxuXG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiYgZ2V0Tm9kZU5hbWUoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keSc7XG4gIH0pO1xufSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBwYXJlbnRzXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KGVsZW1lbnQsIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQpKTtcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufSIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSIsImltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG4gIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iLCJpbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IHsgdmFyaWF0aW9uUGxhY2VtZW50cywgYmFzZVBsYWNlbWVudHMsIHBsYWNlbWVudHMgYXMgYWxsUGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IGFsbFBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcbiAgdmFyIHBsYWNlbWVudHMgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XG4gIH0pIDogYmFzZVBsYWNlbWVudHM7XG4gIHZhciBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xuICB9KTtcblxuICBpZiAoYWxsb3dlZFBsYWNlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogVGhlIGBhbGxvd2VkQXV0b1BsYWNlbWVudHNgIG9wdGlvbiBkaWQgbm90IGFsbG93IGFueScsICdwbGFjZW1lbnRzLiBFbnN1cmUgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbiBtYXRjaGVzIHRoZSB2YXJpYXRpb24nLCAnb2YgdGhlIGFsbG93ZWQgcGxhY2VtZW50cy4nLCAnRm9yIGV4YW1wbGUsIFwiYXV0b1wiIGNhbm5vdCBiZSB1c2VkIHRvIGFsbG93IFwiYm90dG9tLXN0YXJ0XCIuJywgJ1VzZSBcImF1dG8tc3RhcnRcIiBpbnN0ZWFkLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXG5cblxuICB2YXIgb3ZlcmZsb3dzID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVBdXRvUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgYm90dG9tLCB0b3AsIHN0YXJ0LCByaWdodCwgbGVmdCwgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZmxpcCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBmbGlwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxuICBkYXRhOiB7XG4gICAgX3NraXA6IGZhbHNlXG4gIH1cbn07IiwiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgcGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXG4gICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXRcbn07IiwiaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuLi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3BvcHBlck9mZnNldHMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3JlYWQnLFxuICBmbjogcG9wcGVyT2Zmc2V0cyxcbiAgZGF0YToge31cbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59IiwiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBzdGFydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEFsdEF4aXMgZnJvbSBcIi4uL3V0aWxzL2dldEFsdEF4aXMuanNcIjtcbmltcG9ydCB3aXRoaW4gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4uL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuaW1wb3J0IHsgbWF4IGFzIG1hdGhNYXgsIG1pbiBhcyBtYXRoTWluIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzIHx8IGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdIC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSB0ZXRoZXJPZmZzZXRWYWx1ZSA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gdGV0aGVyT2Zmc2V0VmFsdWU7XG4gICAgdmFyIG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICsgYWRkaXRpdmUgKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIHRldGhlck9mZnNldFZhbHVlIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyB0ZXRoZXJPZmZzZXRWYWx1ZTtcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF1bbWFpbkF4aXNdIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgdmFyIHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtYXRoTWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoTWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heCk7XG4gICAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XG5cbiAgICAgIHZhciBfbWluID0gX29mZnNldCArIG92ZXJmbG93W19tYWluU2lkZV07XG5cbiAgICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgICAgdmFyIF9wcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihfbWluLCB0ZXRoZXJNaW4pIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gbWF0aE1heChfbWF4LCB0ZXRoZXJNYXgpIDogX21heCk7XG5cbiAgICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0SFRNTEVsZW1lbnRTY3JvbGwgZnJvbSBcIi4vZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldE5vZGVTY3JvbGwgZnJvbSBcIi4vZ2V0Tm9kZVNjcm9sbC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByZWN0LndpZHRoIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xuICB2YXIgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59IiwiaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gIHZhciBwZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXQoc3RyKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBbXS5jb25jYXQoYXJncykucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgcmV0dXJuIHAucmVwbGFjZSgvJXMvLCBjKTtcbiAgfSwgc3RyKTtcbn0iLCJpbXBvcnQgZm9ybWF0IGZyb20gXCIuL2Zvcm1hdC5qc1wiO1xuaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbnZhciBJTlZBTElEX01PRElGSUVSX0VSUk9SID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHByb3ZpZGVkIGFuIGludmFsaWQgJXMgcHJvcGVydHksIGV4cGVjdGVkICVzIGJ1dCBnb3QgJXMnO1xudmFyIE1JU1NJTkdfREVQRU5ERU5DWV9FUlJPUiA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiByZXF1aXJlcyBcIiVzXCIsIGJ1dCBcIiVzXCIgbW9kaWZpZXIgaXMgbm90IGF2YWlsYWJsZSc7XG52YXIgVkFMSURfUFJPUEVSVElFUyA9IFsnbmFtZScsICdlbmFibGVkJywgJ3BoYXNlJywgJ2ZuJywgJ2VmZmVjdCcsICdyZXF1aXJlcycsICdvcHRpb25zJ107XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgW10uY29uY2F0KE9iamVjdC5rZXlzKG1vZGlmaWVyKSwgVkFMSURfUFJPUEVSVElFUykgLy8gSUUxMS1jb21wYXRpYmxlIHJlcGxhY2VtZW50IGZvciBgbmV3IFNldChpdGVyYWJsZSlgXG4gICAgLmZpbHRlcihmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBzZWxmKSB7XG4gICAgICByZXR1cm4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXg7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBTdHJpbmcobW9kaWZpZXIubmFtZSksICdcIm5hbWVcIicsICdcInN0cmluZ1wiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIubmFtZSkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2VuYWJsZWQnOlxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIuZW5hYmxlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJlbmFibGVkXCInLCAnXCJib29sZWFuXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5lbmFibGVkKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncGhhc2UnOlxuICAgICAgICAgIGlmIChtb2RpZmllclBoYXNlcy5pbmRleE9mKG1vZGlmaWVyLnBoYXNlKSA8IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcInBoYXNlXCInLCBcImVpdGhlciBcIiArIG1vZGlmaWVyUGhhc2VzLmpvaW4oJywgJyksIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLnBoYXNlKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm4nOlxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIuZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcImZuXCInLCAnXCJmdW5jdGlvblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZm4pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlZmZlY3QnOlxuICAgICAgICAgIGlmIChtb2RpZmllci5lZmZlY3QgIT0gbnVsbCAmJiB0eXBlb2YgbW9kaWZpZXIuZWZmZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJlZmZlY3RcIicsICdcImZ1bmN0aW9uXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5mbikgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JlcXVpcmVzJzpcbiAgICAgICAgICBpZiAobW9kaWZpZXIucmVxdWlyZXMgIT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShtb2RpZmllci5yZXF1aXJlcykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcInJlcXVpcmVzXCInLCAnXCJhcnJheVwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIucmVxdWlyZXMpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZXF1aXJlc0lmRXhpc3RzJzpcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcInJlcXVpcmVzSWZFeGlzdHNcIicsICdcImFycmF5XCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnb3B0aW9ucyc6XG4gICAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlBvcHBlckpTOiBhbiBpbnZhbGlkIHByb3BlcnR5IGhhcyBiZWVuIHByb3ZpZGVkIHRvIHRoZSBcXFwiXCIgKyBtb2RpZmllci5uYW1lICsgXCJcXFwiIG1vZGlmaWVyLCB2YWxpZCBwcm9wZXJ0aWVzIGFyZSBcIiArIFZBTElEX1BST1BFUlRJRVMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyBzICsgXCJcXFwiXCI7XG4gICAgICAgICAgfSkuam9pbignLCAnKSArIFwiOyBidXQgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBwcm92aWRlZC5cIik7XG4gICAgICB9XG5cbiAgICAgIG1vZGlmaWVyLnJlcXVpcmVzICYmIG1vZGlmaWVyLnJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVpcmVtZW50KSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMuZmluZChmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgcmV0dXJuIG1vZC5uYW1lID09PSByZXF1aXJlbWVudDtcbiAgICAgICAgfSkgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KE1JU1NJTkdfREVQRU5ERU5DWV9FUlJPUiwgU3RyaW5nKG1vZGlmaWVyLm5hbWUpLCByZXF1aXJlbWVudCwgcmVxdWlyZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVuaXF1ZUJ5KGFyciwgZm4pIHtcbiAgdmFyIGlkZW50aWZpZXJzID0gbmV3IFNldCgpO1xuICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBpZGVudGlmaWVyID0gZm4oaXRlbSk7XG5cbiAgICBpZiAoIWlkZW50aWZpZXJzLmhhcyhpZGVudGlmaWVyKSkge1xuICAgICAgaWRlbnRpZmllcnMuYWRkKGlkZW50aWZpZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0Q29tcG9zaXRlUmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tIFwiLi91dGlscy9vcmRlck1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCIuL3V0aWxzL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgdmFsaWRhdGVNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvdmFsaWRhdGVNb2RpZmllcnMuanNcIjtcbmltcG9ydCB1bmlxdWVCeSBmcm9tIFwiLi91dGlscy91bmlxdWVCeS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IG1lcmdlQnlOYW1lIGZyb20gXCIuL3V0aWxzL21lcmdlQnlOYW1lLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4vZW51bXMuanNcIjtcbnZhciBJTlZBTElEX0VMRU1FTlRfRVJST1IgPSAnUG9wcGVyOiBJbnZhbGlkIHJlZmVyZW5jZSBvciBwb3BwZXIgYXJndW1lbnQgcHJvdmlkZWQuIFRoZXkgbXVzdCBiZSBlaXRoZXIgYSBET00gZWxlbWVudCBvciB2aXJ0dWFsIGVsZW1lbnQuJztcbnZhciBJTkZJTklURV9MT09QX0VSUk9SID0gJ1BvcHBlcjogQW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgbW9kaWZpZXJzIGN5Y2xlIGhhcyBiZWVuIGRldGVjdGVkISBUaGUgY3ljbGUgaGFzIGJlZW4gaW50ZXJydXB0ZWQgdG8gcHJldmVudCBhIGJyb3dzZXIgY3Jhc2guJztcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTsgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIG1vZGlmaWVycyBzbyB0aGF0IHRoZSBjb25zdW1lciB3aWxsIGdldCB3YXJuZWRcbiAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBtb2RpZmllcnMgaXMgaW52YWxpZCBmb3IgYW55IHJlYXNvblxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgbW9kaWZpZXJzID0gdW5pcXVlQnkoW10uY29uY2F0KG9yZGVyZWRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFsaWRhdGVNb2RpZmllcnMobW9kaWZpZXJzKTtcblxuICAgICAgICAgIGlmIChnZXRCYXNlUGxhY2VtZW50KHN0YXRlLm9wdGlvbnMucGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgICAgICAgICAgdmFyIGZsaXBNb2RpZmllciA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZmluZChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lO1xuICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gJ2ZsaXAnO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZmxpcE1vZGlmaWVyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXV0b1wiIHBsYWNlbWVudHMgcmVxdWlyZSB0aGUgXCJmbGlwXCIgbW9kaWZpZXIgYmUnLCAncHJlc2VudCBhbmQgZW5hYmxlZCB0byB3b3JrLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShwb3BwZXIpLFxuICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgIG1hcmdpblJpZ2h0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luUmlnaHQsXG4gICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkJvdHRvbSxcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkxlZnQ7IC8vIFdlIG5vIGxvbmdlciB0YWtlIGludG8gYWNjb3VudCBgbWFyZ2luc2Agb24gdGhlIHBvcHBlciwgYW5kIGl0IGNhblxuICAgICAgICAgIC8vIGNhdXNlIGJ1Z3Mgd2l0aCBwb3NpdGlvbmluZywgc28gd2UnbGwgd2FybiB0aGUgY29uc3VtZXJcblxuXG4gICAgICAgICAgaWYgKFttYXJnaW5Ub3AsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnRdLnNvbWUoZnVuY3Rpb24gKG1hcmdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWFyZ2luKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBDU1MgXCJtYXJnaW5cIiBzdHlsZXMgY2Fubm90IGJlIHVzZWQgdG8gYXBwbHkgcGFkZGluZycsICdiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudCBvciBib3VuZGFyeS4nLCAnVG8gcmVwbGljYXRlIG1hcmdpbiwgdXNlIHRoZSBgb2Zmc2V0YCBtb2RpZmllciwgYXMgd2VsbCBhcycsICd0aGUgYHBhZGRpbmdgIG9wdGlvbiBpbiB0aGUgYHByZXZlbnRPdmVyZmxvd2AgYW5kIGBmbGlwYCcsICdtb2RpZmllcnMuJ10uam9pbignICcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfX2RlYnVnX2xvb3BzX18gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIF9fZGVidWdfbG9vcHNfXyArPSAxO1xuXG4gICAgICAgICAgICBpZiAoX19kZWJ1Z19sb29wc19fID4gMTAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5GSU5JVEVfTE9PUF9FUlJPUik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxuICAgICAgICAgICAgICBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm9wdGlvbnMsXG4gICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICB9KSB8fCBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICAgICAgX3JlZjMkb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZjMkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZjMuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07IiwiaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gXCIuL2NyZWF0ZVBvcHBlci5qc1wiO1xuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1wiO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSBcIi4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcIjtcbmltcG9ydCBjb21wdXRlU3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXCI7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXCI7XG5pbXBvcnQgb2Zmc2V0IGZyb20gXCIuL21vZGlmaWVycy9vZmZzZXQuanNcIjtcbmltcG9ydCBmbGlwIGZyb20gXCIuL21vZGlmaWVycy9mbGlwLmpzXCI7XG5pbXBvcnQgcHJldmVudE92ZXJmbG93IGZyb20gXCIuL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBhcnJvdyBmcm9tIFwiLi9tb2RpZmllcnMvYXJyb3cuanNcIjtcbmltcG9ydCBoaWRlIGZyb20gXCIuL21vZGlmaWVycy9oaWRlLmpzXCI7XG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cywgY29tcHV0ZVN0eWxlcywgYXBwbHlTdHlsZXMsIG9mZnNldCwgZmxpcCwgcHJldmVudE92ZXJmbG93LCBhcnJvdywgaGlkZV07XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJMaXRlIH0gZnJvbSBcIi4vcG9wcGVyLWxpdGUuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgKiBmcm9tIFwiLi9tb2RpZmllcnMvaW5kZXguanNcIjsiLCJpbXBvcnQgXCIuL3BvcHBlci1jb25maWdcIjtcclxuaW1wb3J0IHsgY3JlYXRlUG9wcGVyIH0gZnJvbSBcIkBwb3BwZXJqcy9jb3JlXCI7XHJcbmltcG9ydCB7IHVzZUdsb2JhbEhhbmRsZXIsIHVzZUxvZ2ljYWxEaXJlY3Rpb24sIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGF0ZSwgdXNlVGltZW91dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VQb3BwZXJBcGkoeyB1cGRhdGluZywgcG9zaXRpb24sIHNraWRkaW5nLCBkaXN0YW5jZSwgcGFkZGluZ1RvcCwgcGFkZGluZ0JvdHRvbSwgcGFkZGluZ0xlZnQsIHBhZGRpbmdSaWdodCB9KSB7XHJcbiAgICBjb25zdCBbcG9wcGVySW5zdGFuY2UsIHNldFBvcHBlckluc3RhbmNlLCBnZXRQb3BwZXJJbnN0YW5jZV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFt1c2VkUGxhY2VtZW50LCBzZXRVc2VkUGxhY2VtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgeyBlbGVtZW50OiBzb3VyY2VFbGVtZW50LCBnZXRFbGVtZW50OiBnZXRTb3VyY2VFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZVNvdXJjZUVsZW1lbnRSZWZQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgY29uc3QgeyBlbGVtZW50OiBwb3BwZXJFbGVtZW50LCBnZXRFbGVtZW50OiBnZXRQb3BwZXJFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZVBvcHBlckVsZW1lbnRSZWZQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgY29uc3QgeyBlbGVtZW50OiBhcnJvd0VsZW1lbnQsIGdldEVsZW1lbnQ6IGdldEFycm93RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VBcnJvd0VsZW1lbnRSZWZQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgY29uc3QgW3NvdXJjZVN0eWxlLCBzZXRTb3VyY2VTdHlsZV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtzb3VyY2VBdHRyaWJ1dGVzLCBzZXRTb3VyY2VBdHRyaWJ1dGVzXSA9IHVzZVN0YXRlKHt9KTtcclxuICAgIGNvbnN0IFtwb3BwZXJTdHlsZSwgc2V0UG9wcGVyU3R5bGVdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBbcG9wcGVyQXR0cmlidXRlcywgc2V0UG9wcGVyQXR0cmlidXRlc10gPSB1c2VTdGF0ZSh7fSk7XHJcbiAgICBjb25zdCBbYXJyb3dTdHlsZSwgc2V0QXJyb3dTdHlsZV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFthcnJvd0F0dHJpYnV0ZXMsIHNldEFycm93QXR0cmlidXRlc10gPSB1c2VTdGF0ZSh7fSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICh1cGRhdGluZykge1xyXG4gICAgICAgICAgICBsZXQgcmFmSGFuZGxlID0gMDtcclxuICAgICAgICAgICAgZnVuY3Rpb24gcmFmKCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHAgPSAoKGNsb3NlZCA/IFByb21pc2UucmVzb2x2ZSgpIDogZ2V0UG9wcGVySW5zdGFuY2UoKT8udXBkYXRlKCkpID8/IFByb21pc2UucmVzb2x2ZSgpKTtcclxuICAgICAgICAgICAgICAgIHAudGhlbihfID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFmSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmFmSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZik7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2luZ2xlLXRocmVhZGVkIGxhbmd1YWdlcyBhcmUgbmljZSBzb21ldGltZXMuXHJcbiAgICAgICAgICAgICAgICByYWZIYW5kbGUgPSAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt1cGRhdGluZ10pO1xyXG4gICAgY29uc3QgdXBkYXRlU3RhdGVNb2RpZmllciA9IHVzZU1lbW8oKCkgPT4ge1xyXG4gICAgICAgIGxldCBtb2RpZmllciA9IHtcclxuICAgICAgICAgICAgbmFtZTogXCJ1cGRhdGVTdGF0ZVwiLFxyXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICBwaGFzZTogXCJ3cml0ZVwiLFxyXG4gICAgICAgICAgICBmbjogKHsgc3RhdGUsIG9wdGlvbnMsIG5hbWUsIGluc3RhbmNlIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB1c2VkUGxhY2VtZW50ID0gc3RhdGUucGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZWRQbGFjZW1lbnQuaW5jbHVkZXMoXCItXCIpKVxyXG4gICAgICAgICAgICAgICAgICAgIHVzZWRQbGFjZW1lbnQgPSB1c2VkUGxhY2VtZW50LnN1YnN0cigwLCB1c2VkUGxhY2VtZW50LmluZGV4T2YoXCItXCIpKTtcclxuICAgICAgICAgICAgICAgIHNldFVzZWRQbGFjZW1lbnQodXNlZFBsYWNlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3R5bGVzLnJlZmVyZW5jZSlcclxuICAgICAgICAgICAgICAgICAgICBzZXRTb3VyY2VTdHlsZShzdGF0ZS5zdHlsZXMucmVmZXJlbmNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hdHRyaWJ1dGVzLnJlZmVyZW5jZSlcclxuICAgICAgICAgICAgICAgICAgICBzZXRTb3VyY2VBdHRyaWJ1dGVzKHN0YXRlLmF0dHJpYnV0ZXMucmVmZXJlbmNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdHlsZXMucG9wcGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFBvcHBlclN0eWxlKHN0YXRlLnN0eWxlcy5wb3BwZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFBvcHBlckF0dHJpYnV0ZXMoc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnN0eWxlcy5hcnJvdylcclxuICAgICAgICAgICAgICAgICAgICBzZXRBcnJvd1N0eWxlKHN0YXRlLnN0eWxlcy5hcnJvdyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYXR0cmlidXRlcy5hcnJvdylcclxuICAgICAgICAgICAgICAgICAgICBzZXRBcnJvd0F0dHJpYnV0ZXMoc3RhdGUuYXR0cmlidXRlcy5hcnJvdyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJjb21wdXRlU3R5bGVzXCIsIFwiZmxpcFwiXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVyO1xyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3QgeyBjb252ZXJ0RWxlbWVudFNpemUsIGdldExvZ2ljYWxEaXJlY3Rpb24gfSA9IHVzZUxvZ2ljYWxEaXJlY3Rpb24oc291cmNlRWxlbWVudCk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChzb3VyY2VFbGVtZW50ICYmIHBvcHBlckVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgb25GaXJzdFVwZGF0ZSA9ICgpID0+IHsgfTtcclxuICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBcImFic29sdXRlXCI7XHJcbiAgICAgICAgICAgIGxldCBwbGFjZW1lbnQgPSBsb2dpY2FsVG9QbGFjZW1lbnQoZ2V0TG9naWNhbERpcmVjdGlvbigpLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHNldFBvcHBlckluc3RhbmNlKGNyZWF0ZVBvcHBlcihzb3VyY2VFbGVtZW50LCBwb3BwZXJFbGVtZW50LCB7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllcnM6IFtcclxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiZmxpcFwiLCBvcHRpb25zOiB7fSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJwcmV2ZW50T3ZlcmZsb3dcIiwgb3B0aW9uczogeyBwYWRkaW5nOiB7IGJvdHRvbTogcGFkZGluZ0JvdHRvbSwgdG9wOiBwYWRkaW5nVG9wLCBsZWZ0OiBwYWRkaW5nTGVmdCwgcmlnaHQ6IHBhZGRpbmdSaWdodCB9IH0gfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdGF0ZU1vZGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJywgZW5hYmxlZDogZmFsc2UgfSxcclxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiYXBwbHlTdHlsZXNcIiwgZW5hYmxlZDogZmFsc2UgfSxcclxuICAgICAgICAgICAgICAgIF0sIG9uRmlyc3RVcGRhdGUsIHBsYWNlbWVudCwgc3RyYXRlZ3lcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtzb3VyY2VFbGVtZW50LCBwb3BwZXJFbGVtZW50LCBwb3NpdGlvbiwgc2tpZGRpbmcsIGRpc3RhbmNlLCBwYWRkaW5nVG9wLCBwYWRkaW5nQm90dG9tLCBwYWRkaW5nTGVmdCwgcGFkZGluZ1JpZ2h0XSk7XHJcbiAgICBmdW5jdGlvbiB1c2VQb3BwZXJTb3VyY2UoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlUG9wcGVyU291cmNlUHJvcHMocHJvcHMpIHtcclxuICAgICAgICAgICAgbGV0IHN0eWxlID0geyAuLi5zb3VyY2VTdHlsZSB9O1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKShzb3VyY2VBdHRyaWJ1dGVzLCB1c2VNZXJnZWRQcm9wcygpKHsgc3R5bGUgfSwgdXNlU291cmNlRWxlbWVudFJlZlByb3BzKHByb3BzKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1c2VQb3BwZXJTb3VyY2VQcm9wcyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXNlUG9wcGVyUG9wdXAoeyBvcGVuIH0pIHtcclxuICAgICAgICBmdW5jdGlvbiB1c2VQb3BwZXJQb3B1cFByb3BzKHByb3BzKSB7XHJcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHsgLi4ucG9wcGVyU3R5bGUsIHBvaW50ZXJFdmVudHM6IG9wZW4gPyB1bmRlZmluZWQgOiBcIm5vbmVcIiB9O1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKShwb3BwZXJBdHRyaWJ1dGVzLCB1c2VNZXJnZWRQcm9wcygpKHsgc3R5bGUgfSwgdXNlUG9wcGVyRWxlbWVudFJlZlByb3BzKHByb3BzKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1c2VQb3BwZXJQb3B1cFByb3BzIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1c2VQb3BwZXJBcnJvdygpIHtcclxuICAgICAgICBmdW5jdGlvbiB1c2VQb3BwZXJBcnJvd1Byb3BzKHByb3BzKSB7XHJcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHsgLi4uYXJyb3dTdHlsZSB9O1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKShwb3BwZXJBdHRyaWJ1dGVzLCB1c2VNZXJnZWRQcm9wcygpKHsgc3R5bGUgfSwgdXNlQXJyb3dFbGVtZW50UmVmUHJvcHMocHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZVBvcHBlckFycm93UHJvcHMgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHVzZVBvcHBlclNvdXJjZSwgdXNlUG9wcGVyUG9wdXAsIHVzZVBvcHBlckFycm93LCB1c2VkUGxhY2VtZW50LCBnZXRMb2dpY2FsRGlyZWN0aW9uIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHBsYWNlbWVudFRvTG9naWNhbChsb2dpY2FsRGlyZWN0aW9uLCBwbGFjZW1lbnQpIHtcclxuICAgIGNvbnN0IHsgYmxvY2tEaXJlY3Rpb24sIGJsb2NrT3JpZW50YXRpb24sIGlubGluZURpcmVjdGlvbiwgaW5saW5lT3JpZW50YXRpb24gfSA9IGxvZ2ljYWxEaXJlY3Rpb247XHJcbiAgICBsZXQgbG9naWNhbDtcclxuICAgIHN3aXRjaCAoYCR7aW5saW5lRGlyZWN0aW9ufS0ke2Jsb2NrRGlyZWN0aW9ufSwke3BsYWNlbWVudH1gKSB7XHJcbiAgICAgICAgLy8gVGhlcmUncyBhIHBhdHRlcm4sIGFuZCBpdCBjb3VsZCBiZSBjb2RlZCBhcyBhIHBhdHRlcm5cclxuICAgICAgICBjYXNlIFwibHRyLXR0Yix0b3BcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stc3RhcnRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImx0ci1idHQsYm90dG9tXCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLXN0YXJ0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJydGwtdHRiLHRvcFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1zdGFydFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwicnRsLWJ0dCxib3R0b21cIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stc3RhcnRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInR0Yi1sdHIsbGVmdFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1zdGFydFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiYnR0LWx0cixyaWdodFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1zdGFydFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwidHRiLXJ0bCxsZWZ0XCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLXN0YXJ0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJidHQtcnRsLHJpZ2h0XCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLXN0YXJ0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJsdHItdHRiLGJvdHRvbVwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1lbmRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInJ0bC10dGIsYm90dG9tXCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwibHRyLWJ0dCx0b3BcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stZW5kXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJydGwtYnR0LHRvcFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1lbmRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInR0Yi1sdHIscmlnaHRcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stZW5kXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJ0dGItcnRsLHJpZ2h0XCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiYnR0LWx0cixsZWZ0XCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiYnR0LXJ0bCxsZWZ0XCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwidHRiLWx0cix0b3BcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLXN0YXJ0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJ0dGItcnRsLHRvcFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtc3RhcnRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImJ0dC1sdHIsYm90dG9tXCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1zdGFydFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiYnR0LXJ0bCxib3R0b21cIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLXN0YXJ0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJsdHItdHRiLGxlZnRcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLXN0YXJ0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJydGwtdHRiLGxlZnRcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLXN0YXJ0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJsdHItYnR0LHJpZ2h0XCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1zdGFydFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwicnRsLWJ0dCxyaWdodFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtc3RhcnRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInR0Yi1sdHIsYm90dG9tXCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1lbmRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInR0Yi1ydGwsYm90dG9tXCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1lbmRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImJ0dC1sdHIsdG9wXCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1lbmRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImJ0dC1ydGwsdG9wXCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1lbmRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImx0ci10dGIscmlnaHRcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwicnRsLXR0YixyaWdodFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtZW5kXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJsdHItYnR0LGxlZnRcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwicnRsLWJ0dCxsZWZ0XCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1lbmRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gU2hvdWxkbid0IGhhcHBlbiwgYnV0IGhlcmUgZm9yIHR5cGUgY29ycmVjdG5lc3MuXHJcbiAgICAgICAgY2FzZSBcInR0Yi10dGIsYm90dG9tXCI6XHJcbiAgICAgICAgY2FzZSBcInR0Yi10dGIsdG9wXCI6XHJcbiAgICAgICAgY2FzZSBcImJ0dC1idHQsYm90dG9tXCI6XHJcbiAgICAgICAgY2FzZSBcImJ0dC1idHQsdG9wXCI6XHJcbiAgICAgICAgY2FzZSBcImx0ci1sdHIsYm90dG9tXCI6XHJcbiAgICAgICAgY2FzZSBcImx0ci1sdHIsdG9wXCI6XHJcbiAgICAgICAgY2FzZSBcInJ0bC1ydGwsYm90dG9tXCI6XHJcbiAgICAgICAgY2FzZSBcInJ0bC1ydGwsdG9wXCI6XHJcbiAgICAgICAgY2FzZSBcInR0Yi1idHQsYm90dG9tXCI6XHJcbiAgICAgICAgY2FzZSBcImJ0dC10dGIsdG9wXCI6XHJcbiAgICAgICAgY2FzZSBcImJ0dC10dGIsYm90dG9tXCI6XHJcbiAgICAgICAgY2FzZSBcInR0Yi1idHQsdG9wXCI6XHJcbiAgICAgICAgY2FzZSBcImx0ci1ydGwsYm90dG9tXCI6XHJcbiAgICAgICAgY2FzZSBcInJ0bC1sdHIsdG9wXCI6XHJcbiAgICAgICAgY2FzZSBcInJ0bC1sdHIsYm90dG9tXCI6XHJcbiAgICAgICAgY2FzZSBcImx0ci1ydGwsdG9wXCI6XHJcbiAgICAgICAgY2FzZSBcInR0Yi10dGIscmlnaHRcIjpcclxuICAgICAgICBjYXNlIFwidHRiLXR0YixsZWZ0XCI6XHJcbiAgICAgICAgY2FzZSBcImJ0dC1idHQscmlnaHRcIjpcclxuICAgICAgICBjYXNlIFwiYnR0LWJ0dCxsZWZ0XCI6XHJcbiAgICAgICAgY2FzZSBcImx0ci1sdHIscmlnaHRcIjpcclxuICAgICAgICBjYXNlIFwibHRyLWx0cixsZWZ0XCI6XHJcbiAgICAgICAgY2FzZSBcInJ0bC1ydGwscmlnaHRcIjpcclxuICAgICAgICBjYXNlIFwicnRsLXJ0bCxsZWZ0XCI6XHJcbiAgICAgICAgY2FzZSBcInR0Yi1idHQscmlnaHRcIjpcclxuICAgICAgICBjYXNlIFwiYnR0LXR0YixsZWZ0XCI6XHJcbiAgICAgICAgY2FzZSBcImJ0dC10dGIscmlnaHRcIjpcclxuICAgICAgICBjYXNlIFwidHRiLWJ0dCxsZWZ0XCI6XHJcbiAgICAgICAgY2FzZSBcImx0ci1ydGwscmlnaHRcIjpcclxuICAgICAgICBjYXNlIFwicnRsLWx0cixsZWZ0XCI6XHJcbiAgICAgICAgY2FzZSBcInJ0bC1sdHIscmlnaHRcIjpcclxuICAgICAgICBjYXNlIFwibHRyLXJ0bCxsZWZ0XCI6XHJcbiAgICAgICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgICAgICBsb2dpY2FsID0gbG9naWNhbDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9naWNhbDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gbG9naWNhbFRvUGxhY2VtZW50KGxvZ2ljYWxEaXJlY3Rpb24sIHBvc2l0aW9uKSB7XHJcbiAgICBsZXQgcGxhY2VtZW50O1xyXG4gICAgY29uc3QgeyBibG9ja0RpcmVjdGlvbiwgYmxvY2tPcmllbnRhdGlvbiwgaW5saW5lRGlyZWN0aW9uLCBpbmxpbmVPcmllbnRhdGlvbiB9ID0gbG9naWNhbERpcmVjdGlvbjtcclxuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJibG9jay1zdGFydFwiIHx8IHBvc2l0aW9uID09IFwiYmxvY2stZW5kXCIpIHtcclxuICAgICAgICBzd2l0Y2ggKGAke3Bvc2l0aW9ufS0ke2Jsb2NrRGlyZWN0aW9ufWApIHtcclxuICAgICAgICAgICAgY2FzZSBcImJsb2NrLXN0YXJ0LXR0YlwiOlxyXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJ0b3BcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stZW5kLWJ0dFwiOlxyXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJ0b3BcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stc3RhcnQtYnR0XCI6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcImJvdHRvbVwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1lbmQtdHRiXCI6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcImJvdHRvbVwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1zdGFydC1sdHJcIjpcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1lbmQtcnRsXCI6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stZW5kLWx0clwiOlxyXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1zdGFydC1ydGxcIjpcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJib3R0b21cIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN3aXRjaCAoYCR7cG9zaXRpb259LSR7aW5saW5lRGlyZWN0aW9ufWApIHtcclxuICAgICAgICAgICAgY2FzZSBcImlubGluZS1zdGFydC1sdHJcIjpcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtZW5kLXJ0bFwiOlxyXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImlubGluZS1lbmQtbHRyXCI6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImlubGluZS1zdGFydC1ydGxcIjpcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLXN0YXJ0LXR0YlwiOlxyXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJ0b3BcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLWVuZC1idHRcIjpcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwidG9wXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImlubGluZS1lbmQtdHRiXCI6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcImJvdHRvbVwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtc3RhcnQtYnR0XCI6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcImJvdHRvbVwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGxhY2VtZW50O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTaG91bGRVcGRhdGVQb3BwZXIob3BlbiwgZWxlbWVudFNpemUpIHtcclxuICAgIC8vIFNpbmNlIHNjcm9sbCBldmVudHMgYXJlIGFzeW5jaHJvbm91cywgZXNwZWNpYWxseSBvbiBpT1MgZGV2aWNlcyxcclxuICAgIC8vIGp1c3QgbWFudWFsbHkgYWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGZvciBhIGJpdFxyXG4gICAgLy8gYW55IHRpbWUgYmFzaWNhbGx5IGFueSB1c2VyIGludGVyYWN0aW9uIGhhcHBlbnMuXHJcbiAgICBjb25zdCBbdXBkYXRpbmdGb3JBQml0LCBzZXRVcGRhdGluZ0ZvckFCaXRdID0gdXNlU3RhdGUoMCk7XHJcbiAgICB1c2VUaW1lb3V0KHsgY2FsbGJhY2s6ICgpID0+IHsgc2V0VXBkYXRpbmdGb3JBQml0KDApOyB9LCB0aW1lb3V0OiAxMDAsIHRyaWdnZXJJbmRleDogdXBkYXRpbmdGb3JBQml0IH0pO1xyXG4gICAgbGV0IG9uSW50ZXJhY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7IHNldFVwZGF0aW5nRm9yQUJpdCh1ID0+ICsrdSk7IH0sIFtjbG9zZWRdKTtcclxuICAgIGlmICghb3BlbilcclxuICAgICAgICBvbkludGVyYWN0aW9uID0gbnVsbDtcclxuICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwia2V5ZG93blwiLCBvbkludGVyYWN0aW9uLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSk7XHJcbiAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJjbGlja1wiLCBvbkludGVyYWN0aW9uLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSk7XHJcbiAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJzY3JvbGxcIiwgb3BlbiA/IG9uSW50ZXJhY3Rpb24gOiBudWxsLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSk7XHJcbiAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJwb2ludGVybW92ZVwiLCBvcGVuID8gb25JbnRlcmFjdGlvbiA6IG51bGwsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcInJlc2l6ZVwiLCBvcGVuID8gb25JbnRlcmFjdGlvbiA6IG51bGwsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7IG9uSW50ZXJhY3Rpb24/LigpOyB9LCBPYmplY3QudmFsdWVzKGVsZW1lbnRTaXplID8/IHt9KSk7XHJcbiAgICByZXR1cm4geyBzaG91bGRVcGRhdGU6ICEhdXBkYXRpbmdGb3JBQml0LCBvbkludGVyYWN0aW9uIH07XHJcbn1cclxuLyoqXHJcbiAqIEhhbmRsZSB0aGUgZS5nLiB6b29tT3JpZ2luRHluYW1pYyBwcm9wcywgdG8gdHVybiB0aGVtIGludG8gem9vbU9yaWdpbklubGluZSBvciB6b29tT3JpZ2luQmxvY2sgYXMgYXBwcm9wcmlhdGUuXHJcbiAqIFRPRE86IFJpZ2h0IG5vdywgYWxsICpEeW5hbWljIHByb3BzIGFyZSBqdXN0IGhhbmRsZWQgYXMgMSAtIHByb3AuIFNvbWUgcHJvYmFibHkgbmVlZCB0byBiZSAtMSAqIHByb3AgdGhvdWdoLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpeFByb3BzKGxvZ2ljYWxEaXJlY3Rpb24sIHJlcXVlc3RlZFBsYWNlbWVudCwgdXNlZFBsYWNlbWVudCwgcHJvcHMpIHtcclxuICAgIGxldCBsb2dpY2FsU25ha2UgPSBwbGFjZW1lbnRUb0xvZ2ljYWwobG9naWNhbERpcmVjdGlvbiwgdXNlZFBsYWNlbWVudCk7XHJcbiAgICBsZXQgcHJvcEF4aXM7XHJcbiAgICBsZXQgcmV2ZXJzZTtcclxuICAgIHN3aXRjaCAobG9naWNhbFNuYWtlKSB7XHJcbiAgICAgICAgY2FzZSBcImJsb2NrLXN0YXJ0XCI6XHJcbiAgICAgICAgICAgIHByb3BBeGlzID0gXCJCbG9ja1wiO1xyXG4gICAgICAgICAgICByZXZlcnNlID0gKHJlcXVlc3RlZFBsYWNlbWVudCA9PSBcImJsb2NrLWVuZFwiKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImJsb2NrLWVuZFwiOlxyXG4gICAgICAgICAgICBwcm9wQXhpcyA9IFwiQmxvY2tcIjtcclxuICAgICAgICAgICAgcmV2ZXJzZSA9IChyZXF1ZXN0ZWRQbGFjZW1lbnQgPT0gXCJibG9jay1zdGFydFwiKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImlubGluZS1zdGFydFwiOlxyXG4gICAgICAgICAgICBwcm9wQXhpcyA9IFwiSW5saW5lXCI7XHJcbiAgICAgICAgICAgIHJldmVyc2UgPSAocmVxdWVzdGVkUGxhY2VtZW50ID09IFwiaW5saW5lLWVuZFwiKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImlubGluZS1lbmRcIjpcclxuICAgICAgICAgICAgcHJvcEF4aXMgPSBcIklubGluZVwiO1xyXG4gICAgICAgICAgICByZXZlcnNlID0gKHJlcXVlc3RlZFBsYWNlbWVudCA9PSBcImlubGluZS1zdGFydFwiKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBsZXQgbmV3UHJvcHMgPSB7IC4uLnByb3BzIH07XHJcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wcykge1xyXG4gICAgICAgIGlmIChwcm9wTmFtZS5lbmRzV2l0aChcIkR5bmFtaWNcIikgJiYgdHlwZW9mIHByb3BzW3Byb3BOYW1lXSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBsZXQgbmV3UHJvcE5hbWUgPSBgJHtwcm9wTmFtZS5zdWJzdHIoMCwgcHJvcE5hbWUuaW5kZXhPZihcIkR5bmFtaWNcIikpfSR7cHJvcEF4aXN9YDtcclxuICAgICAgICAgICAgbmV3UHJvcHNbbmV3UHJvcE5hbWVdID0gKCFyZXZlcnNlID8gbmV3UHJvcHNbcHJvcE5hbWVdIDogMSAtIG5ld1Byb3BzW3Byb3BOYW1lXSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1Byb3BzO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci1hcGkuanMubWFwIiwiaW1wb3J0IHsgY2xvbmVFbGVtZW50LCBjcmVhdGVDb250ZXh0LCBGcmFnbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQXJpYU1lbnUgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0c1wiO1xyXG5pbXBvcnQgeyB1c2VFbGVtZW50U2l6ZSwgdXNlTWVyZ2VkUHJvcHMsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgQm9keVBvcnRhbCB9IGZyb20gXCIuLi9wb3J0YWxcIjtcclxuaW1wb3J0IHsgZml4UHJvcHMsIHVzZVBvcHBlckFwaSwgdXNlU2hvdWxkVXBkYXRlUG9wcGVyIH0gZnJvbSBcIi4vcG9wcGVyLWFwaVwiO1xyXG5mdW5jdGlvbiBmb28ocGxhY2VtZW50LCBwcm9wcykge1xyXG59XHJcbmNvbnN0IE9uQ2xvc2VDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xyXG5jb25zdCBVc2VNZW51SXRlbUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG5leHBvcnQgZnVuY3Rpb24gTWVudSh7IGFuY2hvciwgYW5jaG9yVGFnLCBjaGlsZHJlbiwgdGFnLCBUcmFuc2l0aW9uLCAuLi5yZXN0IH0pIHtcclxuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IG9uQ2xvc2UgPSB1c2VDYWxsYmFjaygoKSA9PiBzZXRPcGVuKGZhbHNlKSwgW10pO1xyXG4gICAgY29uc3Qgb25PcGVuID0gKCkgPT4gc2V0T3Blbih0cnVlKTtcclxuICAgIGNvbnN0IHsgdXNlRWxlbWVudFNpemVQcm9wcywgZWxlbWVudFNpemUgfSA9IHVzZUVsZW1lbnRTaXplKCk7XHJcbiAgICBjb25zdCB7IHNob3VsZFVwZGF0ZTogdXBkYXRpbmdGb3JBQml0LCBvbkludGVyYWN0aW9uIH0gPSB1c2VTaG91bGRVcGRhdGVQb3BwZXIob3BlbiwgZWxlbWVudFNpemUpO1xyXG4gICAgY29uc3QgeyB1c2VQb3BwZXJBcnJvdywgdXNlUG9wcGVyUG9wdXAsIHVzZVBvcHBlclNvdXJjZSwgdXNlZFBsYWNlbWVudCwgZ2V0TG9naWNhbERpcmVjdGlvbiB9ID0gdXNlUG9wcGVyQXBpKHsgcG9zaXRpb246IFwiYmxvY2stZW5kXCIsIHVwZGF0aW5nOiB1cGRhdGluZ0ZvckFCaXQgfSk7XHJcbiAgICBjb25zdCB7IHVzZU1lbnVCdXR0b24sIHVzZU1lbnVJdGVtLCB1c2VNZW51SXRlbUNoZWNrYm94LCB1c2VNZW51UHJvcHMsIHVzZU1lbnVTdWJtZW51SXRlbSwgZm9jdXNNZW51IH0gPSB1c2VBcmlhTWVudSh7IG9wZW4sIG9uQ2xvc2UsIG9uT3BlbiB9KTtcclxuICAgIGNvbnN0IHsgdXNlTWVudUJ1dHRvblByb3BzIH0gPSB1c2VNZW51QnV0dG9uKHsgdGFnOiBhbmNob3JUYWcgPz8gXCJidXR0b25cIiB9KTtcclxuICAgIGNvbnN0IHsgdXNlUG9wcGVyU291cmNlUHJvcHMgfSA9IHVzZVBvcHBlclNvdXJjZSgpO1xyXG4gICAgY29uc3QgeyB1c2VQb3BwZXJQb3B1cFByb3BzIH0gPSB1c2VQb3BwZXJQb3B1cCh7IG9wZW4gfSk7XHJcbiAgICBjb25zdCB7IHVzZVBvcHBlckFycm93UHJvcHMgfSA9IHVzZVBvcHBlckFycm93KCk7XHJcbiAgICAvKmNvbnN0IFtzZW50aW5lbEZvY3VzZWQsIHNldFNlbnRpbmVsRm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICB1c2VUaW1lb3V0KHsgY2FsbGJhY2s6ICgpID0+IHsgaWYgKHNlbnRpbmVsRm9jdXNlZCkgb25DbG9zZSgpOyBzZXRTZW50aW5lbEZvY3VzZWQoZmFsc2UpOyB9LCB0aW1lb3V0OiAxMDAwLCB0cmlnZ2VySW5kZXg6IHNlbnRpbmVsRm9jdXNlZC50b1N0cmluZygpIH0pKi9cclxuICAgIGNvbnN0IFtmaXJzdFNlbnRpbmVsSXNBY3RpdmUsIHNldEZpcnN0U2VudGluZWxJc0FjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICB1c2VUaW1lb3V0KHsgY2FsbGJhY2s6ICgpID0+IHsgc2V0Rmlyc3RTZW50aW5lbElzQWN0aXZlKG9wZW4pOyB9LCB0aW1lb3V0OiAxMDAsIHRyaWdnZXJJbmRleDogYCR7Zmlyc3RTZW50aW5lbElzQWN0aXZlfWAgfSk7XHJcbiAgICBjb25zdCBtZW51Q2hpbGRyZW4gPSAoaChGcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlUG9wcGVyQXJyb3dQcm9wcyh7fSkgfSksXHJcbiAgICAgICAgaChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogXCJ2aXN1YWxseS1oaWRkZW5cIiwgb25Gb2N1czogIWZpcnN0U2VudGluZWxJc0FjdGl2ZSA/ICgpID0+IGZvY3VzTWVudT8uKCkgOiAoKSA9PiBvbkNsb3NlKCksIG9uQ2xpY2s6IG9uQ2xvc2UgfSwgXCJDbG9zZSBtZW51XCIpLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGgoXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IFwidmlzdWFsbHktaGlkZGVuXCIsIG9uRm9jdXM6IG9uQ2xvc2UsIG9uQ2xpY2s6IG9uQ2xvc2UgfSwgXCJDbG9zZSBtZW51XCIpKSk7XHJcbiAgICBjb25zdCBsb2dpY2FsRGlyZWN0aW9uID0gZ2V0TG9naWNhbERpcmVjdGlvbigpO1xyXG4gICAgaWYgKGxvZ2ljYWxEaXJlY3Rpb24gJiYgdXNlZFBsYWNlbWVudClcclxuICAgICAgICByZXN0ID0gZml4UHJvcHMobG9naWNhbERpcmVjdGlvbiwgXCJibG9jay1lbmRcIiwgdXNlZFBsYWNlbWVudCwgcmVzdCk7XHJcbiAgICByZXR1cm4gKGgoRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgaChPbkNsb3NlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogb25DbG9zZSB9LFxyXG4gICAgICAgICAgICBoKFVzZU1lbnVJdGVtQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlTWVudUl0ZW0gfSxcclxuICAgICAgICAgICAgICAgIGNsb25lRWxlbWVudChhbmNob3IsIHVzZU1lcmdlZFByb3BzKCkodXNlRWxlbWVudFNpemVQcm9wcyh7IHJlZjogYW5jaG9yLnJlZiwgY2xhc3M6IGBkcm9wZG93bi10b2dnbGUgJHtvcGVuID8gXCJhY3RpdmVcIiA6IFwiXCJ9YCB9KSwgdXNlUG9wcGVyU291cmNlUHJvcHModXNlTWVudUJ1dHRvblByb3BzKGFuY2hvci5wcm9wcykpKSksXHJcbiAgICAgICAgICAgICAgICBoKEJvZHlQb3J0YWwsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IC4uLnVzZVBvcHBlclBvcHVwUHJvcHMoeyBjbGFzczogXCJkcm9wZG93bi1tZW51LXBvcHBlclwiIH0pIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoVHJhbnNpdGlvbiwgeyAuLi51c2VNZW51UHJvcHMocmVzdCksIG9wZW46IG9wZW4sIG9uVHJhbnNpdGlvblVwZGF0ZTogb25JbnRlcmFjdGlvbiwgZXhpdFZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgbnVsbCwgaCh0YWcsIHsgY2hpbGRyZW46IG1lbnVDaGlsZHJlbiwgY2xhc3NOYW1lOiBcImRyb3Bkb3duLW1lbnVcIiB9KSkpKSkpKSkpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBNZW51SXRlbSh7IGNoaWxkcmVuLCBpbmRleCwgLi4ucmVzdCB9KSB7XHJcbiAgICBjb25zdCB1c2VNZW51SXRlbSA9IHVzZUNvbnRleHQoVXNlTWVudUl0ZW1Db250ZXh0KTtcclxuICAgIGNvbnN0IFt0ZXh0LCBzZXRUZXh0XSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgIHNldFRleHQoZWxlbWVudC5pbm5lclRleHQpO1xyXG4gICAgfSwgW2VsZW1lbnRdKTtcclxuICAgIGNvbnN0IHsgdXNlTWVudUl0ZW1Qcm9wcyB9ID0gdXNlTWVudUl0ZW0oeyBpbmRleCwgdGV4dCB9KTtcclxuICAgIHJldHVybiAoaChcImxpXCIsIG51bGwsXHJcbiAgICAgICAgaChcImJ1dHRvblwiLCB7IC4uLnVzZU1lbnVJdGVtUHJvcHModXNlUmVmRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzKCkocmVzdCwgeyBjbGFzczogXCJkcm9wZG93bi1pdGVtXCIgfSkpKSB9LCBjaGlsZHJlbikpKTtcclxufVxyXG5mdW5jdGlvbiBmbGlwVHJhbnNpdGlvbkNvbXBvbmVudChpbnB1dCwgeyBpbmxpbmUsIGJsb2NrIH0pIHtcclxuICAgIGxldCBvdXRwdXQgPSB7IC4uLmlucHV0IH07XHJcbiAgICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIG91dHB1dCkge1xyXG4gICAgICAgIGlmIChvdXRwdXRbYCR7cHJvcE5hbWV9RmxpcHNgXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBsZXQgbCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzSW5saW5lID0gbC5pbmNsdWRlcyhcImlubGluZVwiKTtcclxuICAgICAgICAgICAgY29uc3QgaXNCbG9jayA9IGwuaW5jbHVkZXMoXCJibG9ja1wiKTtcclxuICAgICAgICAgICAgaWYgKChpc0lubGluZSAmJiBpbmxpbmUpIHx8IChpc0Jsb2NrICYmIGJsb2NrKSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG91dHB1dFtgJHtwcm9wTmFtZX1GbGlwc2BdO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0W3Byb3BOYW1lXSA9IC1pbnB1dFtwcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbnUuanMubWFwIiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgaCwgY3JlYXRlQ29udGV4dCwgY2xvbmVFbGVtZW50IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VBcmlhVGFicyB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzXCI7XHJcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHMvcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQXN5bmNIYW5kbGVyIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IFN3YXBwYWJsZSB9IGZyb20gXCJwcmVhY3QtdHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5jb25zdCBVc2VUYWJDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuY29uc3QgVXNlVGFiUGFuZWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuZXhwb3J0IGZ1bmN0aW9uIFRhYnMoeyBvblNlbGVjdDogb25TZWxlY3RBc3luYywgb3JpZW50YXRpb24sIHNlbGVjdGVkSW5kZXgsIHNlbGVjdGlvbk1vZGUsIHRhZywgY2hpbGRyZW4sIHZpc3VhbFZhcmlhbnQsIC4uLnByb3BzIH0pIHtcclxuICAgIGNvbnN0IGNhcHR1cmUgPSAoZSkgPT4geyByZXR1cm4gZVtFdmVudERldGFpbF0uc2VsZWN0ZWRJbmRleDsgfTtcclxuICAgIG9yaWVudGF0aW9uID8/PSBcImlubGluZVwiO1xyXG4gICAgY29uc3QgeyBnZXRTeW5jSGFuZGxlciB9ID0gdXNlQXN5bmNIYW5kbGVyKCkoeyBjYXB0dXJlOiBjYXB0dXJlIH0pO1xyXG4gICAgY29uc3Qgb25TZWxlY3QgPSBnZXRTeW5jSGFuZGxlcihvblNlbGVjdEFzeW5jKTtcclxuICAgIGNvbnN0IHsgdXNlVGFiLCB1c2VUYWJQYW5lbCwgdXNlVGFic0xhYmVsLCB1c2VUYWJzTGlzdCB9ID0gdXNlQXJpYVRhYnMoeyBvblNlbGVjdCwgc2VsZWN0ZWRJbmRleCwgc2VsZWN0aW9uTW9kZSwgb3JpZW50YXRpb24gfSk7XHJcbiAgICBjb25zdCB7IHVzZVRhYkxpc3RQcm9wcyB9ID0gdXNlVGFic0xpc3QoKTtcclxuICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBjbHN4KFwidGFicy1jb250YWluZXJcIiwgYHRhYnMtb3JpZW50YXRpb24tJHtvcmllbnRhdGlvbn1gKSB9LFxyXG4gICAgICAgIGgoVXNlVGFiQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlVGFiIH0sIGNsb25lRWxlbWVudChjaGlsZHJlblswXSwgdXNlVGFiTGlzdFByb3BzKHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzc05hbWU6IGNsc3goXCJuYXZcIiwgdmlzdWFsVmFyaWFudCA9PSBcInBpbGxzXCIgPyBcIm5hdi1waWxsc1wiIDogXCJuYXYtdGFic1wiKSB9LCB7IC4uLnByb3BzIH0pKSwgY2hpbGRyZW5bMF0ucHJvcHMuY2hpbGRyZW4pKSxcclxuICAgICAgICBoKFVzZVRhYlBhbmVsQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlVGFiUGFuZWwgfSxcclxuICAgICAgICAgICAgaChTd2FwcGFibGUsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3M6IFwidGFiLWNvbnRlbnRcIiB9LCBjaGlsZHJlbi5zbGljZSgxKSkpKSkpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBUYWIoeyBpbmRleCwgY2hpbGRyZW4sIC4uLnByb3BzIH0pIHtcclxuICAgIGNvbnN0IHVzZVRhYkNvbnRleHQgPSB1c2VDb250ZXh0KFVzZVRhYkNvbnRleHQpO1xyXG4gICAgY29uc3QgeyB1c2VUYWJQcm9wcywgc2VsZWN0ZWQgfSA9IHVzZVRhYkNvbnRleHQoeyBpbmRleCwgdGV4dDogbnVsbCwgdGFnOiBcImJ1dHRvblwiIH0pO1xyXG4gICAgcmV0dXJuIGgoXCJsaVwiLCB7IGNsYXNzTmFtZTogXCJuYXYtaXRlbVwiLCByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sXHJcbiAgICAgICAgaChcImJ1dHRvblwiLCB7IC4uLnVzZVRhYlByb3BzKHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzczogY2xzeChgbmF2LWxpbmtgLCBzZWxlY3RlZCAmJiBgYWN0aXZlYCkgfSwgcHJvcHMpKSB9LCBjaGlsZHJlbikpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBUYWJQYW5lbCh7IGluZGV4LCBjaGlsZHJlbiwgVHJhbnNpdGlvbiwgLi4ucmVzdCB9KSB7XHJcbiAgICBjb25zdCB1c2VUYWJQYW5lbCA9IHVzZUNvbnRleHQoVXNlVGFiUGFuZWxDb250ZXh0KTtcclxuICAgIGNvbnN0IHsgdXNlVGFiUGFuZWxQcm9wcywgc2VsZWN0ZWQgfSA9IHVzZVRhYlBhbmVsKHsgaW5kZXggfSk7XHJcbiAgICByZXR1cm4gaChUcmFuc2l0aW9uLCB1c2VUYWJQYW5lbFByb3BzKHsgY2xhc3M6IFwiXCIsIG9wZW46IHNlbGVjdGVkLCBjaGlsZHJlbiwgLi4ucmVzdCB9KSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFicy5qcy5tYXAiLCJpbXBvcnQgeyBCdXR0b24gfSBmcm9tIFwiLi4vYnV0dG9uL2J1dHRvblwiO1xyXG5pbXBvcnQgeyBCb2R5UG9ydGFsIH0gZnJvbSBcIi4uL3BvcnRhbFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBGcmFnbWVudCwgaCwgY2xvbmVFbGVtZW50IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBnZW5lcmF0ZVJhbmRvbUlkIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXJhbmRvbS1pZFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBTbGlkZUZhZGUgfSBmcm9tIFwicHJlYWN0LXRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgdXNlVG9hc3RzIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHNcIjtcclxuY29uc3QgUHVzaFRvYXN0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmNvbnN0IERlZmF1bHRUb2FzdFRpbWVvdXQgPSBjcmVhdGVDb250ZXh0KDUwMDApO1xyXG5leHBvcnQgZnVuY3Rpb24gVG9hc3RzUHJvdmlkZXIoeyBjaGlsZHJlbiwgZGVmYXVsdFRpbWVvdXQgfSkge1xyXG4gICAgY29uc3QgW3B1c2hUb2FzdCwgc2V0UHVzaFRvYXN0XSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgcHVzaFRvYXN0U3RhYmxlID0gdXNlU3RhYmxlQ2FsbGJhY2soKHRvYXN0KSA9PiB7XHJcbiAgICAgICAgcHVzaFRvYXN0Py4odG9hc3QpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gKGgoRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgaChEZWZhdWx0VG9hc3RUaW1lb3V0LlByb3ZpZGVyLCB7IHZhbHVlOiBkZWZhdWx0VGltZW91dCA/PyA1MDAwIH0sXHJcbiAgICAgICAgICAgIGgoVG9hc3RzUHJvdmlkZXJIZWxwZXIsIHsgc2V0UHVzaFRvYXN0OiBzZXRQdXNoVG9hc3QgfSksXHJcbiAgICAgICAgICAgIHB1c2hUb2FzdCAmJiBoKFB1c2hUb2FzdENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHB1c2hUb2FzdFN0YWJsZSB9LCBjaGlsZHJlbikpKSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVB1c2hUb2FzdCgpIHtcclxuICAgIGNvbnN0IHB1c2hUb2FzdCA9IHVzZUNvbnRleHQoUHVzaFRvYXN0Q29udGV4dCk7XHJcbiAgICByZXR1cm4gcHVzaFRvYXN0O1xyXG59XHJcbi8vIEV4dHJhY3RlZCB0byBhIHNlcGFyYXRlIGNvbXBvbmVudCB0byBhdm9pZCByZXJlbmRlcmluZyBhbGwgbm9uLXRvYXN0IGNoaWxkcmVuXHJcbmZ1bmN0aW9uIFRvYXN0c1Byb3ZpZGVySGVscGVyKHsgc2V0UHVzaFRvYXN0IH0pIHtcclxuICAgIGNvbnN0IFtjaGlsZHJlbiwgc2V0Q2hpbGRyZW5dID0gdXNlU3RhdGUoW10pO1xyXG4gICAgY29uc3QgcHVzaFRvYXN0ID0gdXNlQ2FsbGJhY2soKHRvYXN0KSA9PiB7IGNvbnN0IHJhbmRvbUtleSA9IGdlbmVyYXRlUmFuZG9tSWQoKTsgc2V0Q2hpbGRyZW4ocHJldiA9PiAoWy4uLnByZXYsIGNsb25lRWxlbWVudCh0b2FzdCwgeyBrZXk6IHJhbmRvbUtleSB9KV0pKTsgfSwgW10pO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgc2V0UHVzaFRvYXN0KF8gPT4gcHVzaFRvYXN0KTsgfSwgW3B1c2hUb2FzdF0pO1xyXG4gICAgcmV0dXJuIChoKEJvZHlQb3J0YWwsIG51bGwsXHJcbiAgICAgICAgaChUb2FzdHNDb250YWluZXJDaGlsZHJlbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNoaWxkcmVuIH0sXHJcbiAgICAgICAgICAgIGgoVG9hc3RzQ29udGFpbmVyLCBudWxsKSkpKTtcclxufVxyXG5jb25zdCBUb2FzdHNDb250YWluZXJDaGlsZHJlbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KFtdKTtcclxuY29uc3QgVXNlVG9hc3RDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuZnVuY3Rpb24gVG9hc3RzQ29udGFpbmVyKHByb3BzKSB7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHVzZUNvbnRleHQoVG9hc3RzQ29udGFpbmVyQ2hpbGRyZW5Db250ZXh0KTtcclxuICAgIGNvbnN0IHsgdXNlVG9hc3QsIHVzZVRvYXN0Q29udGFpbmVyUHJvcHMgfSA9IHVzZVRvYXN0cyhwcm9wcyk7XHJcbiAgICByZXR1cm4gKGgoVXNlVG9hc3RDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VUb2FzdCB9LFxyXG4gICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VUb2FzdENvbnRhaW5lclByb3BzKHByb3BzKSB9LCBjaGlsZHJlbikpKTtcclxufVxyXG5jb25zdCBUb2FzdERpc21pc3NDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuZXhwb3J0IGZ1bmN0aW9uIFRvYXN0KHsgdGltZW91dCwgcG9saXRlbmVzcywgY2hpbGRyZW4gfSkge1xyXG4gICAgY29uc3QgdXNlVG9hc3QgPSB1c2VDb250ZXh0KFVzZVRvYXN0Q29udGV4dCk7XHJcbiAgICBjb25zdCBkZWZhdWx0VGltZW91dCA9IHVzZUNvbnRleHQoRGVmYXVsdFRvYXN0VGltZW91dCk7XHJcbiAgICBjb25zdCB7IHVzZVRvYXN0UHJvcHMsIGRpc21pc3MsIHN0YXR1cyB9ID0gdXNlVG9hc3QoeyB0aW1lb3V0OiB0aW1lb3V0ID8/IGRlZmF1bHRUaW1lb3V0LCBwb2xpdGVuZXNzIH0pO1xyXG4gICAgcmV0dXJuIChoKFRvYXN0RGlzbWlzc0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGRpc21pc3MgfSxcclxuICAgICAgICBoKFNsaWRlRmFkZSwgeyBvcGVuOiBzdGF0dXMgIT0gXCJkaXNtaXNzZWRcIiwgc2xpZGVUYXJnZXRJbmxpbmU6IDEsIGFuaW1hdGVPbk1vdW50OiB0cnVlLCBleGl0VmlzaWJpbGl0eTogXCJyZW1vdmVkXCIgfSxcclxuICAgICAgICAgICAgaChcImRpdlwiLCB7IC4uLnVzZVRvYXN0UHJvcHMoeyBjbGFzczogXCJ0b2FzdCBzaG93XCIgfSkgfSxcclxuICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJkLWZsZXhcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJ0b2FzdC1ib2R5XCIgfSwgY2hpbGRyZW4pLFxyXG4gICAgICAgICAgICAgICAgICAgIGgoQnV0dG9uLCB7IGNsYXNzOiBcImJ0bi1jbG9zZSBtZS0yIG0tYXV0b1wiLCBcImFyaWEtbGFiZWxcIjogXCJEaXNtaXNzIGFsZXJ0XCIsIG9uQ2xpY2s6IGRpc21pc3MgfSkpKSkpKTtcclxufVxyXG4vKlxyXG5leHBvcnQgZnVuY3Rpb24gVG9hc3RIZWFkZXIoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbiB9KSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0b2FzdC1oZWFkZXJcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1lLWF1dG9cIj5cclxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxCdXR0b24gY2xhc3M9XCJidG4tY2xvc2VcIiBhcmlhLWxhYmVsPVwiQ2xvc2VcIiAvPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59Ki9cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9hc3QuanMubWFwIiwiaW1wb3J0IHsgQm9keVBvcnRhbCB9IGZyb20gXCIuLi9wb3J0YWxcIjtcclxuaW1wb3J0IHsgY2xvbmVFbGVtZW50LCBoLCBGcmFnbWVudCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQXJpYVRvb2x0aXAgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtdG9vbHRpcFwiO1xyXG5pbXBvcnQgeyB1c2VFbGVtZW50U2l6ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1lbGVtZW50LXNpemVcIjtcclxuaW1wb3J0IHsgZml4UHJvcHMsIHVzZVBvcHBlckFwaSwgdXNlU2hvdWxkVXBkYXRlUG9wcGVyIH0gZnJvbSBcIi4uL21lbnUvcG9wcGVyLWFwaVwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIFRvb2x0aXAoeyBjaGlsZHJlbiwgcG9zaXRpb24sIHRvb2x0aXAsIFRyYW5zaXRpb24sIG1vdXNlb3ZlckRlbGF5LCAuLi5yZXN0IH0pIHtcclxuICAgIGNvbnN0IHsgZ2V0SXNPcGVuLCBpc09wZW4sIHVzZVRvb2x0aXAsIHVzZVRvb2x0aXBUcmlnZ2VyIH0gPSB1c2VBcmlhVG9vbHRpcCh7IG1vdXNlb3ZlckRlbGF5IH0pO1xyXG4gICAgY29uc3QgeyB1c2VFbGVtZW50U2l6ZVByb3BzLCBlbGVtZW50U2l6ZSB9ID0gdXNlRWxlbWVudFNpemUoKTtcclxuICAgIGxldCBjbG9uZWFibGU7XHJcbiAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgY2hpbGRyZW4gPT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIGNoaWxkcmVuID09PSBcImJpZ2ludFwiKSB7XHJcbiAgICAgICAgY2xvbmVhYmxlID0gaChcInNwYW5cIiwgbnVsbCwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICBjbG9uZWFibGUgPSBoKFwic3BhblwiLCBudWxsLCBjaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjbG9uZWFibGUgPSBjaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgdXNlVG9vbHRpcFByb3BzIH0gPSB1c2VUb29sdGlwKCk7XHJcbiAgICBjb25zdCB7IHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMgfSA9IHVzZVRvb2x0aXBUcmlnZ2VyKCk7XHJcbiAgICBjb25zdCB7IHNob3VsZFVwZGF0ZSwgb25JbnRlcmFjdGlvbiB9ID0gdXNlU2hvdWxkVXBkYXRlUG9wcGVyKGlzT3BlbiwgZWxlbWVudFNpemUpO1xyXG4gICAgY29uc3QgeyBnZXRMb2dpY2FsRGlyZWN0aW9uLCB1c2VQb3BwZXJBcnJvdywgdXNlUG9wcGVyUG9wdXAsIHVzZVBvcHBlclNvdXJjZSwgdXNlZFBsYWNlbWVudCB9ID0gdXNlUG9wcGVyQXBpKHsgdXBkYXRpbmc6IHNob3VsZFVwZGF0ZSwgcG9zaXRpb24sIH0pO1xyXG4gICAgY29uc3QgeyB1c2VQb3BwZXJQb3B1cFByb3BzIH0gPSB1c2VQb3BwZXJQb3B1cCh7IG9wZW46IGlzT3BlbiB9KTtcclxuICAgIGNvbnN0IHsgdXNlUG9wcGVyQXJyb3dQcm9wcyB9ID0gdXNlUG9wcGVyQXJyb3coKTtcclxuICAgIGNvbnN0IHsgdXNlUG9wcGVyU291cmNlUHJvcHMgfSA9IHVzZVBvcHBlclNvdXJjZSgpO1xyXG4gICAgY29uc3QgbG9naWNhbERpcmVjdGlvbiA9IGdldExvZ2ljYWxEaXJlY3Rpb24oKTtcclxuICAgIGlmIChsb2dpY2FsRGlyZWN0aW9uICYmIHVzZWRQbGFjZW1lbnQpXHJcbiAgICAgICAgcmVzdCA9IGZpeFByb3BzKGxvZ2ljYWxEaXJlY3Rpb24sIFwiYmxvY2stZW5kXCIsIHVzZWRQbGFjZW1lbnQsIHJlc3QpO1xyXG4gICAgLy8gVE9ETzogSXQncyByZXF1aXJlZCBmb3IgdGhpcyB0byBiZSBleGl0VmlzaWJpbGl0eT1cImhpZGRlblwiIGZvciB0cmFuc2Zvcm1zIHRvIHdvcms/XHJcbiAgICAvLyBQcm9iYWJseSBhbiBpc3N1ZSBpbiB0aGUgVHJhbnNpdGlvbiBlbGVtZW50IGl0c2VsZiBiZWNhdXNlIGl0J3Mgbm90IGJyb3dzZXItc3BlY2lmaWMgYnV0IGl0J3MgYSBsaXR0bGUgd2VpcmRcclxuICAgIHJldHVybiBoKEZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIGNsb25lRWxlbWVudChjbG9uZWFibGUsIHVzZU1lcmdlZFByb3BzKCkoeyByZWY6IGNsb25lYWJsZS5yZWYgfSwgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyh1c2VFbGVtZW50U2l6ZVByb3BzKHVzZVBvcHBlclNvdXJjZVByb3BzKGNsb25lYWJsZS5wcm9wcykpKSkpLFxyXG4gICAgICAgIGgoQm9keVBvcnRhbCwgbnVsbCxcclxuICAgICAgICAgICAgaChcImRpdlwiLCB7IC4uLnVzZVBvcHBlclBvcHVwUHJvcHMoeyBjbGFzczogXCJ0b29sdGlwLXdyYXBwZXJcIiB9KSB9LFxyXG4gICAgICAgICAgICAgICAgaChUcmFuc2l0aW9uLCB7IC4uLnJlc3QsIG9wZW46IGlzT3Blbiwgb25UcmFuc2l0aW9uVXBkYXRlOiBvbkludGVyYWN0aW9uLCBleGl0VmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VUb29sdGlwUHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzOiBcInRvb2x0aXAgc2hvd1wiLCByb2xlOiBcInRvb2x0aXBcIiB9LCB7fSkpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VQb3BwZXJBcnJvd1Byb3BzKHsgY2xhc3M6IFwidG9vbHRpcC1hcnJvd1wiIH0pIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3M6IFwidG9vbHRpcC1pbm5lclwiIH0sIHRvb2x0aXApKSkpKSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9vbHRpcC5qcy5tYXAiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4uL3Byb3BzXCI7XHJcbmV4cG9ydCBjb25zdCBDYXJkID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2FyZChwLCByZWYpIHtcclxuICAgIGxldCB7IGNoaWxkcmVuLCAuLi5wcm9wcyB9ID0gcDtcclxuICAgIHJldHVybiAoaChcImRpdlwiLCB7IC4uLnVzZU1lcmdlZFByb3BzKCkoeyByZWYsIGNsYXNzTmFtZTogXCJjYXJkXCIgfSwgcHJvcHMpIH0sIGNoaWxkcmVuKSk7XHJcbn0pO1xyXG5mdW5jdGlvbiBDYXJkRWxlbWVudDIoeyBjaGlsZHJlbiwgLi4ucCB9LCByZWYpIHtcclxuICAgIHN3aXRjaCAocC50eXBlKSB7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICBjYXNlIFwicGFyYWdyYXBoXCI6IHtcclxuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCAuLi5wcm9wcyB9ID0gcDtcclxuICAgICAgICAgICAgcmV0dXJuIGgoQ2FyZEJvZHksIHsgLi4ucHJvcHMsIHJlZjogcmVmIH0sXHJcbiAgICAgICAgICAgICAgICBoKENhcmRUZXh0LCBudWxsLCBjaGlsZHJlbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiZm9vdGVyXCI6IHtcclxuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCAuLi5wcm9wcyB9ID0gcDtcclxuICAgICAgICAgICAgcmV0dXJuIGgoQ2FyZEZvb3RlciwgeyAuLi5wcm9wcywgcmVmOiByZWYgfSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwic3VidGl0bGVcIjoge1xyXG4gICAgICAgICAgICBjb25zdCB7IHR5cGUsIHRhZywgLi4ucHJvcHMgfSA9IHA7XHJcbiAgICAgICAgICAgIHJldHVybiBoKENhcmRCb2R5LCB7IC4uLnByb3BzLCByZWY6IHJlZiB9LFxyXG4gICAgICAgICAgICAgICAgaChDYXJkU3VidGl0bGUsIHsgdGFnOiB0YWcgfSwgY2hpbGRyZW4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcInRpdGxlXCI6IHtcclxuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCB0YWcsIC4uLnByb3BzIH0gPSBwO1xyXG4gICAgICAgICAgICByZXR1cm4gaChDYXJkQm9keSwgeyAuLi5wcm9wcywgcmVmOiByZWYgfSxcclxuICAgICAgICAgICAgICAgIGgoQ2FyZFRpdGxlLCB7IHRhZzogdGFnIH0sIGNoaWxkcmVuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJpbWFnZVwiOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgc3JjLCAuLi5wcm9wcyB9ID0gcDtcclxuICAgICAgICAgICAgcmV0dXJuIGgoQ2FyZEltYWdlLCB7IHNyYzogc3JjLCBwb3NpdGlvbjogXCJib3RoXCIsIC4uLnByb3BzLCByZWY6IHJlZiB9LCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJmbHVzaFwiOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdGFnLCAuLi5wcm9wcyB9ID0gcDtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnLCBwcm9wcywgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnQgY29uc3QgQ2FyZEVsZW1lbnQgPSBmb3J3YXJkRWxlbWVudFJlZihDYXJkRWxlbWVudDIpO1xyXG5jb25zdCBDYXJkSW1hZ2UgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDYXJkSW1hZ2UocCwgcmVmKSB7XHJcbiAgICBjb25zdCB7IHBvc2l0aW9uLCAuLi5wcm9wcyB9ID0gcDtcclxuICAgIHJldHVybiAoaChcImltZ1wiLCB7IC4uLnVzZU1lcmdlZFByb3BzKCkocHJvcHMsIHsgcmVmLCBjbGFzc05hbWU6IGBjYXJkLWltZyR7cG9zaXRpb24gPT0gXCJib3RoXCIgPyBcIlwiIDogYC0ke3Bvc2l0aW9ufWB9YCB9KSB9KSk7XHJcbn0pO1xyXG5jb25zdCBDYXJkQm9keSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENhcmRCb2R5KHByb3BzLCByZWYpIHtcclxuICAgIHJldHVybiAoaChcImRpdlwiLCB7IC4uLnVzZU1lcmdlZFByb3BzKCkocHJvcHMsIHsgcmVmLCBjbGFzc05hbWU6IFwiY2FyZC1ib2R5XCIgfSkgfSkpO1xyXG59KTtcclxuY29uc3QgQ2FyZEZvb3RlciA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENhcmRIZWFkZXIocHJvcHMsIHJlZikge1xyXG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKShwcm9wcywgeyByZWYsIGNsYXNzTmFtZTogXCJjYXJkXCIgfSkgfSkpO1xyXG59KTtcclxuY29uc3QgQ2FyZFRpdGxlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2FyZFRpdGxlKHAsIHJlZikge1xyXG4gICAgY29uc3QgeyB0YWcsIC4uLnByb3BzIH0gPSBwO1xyXG4gICAgcmV0dXJuIGgodGFnID8/IFwiaDVcIiwgdXNlTWVyZ2VkUHJvcHMoKShwcm9wcywgeyByZWYsIGNsYXNzTmFtZTogXCJjYXJkLXRpdGxlXCIgfSkpO1xyXG59KTtcclxuY29uc3QgQ2FyZFN1YnRpdGxlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2FyZFN1YnRpdGxlKHAsIHJlZikge1xyXG4gICAgY29uc3QgeyB0YWcsIC4uLnByb3BzIH0gPSBwO1xyXG4gICAgcmV0dXJuIGgodGFnID8/IFwiaDVcIiwgdXNlTWVyZ2VkUHJvcHMoKShwcm9wcywgeyByZWYsIGNsYXNzTmFtZTogY2xzeChcImNhcmQtc3VidGl0bGVcIiwgXCJtYi0yXCIsIFwidGV4dC1tdXRlZFwiKSB9KSk7XHJcbn0pO1xyXG5jb25zdCBDYXJkVGV4dCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENhcmRUZXh0KHByb3BzLCByZWYpIHtcclxuICAgIHJldHVybiAoaChcImRpdlwiLCB7IC4uLnVzZU1lcmdlZFByb3BzKCkocHJvcHMsIHsgcmVmLCBjbGFzc05hbWU6IFwiY2FyZC10ZXh0XCIgfSkgfSkpO1xyXG59KTtcclxuY29uc3QgQ2FyZEhlYWRlciA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENhcmRIZWFkZXIocHJvcHMsIHJlZikge1xyXG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKShwcm9wcywgeyByZWYsIGNsYXNzTmFtZTogXCJjYXJkLWhlYWRlclwiIH0pIH0pKTtcclxufSk7XHJcbmNvbnN0IGEyID0gaChDYXJkRWxlbWVudCwgeyB0eXBlOiBcInRpdGxlXCIsIHRhZzogXCJoMVwiLCBjaGlsZHJlbjogXCJcIiwgY2xhc3M6IFwiXCIgfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhcmQuanMubWFwIixudWxsLG51bGwsbnVsbCxudWxsLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBjbG9uZUVsZW1lbnQsIGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWJ1dHRvblwiO1xyXG5pbXBvcnQgeyB1c2VHcmlkTmF2aWdhdGlvbiwgdXNlSGFzRm9jdXMsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBGYWRlLCBTd2FwcGFibGUgfSBmcm9tIFwicHJlYWN0LXRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuLi9wcm9wc1wiO1xyXG5jb25zdCBDdXJyZW50U29ydGVkQ29sdW1uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmNvbnN0IFNldEN1cnJlbnRTb3J0ZWRDb2x1bW5Db250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuLy8gVGhpcyBpcyB0aGUgaG9vayB0aGF0IHJvd3MgdXNlIGZvciBuYXZpZ2F0aW9uXHJcbmNvbnN0IFVzZUJvZHlHcmlkTmF2aWdhdGlvblJvd0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG4vLyBUaGlzIGlzIHRoZSBob29rIHRoYXQgY2VsbHMgdXNlIGZvciBuYXZpZ2F0aW9uXHJcbmNvbnN0IFVzZUJvZHlHcmlkTmF2aWdhdGlvbkNlbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuY29uc3QgVXNlSGVhZEdyaWROYXZpZ2F0aW9uUm93Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmNvbnN0IFVzZUhlYWRHcmlkTmF2aWdhdGlvbkNlbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuLy8gVGhpcyBpcywgaW50ZXJuYWxseSwgd2hhdCB0aGUgaGVhZGVyIGNlbGwgY2FsbHMgd2hlbiB0aGUgdXNlciBjbGlja3MgaXQuXHJcbi8vIFRoZSBib2R5IGNyZWF0ZXMgaXQtLWl0IHNvcnRzIHRoZSBrbm93biByb3dzIGFuZCB1cGRhdGVzIHRoZSBjaGlsZHJlbi5cclxuY29uc3QgSW50ZXJuYWxTb3J0SGFuZGxlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG4vLyBUaGlzIGlzIHVzZWQgYnkgdGhlIGJvZHkuIEl0IGNyZWF0ZXMgdGhlIHNvcnQgaGFuZGxlciwgYnV0IGluIG9yZGVyXHJcbi8vIHRvIGdldCBpdCB0byB0aGUgaGVhZCwgd2hlcmUgdGhlIGNsaWNrYWJsZSBoZWFkZXIgY2VsbHMgYXJlLCB3ZSBuZWVkXHJcbi8vIHRoaXMgQ29udGV4dCwgdXNlZCBieSB0aGUgcGFyZW50IFRhYmxlLCB0byBmYXNjaWxpdGF0ZSBjb21tdW5pY2F0aW9uLlxyXG5jb25zdCBTZXRJbnRlcm5hbFNvcnRIYW5kbGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmV4cG9ydCBjb25zdCBUYWJsZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFRhYmxlKHsgY2hpbGRyZW4sIHNtYWxsLCBzdHJpcGVkLCBob3ZlcmFibGUsIGJvcmRlciwgdmFyaWFudCwgYm9yZGVyQ29sb3IsIC4uLnByb3BzIH0sIHJlZikge1xyXG4gICAgY29uc3QgW3NvcnRlZENvbHVtbiwgc2V0U29ydGVkQ29sdW1uXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgLy8gVGhpcyBpcyB0aGUgb25lIHRoYXQncyB1c2VkIGZvciB0aGUgYnV0dG9uIGluIHRoZSB0YWJsZSBoZWFkXHJcbiAgICBjb25zdCBbaW50ZXJuYWxTb3J0SGFuZGxlciwgc2V0SW50ZXJuYWxTb3J0SGFuZGxlcl0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIHJldHVybiAoaChcInRhYmxlXCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgcm9sZTogXCJncm91cFwiLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsc3goXCJ0YWJsZVwiLCBzbWFsbCAmJiBcInRhYmxlLXNtXCIsIHN0cmlwZWQgJiYgXCJ0YWJsZS1zdHJpcGVkXCIsIGhvdmVyYWJsZSAmJiBcInRhYmxlLWhvdmVyXCIsIGJvcmRlciA9PT0gXCJhbGxcIiAmJiBcInRhYmxlLWJvcmRlcmVkXCIsIGJvcmRlciA9PT0gXCJub25lXCIgJiYgXCJ0YWJsZS1ib3JkZXJsZXNzXCIsIHZhcmlhbnQgJiYgYHRhYmxlLSR7dmFyaWFudH1gLCBib3JkZXJDb2xvciAmJiBgYm9yZGVyLSR7Ym9yZGVyQ29sb3J9YClcclxuICAgICAgICB9LCBwcm9wcykgfSxcclxuICAgICAgICBoKFNldEludGVybmFsU29ydEhhbmRsZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzZXRJbnRlcm5hbFNvcnRIYW5kbGVyIH0sXHJcbiAgICAgICAgICAgIGgoSW50ZXJuYWxTb3J0SGFuZGxlckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGludGVybmFsU29ydEhhbmRsZXIgfSxcclxuICAgICAgICAgICAgICAgIGgoQ3VycmVudFNvcnRlZENvbHVtbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHNvcnRlZENvbHVtbiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGgoU2V0Q3VycmVudFNvcnRlZENvbHVtbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHNldFNvcnRlZENvbHVtbiB9LCBjaGlsZHJlbikpKSkpKTtcclxufSk7XHJcbmNvbnN0IENlbGxJc0luSGVhZGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoZmFsc2UpO1xyXG5mdW5jdGlvbiBub29wKCkgeyB9XHJcbjtcclxuZXhwb3J0IGNvbnN0IFRhYmxlSGVhZCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFRhYmxlSGVhZCh7IGNoaWxkcmVuLCB2YXJpYW50LCAuLi5wcm9wcyB9LCByZWYpIHtcclxuICAgIGNvbnN0IHsgZm9jdXNlZElubmVyLCB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1cyh7fSk7XHJcbiAgICBjb25zdCB7IGNlbGxJbmRleCwgcm93SW5kZXgsIHJvd0NvdW50LCB1c2VHcmlkTmF2aWdhdGlvblJvdyB9ID0gdXNlR3JpZE5hdmlnYXRpb24oeyBmb2N1c09uQ2hhbmdlOiBmb2N1c2VkSW5uZXIgfSk7XHJcbiAgICByZXR1cm4gKGgoVXNlSGVhZEdyaWROYXZpZ2F0aW9uUm93Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlR3JpZE5hdmlnYXRpb25Sb3cgfSxcclxuICAgICAgICBoKENlbGxJc0luSGVhZGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdHJ1ZSB9LFxyXG4gICAgICAgICAgICBoKFwidGhlYWRcIiwgeyAuLi51c2VIYXNGb2N1c1Byb3BzKHVzZU1lcmdlZFByb3BzKCkoe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgICAgICAgICByb2xlOiBcInJvd2dyb3VwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLWN1cnJlbnQtcm93XCI6IHJvd0luZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0YS1jdXJyZW50LWNvbHVtblwiOiBjZWxsSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXJvdy1jb3VudFwiOiByb3dDb3VudCxcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsc3godmFyaWFudCAmJiBgdGFibGUtJHt2YXJpYW50fWApXHJcbiAgICAgICAgICAgICAgICB9LCBwcm9wcykpIH0sIGNoaWxkcmVuKSkpKTtcclxufSk7XHJcbmZ1bmN0aW9uIGNvbXBhcmUzKGxocywgcmhzKSB7XHJcbiAgICBpZiAoYCR7K2xoc31gID09PSBsaHMpXHJcbiAgICAgICAgbGhzID0gK2xocztcclxuICAgIGlmIChgJHsrcmhzfWAgPT09IHJocylcclxuICAgICAgICByaHMgPSArcmhzO1xyXG4gICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgcmhzID0gYCR7cmhzfWA7XHJcbiAgICBpZiAodHlwZW9mIHJocyA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICBsaHMgPSBgJHtsaHN9YDtcclxuICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBsaHMgPT09IHR5cGVvZiByaHMpO1xyXG4gICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgcmV0dXJuIGxocy5sb2NhbGVDb21wYXJlKHJocyk7XHJcbiAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICByZXR1cm4gK2xocyAtICtyaHM7XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlMihsaHMsIHJocykge1xyXG4gICAgaWYgKHR5cGVvZiBsaHMgPT09IFwiYm9vbGVhblwiIHx8IGxocyBpbnN0YW5jZW9mIERhdGUpXHJcbiAgICAgICAgbGhzID0gK2xocztcclxuICAgIGlmICh0eXBlb2YgcmhzID09PSBcImJvb2xlYW5cIiB8fCByaHMgaW5zdGFuY2VvZiBEYXRlKVxyXG4gICAgICAgIHJocyA9ICtyaHM7XHJcbiAgICByZXR1cm4gY29tcGFyZTMobGhzLCByaHMpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmUxKGxocywgcmhzKSB7XHJcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcclxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbnVsbFxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGhzID09IG51bGwgfHwgcmhzID09IG51bGwpIHtcclxuICAgICAgICAvLyBPbmUgb2YgdGhlIHR3byBpcyBudWxsIC0tIGVhc3kgY2FzZVxyXG4gICAgICAgIHJldHVybiBsaHMgIT0gbnVsbCA/IC0xIDogMTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb21wYXJlMihsaHMsIHJocyk7XHJcbn1cclxuY29uc3QgU29ydENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG5leHBvcnQgY29uc3QgVGFibGVCb2R5ID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gVGFibGVCb2R5KHsgY2hpbGRyZW4sIHZhcmlhbnQsIC4uLnByb3BzIH0sIHJlZikge1xyXG4gICAgY29uc3QgeyBmb2N1c2VkSW5uZXIsIHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzKHt9KTtcclxuICAgIGNvbnN0IHsgY2VsbEluZGV4LCByb3dJbmRleCwgcm93Q291bnQsIHVzZUdyaWROYXZpZ2F0aW9uUm93LCBtYW5hZ2VkUm93cyB9ID0gdXNlR3JpZE5hdmlnYXRpb24oeyBmb2N1c09uQ2hhbmdlOiBmb2N1c2VkSW5uZXIgfSk7XHJcbiAgICAvLyBUaGlzIGhvb2tzIHVwIHRvIGludGVybmFsU29ydEhhbmRsZXIsIHVzZWQgYnkgdGhlIHRhYmxlIGhlYWQuXHJcbiAgICBjb25zdCBzb3J0ID0gdXNlQ2FsbGJhY2soKGNvbHVtbiwgZGlyZWN0aW9uKSA9PiB7XHJcbiAgICAgICAgbGV0IHNvcnRlZFJvd3MgPSBtYW5hZ2VkUm93cy5zbGljZSgpLnNvcnQoKGxoc1JvdywgcmhzUm93KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBjb21wYXJlMShsaHNSb3cuZ2V0TWFuYWdlZENlbGxzKClbY29sdW1uXS5saXRlcmFsVmFsdWUsIHJoc1Jvdy5nZXRNYW5hZ2VkQ2VsbHMoKVtjb2x1bW5dLmxpdGVyYWxWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb25bMF0gPT0gXCJkXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLXJlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBmb3IgKGxldCBsaXRlcmFsSW5kZXggPSAwOyBsaXRlcmFsSW5kZXggPCBzb3J0ZWRSb3dzLmxlbmd0aDsgKytsaXRlcmFsSW5kZXgpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGRlbkluZGV4ID0gc29ydGVkUm93c1tsaXRlcmFsSW5kZXhdLmluZGV4O1xyXG4gICAgICAgICAgICBjb25zdCBvdmVycmlkZGVuQ2VsbHMgPSBzb3J0ZWRSb3dzW292ZXJyaWRkZW5JbmRleF0uZ2V0TWFuYWdlZENlbGxzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpdGVyYWxDZWxscyA9IHNvcnRlZFJvd3NbbGl0ZXJhbEluZGV4XS5nZXRNYW5hZ2VkQ2VsbHMoKTtcclxuICAgICAgICAgICAgbWFuYWdlZFJvd3NbbGl0ZXJhbEluZGV4XS5zZXRPdmVycmlkZGVuUm93SW5kZXgob3ZlcnJpZGRlbkluZGV4KTtcclxuICAgICAgICAgICAgZm9yIChsZXQgY2VsbEluZGV4ID0gMDsgY2VsbEluZGV4IDwgb3ZlcnJpZGRlbkNlbGxzLmxlbmd0aDsgKytjZWxsSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJyaWRkZW5DZWxsc1tjZWxsSW5kZXhdLnByb3ZpZGVXaXRoU2libGluZ3NTZXRPdmVycmlkZGVuVmFsdWUoKCkgPT4gbGl0ZXJhbENlbGxzW2NlbGxJbmRleF0uc2V0T3ZlcnJpZGRlblZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHNldEludGVybmFsU29ydEhhbmRsZXIgPSB1c2VDb250ZXh0KFNldEludGVybmFsU29ydEhhbmRsZXJDb250ZXh0KTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7IHNldEludGVybmFsU29ydEhhbmRsZXIoKCkgPT4gc29ydCk7IH0sIFtzZXRJbnRlcm5hbFNvcnRIYW5kbGVyLCBzb3J0XSk7XHJcbiAgICByZXR1cm4gKGgoXCJ0Ym9keVwiLCB7IC4uLnVzZUhhc0ZvY3VzUHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgcm9sZTogXCJyb3dncm91cFwiLFxyXG4gICAgICAgICAgICBcImRhdGEtY3VycmVudC1yb3dcIjogcm93SW5kZXgsXHJcbiAgICAgICAgICAgIFwiZGF0YS1jdXJyZW50LWNvbHVtblwiOiBjZWxsSW5kZXgsXHJcbiAgICAgICAgICAgIFwiZGF0YS1yb3ctY291bnRcIjogcm93Q291bnQsXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzeCh2YXJpYW50ICYmIGB0YWJsZS0ke3ZhcmlhbnR9YClcclxuICAgICAgICB9LCBwcm9wcykpIH0sXHJcbiAgICAgICAgaChVc2VCb2R5R3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VHcmlkTmF2aWdhdGlvblJvdyB9LFxyXG4gICAgICAgICAgICBoKFNvcnRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzb3J0IH0sIGNoaWxkcmVuKSkpKTtcclxufSk7XHJcbmV4cG9ydCBjb25zdCBUYWJsZUZvb3QgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBUYWJsZUZvb3QoeyBjaGlsZHJlbiwgdmFyaWFudCwgLi4ucHJvcHMgfSwgcmVmKSB7XHJcbiAgICBjb25zdCB7IGZvY3VzZWRJbm5lciwgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXMoe30pO1xyXG4gICAgY29uc3QgeyBjZWxsSW5kZXgsIHJvd0luZGV4LCByb3dDb3VudCwgdXNlR3JpZE5hdmlnYXRpb25Sb3cgfSA9IHVzZUdyaWROYXZpZ2F0aW9uKHsgZm9jdXNPbkNoYW5nZTogZm9jdXNlZElubmVyIH0pO1xyXG4gICAgcmV0dXJuIChoKFVzZUJvZHlHcmlkTmF2aWdhdGlvblJvd0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHVzZUdyaWROYXZpZ2F0aW9uUm93IH0sXHJcbiAgICAgICAgaChcInRmb290XCIsIHsgLi4udXNlSGFzRm9jdXNQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHtcclxuICAgICAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgICAgIFwiZGF0YS1jdXJyZW50LXJvd1wiOiByb3dJbmRleCxcclxuICAgICAgICAgICAgICAgIFwiZGF0YS1jdXJyZW50LWNvbHVtblwiOiBjZWxsSW5kZXgsXHJcbiAgICAgICAgICAgICAgICBcImRhdGEtcm93LWNvdW50XCI6IHJvd0NvdW50LFxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbHN4KHZhcmlhbnQgJiYgYHRhYmxlLSR7dmFyaWFudH1gKVxyXG4gICAgICAgICAgICB9LCBwcm9wcykpIH0sIGNoaWxkcmVuKSkpO1xyXG59KTtcclxuZXhwb3J0IGNvbnN0IFRhYmxlUm93ID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gVGFibGVSb3coeyBjaGlsZHJlbiwgaW5kZXg6IGxpdGVyYWxSb3dJbmRleCwgdmFyaWFudCwgLi4ucHJvcHMgfSwgcmVmKSB7XHJcbiAgICBjb25zdCBpc0luVEhlYWQgPSB1c2VDb250ZXh0KENlbGxJc0luSGVhZGVyQ29udGV4dCk7XHJcbiAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvblJvdyA9IHVzZUNvbnRleHQoaXNJblRIZWFkID8gVXNlSGVhZEdyaWROYXZpZ2F0aW9uUm93Q29udGV4dCA6IFVzZUJvZHlHcmlkTmF2aWdhdGlvblJvd0NvbnRleHQpO1xyXG4gICAgY29uc3QgW292ZXJyaWRkZW5Sb3dJbmRleCwgc2V0T3ZlcnJpZGRlblJvd0luZGV4XSA9IHVzZVN0YXRlKGxpdGVyYWxSb3dJbmRleCk7XHJcbiAgICBjb25zdCB7IGNlbGxDb3VudCwgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcywgdXNlR3JpZE5hdmlnYXRpb25DZWxsLCB0YWJiYWJsZUNlbGwsIGlzVGFiYmFibGVSb3csIG1hbmFnZWRDZWxscyB9ID0gdXNlR3JpZE5hdmlnYXRpb25Sb3coe1xyXG4gICAgICAgIGluZGV4OiBsaXRlcmFsUm93SW5kZXgsIHNldE92ZXJyaWRkZW5Sb3dJbmRleCwgZ2V0TWFuYWdlZENlbGxzOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiBtYW5hZ2VkQ2VsbHMpXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHJvd1Byb3BzID0ge1xyXG4gICAgICAgIGNoaWxkcmVuLCAuLi4odXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgcm9sZTogXCJyb3dcIixcclxuICAgICAgICAgICAgXCJkYXRhLWxpdGVyYWwtaW5kZXhcIjogbGl0ZXJhbFJvd0luZGV4LFxyXG4gICAgICAgICAgICBcImRhdGEtb3ZlcnJpZGRlbi1pbmRleFwiOiBvdmVycmlkZGVuUm93SW5kZXgsXHJcbiAgICAgICAgICAgIFwiZGF0YS10YWJiYWJsZVwiOiBgJHtpc1RhYmJhYmxlUm93fWAsXHJcbiAgICAgICAgICAgIFwiZGF0YS10YWJiYWJsZS1jZWxsXCI6IGAke3RhYmJhYmxlQ2VsbH1gLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsc3godmFyaWFudCAmJiBgdGFibGUtJHt2YXJpYW50fWApLFxyXG4gICAgICAgICAgICBcImRhdGEtY2VsbC1jb3VudFwiOiBjZWxsQ291bnRcclxuICAgICAgICB9LCBwcm9wcykpXHJcbiAgICB9O1xyXG4gICAgLy8gVGhpcyBpcyB3aGF0IHdlIGRpc3BsYXkgdW5kZXIgdGhlIGRlZmF1bHQgY2lyY3Vtc3RhbmNlICh3ZSdyZSBkaXNwbGF5aW5nIG91ciBvd24gcm93KVxyXG4gICAgY29uc3Qgcm93SnN4ID0gaChcInRyXCIsIHsgLi4udXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyhyb3dQcm9wcykgfSwgY2hpbGRyZW4pO1xyXG4gICAgY29uc3QgUHJvdmlkZXIgPSAhaXNJblRIZWFkID8gVXNlQm9keUdyaWROYXZpZ2F0aW9uQ2VsbENvbnRleHQuUHJvdmlkZXIgOiBVc2VIZWFkR3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dC5Qcm92aWRlcjtcclxuICAgIHJldHVybiAoaChQcm92aWRlciwgeyB2YWx1ZTogdXNlR3JpZE5hdmlnYXRpb25DZWxsIH0sXHJcbiAgICAgICAgaChPdmVycmlkZGVuUm93SW5kZXhDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBvdmVycmlkZGVuUm93SW5kZXggfSwgcm93SnN4KSkpO1xyXG59KTtcclxuY29uc3QgT3ZlcnJpZGRlblJvd0luZGV4Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmV4cG9ydCBjb25zdCBUYWJsZUNlbGwgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBUYWJsZUNlbGwoeyB2YWx1ZTogbGl0ZXJhbFZhbHVlLCBjaGlsZHJlbiwgaW5kZXgsIHZhcmlhbnQsIGZvY3VzLCBhY3RpdmUsIC4uLnByb3BzIH0sIHJlZikge1xyXG4gICAgZm9jdXMgPz89IFwiY2VsbFwiO1xyXG4gICAgY29uc3QgdXNlR3JpZE5hdmlnYXRpb25DZWxsID0gdXNlQ29udGV4dChVc2VCb2R5R3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dCk7XHJcbiAgICBjb25zdCBpc0Rpc3BsYXlDaGlsZHJlbiA9ICh0eXBlb2YgY2hpbGRyZW4gPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY2hpbGRyZW4gPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgY2hpbGRyZW4gPT0gXCJib29sZWFuXCIpO1xyXG4gICAgY29uc3QgZGlzcGxheVZhbHVlID0gaXNEaXNwbGF5Q2hpbGRyZW4gPyBjaGlsZHJlbiA6IGxpdGVyYWxWYWx1ZTtcclxuICAgIGNvbnN0IFtvdmVycmlkZGVuVmFsdWUsIHNldE92ZXJyaWRkZW5WYWx1ZV0gPSB1c2VTdGF0ZShsaXRlcmFsVmFsdWUpO1xyXG4gICAgY29uc3QgW3NldFNpYmxpbmdPdmVycmlkZGVuVmFsdWUsIHByb3ZpZGVXaXRoU2libGluZ3NTZXRPdmVycmlkZGVuVmFsdWVdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCB7IHRhYmJhYmxlLCB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyB9ID0gdXNlR3JpZE5hdmlnYXRpb25DZWxsKHsgaW5kZXgsIHRleHQ6IG51bGwsIG92ZXJyaWRkZW5WYWx1ZSwgbGl0ZXJhbFZhbHVlLCBkaXNwbGF5VmFsdWUsIHByb3ZpZGVXaXRoU2libGluZ3NTZXRPdmVycmlkZGVuVmFsdWUsIHNldE92ZXJyaWRkZW5WYWx1ZSB9KTtcclxuICAgIGNvbnN0IG92ZXJyaWRkZW5Sb3dJbmRleCA9IHVzZUNvbnRleHQoT3ZlcnJpZGRlblJvd0luZGV4Q29udGV4dCk7XHJcbiAgICBjb25zdCBjZWxsUHJvcHMgPSB1c2VNZXJnZWRQcm9wcygpKHtcclxuICAgICAgICByZWYsXHJcbiAgICAgICAgcm9sZTogXCJncmlkY2VsbFwiLFxyXG4gICAgICAgIFwiZGF0YS1saXRlcmFsLXZhbHVlXCI6IGAke2xpdGVyYWxWYWx1ZX1gLFxyXG4gICAgICAgIFwiZGF0YS1kaXNwbGF5LXZhbHVlXCI6IGAke2Rpc3BsYXlWYWx1ZX1gLFxyXG4gICAgICAgIFwiZGF0YS1vdmVycmlkZGVuLXZhbHVlXCI6IGAke292ZXJyaWRkZW5WYWx1ZX1gLFxyXG4gICAgICAgIFwiZGF0YS1vdmVycmlkZGVuLXJvd1wiOiBgJHtvdmVycmlkZGVuUm93SW5kZXh9YCxcclxuICAgICAgICBjbGFzc05hbWU6IGNsc3godmFyaWFudCAmJiBgdGFibGUtJHt2YXJpYW50fWApXHJcbiAgICB9LCBwcm9wcyk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldFNpYmxpbmdPdmVycmlkZGVuVmFsdWU/LihkaXNwbGF5VmFsdWUpO1xyXG4gICAgfSwgW3NldFNpYmxpbmdPdmVycmlkZGVuVmFsdWUsIGRpc3BsYXlWYWx1ZV0pO1xyXG4gICAgaWYgKGNoaWxkcmVuICYmICFpc0Rpc3BsYXlDaGlsZHJlbikge1xyXG4gICAgICAgIHJldHVybiAoaChcInRkXCIsIHsgLi4uY2VsbFByb3BzIH0sIGNyZWF0ZUVsZW1lbnQoY2hpbGRyZW4sIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzKHsgb3ZlcnJpZGRlblJvd0luZGV4LCBvdmVycmlkZGVuVmFsdWUsIGNsYXNzTmFtZTogXCJ0ZXN0XCIgfSkpKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gKGgoXCJ0ZFwiLCB7IC4uLnVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzKGNlbGxQcm9wcykgfSwgc3RyaW5naWZ5KG92ZXJyaWRkZW5WYWx1ZSkpKTtcclxuICAgIH1cclxufSk7XHJcbmV4cG9ydCBjb25zdCBUYWJsZUhlYWRlckNlbGwgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBUYWJsZUhlYWRlckNlbGwoeyBpbmRleCwgZm9jdXMsIGNoaWxkcmVuLCB2YXJpYW50LCBhY3RpdmUsIHVuc29ydGFibGUsIC4uLnByb3BzIH0sIHJlZikge1xyXG4gICAgZm9jdXMgPz89IFwiY2VsbFwiO1xyXG4gICAgY29uc3QgW3NvcnREaXJlY3Rpb24sIHNldFNvcnREaXJlY3Rpb24sIGdldFNvcnREaXJlY3Rpb25dID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBpc0luVEhlYWQgPSB1c2VDb250ZXh0KENlbGxJc0luSGVhZGVyQ29udGV4dCk7XHJcbiAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvbkNlbGwgPSB1c2VDb250ZXh0KFVzZUhlYWRHcmlkTmF2aWdhdGlvbkNlbGxDb250ZXh0KTtcclxuICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBlbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICBjb25zdCBbdGV4dCwgc2V0VGV4dF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgc2V0VGV4dChlbGVtZW50LmlubmVyVGV4dCk7XHJcbiAgICB9IH0sIFtlbGVtZW50XSk7XHJcbiAgICBjb25zdCB7IHRhYmJhYmxlLCB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyB9ID0gdXNlR3JpZE5hdmlnYXRpb25DZWxsKHsgaW5kZXgsIHRleHQgfSk7XHJcbiAgICBjb25zdCBjdXJyZW50U29ydGVkQ29sdW1uID0gdXNlQ29udGV4dChDdXJyZW50U29ydGVkQ29sdW1uQ29udGV4dCk7XHJcbiAgICBjb25zdCBzZXRDdXJyZW50U29ydGVkQ29sdW1uID0gdXNlQ29udGV4dChTZXRDdXJyZW50U29ydGVkQ29sdW1uQ29udGV4dCk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50U29ydGVkQ29sdW1uICE9IGluZGV4KVxyXG4gICAgICAgICAgICBzZXRTb3J0RGlyZWN0aW9uKG51bGwpO1xyXG4gICAgfSwgW2N1cnJlbnRTb3J0ZWRDb2x1bW4sIGluZGV4XSk7XHJcbiAgICBjb25zdCBvblNvcnQgPSB1c2VDb250ZXh0KEludGVybmFsU29ydEhhbmRsZXJDb250ZXh0KTtcclxuICAgIGNvbnN0IG9uU29ydENsaWNrID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGxldCBuZXh0U29ydERpcmVjdGlvbiA9IGdldFNvcnREaXJlY3Rpb24oKTtcclxuICAgICAgICBpZiAobmV4dFNvcnREaXJlY3Rpb24gPT09IFwiYXNjZW5kaW5nXCIpXHJcbiAgICAgICAgICAgIG5leHRTb3J0RGlyZWN0aW9uID0gXCJkZXNjZW5kaW5nXCI7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBuZXh0U29ydERpcmVjdGlvbiA9IFwiYXNjZW5kaW5nXCI7XHJcbiAgICAgICAgc2V0U29ydERpcmVjdGlvbihuZXh0U29ydERpcmVjdGlvbik7XHJcbiAgICAgICAgb25Tb3J0Py4oaW5kZXgsIG5leHRTb3J0RGlyZWN0aW9uKTtcclxuICAgICAgICBzZXRDdXJyZW50U29ydGVkQ29sdW1uKHByZXYgPT4gaW5kZXgpO1xyXG4gICAgfSwgW29uU29ydCwgaW5kZXhdKTtcclxuICAgIGNvbnN0IGNlbGxQcm9wcyA9IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzKFwidGhcIiwgdW5zb3J0YWJsZSA/IG51bGwgOiBvblNvcnRDbGljaywgdW5kZWZpbmVkKSh1c2VSZWZFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgcmVmLFxyXG4gICAgICAgIHJvbGU6IFwiY29sdW1uaGVhZGVyXCIsXHJcbiAgICAgICAgc2NvcGU6IChpc0luVEhlYWQgPyBcImNvbFwiIDogXCJyb3dcIiksXHJcbiAgICAgICAgY2xhc3NOYW1lOiBjbHN4KHZhcmlhbnQgJiYgYHRhYmxlLSR7dmFyaWFudH1gLCB1bnNvcnRhYmxlICYmIFwidW5zb3J0YWJsZVwiKVxyXG4gICAgfSwgcHJvcHMpKSk7XHJcbiAgICBjb25zdCBzb3J0SWNvbiA9IChoKFN3YXBwYWJsZSwgbnVsbCxcclxuICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3M6IGNsc3goXCJ0YWJsZS1zb3J0LWljb24tY29udGFpbmVyXCIsIGBzb3J0LWRpcmVjdGlvbi0ke3NvcnREaXJlY3Rpb24gPz8gXCJudWxsXCJ9YCkgfSxcclxuICAgICAgICAgICAgaChGYWRlLCB7IG9wZW46IHNvcnREaXJlY3Rpb24gPT0gbnVsbCB9LFxyXG4gICAgICAgICAgICAgICAgaChcImlcIiwgeyBjbGFzczogXCJiaSBiaS1zb3J0LWRvd24tYWx0IGhvdmVyLW9ubHlcIiB9KSksXHJcbiAgICAgICAgICAgIGgoRmFkZSwgeyBvcGVuOiBzb3J0RGlyZWN0aW9uID09IFwiZGVzY2VuZGluZ1wiIH0sXHJcbiAgICAgICAgICAgICAgICBoKFwiaVwiLCB7IGNsYXNzOiBcImJpIGJpLXNvcnQtdXAgbm8taG92ZXItb25seVwiIH0pKSxcclxuICAgICAgICAgICAgaChGYWRlLCB7IG9wZW46IHNvcnREaXJlY3Rpb24gPT0gXCJkZXNjZW5kaW5nXCIgfSxcclxuICAgICAgICAgICAgICAgIGgoXCJpXCIsIHsgY2xhc3M6IFwiYmkgYmktc29ydC1kb3duLWFsdCBob3Zlci1vbmx5XCIgfSkpLFxyXG4gICAgICAgICAgICBoKEZhZGUsIHsgb3Blbjogc29ydERpcmVjdGlvbiA9PSBcImFzY2VuZGluZ1wiIH0sXHJcbiAgICAgICAgICAgICAgICBoKFwiaVwiLCB7IGNsYXNzOiBcImJpIGJpLXNvcnQtZG93bi1hbHQgbm8taG92ZXItb25seVwiIH0pKSxcclxuICAgICAgICAgICAgaChGYWRlLCB7IG9wZW46IHNvcnREaXJlY3Rpb24gPT0gXCJhc2NlbmRpbmdcIiB9LFxyXG4gICAgICAgICAgICAgICAgaChcImlcIiwgeyBjbGFzczogXCJiaSBiaS1zb3J0LXVwIGhvdmVyLW9ubHlcIiB9KSkpKSk7XHJcbiAgICBpZiAoZm9jdXMgPT09IFwiY2hpbGRcIikge1xyXG4gICAgICAgIHJldHVybiBoKFwidGhcIiwgeyAuLi5jZWxsUHJvcHMgfSxcclxuICAgICAgICAgICAgaChcImRpdlwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgY2xvbmVFbGVtZW50KGNoaWxkcmVuLCB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyh7fSksIGNoaWxkcmVuLnByb3BzLmNoaWxkcmVuKSxcclxuICAgICAgICAgICAgICAgIHNvcnRJY29uKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gaChcInRoXCIsIHsgLi4udXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMoY2VsbFByb3BzKSB9LFxyXG4gICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICAgICAgICAgIHNvcnRJY29uKSk7XHJcbiAgICB9XHJcbn0pO1xyXG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgLy8gVE9ETzogVGhpcyBjb3VsZCBiZSBhIGxvdCBiZXR0ZXJcclxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICByZXR1cm4gYCR7dmFsdWV9YDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJsZS5qcy5tYXAiLG51bGwsbnVsbF0sIm5hbWVzIjpbIl9fYXNzaWduIiwiT2JqZWN0IiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsInYiLCJvcCIsIlR5cGVFcnJvciIsInBvcCIsInB1c2giLCJFTVBUWV9PQkoiLCJFTVBUWV9BUlIiLCJJU19OT05fRElNRU5TSU9OQUwiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50Q29tcG9uZW50IiwicHJldlJhZiIsImN1cnJlbnRIb29rIiwiYWZ0ZXJQYWludEVmZmVjdHMiLCJvbGRCZWZvcmVEaWZmIiwib3B0aW9ucyIsIm9sZEJlZm9yZVJlbmRlciIsIm9sZEFmdGVyRGlmZiIsImRpZmZlZCIsIm9sZENvbW1pdCIsIm9sZEJlZm9yZVVubW91bnQiLCJ1bm1vdW50IiwiZ2V0SG9va1N0YXRlIiwiaW5kZXgiLCJ0eXBlIiwiaG9va3MiLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInVzZVJlZHVjZXIiLCJpbnZva2VPclJldHVybiIsInJlZHVjZXIiLCJpbml0IiwiaG9va1N0YXRlIiwiX3JlZHVjZXIiLCJ1bmRlZmluZWQiLCJuZXh0VmFsdWUiLCJhY3Rpb24iLCJzZXRTdGF0ZSIsInVzZUVmZmVjdCIsImNhbGxiYWNrIiwiYXJncyIsInN0YXRlIiwiYXJnc0NoYW5nZWQiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCJpbml0aWFsVmFsdWUiLCJ1c2VNZW1vIiwiY3VycmVudCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJyZWYiLCJjcmVhdGVIYW5kbGUiLCJjb25jYXQiLCJmYWN0b3J5IiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwiY29udGV4dCIsInByb3ZpZGVyIiwic3ViIiwicHJvcHMiLCJmbHVzaEFmdGVyUGFpbnRFZmZlY3RzIiwiZm9yRWFjaCIsImNvbXBvbmVudCIsImludm9rZUNsZWFudXAiLCJpbnZva2VFZmZlY3QiLCJ2bm9kZSIsImMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyYWYiLCJjbGVhclRpbWVvdXQiLCJ0aW1lb3V0IiwiSEFTX1JBRiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsInByZXZpb3VzQ29tcG9uZW50IiwiY29tbWl0UXVldWUiLCJzb21lIiwiZmlsdGVyIiwiY2IiLCJob29rIiwiY29tcCIsIm9sZEFyZ3MiLCJuZXdBcmdzIiwiYXJnIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwidG9WYWwiLCJtaXgiLCJrIiwic3RyIiwiQXJyYXkiLCJpc0FycmF5IiwidG1wIiwieCIsInVzZVN0YXRlUCIsInVzZUxheW91dEVmZmVjdE5hdGl2ZSIsInVzZUVmZmVjdE5hdGl2ZSIsIlRhYmxlIiwiY2FuZGlkYXRlU2VsZWN0b3JzIiwibWF0Y2hlcyIsIkVsZW1lbnQiLCJpc0lucHV0Iiwibm9kZSIsImlzSGlkZGVuSW5wdXQiLCJpc0RldGFpbHNXaXRoU3VtbWFyeSIsInIiLCJjaGlsZCIsImlzSGlkZGVuIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzRGlyZWN0U3VtbWFyeSIsIm5vZGVVbmRlckRldGFpbHMiLCJkaXNwbGF5Q2hlY2siLCJ3aWR0aCIsImhlaWdodCIsImlzRGlzYWJsZWRGcm9tRmllbGRzZXQiLCJwYXJlbnROb2RlIiwiaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSIsImZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yIiwiaXNGb2N1c2FibGUiLCJnbG9iYWwiLCJ0aGlzIiwiX2NyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJ3aW5kb3ciLCJzbGljZSIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nIiwiam9pbiIsIkluZXJ0Um9vdCIsInJvb3RFbGVtZW50IiwiaW5lcnRNYW5hZ2VyIiwiX2luZXJ0TWFuYWdlciIsIl9yb290RWxlbWVudCIsIl9tYW5hZ2VkTm9kZXMiLCJTZXQiLCJoYXNBdHRyaWJ1dGUiLCJfc2F2ZWRBcmlhSGlkZGVuIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUiLCJfb2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiX29uTXV0YXRpb24iLCJiaW5kIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiZGVzdHJ1Y3RvciIsImRpc2Nvbm5lY3QiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpbmVydE5vZGUiLCJfdW5tYW5hZ2VOb2RlIiwic3RhcnROb2RlIiwiX3RoaXMyIiwiY29tcG9zZWRUcmVlV2FsayIsIl92aXNpdE5vZGUiLCJhY3RpdmVFbGVtZW50IiwiZG9jdW1lbnQiLCJjb250YWlucyIsInJvb3QiLCJub2RlVHlwZSIsIk5vZGUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiYmx1ciIsImZvY3VzIiwiRUxFTUVOVF9OT0RFIiwiZWxlbWVudCIsIl9hZG9wdEluZXJ0Um9vdCIsIl9tYW5hZ2VOb2RlIiwicmVnaXN0ZXIiLCJhZGQiLCJkZXJlZ2lzdGVyIiwiX3VubWFuYWdlU3VidHJlZSIsIl90aGlzMyIsImluZXJ0U3Vicm9vdCIsImdldEluZXJ0Um9vdCIsInNldEluZXJ0IiwibWFuYWdlZE5vZGVzIiwic2F2ZWRJbmVydE5vZGUiLCJyZWNvcmRzIiwic2VsZiIsInJlY29yZCIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJhdHRyaWJ1dGVOYW1lIiwibWFuYWdlZE5vZGUiLCJnZXQiLCJzZXQiLCJhcmlhSGlkZGVuIiwiSW5lcnROb2RlIiwiaW5lcnRSb290IiwiX25vZGUiLCJfb3ZlcnJvZGVGb2N1c01ldGhvZCIsIl9pbmVydFJvb3RzIiwiX3NhdmVkVGFiSW5kZXgiLCJfZGVzdHJveWVkIiwiZW5zdXJlVW50YWJiYWJsZSIsIl90aHJvd0lmRGVzdHJveWVkIiwiZGVzdHJveWVkIiwiRXJyb3IiLCJ0YWJJbmRleCIsImhhc1NhdmVkVGFiSW5kZXgiLCJhZGRJbmVydFJvb3QiLCJyZW1vdmVJbmVydFJvb3QiLCJzaXplIiwiSW5lcnRNYW5hZ2VyIiwiX2RvY3VtZW50IiwiTWFwIiwiX3dhdGNoRm9ySW5lcnQiLCJhZGRJbmVydFN0eWxlIiwiaGVhZCIsImRvY3VtZW50RWxlbWVudCIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiX29uRG9jdW1lbnRMb2FkZWQiLCJpbmVydCIsImhhcyIsInBhcmVudCIsIl9pbmVydFJvb3QiLCJpbmVydEVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImluZXJ0RWxlbWVudCIsIl90aGlzIiwidW5zaGlmdCIsInNoYWRvd1Jvb3RBbmNlc3RvciIsInNoYWRvd1Jvb3QiLCJsb2NhbE5hbWUiLCJjb250ZW50IiwiZGlzdHJpYnV0ZWROb2RlcyIsImdldERpc3RyaWJ1dGVkTm9kZXMiLCJzbG90IiwiX2Rpc3RyaWJ1dGVkTm9kZXMiLCJhc3NpZ25lZE5vZGVzIiwiZmxhdHRlbiIsIl9pIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicXVlcnlTZWxlY3RvciIsInN0eWxlIiwidGV4dENvbnRlbnQiLCJhcHBlbmRDaGlsZCIsIm9iaiIsInNoYWxsb3dEaWZmZXJzIiwiYSIsImIiLCJmb3J3YXJkRWxlbWVudFJlZiIsImZvcndhcmRSZWYiLCJjbG9uZUVsZW1lbnQiLCJoIiwiY3JlYXRlQ29udGV4dCIsIm1lbW8iLCJjcmVhdGVQb3J0YWwiLCJPcHRpb25hbGx5SW5wdXRHcm91cCIsInRvcCIsImJvdHRvbSIsInJpZ2h0IiwibGVmdCIsImF1dG8iLCJiYXNlUGxhY2VtZW50cyIsInN0YXJ0IiwiZW5kIiwiY2xpcHBpbmdQYXJlbnRzIiwidmlld3BvcnQiLCJwb3BwZXIiLCJyZWZlcmVuY2UiLCJ2YXJpYXRpb25QbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwicGxhY2VtZW50IiwicGxhY2VtZW50cyIsImJlZm9yZVJlYWQiLCJyZWFkIiwiYWZ0ZXJSZWFkIiwiYmVmb3JlTWFpbiIsIm1haW4iLCJhZnRlck1haW4iLCJiZWZvcmVXcml0ZSIsIndyaXRlIiwiYWZ0ZXJXcml0ZSIsIm1vZGlmaWVyUGhhc2VzIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0V2luZG93IiwidG9TdHJpbmciLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0VsZW1lbnQiLCJPd25FbGVtZW50IiwiaXNIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNTaGFkb3dSb290IiwiU2hhZG93Um9vdCIsImFwcGx5U3R5bGVzIiwiX3JlZiIsImtleXMiLCJlbGVtZW50cyIsIm5hbWUiLCJzdHlsZXMiLCJlZmZlY3QiLCJfcmVmMiIsImluaXRpYWxTdHlsZXMiLCJwb3NpdGlvbiIsInN0cmF0ZWd5IiwibWFyZ2luIiwiYXJyb3ciLCJzdHlsZVByb3BlcnRpZXMiLCJwcm9wZXJ0eSIsImF0dHJpYnV0ZSIsImVuYWJsZWQiLCJwaGFzZSIsImZuIiwicmVxdWlyZXMiLCJnZXRCYXNlUGxhY2VtZW50Iiwic3BsaXQiLCJyb3VuZCIsIk1hdGgiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpbmNsdWRlU2NhbGUiLCJyZWN0Iiwic2NhbGVYIiwic2NhbGVZIiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJnZXRMYXlvdXRSZWN0IiwiY2xpZW50UmVjdCIsImFicyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJyb290Tm9kZSIsImdldFJvb3ROb2RlIiwiaXNTYW1lTm9kZSIsImhvc3QiLCJpc1RhYmxlRWxlbWVudCIsImdldERvY3VtZW50RWxlbWVudCIsImdldFBhcmVudE5vZGUiLCJhc3NpZ25lZFNsb3QiLCJnZXRUcnVlT2Zmc2V0UGFyZW50Iiwib2Zmc2V0UGFyZW50IiwiZ2V0Q29udGFpbmluZ0Jsb2NrIiwiaXNGaXJlZm94IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJRSIsImVsZW1lbnRDc3MiLCJjdXJyZW50Tm9kZSIsImNzcyIsInRyYW5zZm9ybSIsInBlcnNwZWN0aXZlIiwiY29udGFpbiIsIndpbGxDaGFuZ2UiLCJnZXRPZmZzZXRQYXJlbnQiLCJnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQiLCJtYXgiLCJtaW4iLCJ3aXRoaW4iLCJtYXRoTWF4IiwibWF0aE1pbiIsImdldEZyZXNoU2lkZU9iamVjdCIsIm1lcmdlUGFkZGluZ09iamVjdCIsInBhZGRpbmdPYmplY3QiLCJleHBhbmRUb0hhc2hNYXAiLCJoYXNoTWFwIiwidG9QYWRkaW5nT2JqZWN0IiwicGFkZGluZyIsInJlY3RzIiwiX3N0YXRlJG1vZGlmaWVyc0RhdGEkIiwiYXJyb3dFbGVtZW50IiwicG9wcGVyT2Zmc2V0cyIsIm1vZGlmaWVyc0RhdGEiLCJiYXNlUGxhY2VtZW50IiwiYXhpcyIsImlzVmVydGljYWwiLCJsZW4iLCJhcnJvd1JlY3QiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImVuZERpZmYiLCJzdGFydERpZmYiLCJhcnJvd09mZnNldFBhcmVudCIsImNsaWVudFNpemUiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsImNlbnRlclRvUmVmZXJlbmNlIiwiY2VudGVyIiwib2Zmc2V0IiwiYXhpc1Byb3AiLCJjZW50ZXJPZmZzZXQiLCJfb3B0aW9ucyRlbGVtZW50IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsImVycm9yIiwicmVxdWlyZXNJZkV4aXN0cyIsImdldFZhcmlhdGlvbiIsInVuc2V0U2lkZXMiLCJyb3VuZE9mZnNldHNCeURQUiIsIndpbiIsImRwciIsImRldmljZVBpeGVsUmF0aW8iLCJtYXBUb1N0eWxlcyIsIl9PYmplY3QkYXNzaWduMiIsInBvcHBlclJlY3QiLCJ2YXJpYXRpb24iLCJvZmZzZXRzIiwiZ3B1QWNjZWxlcmF0aW9uIiwiYWRhcHRpdmUiLCJyb3VuZE9mZnNldHMiLCJfcmVmMyIsIl9yZWYzJHgiLCJfcmVmMyR5IiwiaGFzWCIsImhhc1kiLCJzaWRlWCIsInNpZGVZIiwiaGVpZ2h0UHJvcCIsIndpZHRoUHJvcCIsImNvbW1vblN0eWxlcyIsIl9PYmplY3QkYXNzaWduIiwiY29tcHV0ZVN0eWxlcyIsIl9yZWY0IiwiX29wdGlvbnMkZ3B1QWNjZWxlcmF0IiwiX29wdGlvbnMkYWRhcHRpdmUiLCJfb3B0aW9ucyRyb3VuZE9mZnNldHMiLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJ3YXJuIiwiZGF0YSIsInBhc3NpdmUiLCJfb3B0aW9ucyRzY3JvbGwiLCJzY3JvbGwiLCJfb3B0aW9ucyRyZXNpemUiLCJyZXNpemUiLCJzY3JvbGxQYXJlbnRzIiwic2Nyb2xsUGFyZW50IiwidXBkYXRlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhc2giLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsInJlcGxhY2UiLCJtYXRjaGVkIiwiZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQiLCJnZXRXaW5kb3dTY3JvbGwiLCJzY3JvbGxMZWZ0IiwicGFnZVhPZmZzZXQiLCJzY3JvbGxUb3AiLCJwYWdlWU9mZnNldCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJnZXRWaWV3cG9ydFJlY3QiLCJodG1sIiwidmlzdWFsVmlld3BvcnQiLCJ0ZXN0IiwiZ2V0RG9jdW1lbnRSZWN0IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwid2luU2Nyb2xsIiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJkaXJlY3Rpb24iLCJpc1Njcm9sbFBhcmVudCIsIl9nZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJnZXRTY3JvbGxQYXJlbnQiLCJsaXN0U2Nyb2xsUGFyZW50cyIsImxpc3QiLCJpc0JvZHkiLCJ1cGRhdGVkTGlzdCIsInJlY3RUb0NsaWVudFJlY3QiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFRvcCIsImNsaWVudExlZnQiLCJnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZSIsImNsaXBwaW5nUGFyZW50IiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2FuRXNjYXBlQ2xpcHBpbmciLCJjbGlwcGVyRWxlbWVudCIsImdldENsaXBwaW5nUmVjdCIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwibWFpbkNsaXBwaW5nUGFyZW50cyIsImZpcnN0Q2xpcHBpbmdQYXJlbnQiLCJjbGlwcGluZ1JlY3QiLCJhY2NSZWN0IiwiY29tcHV0ZU9mZnNldHMiLCJjb21tb25YIiwiY29tbW9uWSIsIm1haW5BeGlzIiwiZGV0ZWN0T3ZlcmZsb3ciLCJfb3B0aW9ucyIsIl9vcHRpb25zJHBsYWNlbWVudCIsIl9vcHRpb25zJGJvdW5kYXJ5IiwiX29wdGlvbnMkcm9vdEJvdW5kYXJ5IiwiX29wdGlvbnMkZWxlbWVudENvbnRlIiwiZWxlbWVudENvbnRleHQiLCJfb3B0aW9ucyRhbHRCb3VuZGFyeSIsImFsdEJvdW5kYXJ5IiwiX29wdGlvbnMkcGFkZGluZyIsImFsdENvbnRleHQiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJjb250ZXh0RWxlbWVudCIsInJlZmVyZW5jZUNsaWVudFJlY3QiLCJwb3BwZXJDbGllbnRSZWN0IiwiZWxlbWVudENsaWVudFJlY3QiLCJvdmVyZmxvd09mZnNldHMiLCJvZmZzZXREYXRhIiwibXVsdGlwbHkiLCJjb21wdXRlQXV0b1BsYWNlbWVudCIsImZsaXBWYXJpYXRpb25zIiwiX29wdGlvbnMkYWxsb3dlZEF1dG9QIiwiYWxsb3dlZEF1dG9QbGFjZW1lbnRzIiwiYWxsUGxhY2VtZW50cyIsImFsbG93ZWRQbGFjZW1lbnRzIiwib3ZlcmZsb3dzIiwic29ydCIsImdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJmbGlwIiwiX3NraXAiLCJfb3B0aW9ucyRtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJfb3B0aW9ucyRhbHRBeGlzIiwiYWx0QXhpcyIsImNoZWNrQWx0QXhpcyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrUGxhY2VtZW50cyIsIl9vcHRpb25zJGZsaXBWYXJpYXRpbyIsInByZWZlcnJlZFBsYWNlbWVudCIsImlzQmFzZVBsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJfYmFzZVBsYWNlbWVudCIsImlzU3RhcnRWYXJpYXRpb24iLCJtYWluVmFyaWF0aW9uU2lkZSIsImFsdFZhcmlhdGlvblNpZGUiLCJjaGVja3MiLCJldmVyeSIsImNoZWNrIiwibnVtYmVyT2ZDaGVja3MiLCJfbG9vcCIsImZpdHRpbmdQbGFjZW1lbnQiLCJmaW5kIiwiX3JldCIsInJlc2V0IiwiZ2V0U2lkZU9mZnNldHMiLCJwcmV2ZW50ZWRPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic2lkZSIsImhpZGUiLCJwcmV2ZW50T3ZlcmZsb3ciLCJyZWZlcmVuY2VPdmVyZmxvdyIsInBvcHBlckFsdE92ZXJmbG93IiwicmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzIiwicG9wcGVyRXNjYXBlT2Zmc2V0cyIsImlzUmVmZXJlbmNlSGlkZGVuIiwiaGFzUG9wcGVyRXNjYXBlZCIsImRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZIiwiaW52ZXJ0RGlzdGFuY2UiLCJza2lkZGluZyIsImRpc3RhbmNlIiwiX29wdGlvbnMkb2Zmc2V0IiwiX2RhdGEkc3RhdGUkcGxhY2VtZW50IiwiZ2V0QWx0QXhpcyIsIl9vcHRpb25zJHRldGhlciIsInRldGhlciIsIl9vcHRpb25zJHRldGhlck9mZnNldCIsInRldGhlck9mZnNldCIsInRldGhlck9mZnNldFZhbHVlIiwibWFpblNpZGUiLCJhbHRTaWRlIiwiYWRkaXRpdmUiLCJtaW5MZW4iLCJtYXhMZW4iLCJhcnJvd1BhZGRpbmdPYmplY3QiLCJhcnJvd1BhZGRpbmdNaW4iLCJhcnJvd1BhZGRpbmdNYXgiLCJhcnJvd0xlbiIsIm1pbk9mZnNldCIsIm1heE9mZnNldCIsImNsaWVudE9mZnNldCIsIm9mZnNldE1vZGlmaWVyVmFsdWUiLCJ0ZXRoZXJNaW4iLCJ0ZXRoZXJNYXgiLCJwcmV2ZW50ZWRPZmZzZXQiLCJfbWFpblNpZGUiLCJfYWx0U2lkZSIsIl9vZmZzZXQiLCJfbWluIiwiX21heCIsIl9wcmV2ZW50ZWRPZmZzZXQiLCJnZXRIVE1MRWxlbWVudFNjcm9sbCIsImdldE5vZGVTY3JvbGwiLCJpc0VsZW1lbnRTY2FsZWQiLCJnZXRDb21wb3NpdGVSZWN0IiwiZWxlbWVudE9yVmlydHVhbEVsZW1lbnQiLCJpc0ZpeGVkIiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsIm9yZGVyIiwibW9kaWZpZXJzIiwibWFwIiwidmlzaXRlZCIsIm1vZGlmaWVyIiwiZGVwIiwiZGVwTW9kaWZpZXIiLCJvcmRlck1vZGlmaWVycyIsIm9yZGVyZWRNb2RpZmllcnMiLCJkZWJvdW5jZSIsInBlbmRpbmciLCJmb3JtYXQiLCJfbGVuIiwiX2tleSIsIklOVkFMSURfTU9ESUZJRVJfRVJST1IiLCJNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IiLCJWQUxJRF9QUk9QRVJUSUVTIiwidmFsaWRhdGVNb2RpZmllcnMiLCJTdHJpbmciLCJyZXF1aXJlbWVudCIsIm1vZCIsInVuaXF1ZUJ5IiwiYXJyIiwiaWRlbnRpZmllcnMiLCJpdGVtIiwiaWRlbnRpZmllciIsIm1lcmdlQnlOYW1lIiwibWVyZ2VkIiwiZXhpc3RpbmciLCJJTlZBTElEX0VMRU1FTlRfRVJST1IiLCJJTkZJTklURV9MT09QX0VSUk9SIiwiREVGQVVMVF9PUFRJT05TIiwiYXJlVmFsaWRFbGVtZW50cyIsInBvcHBlckdlbmVyYXRvciIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGVQb3BwZXIiLCJlZmZlY3RDbGVhbnVwRm5zIiwiaXNEZXN0cm95ZWQiLCJzZXRPcHRpb25zIiwic2V0T3B0aW9uc0FjdGlvbiIsImNsZWFudXBNb2RpZmllckVmZmVjdHMiLCJtIiwiZmxpcE1vZGlmaWVyIiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXJnaW5MZWZ0IiwicGFyc2VGbG9hdCIsInJ1bk1vZGlmaWVyRWZmZWN0cyIsImZvcmNlVXBkYXRlIiwiX3N0YXRlJGVsZW1lbnRzIiwiX19kZWJ1Z19sb29wc19fIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllMiIsImRlc3Ryb3kiLCJvbkZpcnN0VXBkYXRlIiwiX3JlZjMkb3B0aW9ucyIsImNsZWFudXBGbiIsIm5vb3BGbiIsImV2ZW50TGlzdGVuZXJzIiwic2xlZXAiLCJSYW5kb21Xb3JkcyIsInJlbmRlciJdLCJtYXBwaW5ncyI6Ijs7O0lBQUE7SUFDQTtBQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQWtCTyxJQUFJQSxRQUFRLEdBQUcsWUFBVztJQUM3QkEsRUFBQUEsUUFBUSxHQUFHQyxNQUFNLENBQUNDLE1BQVAsSUFBaUIsU0FBU0YsUUFBVCxDQUFrQkcsQ0FBbEIsRUFBcUI7SUFDN0MsU0FBSyxJQUFJQyxDQUFKLEVBQU9DLENBQUMsR0FBRyxDQUFYLEVBQWNDLENBQUMsR0FBR0MsU0FBUyxDQUFDQyxNQUFqQyxFQUF5Q0gsQ0FBQyxHQUFHQyxDQUE3QyxFQUFnREQsQ0FBQyxFQUFqRCxFQUFxRDtJQUNqREQsTUFBQUEsQ0FBQyxHQUFHRyxTQUFTLENBQUNGLENBQUQsQ0FBYjs7SUFDQSxXQUFLLElBQUlJLENBQVQsSUFBY0wsQ0FBZDtJQUFpQixZQUFJSCxNQUFNLENBQUNTLFNBQVAsQ0FBaUJDLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ1IsQ0FBckMsRUFBd0NLLENBQXhDLENBQUosRUFBZ0ROLENBQUMsQ0FBQ00sQ0FBRCxDQUFELEdBQU9MLENBQUMsQ0FBQ0ssQ0FBRCxDQUFSO0lBQWpFO0lBQ0g7O0lBQ0QsV0FBT04sQ0FB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
