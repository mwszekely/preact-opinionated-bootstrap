(function () {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

      return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
      var t = {};

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }

      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    }
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }

      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator(thisArg, body) {
      var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) {
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];

            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;

              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };

              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;

              case 7:
                op = _.ops.pop();

                _.trys.pop();

                continue;

              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }

                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }

                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }

                if (t && _.label < t[2]) {
                  _.label = t[2];

                  _.ops.push(op);

                  break;
                }

                if (t[2]) _.ops.pop();

                _.trys.pop();

                continue;
            }

            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    }

    var n,
        l$1,
        u$1,
        t$1,
        o$1,
        r$1,
        f$1,
        e$1 = {},
        c$1 = [],
        s$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function a$1(n, l) {
      for (var u in l) {
        n[u] = l[u];
      }

      return n;
    }

    function h$1(n) {
      var l = n.parentNode;
      l && l.removeChild(n);
    }

    function v$1(l, u, i) {
      var t,
          o,
          r,
          f = {};

      for (r in u) {
        "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
      }

      if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) {
        void 0 === f[r] && (f[r] = l.defaultProps[r]);
      }
      return y$1(l, f, t, o, null);
    }

    function y$1(n, i, t, o, r) {
      var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u$1 : r
      };
      return null != l$1.vnode && l$1.vnode(f), f;
    }

    function d$1(n) {
      return n.children;
    }

    function _$1(n, l) {
      this.props = n, this.context = l;
    }

    function k$1(n, l) {
      if (null == l) return n.__ ? k$1(n.__, n.__.__k.indexOf(n) + 1) : null;

      for (var u; l < n.__k.length; l++) {
        if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
      }

      return "function" == typeof n.type ? k$1(n) : null;
    }

    function b$1(n) {
      var l, u;

      if (null != (n = n.__) && null != n.__c) {
        for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {
          if (null != (u = n.__k[l]) && null != u.__e) {
            n.__e = n.__c.base = u.__e;
            break;
          }
        }

        return b$1(n);
      }
    }

    function m$1(n) {
      (!n.__d && (n.__d = !0) && t$1.push(n) && !g$2.__r++ || r$1 !== l$1.debounceRendering) && ((r$1 = l$1.debounceRendering) || o$1)(g$2);
    }

    function g$2() {
      for (var n; g$2.__r = t$1.length;) {
        n = t$1.sort(function (n, l) {
          return n.__v.__b - l.__v.__b;
        }), t$1 = [], n.some(function (n) {
          var l, u, i, t, o, r;
          n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = a$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? k$1(t) : o, t.__h), z(u, t), t.__e != o && b$1(t)));
        });
      }
    }

    function w$2(n, l, u, i, t, o, r, f, s, a) {
      var h,
          v,
          p,
          _,
          b,
          m,
          g,
          w = i && i.__k || c$1,
          A = w.length;

      for (u.__k = [], h = 0; h < l.length; h++) {
        if (null != (_ = u.__k[h] = null == (_ = l[h]) || "boolean" == typeof _ ? null : "string" == typeof _ || "number" == typeof _ || "bigint" == typeof _ ? y$1(null, _, null, null, _) : Array.isArray(_) ? y$1(d$1, {
          children: _
        }, null, null, null) : _.__b > 0 ? y$1(_.type, _.props, _.key, null, _.__v) : _)) {
          if (_.__ = u, _.__b = u.__b + 1, null === (p = w[h]) || p && _.key == p.key && _.type === p.type) w[h] = void 0;else for (v = 0; v < A; v++) {
            if ((p = w[v]) && _.key == p.key && _.type === p.type) {
              w[v] = void 0;
              break;
            }

            p = null;
          }
          j$2(n, _, p = p || e$1, t, o, r, f, s, a), b = _.__e, (v = _.ref) && p.ref != v && (g || (g = []), p.ref && g.push(p.ref, null, _), g.push(v, _.__c || b, _)), null != b ? (null == m && (m = b), "function" == typeof _.type && null != _.__k && _.__k === p.__k ? _.__d = s = x$2(_, s, n) : s = P$1(n, _, p, w, b, s), a || "option" !== u.type ? "function" == typeof u.type && (u.__d = s) : n.value = "") : s && p.__e == s && s.parentNode != n && (s = k$1(p));
        }
      }

      for (u.__e = m, h = A; h--;) {
        null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = k$1(i, h + 1)), N(w[h], w[h]));
      }

      if (g) for (h = 0; h < g.length; h++) {
        M$1(g[h], g[++h], g[++h]);
      }
    }

    function x$2(n, l, u) {
      var i, t;

      for (i = 0; i < n.__k.length; i++) {
        (t = n.__k[i]) && (t.__ = n, l = "function" == typeof t.type ? x$2(t, l, u) : P$1(u, t, t, n.__k, t.__e, l));
      }

      return l;
    }

    function A$2(n, l) {
      return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
        A$2(n, l);
      }) : l.push(n)), l;
    }

    function P$1(n, l, u, i, t, o) {
      var r, f, e;
      if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
        for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) {
          if (f == t) break n;
        }

        n.insertBefore(t, o), r = o;
      }
      return void 0 !== r ? r : t.nextSibling;
    }

    function C$2(n, l, u, i, t) {
      var o;

      for (o in u) {
        "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);
      }

      for (o in l) {
        t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
      }
    }

    function $$1(n, l, u) {
      "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || s$1.test(l) ? u : u + "px";
    }

    function H$1(n, l, u, i, t) {
      var o;

      n: if ("style" === l) {
        if ("string" == typeof u) n.style.cssText = u;else {
          if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) {
            u && l in u || $$1(n.style, l, "");
          }
          if (u) for (l in u) {
            i && u[l] === i[l] || $$1(n.style, l, u[l]);
          }
        }
      } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$1 : I$1, o) : n.removeEventListener(l, o ? T$1 : I$1, o);else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
          n[l] = null == u ? "" : u;
          break n;
        } catch (n) {}
        "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
      }
    }

    function I$1(n) {
      this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
    }

    function T$1(n) {
      this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
    }

    function j$2(n, u, i, t, o, r, f, e, c) {
      var s,
          h,
          v,
          y,
          p,
          k,
          b,
          m,
          g,
          x,
          A,
          P = u.type;
      if (void 0 !== u.constructor) return null;
      null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (s = l$1.__b) && s(u);

      try {
        n: if ("function" == typeof P) {
          if (m = u.props, g = (s = P.contextType) && t[s.__c], x = s ? g ? g.props.value : s.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in P && P.prototype.render ? u.__c = h = new P(m, x) : (u.__c = h = new _$1(m, x), h.constructor = P, h.render = O$1), g && g.sub(h), h.props = m, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != P.getDerivedStateFromProps && (h.__s == h.state && (h.__s = a$1({}, h.__s)), a$1(h.__s, P.getDerivedStateFromProps(m, h.__s))), y = h.props, p = h.state, v) null == P.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
            if (null == P.getDerivedStateFromProps && m !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(m, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(m, h.__s, x) || u.__v === i.__v) {
              h.props = m, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
                n && (n.__ = u);
              }), h.__h.length && f.push(h);
              break n;
            }

            null != h.componentWillUpdate && h.componentWillUpdate(m, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
              h.componentDidUpdate(y, p, k);
            });
          }
          h.context = x, h.props = m, h.state = h.__s, (s = l$1.__r) && s(u), h.__d = !1, h.__v = u, h.__P = n, s = h.render(h.props, h.state, h.context), h.state = h.__s, null != h.getChildContext && (t = a$1(a$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, p)), A = null != s && s.type === d$1 && null == s.key ? s.props.children : s, w$2(n, Array.isArray(A) ? A : [A], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);

        (s = l$1.diffed) && s(u);
      } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
      }
    }

    function z(n, u) {
      l$1.__c && l$1.__c(u, n), n.some(function (u) {
        try {
          n = u.__h, u.__h = [], n.some(function (n) {
            n.call(u);
          });
        } catch (n) {
          l$1.__e(n, u.__v);
        }
      });
    }

    function L$1(l, u, i, t, o, r, f, c) {
      var s,
          a,
          v,
          y = i.props,
          p = u.props,
          d = u.type,
          _ = 0;
      if ("svg" === d && (o = !0), null != r) for (; _ < r.length; _++) {
        if ((s = r[_]) && (s === l || (d ? s.localName == d : 3 == s.nodeType))) {
          l = s, r[_] = null;
          break;
        }
      }

      if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
      }

      if (null === d) y === p || c && l.data === p || (l.data = p);else {
        if (r = r && n.call(l.childNodes), a = (y = i.props || e$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
          if (null != r) for (y = {}, _ = 0; _ < l.attributes.length; _++) {
            y[l.attributes[_].name] = l.attributes[_].value;
          }
          (v || a) && (v && (a && v.__html == a.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }

        if (C$2(l, p, y, o, c), v) u.__k = [];else if (_ = u.props.children, w$2(l, Array.isArray(_) ? _ : [_], u, i, t, o && "foreignObject" !== d, r, f, r ? r[0] : i.__k && k$1(i, 0), c), null != r) for (_ = r.length; _--;) {
          null != r[_] && h$1(r[_]);
        }
        c || ("value" in p && void 0 !== (_ = p.value) && (_ !== l.value || "progress" === d && !_) && H$1(l, "value", _, y.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && H$1(l, "checked", _, y.checked, !1));
      }
      return l;
    }

    function M$1(n, u, i) {
      try {
        "function" == typeof n ? n(u) : n.current = u;
      } catch (n) {
        l$1.__e(n, i);
      }
    }

    function N(n, u, i) {
      var t, o;

      if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$1(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
          t.componentWillUnmount();
        } catch (n) {
          l$1.__e(n, u);
        }
        t.base = t.__P = null;
      }

      if (t = n.__k) for (o = 0; o < t.length; o++) {
        t[o] && N(t[o], u, "function" != typeof n.type);
      }
      i || null == n.__e || h$1(n.__e), n.__e = n.__d = void 0;
    }

    function O$1(n, l, u) {
      return this.constructor(n, u);
    }

    function S$1(u, i, t) {
      var o, r, f;
      l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, f = [], j$2(i, u = (!o && t || i).__k = v$1(d$1, null, [u]), r || e$1, e$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, f, !o && t ? t : r ? r.__e : i.firstChild, o), z(f, u);
    }

    function B(l, u, i) {
      var t,
          o,
          r,
          f = a$1({}, l.props);

      for (r in u) {
        "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
      }

      return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), y$1(l.type, f, t || l.key, o || l.ref, null);
    }

    function D$1(n, l) {
      var u = {
        __c: l = "__cC" + f$1++,
        __: n,
        Consumer: function (n, l) {
          return n.children(l);
        },
        Provider: function (n) {
          var u, i;
          return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
            return i;
          }, this.shouldComponentUpdate = function (n) {
            this.props.value !== n.value && u.some(m$1);
          }, this.sub = function (n) {
            u.push(n);
            var l = n.componentWillUnmount;

            n.componentWillUnmount = function () {
              u.splice(u.indexOf(n), 1), l && l.call(n);
            };
          }), n.children;
        }
      };
      return u.Provider.__ = u.Consumer.contextType = u;
    }

    n = c$1.slice, l$1 = {
      __e: function (n, l) {
        for (var u, i, t; l = l.__;) {
          if ((u = l.__c) && !u.__) try {
            if ((i = u.constructor) && null != i.getDerivedStateFromError && (u.setState(i.getDerivedStateFromError(n)), t = u.__d), null != u.componentDidCatch && (u.componentDidCatch(n), t = u.__d), t) return u.__E = u;
          } catch (l) {
            n = l;
          }
        }

        throw n;
      }
    }, u$1 = 0, _$1.prototype.setState = function (n, l) {
      var u;
      u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a$1({}, this.state), "function" == typeof n && (n = n(a$1({}, u), this.props)), n && a$1(u, n), null != n && this.__v && (l && this.__h.push(l), m$1(this));
    }, _$1.prototype.forceUpdate = function (n) {
      this.__v && (this.__e = !0, n && this.__h.push(n), m$1(this));
    }, _$1.prototype.render = d$1, t$1 = [], o$1 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g$2.__r = 0, f$1 = 0;

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);

        if (enumerableOnly) {
          symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }

        keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }

      return target;
    }

    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }

      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }

    function _asyncToGenerator(fn) {
      return function () {
        var self = this,
            args = arguments;
        return new Promise(function (resolve, reject) {
          var gen = fn.apply(self, args);

          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }

          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }

          _next(undefined);
        });
      };
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};

      var target = _objectWithoutPropertiesLoose(source, excluded);

      var key, i;

      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }

      return target;
    }

    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];

      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }

      return (hint === "string" ? String : Number)(input);
    }

    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");

      return typeof key === "symbol" ? key : String(key);
    }

    var t,
        u,
        r,
        o = 0,
        i = [],
        c = l$1.__b,
        f = l$1.__r,
        e = l$1.diffed,
        a = l$1.__c,
        v = l$1.unmount;

    function m(t, r) {
      l$1.__h && l$1.__h(u, t, o || r), o = 0;
      var i = u.__H || (u.__H = {
        __: [],
        __h: []
      });
      return t >= i.__.length && i.__.push({}), i.__[t];
    }

    function l(n) {
      return o = 1, p(w$1, n);
    }

    function p(n, r, o) {
      var i = m(t++, 2);
      return i.t = n, i.__c || (i.__ = [o ? o(r) : w$1(void 0, r), function (n) {
        var t = i.t(i.__[0], n);
        i.__[0] !== t && (i.__ = [t, i.__[1]], i.__c.setState({}));
      }], i.__c = u), i.__;
    }

    function y(r, o) {
      var i = m(t++, 3);
      !l$1.__s && k(i.__H, o) && (i.__ = r, i.__H = o, u.__H.__h.push(i));
    }

    function h(r, o) {
      var i = m(t++, 4);
      !l$1.__s && k(i.__H, o) && (i.__ = r, i.__H = o, u.__h.push(i));
    }

    function s(n) {
      return o = 5, d(function () {
        return {
          current: n
        };
      }, []);
    }

    function _(n, t, u) {
      o = 6, h(function () {
        "function" == typeof n ? n(t()) : n && (n.current = t());
      }, null == u ? u : u.concat(n));
    }

    function d(n, u) {
      var r = m(t++, 7);
      return k(r.__H, u) && (r.__ = n(), r.__H = u, r.__h = n), r.__;
    }

    function A$1(n, t) {
      return o = 8, d(function () {
        return n;
      }, t);
    }

    function F(n) {
      var r = u.context[n.__c],
          o = m(t++, 9);
      return o.c = n, r ? (null == o.__ && (o.__ = !0, r.sub(u)), r.props.value) : n.__;
    }

    function x$1() {
      i.forEach(function (t) {
        if (t.__P) try {
          t.__H.__h.forEach(g$1), t.__H.__h.forEach(j$1), t.__H.__h = [];
        } catch (u) {
          t.__H.__h = [], l$1.__e(u, t.__v);
        }
      }), i = [];
    }

    l$1.__b = function (n) {
      u = null, c && c(n);
    }, l$1.__r = function (n) {
      f && f(n), t = 0;
      var r = (u = n.__c).__H;
      r && (r.__h.forEach(g$1), r.__h.forEach(j$1), r.__h = []);
    }, l$1.diffed = function (t) {
      e && e(t);
      var o = t.__c;
      o && o.__H && o.__H.__h.length && (1 !== i.push(o) && r === l$1.requestAnimationFrame || ((r = l$1.requestAnimationFrame) || function (n) {
        var t,
            u = function () {
          clearTimeout(r), b && cancelAnimationFrame(t), setTimeout(n);
        },
            r = setTimeout(u, 100);

        b && (t = requestAnimationFrame(u));
      })(x$1)), u = void 0;
    }, l$1.__c = function (t, u) {
      u.some(function (t) {
        try {
          t.__h.forEach(g$1), t.__h = t.__h.filter(function (n) {
            return !n.__ || j$1(n);
          });
        } catch (r) {
          u.some(function (n) {
            n.__h && (n.__h = []);
          }), u = [], l$1.__e(r, t.__v);
        }
      }), a && a(t, u);
    }, l$1.unmount = function (t) {
      v && v(t);
      var u = t.__c;
      if (u && u.__H) try {
        u.__H.__.forEach(g$1);
      } catch (t) {
        l$1.__e(t, u.__v);
      }
    };
    var b = "function" == typeof requestAnimationFrame;

    function g$1(n) {
      var t = u;
      "function" == typeof n.__c && n.__c(), u = t;
    }

    function j$1(n) {
      var t = u;
      n.__c = n.__(), u = t;
    }

    function k(n, t) {
      return !n || n.length !== t.length || t.some(function (t, u) {
        return t !== n[u];
      });
    }

    function w$1(n, t) {
      return "function" == typeof t ? t(n) : t;
    }

    function useMergedChildren(lhsProps, rhsProps) {
      var lhs = lhsProps === null || lhsProps === void 0 ? void 0 : lhsProps.children;
      var rhs = rhsProps === null || rhsProps === void 0 ? void 0 : rhsProps.children;

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        var ret = v$1(d$1, {}, lhs, rhs);
        return ret;
      }
    }

    function toVal(mix) {
      var k,
          y,
          str = '';

      if (typeof mix === 'string' || typeof mix === 'number') {
        str += mix;
      } else if (typeof mix === 'object') {
        if (Array.isArray(mix)) {
          for (k = 0; k < mix.length; k++) {
            if (mix[k]) {
              if (y = toVal(mix[k])) {
                str && (str += ' ');
                str += y;
              }
            }
          }
        } else {
          for (k in mix) {
            if (mix[k]) {
              str && (str += ' ');
              str += k;
            }
          }
        }
      }

      return str;
    }

    function clsx () {
      var i = 0,
          tmp,
          x,
          str = '';

      while (i < arguments.length) {
        if (tmp = arguments[i++]) {
          if (x = toVal(tmp)) {
            str && (str += ' ');
            str += x;
          }
        }
      }

      return str;
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */

    function useMergedClasses(lhs, rhs) {
      // Note: For the sake of forward compatibility, this function is labelled as
      // a hook, but as it uses no other hooks it technically isn't one.
      return mergeClasses(lhs, rhs);
    }

    function mergeClasses(lhs, rhs) {
      var lhsClass = lhs === null || lhs === void 0 ? void 0 : lhs.class;
      var lhsClassName = lhs === null || lhs === void 0 ? void 0 : lhs.className;
      var rhsClass = rhs === null || rhs === void 0 ? void 0 : rhs.class;
      var rhsClassName = rhs === null || rhs === void 0 ? void 0 : rhs.className;

      if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
        var lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
        var rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
        var allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
        return Array.from(allClasses).join(" ");
      } else {
        return undefined;
      }
    }

    function processRef(instance, ref) {
      if (typeof ref === "function") {
        ref(instance);
      } else if (ref != null) {
        ref.current = instance;
      }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */


    function useMergedRefs() {
      return function (lhsProps, rhsProps) {
        var lhs = lhsProps === null || lhsProps === void 0 ? void 0 : lhsProps.ref;
        var rhs = rhsProps === null || rhsProps === void 0 ? void 0 : rhsProps.ref;

        if (lhs == null && rhs == null) {
          return undefined;
        } else if (lhs == null) {
          return rhs;
        } else if (rhs == null) {
          return lhs;
        } else {
          var ret = A$1(current => {
            processRef(current, lhs);
            processRef(current, rhs);
          }, [lhs, rhs]);
          return ret;
        }
      };
    }
    /*
    function typetest<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const ref: RefObject<HTMLInputElement> = useRef<HTMLInputElement>(null);

        function acceptsRef(ref: Ref<any>) { }
        function acceptsOptionalRef(ref: Ref<any> | undefined) { }

        const c = [
            useMergedRefs<HTMLInputElement>()(undefined, undefined),
            useMergedRefs<HTMLInputElement>()({}, undefined),
            useMergedRefs<HTMLInputElement>()(props, undefined),
            useMergedRefs<HTMLInputElement>()(undefined, props),
            useMergedRefs<HTMLInputElement>()(props, props),
            useMergedRefs<HTMLInputElement>()({ ref }, props),
            useMergedRefs<HTMLInputElement>()({ ref }, { ref: undefined }),
            useMergedRefs<HTMLInputElement>()({ ref: undefined }, { ref }),
            useMergedRefs<HTMLInputElement>()({ ref }, { ref }),
        ] as const;

        /// @ts-expect-error
        acceptsRef(c[0]);
        /// @ts-expect-error
        acceptsRef(c[1]);

        acceptsOptionalRef(c[2]);
        acceptsOptionalRef(c[3]);
        acceptsOptionalRef(c[4]);

        /// @ts-expect-error TODO
        acceptsRef(c[5]);
        acceptsRef(c[6]);
        acceptsRef(c[7]);
        acceptsRef(c[8]);
    }
    */

    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */
    function useMergedStyles(lhs, rhs) {
      var _lhs$style, _rhs$style2;

      // Easy case, when there are no styles to merge return nothing.
      if (!(lhs !== null && lhs !== void 0 && lhs.style) && !(rhs !== null && rhs !== void 0 && rhs.style)) return undefined;

      if (typeof lhs != typeof rhs) {
        // Easy cases, when one is null and the other isn't.
        if (lhs !== null && lhs !== void 0 && lhs.style && !(rhs !== null && rhs !== void 0 && rhs.style)) return lhs.style;
        if (!(lhs !== null && lhs !== void 0 && lhs.style) && rhs !== null && rhs !== void 0 && rhs.style) return rhs.style; // They're both non-null but different types.
        // Convert the string type to an object bag type and run it again.

        if (lhs !== null && lhs !== void 0 && lhs.style && rhs !== null && rhs !== void 0 && rhs.style) {
          if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") return useMergedStyles({
            style: Object.fromEntries(lhs === null || lhs === void 0 ? void 0 : lhs.style.split(";").map(statement => statement.split(":")))
          }, rhs);
          if (typeof (rhs === null || rhs === void 0 ? void 0 : rhs.style) == "string") return useMergedStyles(lhs === null || lhs === void 0 ? void 0 : lhs.style, {
            style: Object.fromEntries(lhs === null || lhs === void 0 ? void 0 : lhs.style.split(";").map(statement => statement.split(":")))
          });
        } // Logic???


        return undefined;
      } // They're both strings, just concatenate them.


      if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") {
        var _rhs$style;

        return "".concat(lhs.style, ";").concat((_rhs$style = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style !== void 0 ? _rhs$style : "");
      } // They're both objects, just merge them.


      return _objectSpread2(_objectSpread2({}, (_lhs$style = lhs === null || lhs === void 0 ? void 0 : lhs.style) !== null && _lhs$style !== void 0 ? _lhs$style : {}), (_rhs$style2 = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style2 !== void 0 ? _rhs$style2 : {});
    }

    var _excluded$J = ["children", "class", "className", "style", "ref"],
        _excluded2$g = ["children", "class", "className", "style", "ref"];

    var log = str => {
      debugger;
      /* Intentional */
    };
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */

    function useMergedProps() {
      return function (lhs2, rhs2) {
        // First, put in all the properties that are easy to reason about
        // and all lhs props. We're going to merge in rhs just after.
        var lhs = _objectWithoutProperties(lhs2, _excluded$J);

        var rhs = _objectWithoutProperties(rhs2, _excluded2$g);

        var ret = _objectSpread2(_objectSpread2({}, lhs), {}, {
          ref: useMergedRefs()(lhs2, rhs2),
          style: useMergedStyles(lhs2, rhs2),
          className: useMergedClasses(lhs2, rhs2),
          children: useMergedChildren(lhs2, rhs2)
        });

        if (ret.ref === undefined) delete ret.ref;
        if (ret.style === undefined) delete ret.style;
        if (ret.className === undefined) delete ret.className;
        if (ret.children === undefined) delete ret.children; // Now, do *everything* else
        // Merge every remaining existing entry in lhs with what we've already put in ret.
        //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];

        var rhsEntries = Object.entries(rhs);

        for (var [rhsKey, rhsValue] of rhsEntries) {
          var lhsValue = lhs[rhsKey];

          if (typeof lhsValue === "function" || typeof rhsValue === "function") {
            // They're both functions that can be merged (or one's a function and the other's null).
            // Not an *easy* case, but a well-defined one.
            var merged = mergeFunctions(lhsValue, rhsValue);
            ret[rhsKey] = merged;
          } else {
            // Uh...we're here because one of them's null, right?
            if (lhsValue == null && rhsValue == null) {
              if (rhsValue === null && lhsValue === undefined) ret[rhsKey] = rhsValue;else ret[rhsKey] = lhsValue;
            }

            if (lhsValue == null) ret[rhsKey] = rhsValue;else if (rhsValue == null) ret[rhsKey] = lhsValue;else if (rhsValue == lhsValue) ; else {
              var _log;

              // Ugh.
              // No good strategies here, just log it if requested
              (_log = log) === null || _log === void 0 ? void 0 : _log("Could not merge incompatible prop \"".concat(rhsKey, "\" (type: ").concat(typeof rhsValue, ", values: [").concat(lhsValue, ", ").concat(rhsValue, "])"));
              ret[rhsKey] = rhsValue;
            }
          }
        }

        return ret;
      };
    }

    function mergeFunctions(lhs, rhs) {
      if (!lhs) return rhs;
      if (!rhs) return lhs;
      return (...args) => {
        var lv = lhs === null || lhs === void 0 ? void 0 : lhs(...args);
        var rv = rhs === null || rhs === void 0 ? void 0 : rhs(...args);
        if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
      };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */

    function useState(initialState) {
      // We keep both
      var [state, setState] = l(initialState);
      var ref = s(state); // Hijack the normal setter function 
      // to also set our ref to the new value

      var set = A$1(value => {
        if (typeof value === "function") {
          var callback = value;
          setState(prevValue => {
            var nextValue = callback(prevValue);
            ref.current = nextValue;
            return nextValue;
          });
        } else {
          ref.current = value;
          setState(value);
        }
      }, []);

      var get = () => {
        return ref.current;
      };

      console.assert(ref.current === state);
      return [state, set, get];
    }

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */

    function useRefElement() {
      // Let us store the actual (reference to) the element we capture
      var [element, setElement, getElement] = useState(null); // Create a RefCallback that's fired when mounted 
      // and that notifies us of our element when we have it

      var myRef = A$1(e => {
        if (e) setElement(() => e);
      }, []);
      var useRefElementProps = A$1(props => useMergedProps()({
        ref: myRef
      }, props), []); // Return both the element and the hook that modifies 
      // the props and allows us to actually find the element

      return {
        useRefElementProps,
        element,
        getElement
      };
    }

    function useElementSize({
      observeBox
    } = {}) {
      var {
        element,
        useRefElementProps
      } = useRefElement();
      var [size, setSize, getSize] = useState(null);
      y(() => {
        if (element) {
          var handleUpdate = () => {
            var {
              clientWidth,
              scrollWidth,
              offsetWidth,
              clientHeight,
              scrollHeight,
              offsetHeight,
              clientLeft,
              scrollLeft,
              offsetLeft,
              clientTop,
              scrollTop,
              offsetTop
            } = element;
            setSize({
              clientWidth,
              scrollWidth,
              offsetWidth,
              clientHeight,
              scrollHeight,
              offsetHeight,
              clientLeft,
              scrollLeft,
              offsetLeft,
              clientTop,
              scrollTop,
              offsetTop
            });
          };

          if (!("ResizeObserver" in window)) {
            document.addEventListener("resize", handleUpdate, {
              passive: true
            });
            return () => document.removeEventListener("resize", handleUpdate);
          } else {
            var observer = new ResizeObserver(entries => {
              handleUpdate();
            });
            observer.observe(element, {
              box: observeBox
            });
            return () => observer.disconnect();
          }
        }
      }, [element, observeBox]);
      return {
        element,
        elementSize: size,
        getElementSize: getSize,
        useElementSizeProps: useRefElementProps
      };
    }

    function capitalize(str) {
      return str[0].toUpperCase() + str.substr(1);
    }
    /**
     * Inspects the element's style and determines the logical direction that text flows.
     *
     * Certain CSS properties, like `block-size`, respect the current writing mode and text direction.
     * But `transform`, `clip`, etc. don't.
     *
     * This is provided so that CSS properties can consistently use those logical properties.
     *
     * See https://drafts.csswg.org/css-writing-modes/#logical-to-physical
     *
     * @returns An object containing the following functions:
     * * `getLogicalDirection`: retrieves a `LogicalDirectionInfo` representing the current state of the element. (Function is constant between renders)
     * * `convertElementSize`: When used in conjunction with `useElementSize`, allows you to retrieve the logical size of an element instead of the physical size.
     * * `convertToLogicalOrientation`: Based on the current direction, converts "horizontal" or "vertical" to "inline" or "block".
     * * `convertToPhysicalOrientation`:  Based on the current direction, converts "inline" or "block" to "horizontal" or "vertical".
     */


    function useLogicalDirection(element) {
      var [writingMode, setWritingMode] = l(null);
      var [direction, setDirection] = l(null);
      var [textOrientation, setTextOrientation] = l(null);
      var writingModeRef = s(writingMode);
      var directionRef = s(direction);
      var textOrientationRef = s(textOrientation);
      h(() => {
        writingModeRef.current = writingMode;
      }, [writingMode]);
      h(() => {
        directionRef.current = direction;
      }, [direction]);
      h(() => {
        textOrientationRef.current = textOrientation;
      }, [textOrientation]);
      h(() => {
        if (element) {
          var computedStyles = window.getComputedStyle(element);
          var w = computedStyles.writingMode;
          var t = computedStyles.textOrientation;
          var d = computedStyles.direction;
          setWritingMode(w || "horizontal-tb");
          setDirection(d || "rtl");
          setTextOrientation(t || "mixed");
        }
      });
      var getLogicalDirection = A$1(() => {
        var _direction;

        var writingMode = writingModeRef.current;
        var direction = directionRef.current;
        var textOrientation = textOrientationRef.current;
        if (!writingMode || !direction || !textOrientation) return null;
        if (textOrientation == "upright") direction = "ltr";
        return _objectSpread2({}, WritingModes[writingMode !== null && writingMode !== void 0 ? writingMode : "horizontal-tb"][(_direction = direction) !== null && _direction !== void 0 ? _direction : "ltr"]);
      }, [writingModeRef, directionRef, textOrientationRef]);
      var convertToLogicalOrientation = A$1((elementOrientation, direction) => {
        var _direction2, _direction3;

        (_direction2 = direction) !== null && _direction2 !== void 0 ? _direction2 : direction = getLogicalDirection();
        if (((_direction3 = direction) === null || _direction3 === void 0 ? void 0 : _direction3.inlineOrientation) === elementOrientation) return "inline";
        return "block";
      }, [getLogicalDirection]);
      var convertToPhysicalOrientation = A$1((elementOrientation, direction) => {
        var _direction4;

        (_direction4 = direction) !== null && _direction4 !== void 0 ? _direction4 : direction = getLogicalDirection();

        if (elementOrientation == "inline") {
          var _direction5;

          if (((_direction5 = direction) === null || _direction5 === void 0 ? void 0 : _direction5.inlineOrientation) == "horizontal") return "horizontal";
          return "vertical";
        } else {
          var _direction6;

          if (((_direction6 = direction) === null || _direction6 === void 0 ? void 0 : _direction6.blockOrientation) == "vertical") return "vertical";
          return "horizontal";
        }
      }, [getLogicalDirection]);
      var convertElementSize = A$1((elementSize, direction) => {
        var _direction7;

        (_direction7 = direction) !== null && _direction7 !== void 0 ? _direction7 : direction = getLogicalDirection();

        if (direction) {
          var {
            inlineSize,
            blockSize,
            inlineDirection,
            blockDirection
          } = direction; // Size is relatively simple

          var clientInlineSize = elementSize["client".concat(capitalize(inlineSize))];
          var clientBlockSize = elementSize["client".concat(capitalize(blockSize))];
          var offsetInlineSize = elementSize["offset".concat(capitalize(inlineSize))];
          var offsetBlockSize = elementSize["offset".concat(capitalize(blockSize))];
          var scrollInlineSize = elementSize["scroll".concat(capitalize(inlineSize))];
          var scrollBlockSize = elementSize["scroll".concat(capitalize(blockSize))]; // Position requires us to sometimes use one property (like `left`)
          // or sometimes two (like `left` + `width`)

          function getPhysicalLeftTop(dir) {
            if (dir === "ltr" || dir == "rtl") return "left";
            return "top";
          }

          function getPhysicalRightBottom(dir) {
            if (dir === "rtl") return "width";
            if (dir === "btt") return "height";
            return null;
          }

          var f1 = getPhysicalLeftTop(inlineDirection);
          var f2 = getPhysicalRightBottom(inlineDirection);
          var f3 = getPhysicalLeftTop(blockDirection);
          var f4 = getPhysicalRightBottom(blockDirection);
          var clientInlineInset = elementSize["client".concat(capitalize(f1))] + (!f2 ? 0 : elementSize["client".concat(capitalize(f2))]);
          var scrollInlineInset = elementSize["scroll".concat(capitalize(f1))] + (!f2 ? 0 : elementSize["scroll".concat(capitalize(f2))]);
          var offsetInlineInset = elementSize["offset".concat(capitalize(f1))] + (!f2 ? 0 : elementSize["offset".concat(capitalize(f2))]);
          var clientBlockInset = elementSize["client".concat(capitalize(f3))] + (!f4 ? 0 : elementSize["client".concat(capitalize(f4))]);
          var scrollBlockInset = elementSize["scroll".concat(capitalize(f3))] + (!f4 ? 0 : elementSize["scroll".concat(capitalize(f4))]);
          var offsetBlockInset = elementSize["offset".concat(capitalize(f3))] + (!f4 ? 0 : elementSize["offset".concat(capitalize(f4))]);
          return {
            clientInlineSize,
            scrollInlineSize,
            offsetInlineSize,
            clientBlockSize,
            scrollBlockSize,
            offsetBlockSize,
            clientInlineInset,
            scrollInlineInset,
            offsetInlineInset,
            clientBlockInset,
            scrollBlockInset,
            offsetBlockInset
          };
        }

        return null;
      }, [getLogicalDirection]);
      return {
        getLogicalDirection,
        convertElementSize,
        convertToLogicalOrientation,
        convertToPhysicalOrientation
      };
    }
    var HorizontalTbLtr = {
      inlineDirection: "ltr",
      blockDirection: "ttb",
      inlineOrientation: "horizontal",
      blockOrientation: "vertical",
      inlineSize: "width",
      blockSize: "height",
      leftRightDirection: "ltr",
      overUnderDirection: "ttb"
    };

    var HorizontalTbRtl = _objectSpread2(_objectSpread2({}, HorizontalTbLtr), {}, {
      inlineDirection: "rtl"
    });

    var VerticalRlLtr = {
      inlineDirection: "ttb",
      blockDirection: "rtl",
      inlineOrientation: "vertical",
      blockOrientation: "horizontal",
      inlineSize: "height",
      blockSize: "width",
      leftRightDirection: "ttb",
      overUnderDirection: "rtl"
    };

    var VerticalRlRtl = _objectSpread2(_objectSpread2({}, VerticalRlLtr), {}, {
      inlineDirection: "btt"
    });

    var SidewaysRlLtr = _objectSpread2({}, VerticalRlLtr);

    var SidewaysRlRtl = _objectSpread2({}, VerticalRlRtl);

    var VerticalLrLtr = _objectSpread2(_objectSpread2({}, VerticalRlLtr), {}, {
      blockDirection: "ltr"
    });

    var VerticalLrRtl = _objectSpread2(_objectSpread2({}, VerticalRlRtl), {}, {
      blockDirection: "ltr"
    });

    var SidewaysLtLtr = _objectSpread2(_objectSpread2({}, VerticalLrLtr), {}, {
      inlineDirection: "btt",
      leftRightDirection: "btt",
      overUnderDirection: "ltr"
    });

    var SidewaysLtRtl = _objectSpread2(_objectSpread2({}, SidewaysLtLtr), {}, {
      inlineDirection: "ttb"
    });

    var HorizontalTb = {
      ltr: HorizontalTbLtr,
      rtl: HorizontalTbRtl
    };
    var VerticalRl = {
      ltr: VerticalRlLtr,
      rtl: VerticalRlRtl
    };
    var VerticalLr = {
      ltr: VerticalLrLtr,
      rtl: VerticalLrRtl
    };
    var SidewaysRl = {
      ltr: SidewaysRlLtr,
      rtl: SidewaysRlRtl
    };
    var SidewaysLr = {
      ltr: SidewaysLtLtr,
      rtl: SidewaysLtRtl
    };
    var WritingModes = {
      "horizontal-tb": HorizontalTb,
      "vertical-lr": VerticalLr,
      "vertical-rl": VerticalRl,
      "sideways-lr": SidewaysLr,
      "sideways-rl": SidewaysRl
    };

    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * Use with caution, and **do not use the getter in useLayoutEffect!!**
     * `setState`'s getter does not have this problem, but then you're using your own state
     * instead of an existing value, which might not always be feasible.
     *
     * Weigh your options, and hopefully one of them gets the job done.
     *
     * @param value
     * @returns
     */

    function useStableGetter(value) {
      var ref = s(value);
      _(ref, () => value);
      return A$1(() => {
        return ref.current;
      }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * DO NOT USE THE RESULT IN useLayoutEffect!!
     *
     * TODO: Investigate options.diffed if the useLayoutEffect limitation becomes limitlessly limiting.
     *
     * Source: https://github.com/facebook/react/issues/14099#issuecomment-659298422
     */

    function useStableCallback(fn) {
      var currentCallbackGetter = useStableGetter(fn);
      return A$1((...args) => {
        var currentFunc = currentCallbackGetter();

        if (!currentFunc) {
          throw new Error('Callback retrieved from useStableCallback() cannot be called from useLayoutEffect().');
        }

        return currentFunc(...args);
      }, []);
    }

    /**
     * Wrap the native `useLayoutEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     */

    function useLayoutEffect(effect, inputs) {
      var prevInputs = s(inputs);

      var effect2 = () => {
        var changes = [];

        for (var i = 0; i < Math.max(prevInputs.current.length, inputs.length); ++i) {
          if (prevInputs.current[i] != inputs[i]) changes[i] = {
            from: prevInputs.current[i],
            to: inputs[i]
          };
        }

        effect(prevInputs.current, changes);
        prevInputs.current = inputs;
      };

      h(effect2, inputs);
    }

    function useTimeout({
      timeout,
      callback,
      triggerIndex
    }) {
      var stableCallback = useStableCallback(callback);
      var getTimeout = useStableGetter(timeout);
      var timeoutIsNull = timeout == null;
      y(() => {
        var timeout = getTimeout();
        console.assert(timeoutIsNull == (timeout == null));

        if (timeout) {
          var handle = setTimeout(stableCallback, timeout);
          return () => clearTimeout(handle);
        }
      }, [triggerIndex, timeoutIsNull]);
    }

    /**
     * Given an asyncronous event handler, returns a syncronous one that works on the DOM,
     * along with some other information related to the current state.
     * Does not modify any props.
     *
     * The handler is automatically throttled to only run one at a time.
     * If the handler is called, and then before it finishes, is called again,
     * it will be put on hold until the current one finishes, at which point
     * the second one will run.  If the handler is called a third time before
     * the first has finished, it will *replace* the second, so only the most
     * recently called iteration of the handler will run.
     *
     * You may optionally *also* specify a debounce parameter that waits until the
     * syncronous handler has not been called for the specified number of
     * milliseconds, at which point we *actually* run the asyncronous handler
     * according to the logic in the previous paragraph. This is in
     * *addition* to throttling the handler, and does not replace that behavior.
     *
     * Note that the parameters to the async handler are slightly different than
     * the sync handler &ndash; the first argument, as decided by you with the
     * `capture` parameter for this hook, is the "saved" information from the
     * event.  For example, the event's currentTarget's `value`, which may have
     * changed by the time the handler is *actually* called.  The second argument
     * is the original event, which might still have some useful fields on it
     * like `mouseX` or something, but is stale at least in regards to the
     * element it references.
     */

    function useAsyncHandler() {
      return function ({
        capture,
        debounce
      }) {
        // Always represents whatever promise is currently being waited on, or null if none.
        var [promise, setPromise, getPromise] = useState(null); // Keep track of how many times we've actually called the async handler

        var [runCount, setRunCount] = useState(0);
        var [resolveCount, setResolveCount] = useState(0);
        var [rejectCount, setRejectCount] = useState(0); // 

        var [currentType, setCurrentType] = useState(null); // If we're set to use a debounce, then when the timeout finishes,
        // the promise from this state object is transferred over to either 
        // the current promise or the pending promise.

        var [debouncedPromiseStarter, setDebouncedPromiseStarter, getDebouncedPromiseStarter] = useState(null); // When we want to start a new promise, we won't allow it to start if one is still running.
        // In that case, we store the promise (or rather, a way to start the promise) in state.

        var [pendingPromiseStarter, setPendingPromiseStarter, getPendingPromiseStarter] = useState(null); // We need to differentiate between `undefined` and "no error has been thrown".

        var [error, setError, getError] = useState(undefined);
        var [hasError, setHasError, getHasError] = useState(false); // Same thing, we need to differentiate between "nothing captured yet" and "`undefined` was captured"

        var [currentCapture, setCurrentCapture, getCurrentCapture] = useState(undefined);
        var [hasCapture, setHasCapture] = useState(false); // When the debounce timer is up (or we manually request the debounce to end)
        // run the normal "please consider running this promise" routine that we would
        // have just run immediately if we weren't debouncing our promises.

        var onDebounceTimeUp = A$1(() => {
          var debouncedPromiseStarter = getDebouncedPromiseStarter();
          if (debouncedPromiseStarter) wantToStartANewPromise(debouncedPromiseStarter);
          setDebouncedPromiseStarter(null);
        }, [wantToStartANewPromise, setDebouncedPromiseStarter]); // Handle the debounce. Logically this happens before the main step as a sort of step 0.
        // Resets the timeout any time the handler was requested to be called again
        // and when it finishes, actually call the handler (or set it as the pending promise)

        useTimeout({
          timeout: debounce !== null && debounce !== void 0 ? debounce : null,
          callback: onDebounceTimeUp,
          triggerIndex: debouncedPromiseStarter
        }); // See if we should set our current promise to be whatever the pending promise is
        // (usually because the current promise finished and became null).

        useLayoutEffect(() => {
          // Our current promise just finished and there's one waiting?
          if (promise == null && pendingPromiseStarter != null) {
            wantToStartANewPromise(pendingPromiseStarter);
            setPendingPromiseStarter(null);
          }
        }, [promise, pendingPromiseStarter]); // Called any time the async handler is about to be called for whatever reason,
        // except for debounce, which comes first, as a sort of "step 0".
        // Handles all the necessary boilerplate related to choosing whether to
        // run or set as pending, resetting state variables, etc.

        function wantToStartANewPromise(startPromise) {
          var alreadyRunningPromise = getPromise() != null; // Boilerplate wrapper around the given promise starter

          var startPromiseWithBoilerplate = () => {
            // When it starts, notify the caller
            setRunCount(r => ++r); // When it completes, notify the caller
            // When it fails, save the error and notify the caller
            // When it settles, reset our state so we can run a pending promise if it exists

            var onThen = () => {
              setResolveCount(c => ++c);
            };

            var onCatch = ex => {
              setError(ex);
              setHasError(true);
              setRejectCount(c => ++c);
            };

            var onFinally = () => {
              setPromise(null);
            }; // Handle the special case where the handler is synchronous


            var result;

            try {
              result = startPromise();

              if (result == undefined) {
                // It's synchronous and returned successfully.
                // Bail out early.
                onThen();
                onFinally();
                setCurrentType("sync");
                return;
              }

              console.assert("then" in result);
            } catch (ex) {
              // It's synchronous (or asynchronous but didn't await anything yet) and threw an error.
              // Bail out early.
              onCatch(ex);
              onFinally();
              setCurrentType("sync");
              return;
            } // The handler is asynchronous


            setCurrentType("async");
            return _asyncToGenerator(function* () {
              yield result;
            })().then(onThen).catch(onCatch).finally(onFinally);
          };

          if (!alreadyRunningPromise) {
            // Start the promise immediately, because there wasn't one running already.
            var nextPromise = startPromiseWithBoilerplate();

            if (nextPromise == undefined) ; else {
              setError(undefined);
              setHasError(false);
              setPromise(nextPromise);
            }
          } else {
            // Don't start the promise yet, 
            // and allow it to start in the future instead.
            setPendingPromiseStarter(_ => startPromiseWithBoilerplate);
          }
        }

        var ret = {
          getSyncHandler,
          getCurrentCapture,
          callCount: runCount,
          currentCapture,
          hasCapture,
          pending: promise != null,
          hasError,
          error,
          currentType,
          flushDebouncedPromise: onDebounceTimeUp,
          resolveCount,
          rejectCount,
          settleCount: rejectCount + resolveCount
        };
        return ret;

        function getSyncHandler(asyncHandler) {
          var syncHandler = useStableCallback(function syncHandler(event) {
            if (asyncHandler == null) return; // Get the most significant information from the event at this time,
            // which is necessary since the promise could actually be called much later
            // when the element's value (etc.) has changed.

            var captured = capture(event);
            setCurrentCapture(captured);
            setHasCapture(true);

            var startPromise = () => asyncHandler(captured, event);

            if (debounce == null) {
              wantToStartANewPromise(startPromise);
            } else {
              setDebouncedPromiseStarter(_ => startPromise);
            }
          });
          return asyncHandler == null ? undefined : syncHandler;
        }
      };
    }

    var _excluded$I = ["text"];
    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useLinearNavigation({
      getIndex,
      setIndex,
      managedChildren,
      navigationDirection
    }) {
      var _navigationDirection;

      (_navigationDirection = navigationDirection) !== null && _navigationDirection !== void 0 ? _navigationDirection : navigationDirection = "either";
      var index = getIndex();
      var childCount = managedChildren.length; // Make sure the tabbable index never escapes the bounds of all available children
      // TODO: Keep track of the original index and keep it, at least until keyboard navigation.

      useLayoutEffect(() => {
        if (index !== null) {
          if (index < 0) {
            setIndex(0);
          } else if (childCount > 0 && index >= childCount) {
            setIndex(childCount - 1);
          }
        }
      }, [index, childCount]); // These allow us to manipulate what our current tabbable child is.

      var navigateToIndex = A$1(index => {
        setIndex(index < 0 ? managedChildren.length + index : index);
      }, []);
      var navigateToNext = A$1(() => {
        setIndex(i => i === null ? null : i >= managedChildren.length - 1 ? managedChildren.length - 1 : ++i);
      }, []);
      var navigateToPrev = A$1(() => {
        setIndex(i => i === null ? null : i < 0 ? 0 : --i);
      }, []);
      var navigateToStart = A$1(() => {
        navigateToIndex(0);
      }, [navigateToIndex]);
      var navigateToEnd = A$1(() => {
        navigateToIndex(-1);
      }, [navigateToIndex]);
      var useLinearNavigationChild = A$1(() => {
        var _element$parentElemen;

        var {
          useRefElementProps,
          element
        } = useRefElement(); // Prefer the parent element's direction so that we're not calling getComputedStyle
        // on every single individual child, which is likely redundant.
        // TODO: Does useLogicalDirection need to hold a per-render & per-element cache to make this work?
        // Or does the browser automatically cache the computations until something changes?
        // Given that the values are live, it seems like it should be the latter...

        var {
          convertElementSize,
          getLogicalDirection
        } = useLogicalDirection((_element$parentElemen = element === null || element === void 0 ? void 0 : element.parentElement) !== null && _element$parentElemen !== void 0 ? _element$parentElemen : element);

        var useLinearNavigationChildProps = props => {
          var onKeyDown = e => {
            // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
            if (e.ctrlKey || e.metaKey) return;
            var info = getLogicalDirection();
            var allowsBlockNavigation = navigationDirection == "block" || navigationDirection == "either";
            var allowsInlineNavigation = navigationDirection == "inline" || navigationDirection == "either";

            switch (e.key) {
              case "ArrowUp":
                {
                  var propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  var directionAllowed = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation;

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowDown":
                {
                  var _propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";

                  var _directionAllowed = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation;

                  if (_directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[_propName]) === "btt") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowLeft":
                {
                  var _propName2 = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";

                  var _directionAllowed2 = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation;

                  if (_directionAllowed2) {
                    if ((info === null || info === void 0 ? void 0 : info[_propName2]) === "rtl") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowRight":
                {
                  var _propName3 = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";

                  var _directionAllowed3 = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation;

                  if (_directionAllowed3) {
                    if ((info === null || info === void 0 ? void 0 : info[_propName3]) === "rtl") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  e.preventDefault();
                  e.stopPropagation();
                  break;
                }

              case "Home":
                navigateToStart();
                e.preventDefault();
                e.stopPropagation();
                break;

              case "End":
                navigateToEnd();
                e.preventDefault();
                e.stopPropagation();
                break;
            }
          };

          return useRefElementProps(useMergedProps()({
            onKeyDown
          }, props));
        };

        return {
          useLinearNavigationChildProps
        };
      }, [navigationDirection, navigateToNext, navigateToPrev, navigateToStart, navigateToEnd]);
      return {
        useLinearNavigationChild,
        navigateToIndex,
        navigateToNext,
        navigateToPrev,
        navigateToStart,
        navigateToEnd
      };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useTypeaheadNavigation({
      collator,
      getIndex,
      typeaheadTimeout,
      setIndex
    }) {
      // For typeahead, keep track of what our current "search" string is (if we have one)
      // and also clear it every 1000 ms since the last time it changed.
      // Next, keep a mapping of typeahead values to indices for faster searching.
      // And, for the user's sake, let them know when their typeahead can't match anything anymore
      var [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
      useTimeout({
        timeout: typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000,
        callback: () => {
          setCurrentTypeahead(null);
          setInvalidTypeahead(null);
        },
        triggerIndex: currentTypeahead
      });
      var sortedTypeaheadInfo = s([]);
      var [invalidTypeahead, setInvalidTypeahead] = useState(false); // Handle typeahead for input method editors as well
      // Essentially, when active, ignore further keys 
      // because we're waiting for a CompositionEnd event

      var [imeActive, setImeActive, getImeActive] = useState(false); // Because composition events fire *after* keydown events 
      // (but within the same task, which, TODO, could be browser-dependent),
      // we can use this to keep track of which event we're listening for on the first keydown.

      var [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
      useLayoutEffect(() => {
        if (nextTypeaheadChar !== null) {
          setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar);
          setNextTypeaheadChar(null);
        }
      }, [nextTypeaheadChar]);
      var comparator = useStableCallback((lhs, rhs) => {
        var compare;

        if (typeof lhs === "string" && typeof rhs.text === "string") {
          var _safeRhs$toLowerCase;

          // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
          // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.
          var safeLhs = lhs.normalize("NFD");
          var safeRhs = rhs.text.normalize("NFD").substr(0, safeLhs.length);
          if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
          return compare;
        }

        return lhs - rhs;
      }); // Handle changes in typeahead that cause changes to the tabbable index

      y(() => {
        if (currentTypeahead && sortedTypeaheadInfo.current.length) {
          var sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, comparator);

          if (sortedTypeaheadIndex < 0) {
            // The user has typed an entry that doesn't exist in the list
            // (or more specifically "for which there is no entry that starts with that input")
            setInvalidTypeahead(true);
          } else {
            setInvalidTypeahead(false);
            /*
              We know roughly where, in the sorted array of strings, our next typeahead location is.
              But roughly isn't good enough if there are multiple matches.
              To convert our sorted index to the unsorted index we need, we have to find the first
              element that matches us *and* (if any such exist) is *after* our current selection.
                In other words, the only way typeahead moves backwards relative to our current
              position is if the only other option is behind us.
                It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
              Though there's also a case for just going upwards to the nearest to prevent jumpiness.
              But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
              I dunno. Going back to the start is the simplist though.
                Basically what this does: Starting from where we found ourselves after our binary search,
              scan backwards and forwards through all adjacent entries that also compare equally so that
              we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
              (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
                TODO: The binary search starts this off with a solid O(log n), but one-character
              searches are, thanks to pigeonhole principal, eventually guaranteed to become
              O(n*log n). This is annoying but probably not easily solvable? There could be an
              exception for one-character strings, but that's just kicking the can down
              the road. Maybe one or two characters would be good enough though.
            */
            // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.

            var lowestUnsortedIndexAll = null;
            var lowestSortedIndexAll = sortedTypeaheadIndex; // These two are only set for elements that are ahead of us, but the principle's the same otherwise

            var lowestUnsortedIndexNext = null;
            var lowestSortedIndexNext = sortedTypeaheadIndex;

            var updateBestFit = u => {
              var _getIndex;

              if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                lowestUnsortedIndexAll = u;
                lowestSortedIndexAll = i;
              }

              if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > ((_getIndex = getIndex()) !== null && _getIndex !== void 0 ? _getIndex : -Infinity)) {
                lowestUnsortedIndexNext = u;
                lowestSortedIndexNext = i;
              }
            };

            var i = sortedTypeaheadIndex;

            while (i >= 0 && comparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              --i;
            }

            i = sortedTypeaheadIndex;

            while (i < sortedTypeaheadInfo.current.length && comparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              ++i;
            }

            if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
          }
        }
      }, [currentTypeahead]);
      var useTypeaheadNavigationChild = A$1(_ref => {
        var {
          text
        } = _ref,
            i = _objectWithoutProperties(_ref, _excluded$I);

        y(() => {
          if (text) {
            // Find where to insert this item.
            // Because all index values should be unique, the returned sortedIndex
            // should always refer to a new location (i.e. be negative)                
            var sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, comparator);
            console.assert(sortedIndex < 0);

            if (sortedIndex < 0) {
              sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, {
                text,
                unsortedIndex: i.index
              });
            }

            return () => {
              // When unmounting, find where we were and remove ourselves.
              // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
              var sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, comparator);
              console.assert(sortedIndex >= 0);

              if (sortedIndex >= 0) {
                sortedTypeaheadInfo.current.splice(sortedIndex, 1);
              }
            };
          }
        }, [text]);

        var useTypeaheadNavigationChildProps = function (_ref2) {
          var props = _extends({}, _ref2);

          var {
            useRefElementProps,
            element
          } = useRefElement();

          var onCompositionStart = e => {
            setImeActive(true);
          };

          var onCompositionEnd = e => {
            setNextTypeaheadChar(e.data);
            setImeActive(false);
          };

          var onKeyDown = e => {
            var imeActive = getImeActive();
            var key = e.key; // Not handled by typeahead (i.e. assume this is a keyboard shortcut)

            if (e.ctrlKey || e.metaKey) return;

            if (!imeActive && e.key === "Backspace") {
              // Remove the last character in a way that doesn't split UTF-16 surrogates.
              setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
              e.preventDefault();
              e.stopPropagation();
              return;
            } // The key property represents the typed character OR the "named key attribute" of the key pressed.
            // There's no definite way to tell the difference, but for all intents and purposes
            // there are no one-character names, and there are no non-ASCII-alpha names.
            // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.


            var isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);

            if (isCharacterKey) {
              var _getCurrentTypeahead;

              if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ; else {
                e.preventDefault();
                e.stopPropagation(); // Note: Won't be true for the first keydown
                // but will be overwritten before useLayoutEffect is called
                // to actually apply the change

                if (!imeActive) setNextTypeaheadChar(key);
              }
            }
          };

          return useMergedProps()(useRefElementProps({
            onKeyDown,
            onCompositionStart,
            onCompositionEnd
          }), props);
        };

        return {
          useTypeaheadNavigationChildProps
        };
      }, []);
      return {
        useTypeaheadNavigationChild,
        currentTypeahead,
        invalidTypeahead
      };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */

    function binarySearch(array, wanted, comparator) {
      var firstIndex = 0;
      var lastIndex = array.length - 1;

      while (firstIndex <= lastIndex) {
        var testIndex = lastIndex + firstIndex >> 1;
        var comparisonResult = comparator(wanted, array[testIndex]);

        if (comparisonResult > 0) {
          firstIndex = testIndex + 1;
        } else if (comparisonResult < 0) {
          lastIndex = testIndex - 1;
        } else {
          return testIndex;
        }
      }

      return -firstIndex - 1;
    }

    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is slightly more complicated in that it returns both a
     * prop-modifying hook, but also a hook that each child will need
     * to use: `useManagedChild`.  It's stable across renders, so just
     * toss it into a `Context` so the children can have access to it.
     * This function registers the child with the parent and provides
     * it with any requested information, but doesn't do anything else
     * until it unmounts and retracts that information.
     */

    function useChildManager() {
      // This is blindly updated any time a child mounts or unmounts itself.
      // Used to make sure that any time the array of managed children updates,
      // we also re-render.
      var [childUpdateIndex, setChildUpdateIndex] = useState(0);
      var [totalChildrenMounted, setTotalChildrenMounted, getTotalChildrenMounted] = useState(0);
      var [totalChildrenUnounted, setTotalChildrenUnounted, getTotalChildrenUnounted] = useState(0);
      var childrenCurrentlyMounted = totalChildrenMounted - totalChildrenUnounted;
      var managedChildren = s([]
      /** TODO: Any problems caused by using an array when it should be an object? */
      );
      var mountedChildren = s([]);
      var mountOrder = s(new Map());
      var indicesByElement = s(new Map());
      var getMountIndex = A$1(index => {
        return mountOrder.current.get(index);
      }, []);
      var useManagedChild = A$1(info => {
        var {
          element,
          getElement,
          useRefElementProps
        } = useRefElement();
        useLayoutEffect(() => {
          var index = getTotalChildrenMounted();
          mountOrder.current.set(info.index, index);
          mountedChildren.current[index] = info;
          setTotalChildrenMounted(t => ++t);
          return () => {
            mountOrder.current.delete(info.index);
            mountedChildren.current[index] = null;
            setTotalChildrenUnounted(t => ++t);
          };
        }, [info.index]); // As soon as the component mounts, notify the parent and request a rerender.

        useLayoutEffect(([prevElement, prevIndex], changes) => {
          if (element) {
            indicesByElement.current.set(element, info.index);

            if (managedChildren.current[info.index] != undefined) {
              console.assert(info.index == undefined, "Two children with the same index were added, which may result in unexpected behavior.");
              debugger; // Intentional
            }

            setChildUpdateIndex(c => ++c);
            managedChildren.current[info.index] = _objectSpread2({}, info);
            return () => {
              setChildUpdateIndex(c => ++c);
              delete managedChildren.current[info.index];
              indicesByElement.current.delete(element);
            };
          }
        }, [element, info.index]); // Any time our child props change, make that information available generally.
        // *Don't re-render*, otherwise we'd be stuck in an
        // infinite loop every time an anonymous function is passed.
        // It comes in from the props so the child was already updated by it --
        // we don't need the parent to re-render every single child any time
        // "onClick" updates or whatever.  The relevant child already knows,
        // and that's what matters.

        useLayoutEffect(() => {
          if (managedChildren.current[info.index] != undefined) managedChildren.current[info.index] = _objectSpread2({}, info);
        }, [...Object.entries(info).flat()]);
        return {
          element,
          getElement,
          useManagedChildProps: useRefElementProps
        };
      }, []);
      return {
        useManagedChild,
        childCount: childrenCurrentlyMounted,
        managedChildren: managedChildren.current,
        mountedChildren: mountedChildren.current,
        indicesByElement: indicesByElement.current,
        totalChildrenMounted,
        totalChildrenUnounted,
        getMountIndex
      };
    }
    /**
     * Helper function for letting children know when they are or are not the
     * current selected/expanded/focused/whatever child.
     *
     * Automatically handles when children are mounted & unmounted and such.
     *
     * @param activatedIndex What index the current selected (etc.) child is
     * @param length How many children exist (as managedChildren.length)
     * @param setFlag A function that probably looks like (i, flag) => managedChildren[i].setActive(flag)
     */

    function useChildFlag(activatedIndex, length, setFlag) {
      var [prevActivatedIndex, setPrevActivatedIndex, getPrevActivatedIndex] = useState(null);
      var [prevChildCount, setPrevChildCount, getPrevChildCount] = useState(length); // Any time the number of components changes,
      // reset any initial, possibly incorrect state they might have had, just in case.

      useLayoutEffect(() => {
        var direction = Math.sign(length - getPrevChildCount());

        if (direction !== 0) {
          for (var i = (_getPrevChildCount = getPrevChildCount()) !== null && _getPrevChildCount !== void 0 ? _getPrevChildCount : 0; i != length; i += direction) {
            var _getPrevChildCount;

            setFlag(i, i === activatedIndex);
          }

          setPrevChildCount(length);
        }
      }, [setFlag, activatedIndex, length]);
      useLayoutEffect(() => {
        // Deactivate the previously activated component
        var prevActivatedIndex = getPrevActivatedIndex();

        if (prevActivatedIndex != activatedIndex) {
          if (prevActivatedIndex != null && prevActivatedIndex >= 0 && prevActivatedIndex < length) setFlag(prevActivatedIndex, false);
        } // Activate the current component


        if (activatedIndex != null && activatedIndex >= 0 && activatedIndex < length) {
          setFlag(activatedIndex, true);
          setPrevActivatedIndex(activatedIndex);
        }
      }, [setFlag, activatedIndex, length]);
    }

    var _excluded$H = ["managedChildren", "childCount", "useManagedChild", "indicesByElement"],
        _excluded2$f = ["tabIndex"],
        _excluded3$7 = ["tabIndex"];
    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `focusOnChange` should be set to true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const { focused, focusedInner, useHasFocusProps } = useHasFocus<ParentElement>();
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */

    function useRovingTabIndex({
      focusOnChange: foc,
      tabbableIndex
    }) {
      var [rerenderAndFocus, setRerenderAndFocus] = useState(null);
      var getFocusOnChange = useStableGetter(foc);
      var getTabbableIndex = useStableGetter(tabbableIndex);
      s(-Infinity); // Call the hook that allows us to collect information from children who provide it

      var _useChildManager = useChildManager(),
          {
        managedChildren,
        childCount,
        useManagedChild,
        indicesByElement
      } = _useChildManager,
          rest = _objectWithoutProperties(_useChildManager, _excluded$H); // Any time the tabbable index changes,
      // notify the previous child that it's no longer tabbable,
      // and notify the next child that is allowed to be tabbed to.


      useChildFlag(tabbableIndex, childCount, (index, tabbable) => {
        var _managedChildren$inde;

        if (index != null) (_managedChildren$inde = managedChildren[index]) === null || _managedChildren$inde === void 0 ? void 0 : _managedChildren$inde.setTabbable(tabbable);
      });
      A$1(() => {
        if (tabbableIndex != null) managedChildren[tabbableIndex].setTabbable(true);
      }, [tabbableIndex]);
      var useRovingTabIndexChild = A$1(info => {
        var [rrafIndex, setRrafIndex] = useState(1);
        var rerenderAndFocus = A$1(() => {
          setRrafIndex(i => ++i);
        }, []);

        var newInfo = _objectSpread2(_objectSpread2({}, info), {}, {
          rerenderAndFocus,
          setTabbable: A$1(tabbable => {
            setTabbable(tabbable);
          }, [])
        });

        var {
          element,
          getElement,
          useManagedChildProps
        } = useManagedChild(newInfo); // TODO: Using getTabbableIndex during render phase on mount

        var [tabbable, setTabbable] = useState(getTabbableIndex() == info.index);
        y(() => {
          if (element && tabbable) {
            setRerenderAndFocus(_ => rerenderAndFocus);

            if (getFocusOnChange() && "focus" in element) {
              requestAnimationFrame(() => {
                queueMicrotask(() => {
                  element.focus();
                });
              });
            }
          }
        }, [element, tabbable, rrafIndex]);

        function useRovingTabIndexSiblingProps(_ref) {
          var {
            tabIndex
          } = _ref,
              props = _objectWithoutProperties(_ref, _excluded2$f);

          if (tabIndex == null) {
            if (tabbable) tabIndex = 0;else tabIndex = -1;
          }

          return useMergedProps()({
            tabIndex
          }, props);
        }

        function useRovingTabIndexChildProps(_ref2) {
          var {
            tabIndex
          } = _ref2,
              props = _objectWithoutProperties(_ref2, _excluded3$7);

          if (tabIndex == null) {
            if (tabbable) tabIndex = 0;else tabIndex = -1;
          }

          return useMergedProps()(useManagedChildProps({
            tabIndex
          }), props);
        }
        return {
          useRovingTabIndexChildProps,
          useRovingTabIndexSiblingProps,
          tabbable
        };
      }, [useManagedChild]);
      return _objectSpread2({
        useRovingTabIndexChild,
        childCount,
        managedChildren,
        indicesByElement,
        focusCurrent: rerenderAndFocus
      }, rest);
    }

    var _excluded$G = ["managedChildren", "indicesByElement", "useRovingTabIndexChild", "focusCurrent"];
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */

    function useListNavigation({
      initialIndex,
      focusOnChange,
      collator,
      keyNavigation
    }) {
      var _keyNavigation;

      (_keyNavigation = keyNavigation) !== null && _keyNavigation !== void 0 ? _keyNavigation : keyNavigation = "either"; // Keep track of three things related to the currently tabbable element's index:
      // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.

      var [tabbableIndex, setTabbableIndex, getTabbableIndex] = useState(initialIndex === undefined ? 0 : initialIndex);
      var setIndex = A$1(index => {
        setTabbableIndex(index);
      }, []);

      var _useRovingTabIndex = useRovingTabIndex({
        focusOnChange,
        tabbableIndex
      }),
          {
        managedChildren,
        indicesByElement,
        useRovingTabIndexChild,
        focusCurrent
      } = _useRovingTabIndex,
          rest = _objectWithoutProperties(_useRovingTabIndex, _excluded$G);

      var {
        currentTypeahead,
        invalidTypeahead,
        useTypeaheadNavigationChild
      } = useTypeaheadNavigation({
        collator,
        getIndex: getTabbableIndex,
        setIndex,
        typeaheadTimeout: 1000
      });
      var {
        navigateToEnd,
        navigateToIndex,
        navigateToNext,
        navigateToPrev,
        navigateToStart,
        useLinearNavigationChild
      } = useLinearNavigation({
        navigationDirection: keyNavigation,
        getIndex: getTabbableIndex,
        setIndex,
        managedChildren
      });
      var useListNavigationChild = A$1(info => {
        var {
          useTypeaheadNavigationChildProps
        } = useTypeaheadNavigationChild(info);
        var {
          useLinearNavigationChildProps
        } = useLinearNavigationChild();
        var {
          useRovingTabIndexChildProps,
          useRovingTabIndexSiblingProps,
          tabbable
        } = useRovingTabIndexChild(info);

        var useListNavigationChildProps = function (_ref) {
          var props = _extends({}, _ref);

          return useMergedProps()(useRovingTabIndexChildProps(useTypeaheadNavigationChildProps(useLinearNavigationChildProps({
            onClick: roveToSelf
          }))), props);
        };

        var roveToSelf = A$1(() => {
          navigateToIndex(info.index);
        }, []);
        return {
          useListNavigationChildProps,
          useListNavigationSiblingProps: useRovingTabIndexSiblingProps,
          tabbable //roveToSelf,
          //element

        };
      }, [useTypeaheadNavigationChild, useLinearNavigationChild, useRovingTabIndexChild, navigateToIndex]);
      return _objectSpread2({
        useListNavigationChild,
        currentTypeahead,
        invalidTypeahead,
        tabbableIndex,
        setTabbableIndex,
        managedChildren,
        indicesByElement,
        navigateToIndex,
        navigateToNext,
        navigateToPrev,
        navigateToStart,
        navigateToEnd,
        focusCurrent
      }, rest);
    }

    /**
     *
     * There are several different ways that a focus event can happen.  Assume
     * the following steps happen in order:
     *
     * 1. The page loads.
     *    * Nothing is focused, but `document.activeElement` is `body`.
     *    * No focus events are fired.
     * 2. The window is focused, an unfocusable element is clicked, text is selected, etc.
     *    * The `activeElement` remains as `body`.
     *    * A `focus`/`focusin` event *MIGHT* be fired for `body`. Depending on
     *      the browser, this depends on whether the handler was attached to `window` or `document`.
     *      Probably just best to not rely on it, or listen to `window` focus events directly.
     * 3. A focusable element is clicked, etc.
     *    * The `activeElement` is set to the new element before any event even fires.
     *    * `focusout` and `blur` are *not* fired on `body`.
     *    * `focus` and `focusin` are fired on the new element. `relatedTarget` is null.
     * 4. A focusable element is clicked, etc.
     *    * **The `activeElement` is set to the `body`** before any event even fires.
     *    * `blur` and `focusout` are fired on the old element. `relatedTarget` is the new element.
     *    * The `activeElement` is now set to the new element.
     *    * `focusin` is fired on the new element. `relatedTarget` is the old element.
     * 5. An unfocusable element is clicked, text is selected, etc.
     *    * The `activeElement` is set to `body`.
     *    * `blur` and `focusout` are fired on the old element. `relatedTarget` is null.
     *    * `focusin` is *not* fired on `body`.
     *
     *
     * In summary:
     * 1. Focus events *do* notify us of all changes in focus, but there is no one single comprehensive event that provides us with all available information.
     * 2. `document.activeElement` *is not* always the same as what's being referenced by a focus event. In particular, it may become `body` at any arbitrary time.
     * 3. A `blur` without a `focus` can and will occur. This means it is not possible to solely use `focus` to detect all changes.
     * 4. A `blur` event whose `relatedTarget` is null indicates that there will be no following `focus` event.
     *
     *
     * @param callback
     * @returns
     */

    var currentlyFocusedElement = null;
    var lastFocusedElement = null;

    function getLastFocusedElement() {
      return lastFocusedElement;
    }

    function getCurrentlyFocusedElement() {
      return currentlyFocusedElement;
    }

    var updaters = new Set();

    function focusout(e) {
      if (e.relatedTarget == null) {
        currentlyFocusedElement = null;

        for (var f of updaters) {
          f({
            current: currentlyFocusedElement,
            last: lastFocusedElement,
            windowFocused
          });
        }
      }
    }

    function focusin(e) {
      currentlyFocusedElement = lastFocusedElement = e.target;

      for (var f of updaters) {
        f({
          current: currentlyFocusedElement,
          last: lastFocusedElement,
          windowFocused
        });
      }
    }

    var windowFocused = true;

    function windowFocus() {
      windowFocused = true;

      for (var f of updaters) {
        f({
          current: currentlyFocusedElement,
          last: lastFocusedElement,
          windowFocused
        });
      }
    }

    function windowBlur() {
      windowFocused = false;

      for (var f of updaters) {
        f({
          current: currentlyFocusedElement,
          last: lastFocusedElement,
          windowFocused
        });
      }
    }

    function useActiveElement(filter) {
      var [i, setI] = useState(0);
      h(() => {
        var F = info => {
          if (filter == null || filter(info)) setI(i => ++i);
        };

        if (updaters.size === 0) {
          document.addEventListener("focusin", focusin, {
            passive: true
          });
          document.addEventListener("focusout", focusout, {
            passive: true
          });
          window.addEventListener("focus", windowFocus, {
            passive: true
          });
          window.addEventListener("blur", windowBlur, {
            passive: true
          });
        }

        updaters.add(F);
        return () => {
          updaters.delete(F);

          if (updaters.size === 0) {
            document.removeEventListener("focusin", focusin);
            document.removeEventListener("focusout", focusout);
            window.removeEventListener("focus", windowFocus);
            window.removeEventListener("blur", windowBlur);
          }
        };
      }, [filter]);
      return {
        activeElement: currentlyFocusedElement,
        lastActiveElement: lastFocusedElement,
        getActiveElement: getCurrentlyFocusedElement,
        getLastActiveElement: getLastFocusedElement,
        windowFocused
      };
    }

    function useHasFocus({} = {}) {
      // These are slightly redundant, but any time the focus changes, we need to know if it's "relevant" to us.
      // It's "relevant" if the newly-focused element is a child of us,
      // OR if we're focused and focus moves OUTSIDE of us our our children.
      // Because of that second bit, we need to keep track of where the focus was the last time we checked for the filter.
      var [hasFocus, setHasFocus, getHasFocus] = useState(false);
      var [hasLastFocus, setHasLastFocus, getHasLastFocus] = useState(false);
      var {
        element,
        getElement,
        useRefElementProps
      } = useRefElement();
      var {
        activeElement,
        lastActiveElement
      } = useActiveElement(A$1(({
        current,
        last,
        windowFocused
      }) => {
        // Keep in mind that once we get our element, even if the hook and filter functions
        // don't re-run, the currently-focused element will still be returned below, and,
        // even if it's not us or one of our children, will still be safely filtered out at render time.
        var element = getElement();
        if (!element) return false;
        var hasFocusNow = element.contains(current) || element.contains(last);

        if (hasFocusNow) {
          return true;
        } else {
          var hadFocusBeforeThis = getHasLastFocus() || getHasFocus();

          if (hadFocusBeforeThis) {
            // Return true once, so that useActiveElement will return one instance of a different element having focus.
            // Then, back outside this filter function, we'll know that we're no longer focused.
            return true;
          }

          return false;
        }
      }, [])); // These are primarily used for bookkeeping during the filter function above.

      h(() => {
        var _element$contains;

        setHasFocus((_element$contains = element === null || element === void 0 ? void 0 : element.contains(activeElement)) !== null && _element$contains !== void 0 ? _element$contains : false);
      }, [element, activeElement]);
      h(() => {
        var _element$contains2;

        setHasLastFocus((_element$contains2 = element === null || element === void 0 ? void 0 : element.contains(lastActiveElement)) !== null && _element$contains2 !== void 0 ? _element$contains2 : false);
      }, [element, lastActiveElement]);
      var useHasFocusProps = A$1(props => {
        return useRefElementProps(props);
      }, [useRefElementProps]);
      var focused = d(() => {
        return element == activeElement;
      }, [element, activeElement]);
      var focusedInner = d(() => {
        var _element$contains3;

        return (_element$contains3 = element === null || element === void 0 ? void 0 : element.contains(activeElement)) !== null && _element$contains3 !== void 0 ? _element$contains3 : false;
      }, [element, activeElement]);
      var lastFocused = d(() => {
        return element == lastActiveElement;
      }, [element, lastActiveElement]);
      var lastFocusedInner = d(() => {
        var _element$contains4;

        return (_element$contains4 = element === null || element === void 0 ? void 0 : element.contains(lastActiveElement)) !== null && _element$contains4 !== void 0 ? _element$contains4 : false;
      }, [element, lastActiveElement]);
      return {
        useHasFocusProps,
        focused,
        focusedInner,
        lastFocused,
        lastFocusedInner
      };
    }

    /**
     * Wrap the native `useEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     */

    function useEffect(effect, inputs) {
      var prevInputs = s(inputs);

      var effect2 = () => {
        var changes = [];

        for (var i = 0; i < Math.max(prevInputs.current.length, inputs.length); ++i) {
          if (prevInputs.current[i] != inputs[i]) changes[i] = {
            from: prevInputs.current[i],
            to: inputs[i]
          };
        }

        effect(prevInputs.current, changes);
        prevInputs.current = inputs;
      };

      y(effect2, inputs);
    }

    var _excluded$F = ["index"],
        _excluded2$e = ["index", "text"];
    function useGridNavigation({
      focusOnChange: foc
    }) {
      var getFocusCellOnRowChange = useStableGetter(foc);
      var [currentRow, setCurrentRow, getCurrentRow] = useState(0);
      var [lastKnownCellIndex, setLastKnownCellIndex, getLastKnownCellIndex] = useState(0);
      useEffect(([prev]) => {
        console.log("currentRow: ".concat(prev, " -> ").concat(currentRow));
      }, [currentRow]);
      var {
        childCount,
        managedChildren,
        indicesByElement,
        getMountIndex,
        mountedChildren,
        totalChildrenMounted,
        totalChildrenUnounted,
        useManagedChild
      } = useChildManager();
      var {
        useLinearNavigationChild
      } = useLinearNavigation({
        managedChildren,
        getIndex: getCurrentRow,
        setIndex: setCurrentRow,
        navigationDirection: "block"
      });
      useChildFlag(currentRow, managedChildren.length, A$1((index, tabbable) => {
        var _managedChildren$inde;

        return (_managedChildren$inde = managedChildren[index]) === null || _managedChildren$inde === void 0 ? void 0 : _managedChildren$inde.setIsTabbableRow(tabbable, lastKnownCellIndex);
      }, [lastKnownCellIndex, managedChildren]));
      var useGridNavigationRow = A$1(_ref => {
        var {
          index
        } = _ref,
            info = _objectWithoutProperties(_ref, _excluded$F);

        var {
          useHasFocusProps,
          lastFocusedInner
        } = useHasFocus();
        var [isTabbableRow, setIsTabbableRow] = useState(false); // Besides just being a list nav child, it's also a list nav parent
        // yaaaayyy

        var {
          useListNavigationChild: useListNavigationChild2,
          childCount: cellCount,
          indicesByElement: cellIndicesByElement,
          managedChildren: managedCells,
          navigateToIndex: setCellIndex,
          tabbableIndex: tabbableCell,
          focusCurrent
        } = useListNavigation({
          focusOnChange: isTabbableRow && getFocusCellOnRowChange(),
          keyNavigation: "inline",
          initialIndex: null
        }); // Any time we become the currently tabbable row,
        // make sure the correct cell is selected and focused.
        // Any other time, make sure no cell is tabbable.

        useEffect(() => {
          if (isTabbableRow) {
            setCellIndex(getLastKnownCellIndex());
          } else {
            setCellIndex(null);
          }
        }, [isTabbableRow]); // Any time we become the currently tabbable row,
        // request the component rerender and focus itself.

        useEffect(() => {
          if (isTabbableRow && getFocusCellOnRowChange()) {
            focusCurrent === null || focusCurrent === void 0 ? void 0 : focusCurrent();
          }
        }, [focusCurrent, isTabbableRow]); // Any time the current cell changes 
        // (probably because we interacted with it, thus focusing it, 
        // changing it from null if the row wasn't already focused)
        // make sure that we're the currently tabbable row if we weren't already.

        useLayoutEffect(() => {
          if (tabbableCell !== null) {
            setLastKnownCellIndex(tabbableCell);
            setIsTabbableRow(true);
            setCurrentRow(index);
          }
        }, [index, tabbableCell, setLastKnownCellIndex]);
        var {
          useManagedChildProps
        } = useManagedChild(_objectSpread2({
          index,
          setIsTabbableRow: A$1((tabbable, newIndex) => {
            if (tabbable) {
              setCellIndex(newIndex);
            }

            setIsTabbableRow(tabbable);
          }, [])
        }, info));
        var {
          useLinearNavigationChildProps
        } = useLinearNavigationChild();
        var useGridNavigationRowProps = A$1(props => useManagedChildProps(useLinearNavigationChildProps(useHasFocusProps(props))), [useManagedChildProps]);
        var useGridNavigationCell = A$1(_ref2 => {
          var {
            index,
            text
          } = _ref2,
              info = _objectWithoutProperties(_ref2, _excluded2$e);

          var {
            tabbable,
            useListNavigationChildProps
          } = useListNavigationChild2(_objectSpread2({
            text,
            index
          }, info));
          var useGridNavigationCellProps = A$1(props => useListNavigationChildProps(props), [useListNavigationChildProps]);
          return {
            tabbable,
            useGridNavigationCellProps
          };
        }, [useListNavigationChild2]);
        return {
          useGridNavigationRowProps,
          useGridNavigationCell,
          cellCount,
          tabbableCell,
          isTabbableRow,
          managedCells
        };
      }, [setLastKnownCellIndex, useLinearNavigationChild, useManagedChild]);
      return {
        useGridNavigationRow,
        rowCount: childCount,
        cellIndex: lastKnownCellIndex,
        rowIndex: currentRow,
        managedRows: managedChildren
      };
    }

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */

    function useGlobalHandler(target, type, handler, options) {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      var stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
      y(() => {
        target.addEventListener(type, stableHandler, options);
        return () => target.removeEventListener(type, stableHandler, options);
      }, [target, type, stableHandler]);
    }

    function getFromLocalStorage() {
      return function (key, converter = JSON.parse) {
        try {
          var item = localStorage.getItem(key);
          if (!item) return undefined;
          return converter(item);
        } catch (e) {
          debugger; // Intentional

          return undefined;
        }
      };
    }
    function storeToLocalStorage() {
      return function (key, value, converter = JSON.stringify) {
        try {
          localStorage.setItem(key, converter(value));
        } catch (e) {
          debugger; // Intentional
        }
      };
    }

    var Table$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";

    function base64(value) {
      return Table$1[value];
    }

    function random6Bits() {
      return Math.floor(Math.random() * 0b1000000);
    }

    function random64Bits() {
      return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     */


    function generateRandomId(prefix) {
      return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits().map(n => base64(n)).join(""));
    }
    /**
     * Returns a hook that modifies a set of props to provide a randomly-generated ID if one was not provided.
     *
     * If you'd like to use the ID in a property that's *not* named `id` (like `for` or `aria-labelledby` or whatnot), `useReferencedIdProps` is also provided.
     *
     * And the randomly-generated id itself is also provided in case you want to handle the logic yourself without `useMergedProps`.
     *
     * Unlike most other `use*Props` hooks, these are mostly stable.
     */

    function useRandomId({
      prefix
    } = {}) {
      var [randomId, setRandomId] = useState(() => generateRandomId(prefix));
      var [watchPrefixUpdates, setWatchPrefixUpdates, getWatchPrefixUpdates] = useState(false);
      h(() => {
        var watchPrefixUpdates = getWatchPrefixUpdates();
        if (watchPrefixUpdates) setRandomId(() => generateRandomId(prefix));
        setWatchPrefixUpdates(true);
      }, [prefix]); // Whatever ID was most recently used by the actual "id" prop.
      // Used so that any ID-referencing props don't need to provide the same value.
      //
      // TODO: This does mean that on the first render, if just the ID is provided,
      // there will be a temporary mismatch, but it's corrected before rendering finishes.
      // Is this okay?

      var [usedId, setUsedId, getUsedId] = useState(undefined);
      var useReferencedIdProps = A$1(function useReferencedIdProps(idPropName) {
        var ret = function (_ref) {
          var _ref2, _ref3;

          var {
            [idPropName]: givenId
          } = _ref,
              props = _objectWithoutProperties(_ref, [idPropName].map(_toPropertyKey));

          var usedId2 = (_ref2 = (_ref3 = givenId !== null && givenId !== void 0 ? givenId : usedId) !== null && _ref3 !== void 0 ? _ref3 : randomId) !== null && _ref2 !== void 0 ? _ref2 : undefined;
          if (idPropName === "id") setUsedId(usedId2);
          return useMergedProps()({
            [idPropName]: usedId2
          }, props);
        };

        return ret;
      }, [usedId, randomId]);
      var useRandomIdProps = A$1(function useRandomIdProps(p) {
        return useReferencedIdProps("id")(p);
      }, [useReferencedIdProps]);
      return {
        randomId,
        id: usedId,
        getId: getUsedId,
        useRandomIdProps,
        useReferencedIdProps
      };
    }

    /*!
    * tabbable 5.2.1
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };

    var isHidden = function isHidden(node, displayCheck) {
      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      }

      if (!displayCheck || displayCheck === 'full') {
        while (node) {
          if (getComputedStyle(node).display === 'none') {
            return true;
          }

          node = node.parentElement;
        }
      } else if (displayCheck === 'non-zero-area') {
        var _node$getBoundingClie = node.getBoundingClientRect(),
            width = _node$getBoundingClie.width,
            height = _node$getBoundingClie.height;

        return width === 0 && height === 0;
      }

      return false;
    }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset


    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (isInput(node) || node.tagName === 'SELECT' || node.tagName === 'TEXTAREA' || node.tagName === 'BUTTON') {
        var parentNode = node.parentElement;

        while (parentNode) {
          if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
            // look for the first <legend> as an immediate child of the disabled
            //  <fieldset>: if the node is in that legend, it'll be enabled even
            //  though the fieldset is disabled; otherwise, the node is in a
            //  secondary/subsequent legend, or somewhere else within the fieldset
            //  (however deep nested) and it'll be disabled
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i);

              if (child.tagName === 'LEGEND') {
                if (child.contains(node)) {
                  return false;
                } // the node isn't in the first legend (in doc order), so no matter
                //  where it is now, it'll be disabled


                return true;
              }
            } // the node isn't in a legend, so no matter where it is now, it'll be disabled


            return true;
          }

          parentNode = parentNode.parentElement;
        }
      } // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state


      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options.displayCheck) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
      var _a, _b, _c;
      /* Symbols for private properties */


      var _blockingElements = Symbol();

      var _alreadyInertElements = Symbol();

      var _topElParents = Symbol();

      var _siblingsToRestore = Symbol();

      var _parentMO = Symbol();
      /* Symbols for private static methods */


      var _topChanged = Symbol();

      var _swapInertedSibling = Symbol();

      var _inertSiblings = Symbol();

      var _restoreInertedSiblings = Symbol();

      var _getParents = Symbol();

      var _getDistributedChildren = Symbol();

      var _isInertable = Symbol();

      var _handleMutations = Symbol();

      class BlockingElementsImpl {
        constructor() {
          /**
           * The blocking elements.
           */
          this[_a] = [];
          /**
           * Used to keep track of the parents of the top element, from the element
           * itself up to body. When top changes, the old top might have been removed
           * from the document, so we need to memoize the inerted parents' siblings
           * in order to restore their inerteness when top changes.
           */

          this[_b] = [];
          /**
           * Elements that are already inert before the first blocking element is
           * pushed.
           */

          this[_c] = new Set();
        }

        destructor() {
          // Restore original inertness.
          this[_restoreInertedSiblings](this[_topElParents]); // Note we don't want to make these properties nullable on the class,
          // since then we'd need non-null casts in many places. Calling a method on
          // a BlockingElements instance after calling destructor will result in an
          // exception.


          var nullable = this;
          nullable[_blockingElements] = null;
          nullable[_topElParents] = null;
          nullable[_alreadyInertElements] = null;
        }

        get top() {
          var elems = this[_blockingElements];
          return elems[elems.length - 1] || null;
        }

        push(element) {
          if (!element || element === this.top) {
            return;
          } // Remove it from the stack, we'll bring it to the top.


          this.remove(element);

          this[_topChanged](element);

          this[_blockingElements].push(element);
        }

        remove(element) {
          var i = this[_blockingElements].indexOf(element);

          if (i === -1) {
            return false;
          }

          this[_blockingElements].splice(i, 1); // Top changed only if the removed element was the top element.


          if (i === this[_blockingElements].length) {
            this[_topChanged](this.top);
          }

          return true;
        }

        pop() {
          var top = this.top;
          top && this.remove(top);
          return top;
        }

        has(element) {
          return this[_blockingElements].indexOf(element) !== -1;
        }
        /**
         * Sets `inert` to all document elements except the new top element, its
         * parents, and its distributed content.
         */


        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
          var toKeepInert = this[_alreadyInertElements];
          var oldParents = this[_topElParents]; // No new top, reset old top if any.

          if (!newTop) {
            this[_restoreInertedSiblings](oldParents);

            toKeepInert.clear();
            this[_topElParents] = [];
            return;
          }

          var newParents = this[_getParents](newTop); // New top is not contained in the main document!


          if (newParents[newParents.length - 1].parentNode !== document.body) {
            throw Error('Non-connected element cannot be a blocking element');
          } // Cast here because we know we'll call _inertSiblings on newParents
          // below.


          this[_topElParents] = newParents;

          var toSkip = this[_getDistributedChildren](newTop); // No previous top element.


          if (!oldParents.length) {
            this[_inertSiblings](newParents, toSkip, toKeepInert);

            return;
          }

          var i = oldParents.length - 1;
          var j = newParents.length - 1; // Find common parent. Index 0 is the element itself (so stop before it).

          while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
            i--;
            j--;
          } // If up the parents tree there are 2 elements that are siblings, swap
          // the inerted sibling.


          if (oldParents[i] !== newParents[j]) {
            this[_swapInertedSibling](oldParents[i], newParents[j]);
          } // Restore old parents siblings inertness.


          i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i)); // Make new parents siblings inert.

          j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
        }
        /**
         * Swaps inertness between two sibling elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_swapInertedSibling](oldInert, newInert) {
          var siblingsToRestore = oldInert[_siblingsToRestore]; // oldInert is not contained in siblings to restore, so we have to check
          // if it's inertable and if already inert.

          if (this[_isInertable](oldInert) && !oldInert.inert) {
            oldInert.inert = true;
            siblingsToRestore.add(oldInert);
          } // If newInert was already between the siblings to restore, it means it is
          // inertable and must be restored.


          if (siblingsToRestore.has(newInert)) {
            newInert.inert = false;
            siblingsToRestore.delete(newInert);
          }

          newInert[_parentMO] = oldInert[_parentMO];
          newInert[_siblingsToRestore] = siblingsToRestore;
          oldInert[_parentMO] = undefined;
          oldInert[_siblingsToRestore] = undefined;
        }
        /**
         * Restores original inertness to the siblings of the elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_restoreInertedSiblings](elements) {
          for (var element of elements) {
            var mo = element[_parentMO];
            mo.disconnect();
            element[_parentMO] = undefined;
            var siblings = element[_siblingsToRestore];

            for (var sibling of siblings) {
              sibling.inert = false;
            }

            element[_siblingsToRestore] = undefined;
          }
        }
        /**
         * Inerts the siblings of the elements except the elements to skip. Stores
         * the inerted siblings into the element's symbol `_siblingsToRestore`.
         * Pass `toKeepInert` to collect the already inert elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_inertSiblings](elements, toSkip, toKeepInert) {
          for (var element of elements) {
            // Assume element is not a Document, so it must have a parentNode.
            var parent = element.parentNode;
            var children = parent.children;
            var inertedSiblings = new Set();

            for (var j = 0; j < children.length; j++) {
              var sibling = children[j]; // Skip the input element, if not inertable or to be skipped.

              if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
                continue;
              } // Should be collected since already inerted.


              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            } // Store the siblings that were inerted.


            element[_siblingsToRestore] = inertedSiblings; // Observe only immediate children mutations on the parent.

            var mo = new MutationObserver(this[_handleMutations].bind(this));
            element[_parentMO] = mo;
            var parentToObserve = parent; // If we're using the ShadyDOM polyfill, then our parent could be a
            // shady root, which is an object that acts like a ShadowRoot, but isn't
            // actually a node in the real DOM. Observe the real DOM parent instead.

            var maybeShadyRoot = parentToObserve;

            if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
              parentToObserve = maybeShadyRoot.host;
            }

            mo.observe(parentToObserve, {
              childList: true
            });
          }
        }
        /**
         * Handles newly added/removed nodes by toggling their inertness.
         * It also checks if the current top Blocking Element has been removed,
         * notifying and removing it.
         */


        [_handleMutations](mutations) {
          var parents = this[_topElParents];
          var toKeepInert = this[_alreadyInertElements];

          for (var mutation of mutations) {
            // If the target is a shadowRoot, get its host as we skip shadowRoots when
            // computing _topElParents.
            var target = mutation.target.host || mutation.target;
            var idx = target === document.body ? parents.length : parents.indexOf(target);
            var inertedChild = parents[idx - 1];
            var inertedSiblings = inertedChild[_siblingsToRestore]; // To restore.

            for (var i = 0; i < mutation.removedNodes.length; i++) {
              var sibling = mutation.removedNodes[i];

              if (sibling === inertedChild) {
                console.info('Detected removal of the top Blocking Element.');
                this.pop();
                return;
              }

              if (inertedSiblings.has(sibling)) {
                sibling.inert = false;
                inertedSiblings.delete(sibling);
              }
            } // To inert.


            for (var _i = 0; _i < mutation.addedNodes.length; _i++) {
              var _sibling = mutation.addedNodes[_i];

              if (!this[_isInertable](_sibling)) {
                continue;
              }

              if (toKeepInert && _sibling.inert) {
                toKeepInert.add(_sibling);
              } else {
                _sibling.inert = true;
                inertedSiblings.add(_sibling);
              }
            }
          }
        }
        /**
         * Returns if the element is inertable.
         */


        [_isInertable](element) {
          return false === /^(style|template|script)$/.test(element.localName);
        }
        /**
         * Returns the list of newParents of an element, starting from element
         * (included) up to `document.body` (excluded).
         */


        [_getParents](element) {
          var parents = [];
          var current = element; // Stop to body.

          while (current && current !== document.body) {
            // Skip shadow roots.
            if (current.nodeType === Node.ELEMENT_NODE) {
              parents.push(current);
            } // ShadowDom v1


            if (current.assignedSlot) {
              // Collect slots from deepest slot to top.
              while (current = current.assignedSlot) {
                parents.push(current);
              } // Continue the search on the top slot.


              current = parents.pop();
              continue;
            }

            current = current.parentNode || current.host;
          }

          return parents;
        }
        /**
         * Returns the distributed children of the element's shadow root.
         * Returns null if the element doesn't have a shadow root.
         */


        [_getDistributedChildren](element) {
          var shadowRoot = element.shadowRoot;

          if (!shadowRoot) {
            return null;
          }

          var result = new Set();
          var i;
          var j;
          var nodes;
          var slots = shadowRoot.querySelectorAll('slot');

          if (slots.length && slots[0].assignedNodes) {
            for (i = 0; i < slots.length; i++) {
              nodes = slots[i].assignedNodes({
                flatten: true
              });

              for (j = 0; j < nodes.length; j++) {
                if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                  result.add(nodes[j]);
                }
              }
            } // No need to search for <content>.

          }

          return result;
        }

      }

      document.$blockingElements = new BlockingElementsImpl();
    })();

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    createCommonjsModule(function (module, exports) {
      (function (global, factory) {
        factory() ;
      })(commonjsGlobal, function () {

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        /**
         * This work is licensed under the W3C Software and Document License
         * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
         */


        (function () {
          // Return early if we're not running inside of the browser.
          if (typeof window === 'undefined') {
            return;
          } // Convenience function for converting NodeLists.

          /** @type {typeof Array.prototype.slice} */


          var slice = Array.prototype.slice;
          /**
           * IE has a non-standard name for "matches".
           * @type {typeof Element.prototype.matches}
           */

          var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
          /** @type {string} */

          var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
          /**
           * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
           * attribute.
           *
           * Its main functions are:
           *
           * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
           *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
           *   each focusable node in the subtree with the singleton `InertManager` which manages all known
           *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
           *   instance exists for each focusable node which has at least one inert root as an ancestor.
           *
           * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
           *   attribute is removed from the root node). This is handled in the destructor, which calls the
           *   `deregister` method on `InertManager` for each managed inert node.
           */


          var InertRoot = function () {
            /**
             * @param {!Element} rootElement The Element at the root of the inert subtree.
             * @param {!InertManager} inertManager The global singleton InertManager object.
             */
            function InertRoot(rootElement, inertManager) {
              _classCallCheck(this, InertRoot);
              /** @type {!InertManager} */


              this._inertManager = inertManager;
              /** @type {!Element} */

              this._rootElement = rootElement;
              /**
               * @type {!Set<!InertNode>}
               * All managed focusable nodes in this InertRoot's subtree.
               */

              this._managedNodes = new Set(); // Make the subtree hidden from assistive technology

              if (this._rootElement.hasAttribute('aria-hidden')) {
                /** @type {?string} */
                this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
              } else {
                this._savedAriaHidden = null;
              }

              this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes


              this._makeSubtreeUnfocusable(this._rootElement); // Watch for:
              // - any additions in the subtree: make them unfocusable too
              // - any removals from the subtree: remove them from this inert root's managed nodes
              // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
              //   element, make that node a managed node.


              this._observer = new MutationObserver(this._onMutation.bind(this));

              this._observer.observe(this._rootElement, {
                attributes: true,
                childList: true,
                subtree: true
              });
            }
            /**
             * Call this whenever this object is about to become obsolete.  This unwinds all of the state
             * stored in this object and updates the state of all of the managed nodes.
             */


            _createClass(InertRoot, [{
              key: 'destructor',
              value: function destructor() {
                this._observer.disconnect();

                if (this._rootElement) {
                  if (this._savedAriaHidden !== null) {
                    this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                  } else {
                    this._rootElement.removeAttribute('aria-hidden');
                  }
                }

                this._managedNodes.forEach(function (inertNode) {
                  this._unmanageNode(inertNode.node);
                }, this); // Note we cast the nulls to the ANY type here because:
                // 1) We want the class properties to be declared as non-null, or else we
                //    need even more casts throughout this code. All bets are off if an
                //    instance has been destroyed and a method is called.
                // 2) We don't want to cast "this", because we want type-aware optimizations
                //    to know which properties we're setting.


                this._observer =
                /** @type {?} */
                null;
                this._rootElement =
                /** @type {?} */
                null;
                this._managedNodes =
                /** @type {?} */
                null;
                this._inertManager =
                /** @type {?} */
                null;
              }
              /**
               * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
               */

            }, {
              key: '_makeSubtreeUnfocusable',

              /**
               * @param {!Node} startNode
               */
              value: function _makeSubtreeUnfocusable(startNode) {
                var _this2 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this2._visitNode(node);
                });
                var activeElement = document.activeElement;

                if (!document.body.contains(startNode)) {
                  // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                  var node = startNode;
                  /** @type {!ShadowRoot|undefined} */

                  var root = undefined;

                  while (node) {
                    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      root =
                      /** @type {!ShadowRoot} */
                      node;
                      break;
                    }

                    node = node.parentNode;
                  }

                  if (root) {
                    activeElement = root.activeElement;
                  }
                }

                if (startNode.contains(activeElement)) {
                  activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1
                  // calling blur() will not actually move the focus.
                  // To work around this we call focus() on the body instead.

                  if (activeElement === document.activeElement) {
                    document.body.focus();
                  }
                }
              }
              /**
               * @param {!Node} node
               */

            }, {
              key: '_visitNode',
              value: function _visitNode(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!Element} */
                node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of
                // this inert root, so all of its managed nodes need to be adopted by this InertRoot.

                if (element !== this._rootElement && element.hasAttribute('inert')) {
                  this._adoptInertRoot(element);
                }

                if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                  this._manageNode(element);
                }
              }
              /**
               * Register the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_manageNode',
              value: function _manageNode(node) {
                var inertNode = this._inertManager.register(node, this);

                this._managedNodes.add(inertNode);
              }
              /**
               * Unregister the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_unmanageNode',
              value: function _unmanageNode(node) {
                var inertNode = this._inertManager.deregister(node, this);

                if (inertNode) {
                  this._managedNodes['delete'](inertNode);
                }
              }
              /**
               * Unregister the entire subtree starting at `startNode`.
               * @param {!Node} startNode
               */

            }, {
              key: '_unmanageSubtree',
              value: function _unmanageSubtree(startNode) {
                var _this3 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this3._unmanageNode(node);
                });
              }
              /**
               * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
               * @param {!Element} node
               */

            }, {
              key: '_adoptInertRoot',
              value: function _adoptInertRoot(node) {
                var inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,
                // so register it now if need be.


                if (!inertSubroot) {
                  this._inertManager.setInert(node, true);

                  inertSubroot = this._inertManager.getInertRoot(node);
                }

                inertSubroot.managedNodes.forEach(function (savedInertNode) {
                  this._manageNode(savedInertNode.node);
                }, this);
              }
              /**
               * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_onMutation',
              value: function _onMutation(records, self) {
                records.forEach(function (record) {
                  var target =
                  /** @type {!Element} */
                  record.target;

                  if (record.type === 'childList') {
                    // Manage added nodes
                    slice.call(record.addedNodes).forEach(function (node) {
                      this._makeSubtreeUnfocusable(node);
                    }, this); // Un-manage removed nodes

                    slice.call(record.removedNodes).forEach(function (node) {
                      this._unmanageSubtree(node);
                    }, this);
                  } else if (record.type === 'attributes') {
                    if (record.attributeName === 'tabindex') {
                      // Re-initialise inert node if tabindex changes
                      this._manageNode(target);
                    } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                      // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                      // already managed nodes from this inert subroot.
                      this._adoptInertRoot(target);

                      var inertSubroot = this._inertManager.getInertRoot(target);

                      this._managedNodes.forEach(function (managedNode) {
                        if (target.contains(managedNode.node)) {
                          inertSubroot._manageNode(managedNode.node);
                        }
                      });
                    }
                  }
                }, this);
              }
            }, {
              key: 'managedNodes',
              get: function get() {
                return new Set(this._managedNodes);
              }
              /** @return {boolean} */

            }, {
              key: 'hasSavedAriaHidden',
              get: function get() {
                return this._savedAriaHidden !== null;
              }
              /** @param {?string} ariaHidden */

            }, {
              key: 'savedAriaHidden',
              set: function set(ariaHidden) {
                this._savedAriaHidden = ariaHidden;
              }
              /** @return {?string} */
              ,
              get: function get() {
                return this._savedAriaHidden;
              }
            }]);

            return InertRoot;
          }();
          /**
           * `InertNode` initialises and manages a single inert node.
           * A node is inert if it is a descendant of one or more inert root elements.
           *
           * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
           * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
           * is intrinsically focusable or not.
           *
           * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
           * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
           * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
           * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
           * or removes the `tabindex` attribute if the element is intrinsically focusable.
           */


          var InertNode = function () {
            /**
             * @param {!Node} node A focusable element to be made inert.
             * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
             */
            function InertNode(node, inertRoot) {
              _classCallCheck(this, InertNode);
              /** @type {!Node} */


              this._node = node;
              /** @type {boolean} */

              this._overrodeFocusMethod = false;
              /**
               * @type {!Set<!InertRoot>} The set of descendant inert roots.
               *    If and only if this set becomes empty, this node is no longer inert.
               */

              this._inertRoots = new Set([inertRoot]);
              /** @type {?number} */

              this._savedTabIndex = null;
              /** @type {boolean} */

              this._destroyed = false; // Save any prior tabindex info and make this node untabbable

              this.ensureUntabbable();
            }
            /**
             * Call this whenever this object is about to become obsolete.
             * This makes the managed node focusable again and deletes all of the previously stored state.
             */


            _createClass(InertNode, [{
              key: 'destructor',
              value: function destructor() {
                this._throwIfDestroyed();

                if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                  var element =
                  /** @type {!Element} */
                  this._node;

                  if (this._savedTabIndex !== null) {
                    element.setAttribute('tabindex', this._savedTabIndex);
                  } else {
                    element.removeAttribute('tabindex');
                  } // Use `delete` to restore native focus method.


                  if (this._overrodeFocusMethod) {
                    delete element.focus;
                  }
                } // See note in InertRoot.destructor for why we cast these nulls to ANY.


                this._node =
                /** @type {?} */
                null;
                this._inertRoots =
                /** @type {?} */
                null;
                this._destroyed = true;
              }
              /**
               * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
               * If the object has been destroyed, any attempt to access it will cause an exception.
               */

            }, {
              key: '_throwIfDestroyed',

              /**
               * Throw if user tries to access destroyed InertNode.
               */
              value: function _throwIfDestroyed() {
                if (this.destroyed) {
                  throw new Error('Trying to access destroyed InertNode');
                }
              }
              /** @return {boolean} */

            }, {
              key: 'ensureUntabbable',

              /** Save the existing tabindex value and make the node untabbable and unfocusable */
              value: function ensureUntabbable() {
                if (this.node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!Element} */
                this.node;

                if (matches.call(element, _focusableElementsString)) {
                  if (
                  /** @type {!HTMLElement} */
                  element.tabIndex === -1 && this.hasSavedTabIndex) {
                    return;
                  }

                  if (element.hasAttribute('tabindex')) {
                    this._savedTabIndex =
                    /** @type {!HTMLElement} */
                    element.tabIndex;
                  }

                  element.setAttribute('tabindex', '-1');

                  if (element.nodeType === Node.ELEMENT_NODE) {
                    element.focus = function () {};

                    this._overrodeFocusMethod = true;
                  }
                } else if (element.hasAttribute('tabindex')) {
                  this._savedTabIndex =
                  /** @type {!HTMLElement} */
                  element.tabIndex;
                  element.removeAttribute('tabindex');
                }
              }
              /**
               * Add another inert root to this inert node's set of managing inert roots.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'addInertRoot',
              value: function addInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots.add(inertRoot);
              }
              /**
               * Remove the given inert root from this inert node's set of managing inert roots.
               * If the set of managing inert roots becomes empty, this node is no longer inert,
               * so the object should be destroyed.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'removeInertRoot',
              value: function removeInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots['delete'](inertRoot);

                if (this._inertRoots.size === 0) {
                  this.destructor();
                }
              }
            }, {
              key: 'destroyed',
              get: function get() {
                return (
                  /** @type {!InertNode} */
                  this._destroyed
                );
              }
            }, {
              key: 'hasSavedTabIndex',
              get: function get() {
                return this._savedTabIndex !== null;
              }
              /** @return {!Node} */

            }, {
              key: 'node',
              get: function get() {
                this._throwIfDestroyed();

                return this._node;
              }
              /** @param {?number} tabIndex */

            }, {
              key: 'savedTabIndex',
              set: function set(tabIndex) {
                this._throwIfDestroyed();

                this._savedTabIndex = tabIndex;
              }
              /** @return {?number} */
              ,
              get: function get() {
                this._throwIfDestroyed();

                return this._savedTabIndex;
              }
            }]);

            return InertNode;
          }();
          /**
           * InertManager is a per-document singleton object which manages all inert roots and nodes.
           *
           * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
           * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
           * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
           * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
           * is created for each such node, via the `_managedNodes` map.
           */


          var InertManager = function () {
            /**
             * @param {!Document} document
             */
            function InertManager(document) {
              _classCallCheck(this, InertManager);

              if (!document) {
                throw new Error('Missing required argument; InertManager needs to wrap a document.');
              }
              /** @type {!Document} */


              this._document = document;
              /**
               * All managed nodes known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertNode>}
               */

              this._managedNodes = new Map();
              /**
               * All inert roots known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertRoot>}
               */

              this._inertRoots = new Map();
              /**
               * Observer for mutations on `document.body`.
               * @type {!MutationObserver}
               */

              this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.

              addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.

              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
              } else {
                this._onDocumentLoaded();
              }
            }
            /**
             * Set whether the given element should be an inert root or not.
             * @param {!Element} root
             * @param {boolean} inert
             */


            _createClass(InertManager, [{
              key: 'setInert',
              value: function setInert(root, inert) {
                if (inert) {
                  if (this._inertRoots.has(root)) {
                    // element is already inert
                    return;
                  }

                  var inertRoot = new InertRoot(root, this);
                  root.setAttribute('inert', '');

                  this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.
                  // Ensure inert styles are added there.


                  if (!this._document.body.contains(root)) {
                    var parent = root.parentNode;

                    while (parent) {
                      if (parent.nodeType === 11) {
                        addInertStyle(parent);
                      }

                      parent = parent.parentNode;
                    }
                  }
                } else {
                  if (!this._inertRoots.has(root)) {
                    // element is already non-inert
                    return;
                  }

                  var _inertRoot = this._inertRoots.get(root);

                  _inertRoot.destructor();

                  this._inertRoots['delete'](root);

                  root.removeAttribute('inert');
                }
              }
              /**
               * Get the InertRoot object corresponding to the given inert root element, if any.
               * @param {!Node} element
               * @return {!InertRoot|undefined}
               */

            }, {
              key: 'getInertRoot',
              value: function getInertRoot(element) {
                return this._inertRoots.get(element);
              }
              /**
               * Register the given InertRoot as managing the given node.
               * In the case where the node has a previously existing inert root, this inert root will
               * be added to its set of inert roots.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {!InertNode} inertNode
               */

            }, {
              key: 'register',
              value: function register(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (inertNode !== undefined) {
                  // node was already in an inert subtree
                  inertNode.addInertRoot(inertRoot);
                } else {
                  inertNode = new InertNode(node, inertRoot);
                }

                this._managedNodes.set(node, inertNode);

                return inertNode;
              }
              /**
               * De-register the given InertRoot as managing the given inert node.
               * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
               * node from the InertManager's set of managed nodes if it is destroyed.
               * If the node is not currently managed, this is essentially a no-op.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
               */

            }, {
              key: 'deregister',
              value: function deregister(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (!inertNode) {
                  return null;
                }

                inertNode.removeInertRoot(inertRoot);

                if (inertNode.destroyed) {
                  this._managedNodes['delete'](node);
                }

                return inertNode;
              }
              /**
               * Callback used when document has finished loading.
               */

            }, {
              key: '_onDocumentLoaded',
              value: function _onDocumentLoaded() {
                // Find all inert roots in document and make them actually inert.
                var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
                inertElements.forEach(function (inertElement) {
                  this.setInert(inertElement, true);
                }, this); // Comment this out to use programmatic API only.

                this._observer.observe(this._document.body || this._document.documentElement, {
                  attributes: true,
                  subtree: true,
                  childList: true
                });
              }
              /**
               * Callback used when mutation observer detects attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_watchForInert',
              value: function _watchForInert(records, self) {
                var _this = this;

                records.forEach(function (record) {
                  switch (record.type) {
                    case 'childList':
                      slice.call(record.addedNodes).forEach(function (node) {
                        if (node.nodeType !== Node.ELEMENT_NODE) {
                          return;
                        }

                        var inertElements = slice.call(node.querySelectorAll('[inert]'));

                        if (matches.call(node, '[inert]')) {
                          inertElements.unshift(node);
                        }

                        inertElements.forEach(function (inertElement) {
                          this.setInert(inertElement, true);
                        }, _this);
                      }, _this);
                      break;

                    case 'attributes':
                      if (record.attributeName !== 'inert') {
                        return;
                      }

                      var target =
                      /** @type {!Element} */
                      record.target;
                      var inert = target.hasAttribute('inert');

                      _this.setInert(target, inert);

                      break;
                  }
                }, this);
              }
            }]);

            return InertManager;
          }();
          /**
           * Recursively walk the composed tree from |node|.
           * @param {!Node} node
           * @param {(function (!Element))=} callback Callback to be called for each element traversed,
           *     before descending into child nodes.
           * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
           */


          function composedTreeWalk(node, callback, shadowRootAncestor) {
            if (node.nodeType == Node.ELEMENT_NODE) {
              var element =
              /** @type {!Element} */
              node;

              if (callback) {
                callback(element);
              } // Descend into node:
              // If it has a ShadowRoot, ignore all child elements - these will be picked
              // up by the <content> or <shadow> elements. Descend straight into the
              // ShadowRoot.


              var shadowRoot =
              /** @type {!HTMLElement} */
              element.shadowRoot;

              if (shadowRoot) {
                composedTreeWalk(shadowRoot, callback);
                return;
              } // If it is a <content> element, descend into distributed elements - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'content') {
                var content =
                /** @type {!HTMLContentElement} */
                element; // Verifies if ShadowDom v0 is supported.

                var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];

                for (var i = 0; i < distributedNodes.length; i++) {
                  composedTreeWalk(distributedNodes[i], callback);
                }

                return;
              } // If it is a <slot> element, descend into assigned nodes - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'slot') {
                var slot =
                /** @type {!HTMLSlotElement} */
                element; // Verify if ShadowDom v1 is supported.

                var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                  flatten: true
                }) : [];

                for (var _i = 0; _i < _distributedNodes.length; _i++) {
                  composedTreeWalk(_distributedNodes[_i], callback);
                }

                return;
              }
            } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
            // element, nor a <shadow> element recurse normally.


            var child = node.firstChild;

            while (child != null) {
              composedTreeWalk(child, callback);
              child = child.nextSibling;
            }
          }
          /**
           * Adds a style element to the node containing the inert specific styles
           * @param {!Node} node
           */


          function addInertStyle(node) {
            if (node.querySelector('style#inert-style, link#inert-style')) {
              return;
            }

            var style = document.createElement('style');
            style.setAttribute('id', 'inert-style');
            style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
            node.appendChild(style);
          }

          if (!Element.prototype.hasOwnProperty('inert')) {
            /** @type {!InertManager} */
            var inertManager = new InertManager(document);
            Object.defineProperty(Element.prototype, 'inert', {
              enumerable: true,

              /** @this {!Element} */
              get: function get() {
                return this.hasAttribute('inert');
              },

              /** @this {!Element} */
              set: function set(inert) {
                inertManager.setInert(this, inert);
              }
            });
          }
        })();
      });
    });

    var blockingElements = document.$blockingElements;
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */

    function useBlockingElement(target) {
      /**
       * Push/pop the element from the blockingElements stack.
       */
      h(() => {
        if (target) {
          blockingElements.push(target);
          return () => {
            blockingElements.remove(target);
          };
        }
      }, [target]);
    }
    function getTopElement() {
      return blockingElements.top;
    }

    var elementsToRestoreFocusTo = new Map();
    function useFocusTrap({
      trapActive
    }) {
      var {
        element,
        useRefElementProps,
        getElement
      } = useRefElement();
      var {
        getLastActiveElement
      } = useActiveElement(); // When the trap becomes active, before we let the blockingElements hook run,
      // keep track of whatever's currently focused and save it.

      h(() => {
        if (trapActive && element) {
          var _getLastActiveElement;

          // Save the currently focused element
          // to whatever's currently at the top of the stack
          elementsToRestoreFocusTo.set(getTopElement(), (_getLastActiveElement = getLastActiveElement()) !== null && _getLastActiveElement !== void 0 ? _getLastActiveElement : document.body);
        }
      }, [trapActive, element]);
      useBlockingElement(trapActive ? element : null);
      /**
       * Any time we activate or deactivate the trap,
       * change focus to something else (something in
       * the trap if it's active, or whatever we've
       * tracked in elementsToRestoreFocusTo if not)
       */

      h(() => {
        if (trapActive && element) {
          var rafHandle = requestAnimationFrame(() => {
            // TODO: This extra queueMicrotask is needed for
            // ...reasons?
            queueMicrotask(() => {
              var _findFirstFocusable;

              (_findFirstFocusable = findFirstFocusable(element)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        } else if (element) {
          // Restore the focus to the element
          // that has returned to the top of the stack
          var _rafHandle = requestAnimationFrame(() => {
            queueMicrotask(() => {
              var _elementsToRestoreFoc;

              (_elementsToRestoreFoc = elementsToRestoreFocusTo.get(getTopElement())) === null || _elementsToRestoreFoc === void 0 ? void 0 : _elementsToRestoreFoc.focus();
              _rafHandle = 0;
            });
          });

          return () => {
            if (_rafHandle) cancelAnimationFrame(_rafHandle);
          };
        }
      }, [trapActive, element]);

      var useFocusTrapProps = props => {
        return useMergedProps()({
          "aria-modal": trapActive ? "true" : undefined
        }, useRefElementProps(props));
      };

      return {
        useFocusTrapProps,
        element,
        getElement
      };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */

    function findFirstFocusable(element) {
      var treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: node => node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      });
      var firstFocusable = treeWalker.firstChild();
      return firstFocusable;
    }

    function useAriaTooltip({
      mouseoverDelay
    }) {
      var _mouseoverDelay;

      (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
      var [open, setOpen, getOpen] = useState(false);
      var [hasAnyMouseover, setHasAnyMouseover] = useState(false); //const [mouseoverIsValid, setMouseoverIsValid] = useState(false);

      var {
        useRandomIdProps: useTooltipIdProps,
        useReferencedIdProps: useTooltipIdReferencingProps
      } = useRandomId({
        prefix: "aria-tooltip-"
      });
      var {
        focusedInner: triggerFocused,
        useHasFocusProps
      } = useHasFocus();
      var [triggerHasMouseover, setTriggerHasMouseover] = useState(false);
      var [tooltipHasMouseover, setTooltipHasMouseover] = useState(false);
      useTimeout({
        timeout: mouseoverDelay,
        triggerIndex: +triggerHasMouseover + +tooltipHasMouseover,
        callback: () => {
          if (triggerHasMouseover || tooltipHasMouseover) setHasAnyMouseover(true);
        }
      });
      useTimeout({
        timeout: 50,
        triggerIndex: +triggerHasMouseover + +tooltipHasMouseover,
        callback: () => {
          if (!triggerHasMouseover && !tooltipHasMouseover) setHasAnyMouseover(false);
        }
      });
      y(() => {
        setOpen(hasAnyMouseover || triggerFocused);
      }, [hasAnyMouseover, triggerFocused]);
      var useTooltipTrigger = A$1(function useTooltipTrigger() {
        function onPointerEnter(e) {
          setTriggerHasMouseover(true);
        }

        function onPointerLeave(e) {
          setTriggerHasMouseover(false);
        }

        function useTooltipTriggerProps(_ref) {
          var props = _extends({}, _ref);

          // Note: Though it's important to make sure that focusing activates a tooltip,
          // it's perfectly reasonable that a child element will be the one that's focused,
          // not this one, so we don't set tabIndex=0
          return useTooltipIdReferencingProps("aria-describedby")(useMergedProps()({
            onPointerEnter,
            onPointerLeave
          }, useHasFocusProps(props)));
        }

        return {
          useTooltipTriggerProps
        };
      }, [useTooltipIdReferencingProps]);
      var useTooltip = A$1(function useTooltip() {
        function onPointerEnter(e) {
          setTooltipHasMouseover(true);
        }

        function onPointerLeave(e) {
          setTooltipHasMouseover(false);
        }

        function useTooltipProps(_ref2) {
          var props = _extends({}, _ref2);

          props.role = "tooltip";
          return useTooltipIdProps(useMergedProps()({
            onPointerEnter,
            onPointerLeave
          }, props));
        }

        return {
          useTooltipProps
        };
      }, [useTooltipIdProps]);
      return {
        useTooltip,
        useTooltipTrigger,
        isOpen: open,
        getIsOpen: getOpen
      };
    }

    function S(n, t) {
      for (var e in t) {
        n[e] = t[e];
      }

      return n;
    }

    function C$1(n, t) {
      for (var e in n) {
        if ("__source" !== e && !(e in t)) return !0;
      }

      for (var r in t) {
        if ("__source" !== r && n[r] !== t[r]) return !0;
      }

      return !1;
    }

    function E(n) {
      this.props = n;
    }

    function g(n, t) {
      function e(n) {
        var e = this.props.ref,
            r = e == n.ref;
        return !r && e && (e.call ? e(null) : e.current = null), t ? !t(this.props, n) || !r : C$1(this.props, n);
      }

      function r(t) {
        return this.shouldComponentUpdate = e, v$1(n, t);
      }

      return r.displayName = "Memo(" + (n.displayName || n.name) + ")", r.prototype.isReactComponent = !0, r.__f = !0, r;
    }

    (E.prototype = new _$1()).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function (n, t) {
      return C$1(this.props, n) || C$1(this.state, t);
    };
    var w = l$1.__b;

    l$1.__b = function (n) {
      n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), w && w(n);
    };

    var R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;

    function x(n) {
      function t(t, e) {
        var r = S({}, t);
        return delete r.ref, n(r, (e = t.ref || e) && ("object" != typeof e || "current" in e) ? e : null);
      }

      return t.$$typeof = R, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
    }

    var A = l$1.__e;

    l$1.__e = function (n, t, e) {
      if (n.then) for (var r, u = t; u = u.__;) {
        if ((r = u.__c) && r.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), r.__c(n, t);
      }
      A(n, t, e);
    };

    var O = l$1.unmount;

    function L() {
      this.__u = 0, this.t = null, this.__b = null;
    }

    function U(n) {
      var t = n.__.__c;
      return t && t.__e && t.__e(n);
    }

    function M() {
      this.u = null, this.o = null;
    }

    l$1.unmount = function (n) {
      var t = n.__c;
      t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), O && O(n);
    }, (L.prototype = new _$1()).__c = function (n, t) {
      var e = t.__c,
          r = this;
      null == r.t && (r.t = []), r.t.push(e);

      var u = U(r.__v),
          o = !1,
          i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };

      e.__R = i;

      var l = function () {
        if (! --r.__u) {
          if (r.state.__e) {
            var n = r.state.__e;

            r.__v.__k[0] = function n(t, e, r) {
              return t && (t.__v = null, t.__k = t.__k && t.__k.map(function (t) {
                return n(t, e, r);
              }), t.__c && t.__c.__P === e && (t.__e && r.insertBefore(t.__e, t.__d), t.__c.__e = !0, t.__c.__P = r)), t;
            }(n, n.__c.__P, n.__c.__O);
          }

          var t;

          for (r.setState({
            __e: r.__b = null
          }); t = r.t.pop();) {
            t.forceUpdate();
          }
        }
      },
          f = !0 === t.__h;

      r.__u++ || f || r.setState({
        __e: r.__b = r.__v.__k[0]
      }), n.then(i, i);
    }, L.prototype.componentWillUnmount = function () {
      this.t = [];
    }, L.prototype.render = function (n, t) {
      if (this.__b) {
        if (this.__v.__k) {
          var e = document.createElement("div"),
              r = this.__v.__k[0].__c;

          this.__v.__k[0] = function n(t, e, r) {
            return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach(function (n) {
              "function" == typeof n.__c && n.__c();
            }), t.__c.__H = null), null != (t = S({}, t)).__c && (t.__c.__P === r && (t.__c.__P = e), t.__c = null), t.__k = t.__k && t.__k.map(function (t) {
              return n(t, e, r);
            })), t;
          }(this.__b, e, r.__O = r.__P);
        }

        this.__b = null;
      }

      var u = t.__e && v$1(d$1, null, n.fallback);
      return u && (u.__h = null), [v$1(d$1, null, t.__e ? null : n.children), u];
    };

    var T = function (n, t, e) {
      if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
        for (; e.length > 3;) {
          e.pop()();
        }

        if (e[1] < e[0]) break;
        n.u = e = e[2];
      }
    };

    function D(n) {
      return this.getChildContext = function () {
        return n.context;
      }, n.children;
    }

    function I(n) {
      var t = this,
          e = n.i;
      t.componentWillUnmount = function () {
        S$1(null, t.l), t.l = null, t.i = null;
      }, t.i && t.i !== e && t.componentWillUnmount(), n.__v ? (t.l || (t.i = e, t.l = {
        nodeType: 1,
        parentNode: e,
        childNodes: [],
        appendChild: function (n) {
          this.childNodes.push(n), t.i.appendChild(n);
        },
        insertBefore: function (n, e) {
          this.childNodes.push(n), t.i.appendChild(n);
        },
        removeChild: function (n) {
          this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), t.i.removeChild(n);
        }
      }), S$1(v$1(D, {
        context: t.context
      }, n.__v), t.l)) : t.l && t.componentWillUnmount();
    }

    function W(n, t) {
      return v$1(I, {
        __v: n,
        i: t
      });
    }

    (M.prototype = new _$1()).__e = function (n) {
      var t = this,
          e = U(t.__v),
          r = t.o.get(n);
      return r[0]++, function (u) {
        var o = function () {
          t.props.revealOrder ? (r.push(u), T(t, n, r)) : u();
        };

        e ? e(o) : o();
      };
    }, M.prototype.render = function (n) {
      this.u = null, this.o = new Map();
      var t = A$2(n.children);
      n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

      for (var e = t.length; e--;) {
        this.o.set(t[e], this.u = [1, 0, this.u]);
      }

      return n.children;
    }, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function () {
      var n = this;
      this.o.forEach(function (t, e) {
        T(n, e, t);
      });
    };

    var j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        P = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        V = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };

    _$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (n) {
      Object.defineProperty(_$1.prototype, n, {
        configurable: !0,
        get: function () {
          return this["UNSAFE_" + n];
        },
        set: function (t) {
          Object.defineProperty(this, n, {
            configurable: !0,
            writable: !0,
            value: t
          });
        }
      });
    });
    var H = l$1.event;

    function Z() {}

    function Y() {
      return this.cancelBubble;
    }

    function $() {
      return this.defaultPrevented;
    }

    l$1.event = function (n) {
      return H && (n = H(n)), n.persist = Z, n.isPropagationStopped = Y, n.isDefaultPrevented = $, n.nativeEvent = n;
    };

    var G = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
        J = l$1.vnode;

    l$1.vnode = function (n) {
      var t = n.type,
          e = n.props,
          r = e;

      if ("string" == typeof t) {
        for (var u in r = {}, e) {
          var o = e[u];
          "value" === u && "defaultValue" in e && null == o || ("defaultValue" === u && "value" in e && null == e.value ? u = "value" : "download" === u && !0 === o ? o = "" : /ondoubleclick/i.test(u) ? u = "ondblclick" : /^onchange(textarea|input)/i.test(u + t) && !V(e.type) ? u = "oninput" : /^on(Ani|Tra|Tou|BeforeInp)/.test(u) ? u = u.toLowerCase() : P.test(u) ? u = u.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === o && (o = void 0), r[u] = o);
        }

        "select" == t && r.multiple && Array.isArray(r.value) && (r.value = A$2(e.children).forEach(function (n) {
          n.props.selected = -1 != r.value.indexOf(n.props.value);
        })), "select" == t && null != r.defaultValue && (r.value = A$2(e.children).forEach(function (n) {
          n.props.selected = r.multiple ? -1 != r.defaultValue.indexOf(n.props.value) : r.defaultValue == n.props.value;
        })), n.props = r;
      }

      t && e.class != e.className && (G.enumerable = "className" in e, null != e.className && (r.class = e.className), Object.defineProperty(r, "className", G)), n.$$typeof = j, J && J(n);
    };

    var K = l$1.__r;

    l$1.__r = function (n) {
      K && K(n);
    };

    /**
     * Shortcut for preact/compat's `forwardRef` that auto-assumes some things that are useful for forwarding refs to `HTMLElements` specifically.
     * Namely it involves de-gunking the type system by letting us return *generic* function and playing nice with React. In all other respects, it acts like `forwardRef`.
     */

    function forwardElementRef$1(Component) {
      var ForwardedComponent = x(Component);
      return ForwardedComponent;
    }

    var _excluded$E = ["children", "duration", "classBase", "measure", "exitVisibility", "open", "onTransitionUpdate", "animateOnMount"];

    function getClassName(classBase, open, phase) {
      if (phase) return "".concat(classBase || "transition", "-").concat(open, "-").concat(phase);else return "".concat(classBase || "transition", "-").concat(open);
    }

    function forceReflow(e) {
      // Try really hard to make sure this isn't optimized out by anything.
      // We need it for its document reflow side effect.
      e.getBoundingClientRect();
      return e;
    }
    /**
     * A hook that adds & removes class names in a way that facilitates proper transitions.
     *
     * The first argument contains the props related directly to the transition.
     *
     * The second argument contains any other props you might want merged into the final product (these are not read or manipulated or anything -- it's purely shorthand and can be omitted with `{}` and then your own `useMergedProps`).
     */


    function useCreateTransitionableProps({
      measure,
      animateOnMount,
      classBase,
      onTransitionUpdate,
      exitVisibility,
      duration,
      open,
      ref
    }, otherProps) {
      var _classBase;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      var {
        element,
        useRefElementProps
      } = useRefElement();
      var [phase, setPhase] = l(animateOnMount ? "init" : null);
      var [direction, setDirection] = l(open == null ? null : open ? "enter" : "exit");
      var [surfaceWidth, setSurfaceWidth] = l(null);
      var [surfaceHeight, setSurfaceHeight] = l(null);
      var [surfaceX, setSurfaceX] = l(null);
      var [surfaceY, setSurfaceY] = l(null);
      var [transitioningWidth, setTransitioningWidth] = l(null);
      var [transitioningHeight, setTransitioningHeight] = l(null);
      var [transitioningX, setTransitioningX] = l(null);
      var [transitioningY, setTransitioningY] = l(null);
      var {
        getLogicalDirection
      } = useLogicalDirection(element);
      var logicalDirection = getLogicalDirection();
      var onTransitionUpdateRef = s(onTransitionUpdate);
      var phaseRef = s(phase);
      var directionRef = s(direction);
      var durationRef = s(duration);
      var tooEarlyTimeoutRef = s(null);
      var tooEarlyValueRef = s(true);
      var tooLateTimeoutRef = s(null);
      var onTransitionEnd = A$1(e => {
        if (e.target === element && tooEarlyValueRef.current == false) {
          setPhase("finalize");
        }
      }, [element]);
      h(() => {
        onTransitionUpdateRef.current = onTransitionUpdate;
      }, [onTransitionUpdate]);
      h(() => {
        phaseRef.current = phase;
      }, [phase]);
      h(() => {
        directionRef.current = direction;
      }, [direction]);
      h(() => {
        durationRef.current = duration;
      }, [duration]);
      h(() => {
        var _onTransitionUpdateRe;

        if (direction && phase) (_onTransitionUpdateRe = onTransitionUpdateRef.current) === null || _onTransitionUpdateRe === void 0 ? void 0 : _onTransitionUpdateRe.call(onTransitionUpdateRef, direction, phase);
      }, [direction, phase]); // Every time the phase changes to "transition", add our transition timeout timeouts
      // to catch any time onTransitionEnd fails to report for whatever reason to be safe

      h(() => {
        if (phase == "transition") {
          var _durationRef$current;

          var timeoutDuration = (_durationRef$current = durationRef.current) !== null && _durationRef$current !== void 0 ? _durationRef$current : 1000;
          tooEarlyTimeoutRef.current = window.setTimeout(() => {
            tooEarlyValueRef.current = false;
            tooEarlyTimeoutRef.current = null;
          }, 50);
          tooLateTimeoutRef.current = window.setTimeout(() => {
            tooEarlyValueRef.current = true;
            tooLateTimeoutRef.current = null;
            setPhase("finalize");
          }, timeoutDuration);
        }

        return () => {
          if (tooEarlyTimeoutRef.current) clearTimeout(tooEarlyTimeoutRef.current);
          if (tooLateTimeoutRef.current) clearTimeout(tooLateTimeoutRef.current);
        };
      }, [phase]); // Any time "open" changes, update our direction and phase.
      // In addition, measure the size of the element if requested.

      h(() => {
        if (element && open != null) {
          var previousPhase = phaseRef.current; // Swap our direction

          if (open) setDirection("enter");else setDirection("exit");
          setPhase(previousPhase === null ? "finalize" : "init");

          if (measure) {
            var currentSizeWithTransition = element.getBoundingClientRect();
            {
              var {
                x,
                y,
                width,
                height
              } = currentSizeWithTransition;
              setTransitioningX(x + "px");
              setTransitioningY(y + "px");
              setTransitioningWidth(width + "px");
              setTransitioningHeight(height + "px");
            }

            if (previousPhase === "finalize") {
              // We're going to be messing with the actual element's class, 
              // so we'll want an easy way to restore it later.
              var backup = element.className;
              element.classList.add("".concat(classBase, "-measure"));
              element.classList.remove("".concat(classBase, "-enter"), "".concat(classBase, "-enter-init"), "".concat(classBase, "-enter-transition"), "".concat(classBase, "-enter-finalize"), "".concat(classBase, "-exit"), "".concat(classBase, "-exit-init"), "".concat(classBase, "-exit-transition"), "".concat(classBase, "-exit-finalize"));
              forceReflow(element);
              var sizeWithoutTransition = element.getBoundingClientRect();
              var {
                x: _x,
                y: _y,
                width: _width,
                height: _height
              } = sizeWithoutTransition;
              setSurfaceX(_x + "px");
              setSurfaceY(_y + "px");
              setSurfaceWidth(_width + "px");
              setSurfaceHeight(_height + "px");
              element.className = backup;
              forceReflow(element);
            }
          }
        }
      }, [open, element, measure, classBase]); // Any time the phase changes to init, immediately before the screen is painted,
      // change the phase to "transition" and re-render ().

      h(() => {
        if (element && directionRef.current != null) {
          var _classBase2;

          (_classBase2 = classBase) !== null && _classBase2 !== void 0 ? _classBase2 : classBase = "transition";

          if (phase === "init") {
            // Preact just finished rendering init
            // Now set our transition style.
            setPhase("transition");

            if (measure) {
              forceReflow(element);
            }
          }
        }
      }, [phase, measure, element]);
      var inlineDirection = logicalDirection === null || logicalDirection === void 0 ? void 0 : logicalDirection.inlineDirection;
      var blockDirection = logicalDirection === null || logicalDirection === void 0 ? void 0 : logicalDirection.blockDirection;
      var writingModeIsHorizontal = inlineDirection == "rtl" || inlineDirection == "ltr";
      var surfaceInlineInset = writingModeIsHorizontal ? surfaceX : surfaceY;
      var surfaceBlockInset = writingModeIsHorizontal ? surfaceY : surfaceX;
      var surfaceInlineSize = writingModeIsHorizontal ? surfaceWidth : surfaceHeight;
      var surfaceBlockSize = writingModeIsHorizontal ? surfaceHeight : surfaceWidth;
      var transitioningInlineInset = writingModeIsHorizontal ? transitioningX : transitioningY;
      var transitioningBlockInset = writingModeIsHorizontal ? transitioningY : transitioningX;
      var transitioningInlineSize = writingModeIsHorizontal ? transitioningWidth : transitioningHeight;
      var transitioningBlockSize = writingModeIsHorizontal ? transitioningHeight : transitioningWidth;
      var almostDone = useRefElementProps(_objectSpread2(_objectSpread2({
        ref,
        style: removeEmpty({
          ["--".concat(classBase, "-duration")]: duration,
          ["--".concat(classBase, "-surface-x")]: surfaceX,
          ["--".concat(classBase, "-surface-y")]: surfaceY,
          ["--".concat(classBase, "-surface-width")]: surfaceWidth,
          ["--".concat(classBase, "-surface-height")]: surfaceHeight,
          ["--".concat(classBase, "-surface-inline-inset")]: surfaceInlineInset,
          ["--".concat(classBase, "-surface-block-inset")]: surfaceBlockInset,
          ["--".concat(classBase, "-surface-inline-size")]: surfaceInlineSize,
          ["--".concat(classBase, "-surface-block-size")]: surfaceBlockSize,
          ["--".concat(classBase, "-transitioning-x")]: transitioningX,
          ["--".concat(classBase, "-transitioning-y")]: transitioningY,
          ["--".concat(classBase, "-transitioning-width")]: transitioningWidth,
          ["--".concat(classBase, "-transitioning-height")]: transitioningHeight,
          ["--".concat(classBase, "-transitioning-inline-inset")]: transitioningInlineInset,
          ["--".concat(classBase, "-transitioning-block-inset")]: transitioningBlockInset,
          ["--".concat(classBase, "-transitioning-inline-size")]: transitioningInlineSize,
          ["--".concat(classBase, "-transitioning-block-size")]: transitioningBlockSize
        }),
        onTransitionEnd
      }, {
        "aria-hidden": open ? undefined : "true"
      }), {}, {
        className: clsx(direction && getClassName(classBase, direction), direction && phase && getClassName(classBase, direction, phase), exitVisibility == "removed" && "".concat(classBase, "-removed-on-exit"), exitVisibility == "visible" && "".concat(classBase, "-visible-on-exit"), "".concat(classBase, "-inline-direction-").concat(inlineDirection !== null && inlineDirection !== void 0 ? inlineDirection : "ltr"), "".concat(classBase, "-block-direction-").concat(blockDirection !== null && blockDirection !== void 0 ? blockDirection : "ttb"))
      }));
      return useMergedProps()(almostDone, otherProps);
    }

    function removeEmpty(obj) {
      return Object.fromEntries(Object.entries(obj).filter(([_, v]) => v != null));
    }
    /**
     * A component that *wraps an HTMLElement or other ref-forwarding component* and allows it to use CSS to transition in/out.
     * Combines the props passed to it, the props its child has, and the props needed for the CSS transition, and passes them
     * all to the child element you provide.
     *
     * This is the most general component that others use as a base. By default, this component by itself doesn't actually add any CSS classes that animate anything (like opacity, for example).
     * It adds classes like `transition-enter-finalize`, but you need to provide the additional e.g. `fade` class that reacts to it.
     *
     * Use this if the other, more specialized Transition components don't fit your needs.
     *
     * @example `<Transitionable open={open} {...useCreateFadeProps(...)}><div>{children}</div></Transitionable>`
     * @example `<Transitionable open={open}><div {...useCreateFadeProps(...)}>{children}</div></Transitionable>`
     */


    var Transitionable = forwardElementRef$1(function Transition(_ref, r) {
      var {
        children: child,
        duration,
        classBase,
        measure,
        exitVisibility,
        open,
        onTransitionUpdate,
        animateOnMount
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$E);

      if (!childIsVNode(child)) {
        throw new Error("A Transitionable component must have exactly one component child (e.g. a <div>, but not \"a string\").");
      }

      var transitionProps = useCreateTransitionableProps({
        classBase,
        duration,
        measure,
        open,
        animateOnMount,
        onTransitionUpdate,
        ref: r,
        exitVisibility
      }, props);
      var mergedWithChildren = useMergedProps()(transitionProps, _objectSpread2(_objectSpread2({}, child.props), {}, {
        ref: child.ref
      }));
      return B(child, mergedWithChildren);
    });

    function childIsVNode(child) {
      if (!child) return false;

      if (Array.isArray(child)) {
        return false;
      }

      if (typeof child != "object") return false;
      return "props" in child;
    }

    var _excluded$D = ["classBase", "clipOrigin", "clipOriginInline", "clipOriginBlock", "clipMin", "clipMinInline", "clipMinBlock", "open"];
    /**
     * Creates a set of props that implement a Clip transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     * Be sure to merge these returned props with whatever the user passed in.
     */

    function useCreateClipProps({
      classBase,
      clipOrigin,
      clipOriginInline,
      clipOriginBlock,
      clipMin,
      clipMinInline,
      clipMinBlock
    }, otherProps) {
      var _classBase, _ref, _ref2, _ref3, _ref4;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      return useMergedProps()({
        className: clsx("".concat(classBase, "-clip")),
        classBase,
        style: {
          ["--".concat(classBase, "-clip-origin-inline")]: (_ref = clipOriginInline !== null && clipOriginInline !== void 0 ? clipOriginInline : clipOrigin) !== null && _ref !== void 0 ? _ref : 0.5,
          ["--".concat(classBase, "-clip-origin-block")]: (_ref2 = clipOriginBlock !== null && clipOriginBlock !== void 0 ? clipOriginBlock : clipOrigin) !== null && _ref2 !== void 0 ? _ref2 : 0,
          ["--".concat(classBase, "-clip-min-inline")]: (_ref3 = clipMinInline !== null && clipMinInline !== void 0 ? clipMinInline : clipMin) !== null && _ref3 !== void 0 ? _ref3 : 1,
          ["--".concat(classBase, "-clip-min-block")]: (_ref4 = clipMinBlock !== null && clipMinBlock !== void 0 ? clipMinBlock : clipMin) !== null && _ref4 !== void 0 ? _ref4 : 0
        }
      }, otherProps);
    }
    var Clip = forwardElementRef$1(function Clip(_ref5, ref) {
      var {
        classBase,
        clipOrigin,
        clipOriginInline,
        clipOriginBlock,
        clipMin,
        clipMinInline,
        clipMinBlock,
        open
      } = _ref5,
          rest = _objectWithoutProperties(_ref5, _excluded$D);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateClipProps({
        classBase,
        clipOrigin,
        clipOriginInline,
        clipOriginBlock,
        clipMin,
        clipMinInline,
        clipMinBlock
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$C = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Creates a set of props that implement a Fade transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     * Be sure to merge these returned props with whatever the user passed in.
     */

    function useCreateFadeProps({
      classBase,
      fadeMin,
      fadeMax
    }, otherProps) {
      var _classBase;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      return useMergedProps()({
        className: "".concat(classBase, "-fade"),
        classBase,
        style: {
          ["--".concat(classBase, "-fade-min")]: fadeMin !== null && fadeMin !== void 0 ? fadeMin : 0,
          ["--".concat(classBase, "-fade-max")]: fadeMax !== null && fadeMax !== void 0 ? fadeMax : 1
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Fade effect.
     *
     * Note that while it is absolutely possible to wrap another transition with `<Fade>`,
     * there will be some duplicate code run as two `<Transitionable>` components end up operating on the same element.
     * It's generally recommended to either use the components that include a combined fade effect,
     * or just directly a `<Transitionable>` on your own.
     *
     * @see `Transitionable`
     */

    var Fade = forwardElementRef$1(function Fade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$C);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$B = ["classBase", "fadeMin", "fadeMax", "open"];
    var ClipFade = forwardElementRef$1(function ClipFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$B);

      return v$1(Clip, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$A = ["classBase", "open", "minBlockSize"];
    /**
     * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     * Be sure to merge these returned props with whatever the user passed in.
     *
     * IMPORTANT: If used outside of a `<Collapse />`, you must include the `measure` prop on the `<Transitionable>` that you use.
     *
     * @example <Transitionable measure {...useCreateCollapseProps(...)} />
     */

    function useCreateCollapseProps({
      classBase,
      minBlockSize
    }, otherProps) {
      var _classBase;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      return useMergedProps()({
        classBase,
        measure: true,
        className: "".concat(classBase, "-collapse"),
        style: {
          ["--".concat(classBase, "-collapse-min-block")]: minBlockSize !== null && minBlockSize !== void 0 ? minBlockSize : 0
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Collapse effect.
     *
     * *Important*: This component is *not* efficient for the browser to animate!
     * Make sure you do testing on lower power devices, or prefer a lighter
     * alternative, like `<Clip>`.
     *
     * @see `Transitionable`
     */

    var Collapse = forwardElementRef$1(function Collapse(_ref, ref) {
      var {
        classBase,
        open,
        minBlockSize
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$A);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateCollapseProps({
        classBase,
        minBlockSize
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$z = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with both Collapse and Fade effects.
     *
     * @see `Transitionable` `Collapse` `Fade`
     */

    forwardElementRef$1(function CollapseFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$z);

      return v$1(Collapse, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$y = ["classBase", "slideTargetInline", "slideTargetBlock", "open"];
    /**
     * Creates a set of props that implement a Slide transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     */

    function useCreateSlideProps({
      classBase,
      slideTargetInline,
      slideTargetBlock
    }, otherProps) {
      var _classBase, _slideTargetInline, _slideTargetBlock, _slideTargetInline2, _slideTargetBlock2;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      var lastValidTargetInline = s((_slideTargetInline = slideTargetInline) !== null && _slideTargetInline !== void 0 ? _slideTargetInline : 1);
      var lastValidTargetBlock = s((_slideTargetBlock = slideTargetBlock) !== null && _slideTargetBlock !== void 0 ? _slideTargetBlock : 0);
      y(() => {
        if (slideTargetInline) lastValidTargetInline.current = slideTargetInline;
      }, [slideTargetInline]);
      y(() => {
        if (slideTargetBlock) lastValidTargetBlock.current = slideTargetBlock;
      }, [slideTargetBlock]);
      if (slideTargetInline == 0) slideTargetInline = lastValidTargetInline.current;
      if (slideTargetBlock == 0) slideTargetBlock = lastValidTargetBlock.current;
      return useMergedProps()({
        className: "".concat(classBase, "-slide"),
        classBase,
        style: {
          ["--".concat(classBase, "-slide-target-inline")]: "".concat((_slideTargetInline2 = slideTargetInline) !== null && _slideTargetInline2 !== void 0 ? _slideTargetInline2 : 0),
          ["--".concat(classBase, "-slide-target-block")]: "".concat((_slideTargetBlock2 = slideTargetBlock) !== null && _slideTargetBlock2 !== void 0 ? _slideTargetBlock2 : 0)
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Slide effect.
     *
     * Provide the direction the element will travel in with `slideInline` and `slideBlock`,
     * with `1` being `100%` of the element's width or height.
     *
     * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
     * which allows for convenient setups inside of a `SwapContainer`
     * (`slideInline={index - selectedIndex}` or similar.)
     *
     * @see `Transitionable`
     */

    var Slide = forwardElementRef$1(function Slide(_ref, ref) {
      var {
        classBase,
        slideTargetInline,
        slideTargetBlock,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$y);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateSlideProps({
        classBase,
        slideTargetInline,
        slideTargetBlock
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$x = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with both Slide and Fade effects.
     *
     * `slideInline={(index - selectedIndex) / 10}` would make the element look like it fades out before it travels to its target destination.
     *
     * @see `Transitionable` `Zoom`
     */

    var SlideFade = forwardElementRef$1(function SlideFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$x);

      return v$1(Slide, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$w = ["classBase", "zoomOrigin", "zoomOriginInline", "zoomOriginBlock", "zoomMin", "zoomMinInline", "zoomMinBlock", "open"];
    /**
     * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     */

    function useCreateZoomProps({
      classBase,
      zoomOrigin,
      zoomOriginInline,
      zoomOriginBlock,
      zoomMin,
      zoomMinInline,
      zoomMinBlock
    }, otherProps) {
      var _classBase, _ref, _ref2, _ref3, _ref4;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      return useMergedProps()({
        className: "".concat(classBase, "-zoom"),
        classBase,
        style: {
          ["--".concat(classBase, "-zoom-origin-inline")]: "".concat((_ref = zoomOriginInline !== null && zoomOriginInline !== void 0 ? zoomOriginInline : zoomOrigin) !== null && _ref !== void 0 ? _ref : 0.5),
          ["--".concat(classBase, "-zoom-origin-block")]: "".concat((_ref2 = zoomOriginBlock !== null && zoomOriginBlock !== void 0 ? zoomOriginBlock : zoomOrigin) !== null && _ref2 !== void 0 ? _ref2 : 0.5),
          ["--".concat(classBase, "-zoom-min-inline")]: "".concat((_ref3 = zoomMinInline !== null && zoomMinInline !== void 0 ? zoomMinInline : zoomMin) !== null && _ref3 !== void 0 ? _ref3 : 0),
          ["--".concat(classBase, "-zoom-min-block")]: "".concat((_ref4 = zoomMinBlock !== null && zoomMinBlock !== void 0 ? zoomMinBlock : zoomMin) !== null && _ref4 !== void 0 ? _ref4 : 0)
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Zoom effect.
     * @see `Transitionable` `ZoomFade`
     */

    var Zoom = forwardElementRef$1(function Zoom(_ref5, ref) {
      var {
        classBase,
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        zoomMin,
        zoomMinInline,
        zoomMinBlock,
        open
      } = _ref5,
          rest = _objectWithoutProperties(_ref5, _excluded$w);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateZoomProps({
        classBase,
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        zoomMin,
        zoomMinInline,
        zoomMinBlock
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$v = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with both Zoom and Fade effects.
     *
     * This is an ideal time to use the minimum size Zoom properties.
     *
     * @see `Transitionable` `Zoom`
     */

    var ZoomFade = forwardElementRef$1(function ZoomFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$v);

      return v$1(Zoom, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$u = ["classBase", "zoomMin", "zoomMinInline", "zoomMinBlock", "zoomOrigin", "zoomOriginInline", "zoomOriginBlock", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with both Slide and Zoom effects.
     *
     * Probably best combined with `useCreateFadeProps` (or just using a `SlideZoomFade`?).
     *
     * @see `Transitionable` `SlideFadeZoom` `Zoom` `Fade`
     */

    var SlideZoom = forwardElementRef$1(function SlideZoom(_ref, ref) {
      var {
        classBase,
        zoomMin,
        zoomMinInline,
        zoomMinBlock,
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$u);

      return v$1(Slide, _objectSpread2({
        open: open
      }, useCreateZoomProps({
        classBase,
        zoomMin,
        zoomMinInline,
        zoomMinBlock,
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$t = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with Zoom, Slide, and Fade effects.
     *
     * Note that this is basically just shorthand for some prop creation and prop merging functions.
     *
     * @see `Transitionable` `Slide` `Zoom` `Fade`
     */

    forwardElementRef$1(function SlideZoomFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$t);

      return v$1(SlideZoom, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$s = ["classBase", "flipAngleInline", "flipAngleBlock", "perspective", "open"];
    /**
     * Creates a set of props that implement a Flip transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     */

    function useCreateFlipProps({
      classBase,
      flipAngleInline,
      flipAngleBlock,
      perspective
    }, otherProps) {
      var _classBase, _flipAngleInline, _flipAngleBlock, _flipAngleInline2, _flipAngleBlock2;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      var lastValidTargetInline = s((_flipAngleInline = flipAngleInline) !== null && _flipAngleInline !== void 0 ? _flipAngleInline : 180);
      var lastValidTargetBlock = s((_flipAngleBlock = flipAngleBlock) !== null && _flipAngleBlock !== void 0 ? _flipAngleBlock : 0);
      y(() => {
        if (flipAngleInline) lastValidTargetInline.current = flipAngleInline;
      }, [flipAngleInline]);
      y(() => {
        if (flipAngleBlock) lastValidTargetBlock.current = flipAngleBlock;
      }, [flipAngleBlock]);
      if (flipAngleInline == 0) flipAngleInline = lastValidTargetInline.current;
      if (flipAngleBlock == 0) flipAngleBlock = lastValidTargetBlock.current;
      return useMergedProps()({
        className: "".concat(classBase, "-flip"),
        classBase,
        style: {
          ["--".concat(classBase, "-flip-angle-inline")]: "".concat((_flipAngleInline2 = flipAngleInline) !== null && _flipAngleInline2 !== void 0 ? _flipAngleInline2 : 0, "deg"),
          ["--".concat(classBase, "-flip-angle-block")]: "".concat((_flipAngleBlock2 = flipAngleBlock) !== null && _flipAngleBlock2 !== void 0 ? _flipAngleBlock2 : 0, "deg"),
          ["--".concat(classBase, "-perspective")]: "".concat(perspective !== null && perspective !== void 0 ? perspective : 800, "px")
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Flip effect.
     *
     * Provide the direction the element will travel in with `flipInline` and `flipBlock`,
     * with `1` being `100%` of the element's width or height.
     *
     * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
     * which allows for convenient setups inside of a `SwapContainer`
     * (`flipInline={index - selectedIndex}` or similar.)
     *
     * @see `Transitionable`
     */

    forwardElementRef$1(function Flip(_ref, ref) {
      var {
        classBase,
        flipAngleInline,
        flipAngleBlock,
        perspective,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$s);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateFlipProps({
        classBase,
        flipAngleInline,
        flipAngleBlock,
        perspective
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$r = ["children", "classBase", "inline"];
    /**
     * Creates a set of props that implement a swap container.
     * Be sure to merge these returned props with whatever the user passed in.
     */

    function useCreateSwappableProps({
      inline,
      classBase
    }, otherProps) {
      return useMergedProps()({
        className: clsx("".concat(classBase !== null && classBase !== void 0 ? classBase : "transition", "-swap-container"), inline && "".concat(classBase !== null && classBase !== void 0 ? classBase : "transition", "-swap-container-inline"))
      }, otherProps);
    }
    /**
     * Allows a set of child <Transitionable> components to animate in & out in-place. Very useful for, e.g., tab panels.
     *
     * You must manage each child `<Transitionable>` component's `open` prop -- this component *does not* manage any sort of state in that regard.
     *
     * Like `<Transitionable>`, *this wraps an HTMLElement (or other ref-forwarding component)*. This will be your container that holds each `<Transitionable>` (or component that uses it). Strictly speaking it could be anything, not a `<Transitionable>`, but if it doesnt't transition out then it's just going to be hanging around 100% of the time.
     *
     * Long way of saying, if you get a cryptic error with this component, make sure it has a single `<div>` child or something.
     * @param param0
     * @returns
     */

    var Swappable = forwardElementRef$1(function Swappable(_ref, ref) {
      var _inline;

      var {
        children,
        classBase,
        inline
      } = _ref,
          p = _objectWithoutProperties(_ref, _excluded$r);

      (_inline = inline) !== null && _inline !== void 0 ? _inline : inline = typeof children.type === "string" && inlineElements.has(children.type);
      var transitionProps = useCreateSwappableProps({
        classBase,
        inline
      }, _objectSpread2(_objectSpread2({}, p), {}, {
        ref
      }));
      var mergedWithChildren = useMergedProps()(transitionProps, children.props);
      return B(children, mergedWithChildren);
    }); // If "inline" isn't explicitly provided, we try to implicitly do it based on the child's tag.
    // Not perfect, but it's not supposed to be. `inline` is for perfect.

    var inlineElements = new Set(["a", "abbr", "acronym", "audio", "b", "bdi", "bdo", "big", "br", "button", "canvas", "cite", "code", "data", "datalist", "del", "dfn", "em", "embed", "i", "iframe", "img", "input", "ins", "kbd", "label", "map", "mark", "meter", "noscript", "object", "output", "picture", "progress", "q", "ruby", "s", "samp", "script", "select", "slot", "small", "span", "strong", "sub", "sup", "svg", "template", "textarea", "time", "u", "tt", "var", "video", "wbr"]);

    var EventDetail = Symbol("event-detail");
    function enhanceEvent(e, detail) {
      var event = e;
      event[EventDetail] = detail;
      return event;
    }

    var _excluded$q = ["aria-pressed", "tabIndex", "role"];
    var pulse = "vibrate" in navigator ? () => navigator.vibrate(10) : () => {};

    function excludes(tag, target, exclude) {
      if (exclude !== null && exclude !== void 0 && exclude[target]) return true;
      if (target === "space" || target === "enter") return tag == "button";
      return false;
    }
    /**
     * Easy way to "polyfill" button-like interactions onto, e.g., a div.
     *
     * Adds click, space on keyDown, and enter on keyUp, as well as haptic
     * feedback via a momentary vibration pulse when there's an onClick handler provided
     * (this can be disabled app-wide with `setButtonVibrate`).
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClick
     * @param exclude Whether the polyfill should apply (can specify for specific interactions)
     */


    function useButtonLikeEventHandlers(tag, onClickSync, exclude) {
      //type E = Ev extends h.JSX.TargetedEvent<infer E, any>? E : EventTarget;
      var [active, setActive] = useState(false);
      var onKeyUp = excludes(tag, "space", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync) {
          e.preventDefault();
          onClickSync(e);
          setActive(false);
        }
      };
      var onMouseDown = excludes(tag, "click", exclude) ? undefined : e => {
        if (e.button === 0) setActive(true);
      };

      var onBlur = e => {
        setActive(false);
      };

      var onMouseUp = excludes(tag, "click", exclude) ? undefined : onBlur;
      var onMouseOut = excludes(tag, "click", exclude) ? undefined : onBlur;
      var onKeyDown = excludes(tag, "space", exclude) && excludes(tag, "enter", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync && !excludes(tag, "space", exclude)) {
          // We don't actually activate it on a space keydown
          // but we do preventDefault to stop the page from scrolling.
          setActive(true);
          e.preventDefault();
        }

        if (e.key == "Enter" && onClickSync && !excludes(tag, "enter", exclude)) {
          e.preventDefault();
          onClickSync(e);
        }
      };
      var onClick2 = excludes(tag, "click", exclude) ? undefined : e => {
        if (onClickSync && !excludes(tag, "click", exclude)) {
          pulse();
          onClickSync(e);
        }
      };
      return props => useMergedProps()(_objectSpread2({
        onKeyDown,
        onKeyUp,
        onClick: onClick2,
        onBlur,
        onMouseDown,
        onMouseUp,
        onMouseOut
      }, {
        "data-pseudo-active": active ? "true" : undefined
      }), props);
    }
    function useAriaButton({
      tag,
      pressed,
      onClick
    }) {
      function useAriaButtonProps(_ref) {
        var {
          "aria-pressed": ariaPressed,
          tabIndex,
          role
        } = _ref,
            p = _objectWithoutProperties(_ref, _excluded$q);

        var props = useButtonLikeEventHandlers(tag, e => onClick === null || onClick === void 0 ? void 0 : onClick(enhanceEvent(e, {
          pressed: pressed == null ? null : !pressed
        })), undefined)(p);
        var buttonProps = {
          role,
          tabIndex,
          "aria-pressed": ariaPressed !== null && ariaPressed !== void 0 ? ariaPressed : pressed === true ? "true" : pressed === false ? "false" : undefined
        };

        var divProps = _objectSpread2(_objectSpread2({}, buttonProps), {}, {
          tabIndex: tabIndex !== null && tabIndex !== void 0 ? tabIndex : 0,
          role: role !== null && role !== void 0 ? role : "button"
        });

        var anchorProps = _objectSpread2({}, divProps);

        switch (tag) {
          case "button":
            return useMergedProps()(buttonProps, props);

          case "a":
            return useMergedProps()(anchorProps, props);

          default:
            return useMergedProps()(divProps, props);
        }
      }

      return {
        useAriaButtonProps
      };
    }

    var _excluded$p = ["aria-expanded", "aria-disabled"],
        _excluded2$d = ["role"];
    function useAriaAccordion({
      expandedIndex,
      setExpandedIndex
    }) {
      var [lastFocusedIndex, setLastFocusedIndex, getLastFocusedIndex] = useState(0);
      var stableSetExpandedIndex = useStableCallback(setExpandedIndex !== null && setExpandedIndex !== void 0 ? setExpandedIndex : () => {});
      var {
        managedChildren: managedAccordionSections,
        useManagedChild: useManagedChildSection
      } = useChildManager();
      var {
        useLinearNavigationChild
      } = useLinearNavigation({
        managedChildren: managedAccordionSections,
        navigationDirection: "block",
        getIndex: getLastFocusedIndex,
        setIndex: setLastFocusedIndex
      }); // Any time list management changes the focused index, manually focus the child
      // TODO: Can this be cut?

      useLayoutEffect(() => {
        var _managedAccordionSect;

        if (lastFocusedIndex != null && lastFocusedIndex >= 0) (_managedAccordionSect = managedAccordionSections[lastFocusedIndex]) === null || _managedAccordionSect === void 0 ? void 0 : _managedAccordionSect.focus();
      }, [lastFocusedIndex]);
      useChildFlag(expandedIndex, managedAccordionSections.length, (i, open) => {
        var _managedAccordionSect2;

        return (_managedAccordionSect2 = managedAccordionSections[i]) === null || _managedAccordionSect2 === void 0 ? void 0 : _managedAccordionSect2.setOpenFromParent(open);
      });
      var useAriaAccordionSection = A$1(args => {
        var _ref, _args$open;

        var [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
        var {
          randomId: bodyRandomId,
          useRandomIdProps: useBodyRandomIdProps,
          useReferencedIdProps: useReferencedBodyIdProps
        } = useRandomId({
          prefix: "aria-accordion-section-body-"
        });
        var {
          randomId: headRandomId,
          useRandomIdProps: useHeadRandomIdProps,
          useReferencedIdProps: useReferencedHeadIdProps
        } = useRandomId({
          prefix: "aria-accordion-section-header-"
        });
        var open = (_ref = (_args$open = args.open) !== null && _args$open !== void 0 ? _args$open : openFromParent) !== null && _ref !== void 0 ? _ref : null; // TODO: Convert to use useManagedChild so that this hook 
        // is stable without (directly) depending on the open state.

        var useAriaAccordionSectionHeader = A$1(function useAriaAccordionSectionHeader({
          tag
        }) {
          var {
            useRefElementProps,
            element
          } = useRefElement();
          var focus = A$1(() => {
            element === null || element === void 0 ? void 0 : element.focus();
          }, [element]);
          var {
            useManagedChildProps
          } = useManagedChildSection({
            index: args.index,
            open: open,
            setOpenFromParent,
            focus
          });
          var {
            useLinearNavigationChildProps
          } = useLinearNavigationChild();

          function useAriaAccordionSectionHeaderProps(_ref2) {
            var {
              ["aria-expanded"]: ariaExpanded,
              ["aria-disabled"]: ariaDisabled
            } = _ref2,
                props = _objectWithoutProperties(_ref2, _excluded$p);

            var onFocus = () => {
              setLastFocusedIndex(args.index);
            };

            var onClick = () => {
              if (getOpenFromParent()) stableSetExpandedIndex(null);else stableSetExpandedIndex(args.index);
            };

            var retB = useMergedProps()({
              tabIndex: 0
            }, useButtonLikeEventHandlers(tag, onClick, undefined)(props));
            var ret3 = useMergedProps()(useHeadRandomIdProps(useReferencedBodyIdProps("aria-controls")(_objectSpread2({
              "aria-expanded": ariaExpanded !== null && ariaExpanded !== void 0 ? ariaExpanded : (!!open).toString(),
              "aria-disabled": ariaDisabled !== null && ariaDisabled !== void 0 ? ariaDisabled : open ? "true" : undefined
            }, useRefElementProps(useManagedChildProps(retB))))), {
              onFocus
            });
            return useLinearNavigationChildProps(ret3);
          }
          return {
            useAriaAccordionSectionHeaderProps
          };
        }, [open]);
        var useAriaAccordionSectionBody = A$1(function useAriaAccordionSectionBody() {
          function useAriaAccordionSectionBodyProps(_ref3) {
            var {
              role
            } = _ref3,
                props = _objectWithoutProperties(_ref3, _excluded2$d);

            var ret1 = useReferencedHeadIdProps("aria-labelledby")(_objectSpread2({
              role: role !== null && role !== void 0 ? role : "region"
            }, props));
            var ret2 = useBodyRandomIdProps(ret1);
            return ret2;
          }
          return {
            useAriaAccordionSectionBodyProps
          };
        }, []);
        return {
          expanded: open,
          useAriaAccordionSectionHeader,
          useAriaAccordionSectionBody
        };
      }, [useLinearNavigationChild]);
      return {
        useAriaAccordionSection
      };
    }

    var _excluded$o = ["aria-labelledby", "aria-label"];
    /**
     * Adds an ID and "aria-labelledby" for two elements, an "input" element and a "label" element.
     *
     * Returns the `useReferencedIdProps` hooks if you need to also add other ID-referencing attributes, like `for`
     *
     * @see useInputLabel
     */

    function useGenericLabel({
      labelPrefix,
      inputPrefix,
      backupText
    } = {
      labelPrefix: "label-",
      inputPrefix: "input-"
    }) {
      var {
        element: labelElement,
        getElement: getLabelElement,
        useRefElementProps: useLabelRefElementProps
      } = useRefElement();
      var {
        element: inputElement,
        getElement: getInputElement,
        useRefElementProps: useInputRefElementProps
      } = useRefElement();
      var {
        useRandomIdProps: useLabelRandomIdProps,
        id: labelId,
        randomId: labelRandomId,
        useReferencedIdProps: useReferencedLabelIdProps
      } = useRandomId({
        prefix: labelPrefix
      });
      var {
        useRandomIdProps: useInputRandomIdProps,
        id: inputId,
        randomId: inputRandomId,
        useReferencedIdProps: useReferencedInputIdProps
      } = useRandomId({
        prefix: inputPrefix
      });
      var labelHasMounted = !!labelElement;
      var useGenericLabelLabel = A$1(function useGenericLabelLabel() {
        return {
          useGenericLabelLabelProps: props => {
            return useLabelRandomIdProps(useLabelRefElementProps(props));
          }
        };
      }, []);
      var useGenericLabelInput = A$1(function useGenericLabelInput() {
        return {
          useGenericLabelInputProps: _ref => {
            var _ref2;

            var {
              "aria-labelledby": ariaLabelledby,
              "aria-label": ariaLabel
            } = _ref,
                props = _objectWithoutProperties(_ref, _excluded$o);

            return useInputRandomIdProps(useReferencedLabelIdProps("aria-labelledby")(useInputRefElementProps(useMergedProps()({
              "aria-label": (_ref2 = !labelHasMounted ? backupText : ariaLabel) !== null && _ref2 !== void 0 ? _ref2 : ariaLabel
            }, props))));
          }
        };
      }, [labelHasMounted]);
      return {
        useGenericLabelInput,
        useGenericLabelLabel,
        useReferencedLabelIdProps,
        useReferencedInputIdProps,
        labelId,
        inputId,
        labelElement,
        inputElement,
        getLabelElement,
        getInputElement
      };
    }
    /**
     * Handles the attributes `id`, `for`, and `aria-labelledby` for to related elements.
     *
     * It's assumed that the label is an `HTMLLabelElement`, and the input is something for which
     * the `for` attribute can reference.
     *
     */

    function useInputLabel({
      labelPrefix,
      inputPrefix
    } = {
      labelPrefix: "label-",
      inputPrefix: "input-"
    }) {
      var {
        useGenericLabelInput,
        useGenericLabelLabel,
        useReferencedInputIdProps,
        useReferencedLabelIdProps,
        inputId,
        labelId,
        inputElement,
        getInputElement,
        labelElement,
        getLabelElement
      } = useGenericLabel({
        labelPrefix,
        inputPrefix
      });
      var useInputLabelLabel = A$1(function useInputLabelLabel({
        tag
      }) {
        var {
          useGenericLabelLabelProps
        } = useGenericLabelLabel();
        return {
          useInputLabelLabelProps(props) {
            var withFor = useReferencedInputIdProps("for")(props);
            var withoutFor = props;
            return useGenericLabelLabelProps(tag == "label" ? withFor : withoutFor);
          }

        };
      }, [useGenericLabelInput]);
      var useInputLabelInput = A$1(function useInputLabelInput() {
        var {
          useGenericLabelInputProps
        } = useGenericLabelInput();
        return {
          useInputLabelInputProps(props) {
            return useGenericLabelInputProps(props);
          }

        };
      }, [useGenericLabelLabel]);
      return {
        useInputLabelLabel,
        useInputLabelInput,
        labelId,
        inputId,
        inputElement,
        labelElement,
        getInputElement,
        getLabelElement
      };
    }

    var handlesInput = (tag, labelPosition, which) => {
      if (labelPosition === "separate") {
        if (which === "input-element") return true;else if (which === "label-element") return tag != "input";
      } else if (labelPosition === "wrapping") {
        if (which === "input-element") return false;
        if (which == "label-element") return true;
      }
    };
    /**
     * Handles label type (wrapping or separate) for checkboxes, radios, switches, etc.
     * @param param0
     * @returns
     */


    function useCheckboxLike({
      checked,
      disabled,
      labelPosition,
      onInput,
      role
    }) {
      var stableOnInput = useStableCallback(e => {
        e.preventDefault();
        onInput === null || onInput === void 0 ? void 0 : onInput(e);
      });
      var {
        inputId,
        labelId,
        useInputLabelInput: useILInput,
        useInputLabelLabel: useILLabel,
        getLabelElement,
        getInputElement
      } = useInputLabel({
        labelPrefix: "aria-checkbox-label-",
        inputPrefix: "aria-checkbox-input-"
      });
      var useCheckboxLikeInputElement = A$1(function useCheckboxInputElement({
        tag
      }) {
        var {
          useInputLabelInputProps: useILInputProps
        } = useILInput();
        var {
          element,
          useRefElementProps
        } = useRefElement(); // onClick and onChange are a bit messy, so we need to
        // *always* make sure that the visible state is correct
        // after all the event dust settles.
        // See https://github.com/preactjs/preact/issues/2745,
        // and https://github.com/preactjs/preact/issues/1899#issuecomment-525690194

        y(() => {
          if (element && tag == "input") {
            element.checked = checked;
          }
        }, [tag, element, checked]);
        return {
          inputElement: element,
          useCheckboxLikeInputElementProps
        };

        function useCheckboxLikeInputElementProps(_ref3) {
          var p0 = _extends({}, _ref3);

          // For some reason, Chrome won't fire onInput events for radio buttons that are tabIndex=-1??
          // Needs investigating, but onInput works fine in Firefox
          // TODO
          var props = useButtonLikeEventHandlers(tag, disabled || !handlesInput(tag, labelPosition, "input-element") ? undefined : stableOnInput, undefined)({});
          if (tag == "input") props.onInput = e => e.preventDefault();
          props = useRefElementProps(useILInputProps(props));

          if (labelPosition == "wrapping") {
            // Because the wrapped label handles all interactions,
            // we need to make sure this element can't be interacted with
            // even if it's an input element.
            props.inert = true;
            props.tabIndex = -1;

            props.onFocus = e => getLabelElement().focus();
          } else {
            if (tag === "input") {
              props.checked = checked;
            } else {
              props.role = role;
              props.tabIndex = 0;
              props["aria-checked"] = checked ? "true" : undefined;
            }

            props["aria-disabled"] = disabled.toString();
          } // Make sure that label clicks can't affect the checkbox while it's disabled


          props.onClick = disabled ? e => {
            e.preventDefault();
          } : props.onClick;
          return useMergedProps()(p0, props);
        }
      }, [useILInput, role, labelPosition, disabled, checked]);
      var useCheckboxLikeLabelElement = A$1(function useCheckboxLabelElement({
        tag
      }) {
        var {
          useInputLabelLabelProps: useILLabelProps
        } = useILLabel({
          tag
        });

        function useCheckboxLikeLabelElementProps(_ref4) {
          var p0 = _extends({}, _ref4);

          var newProps = useButtonLikeEventHandlers("div", disabled || !handlesInput(tag, labelPosition, "label-element") ? undefined : stableOnInput, undefined)({});

          if (labelPosition == "wrapping") {
            newProps.tabIndex = 0;
            newProps.role = role;
            newProps["aria-disabled"] = disabled.toString();
            newProps["aria-checked"] = checked.toString();
          } // Just make sure that label clicks can't affect the checkbox while it's disabled


          newProps.onClick = disabled ? e => {
            e.preventDefault();
          } : newProps.onClick;
          return useMergedProps()(newProps, useILLabelProps(p0));
        }

        return {
          useCheckboxLikeLabelElementProps
        };
      }, [useILLabel, disabled, checked, role, labelPosition]);
      return {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        getLabelElement,
        getInputElement
      };
    }

    function useAriaCheckbox({
      labelPosition,
      checked,
      onInput,
      disabled
    }) {
      var onInputEnhanced = e => onInput === null || onInput === void 0 ? void 0 : onInput(enhanceEvent(e, {
        checked: !checked
      }));

      var {
        getInputElement,
        getLabelElement,
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement
      } = useCheckboxLike({
        checked: !!checked,
        labelPosition,
        role: "checkbox",
        disabled,
        onInput: onInputEnhanced
      });
      var useCheckboxInputElement = A$1(function useCheckboxInputElement({
        tag
      }) {
        var {
          inputElement,
          useCheckboxLikeInputElementProps
        } = useCheckboxLikeInputElement({
          tag
        });
        var isMixed = checked == "mixed";
        y(() => {
          if (inputElement && tag === "input") {
            inputElement.indeterminate = isMixed;
          }
        }, [inputElement, isMixed, tag]);
        return {
          useCheckboxInputElementProps
        };

        function useCheckboxInputElementProps(_ref) {
          var _props$checked;

          var p0 = _extends({}, _ref);

          var props = useCheckboxLikeInputElementProps(p0);
          (_props$checked = props.checked) !== null && _props$checked !== void 0 ? _props$checked : props.checked = !!checked;
          if (tag == "input") props.type = "checkbox";
          return props;
        }
      }, [checked, labelPosition, disabled]);
      var useCheckboxLabelElement = A$1(function useCheckboxLabelElement({
        tag
      }) {
        var {
          useCheckboxLikeLabelElementProps
        } = useCheckboxLikeLabelElement({
          tag
        });

        function useCheckboxLabelElementProps(_ref2) {
          var props = _extends({}, _ref2);

          return useCheckboxLikeLabelElementProps(props);
        }
        return {
          useCheckboxLabelElementProps
        };
      }, [useCheckboxLikeLabelElement, disabled, labelPosition]);
      return {
        useCheckboxInputElement,
        useCheckboxLabelElement
      };
    }

    var _excluded$n = ["aria-modal", "role"];
    /**
     * Adds event handlers for a modal-like soft-dismiss interaction.
     *
     * That is, any clicks or taps outside of the given component,
     * or any time the Escape key is pressed within the component,
     * (with various browser oddities regarding clicks on blank or inert areas handled)
     * the component will request to close itself.
     *
     * Of course, if you don't do anything in the `onClose` function,
     * it won't be a soft dismiss anymore.
     *
     * @param param0
     * @returns
     */

    function useSoftDismiss({
      onClose
    }) {
      var {
        element,
        useRefElementProps
      } = useRefElement();

      function onBackdropClick(e) {
        // Basically, "was this event fired on the root-most element, or at least an element not contained by the modal?"
        // Either could be how the browser handles these sorts of "interacting with nothing" events.
        if (e.target == document.documentElement || !(element && e.target instanceof Element && element instanceof Element && element.contains(e.target))) {
          onClose("backdrop");
        }
      } // Since everything else is inert, we listen for captured clicks on the window
      // (we don't use onClick since that doesn't fire when clicked on empty/inert areas)
      // Note: We need a *separate* touch event on mobile Safari, because
      // it doesn't let click events bubble or be captured from traditionally non-interactive elements,
      // but touch events work as expected.


      useGlobalHandler(window, "mousedown", !open ? null : onBackdropClick, {
        capture: true
      });
      useGlobalHandler(window, "touchstart", !open ? null : onBackdropClick, {
        capture: true
      });

      var onKeyDown = e => {
        if (e.key === "Escape") {
          onClose("escape");
        }
      };

      return {
        useSoftDismissProps: props => useMergedProps()(useRefElementProps({
          onKeyDown
        }), props)
      };
    }
    /**
     * A generic modal hook, used by modal dialogs, but can also
     * be used by anything that's modal with a backdrop.
     * @param param0
     * @returns
     */

    function useAriaModal({
      open,
      onClose
    }) {
      var stableOnClose = useStableCallback(onClose);
      var [modalDescribedByBody, setModalDescribedByBody] = useState(false);
      useHideScroll(open);
      var {
        id: modalId,
        useRandomIdProps: useModalIdProps,
        useReferencedIdProps: useModalReferencingIdProps
      } = useRandomId({
        prefix: "aria-modal-"
      });
      var {
        id: bodyId,
        useRandomIdProps: useBodyIdProps,
        useReferencedIdProps: useBodyReferencingIdProps
      } = useRandomId({
        prefix: "aria-modal-body-"
      });
      var {
        id: titleId,
        useRandomIdProps: useTitleIdProps,
        useReferencedIdProps: useTitleReferencingIdProps
      } = useRandomId({
        prefix: "aria-modal-title-"
      });
      var {
        useSoftDismissProps
      } = useSoftDismiss({
        onClose: stableOnClose
      });
      var useModalBackdrop = A$1(function useModalBackdrop() {
        function useModalBackdropProps(props) {
          return useMergedProps()({
            onPointerUp: () => stableOnClose("backdrop")
          }, props);
        }

        return {
          useModalBackdropProps
        };
      }, []);

      var useModalProps = function (_ref) {
        var p0 = _objectWithoutProperties(_ref, _excluded$n);

        var {
          useFocusTrapProps
        } = useFocusTrap({
          trapActive: open
        });
        var p1 = useTitleReferencingIdProps("aria-labelledby")(p0);
        var p2 = useModalIdProps(p1);
        var pFinal = useBodyReferencingIdProps("aria-describedby")(p2);
        return useFocusTrapProps(useMergedProps()(useSoftDismissProps({
          role: "dialog"
        }), modalDescribedByBody ? pFinal : p2));
      };

      var useModalTitle = A$1(function useModalTitle() {
        var useModalTitleProps = function (props) {
          return useTitleIdProps(props);
        };

        return {
          useModalTitleProps
        };
      }, []);
      var useModalBody = A$1(function useModalBody({
        descriptive
      }) {
        setModalDescribedByBody(descriptive);

        var useModalBodyProps = function (props) {
          return useBodyIdProps(props);
        };

        return {
          useModalBodyProps
        };
      }, []);
      return {
        useModalProps,
        useModalTitle,
        useModalBody,
        useModalBackdrop
      };
    }
    /**
     * Allows for hiding the scroll bar of the root HTML element
     * without shifting the layout of the page more than adding a fow pixels
     * of padding to the root element if necessary.
     * @param hideScroll
     */

    function useHideScroll(hideScroll) {
      var [scrollbarWidth, setScrollbarWidth, getScrollbarWidth] = useState(null);
      y(() => {
        if (hideScroll) {
          var widthWithScrollBar = document.documentElement.scrollWidth;
          document.documentElement.classList.add("document-scroll-hidden");
          document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") + 1).toString();
          var widthWithoutScrollBar = document.documentElement.scrollWidth;

          var _scrollbarWidth = widthWithoutScrollBar - widthWithScrollBar; // Failsafe -- if this measuring trick does something unexpected, just ignore it


          if (_scrollbarWidth > 80) _scrollbarWidth = 0;
          document.documentElement.style.setProperty("--scrollbar-width", "".concat(_scrollbarWidth, "px"));
          setScrollbarWidth(_scrollbarWidth);
          return () => {
            document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") - 1).toString();

            if (document.documentElement.dataset["scrollHiders"] == "0") {
              document.documentElement.removeAttribute("data-scroll-hiders");
              document.documentElement.classList.remove("document-scroll-hidden");
            }
          };
        }
      }, [hideScroll]);
      return {
        scrollbarWidth,
        getScrollbarWidth
      };
    }

    function useAriaDialog({
      open,
      onClose
    }) {
      // TODO: Differences between dialog and modal go here, presumably.
      // Non-modal dialogs need to be able to be repositioned, etc.
      var {
        useModalBackdrop,
        useModalBody,
        useModalProps,
        useModalTitle
      } = useAriaModal({
        open,
        onClose
      });
      var useDialogBackdrop = A$1(() => {
        var {
          useModalBackdropProps
        } = useModalBackdrop();
        return {
          useDialogBackdropProps: useModalBackdropProps
        };
      }, [useModalBackdrop]);
      var useDialogBody = A$1(({
        descriptive
      }) => {
        var {
          useModalBodyProps
        } = useModalBody({
          descriptive
        });
        return {
          useDialogBodyProps: useModalBodyProps
        };
      }, [useModalBackdrop]);
      var useDialogProps = useModalProps;
      var useDialogTitle = A$1(() => {
        var {
          useModalTitleProps
        } = useModalTitle();
        return {
          useDialogTitleProps: useModalTitleProps
        };
      }, [useModalTitle]);
      return {
        useDialogProps,
        useDialogTitle,
        useDialogBody,
        useDialogBackdrop
      };
    }

    function useDrawer({
      open,
      onClose
    }) {
      // TODO: Drawers are not always modal.
      var {
        useModalBackdrop,
        useModalBody,
        useModalProps,
        useModalTitle
      } = useAriaModal({
        open,
        onClose
      });
      var useDrawerBackdrop = A$1(() => {
        var {
          useModalBackdropProps
        } = useModalBackdrop();
        return {
          useDrawerBackdropProps: useModalBackdropProps
        };
      }, [useModalBackdrop]);
      var useDrawerBody = A$1(({
        descriptive
      }) => {
        var {
          useModalBodyProps
        } = useModalBody({
          descriptive
        });
        return {
          useDrawerBodyProps: useModalBodyProps
        };
      }, [useModalBackdrop]);
      var useDrawerProps = useModalProps;
      var useDrawerTitle = A$1(() => {
        var {
          useModalTitleProps
        } = useModalTitle();
        return {
          useDrawerTitleProps: useModalTitleProps
        };
      }, [useModalTitle]);
      return {
        useDrawerProps,
        useDrawerTitle,
        useDrawerBody,
        useDrawerBackdrop
      };
    }

    var _excluded$m = ["selectedIndex", "onSelect", "selectionMode"];
    function useAriaListboxSingle(_ref) {
      var {
        selectedIndex,
        onSelect,
        selectionMode
      } = _ref,
          args = _objectWithoutProperties(_ref, _excluded$m);

      var {
        lastFocusedInner,
        useHasFocusProps
      } = useHasFocus();
      var {
        useGenericLabelInput,
        useGenericLabelLabel,
        useReferencedInputIdProps,
        useReferencedLabelIdProps,
        inputElement
      } = useGenericLabel({
        labelPrefix: "aria-listbox-label-",
        inputPrefix: "aria-listbox-"
      });
      var {
        useListNavigationChild,
        navigateToIndex,
        managedChildren,
        setTabbableIndex,
        tabbableIndex,
        focusCurrent,
        currentTypeahead,
        invalidTypeahead
      } = useListNavigation(_objectSpread2(_objectSpread2({}, args), {}, {
        focusOnChange: lastFocusedInner
      }));
      var {
        useGenericLabelInputProps
      } = useGenericLabelInput();
      var stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
      useChildFlag(selectedIndex, managedChildren.length, (i, selected) => {
        var _managedChildren$i;

        return (_managedChildren$i = managedChildren[i]) === null || _managedChildren$i === void 0 ? void 0 : _managedChildren$i.setSelected(selected);
      });
      useLayoutEffect(([]) => {
        navigateToIndex(selectedIndex);
      }, [selectedIndex, managedChildren.length]);
      var childCount = managedChildren.length;
      var {
        lastActiveElement
      } = useActiveElement();
      var anyRadiosFocused = !!(inputElement !== null && inputElement !== void 0 && inputElement.contains(lastActiveElement));
      y(() => {
        if (!anyRadiosFocused) setTabbableIndex(selectedIndex);
      }, [anyRadiosFocused, selectedIndex, setTabbableIndex]);
      var useListboxSingleItem = A$1(info => {
        var [selected, setSelected, getSelected] = useState(false);
        var {
          tabbable,
          useListNavigationSiblingProps,
          useListNavigationChildProps
        } = useListNavigationChild(_objectSpread2({
          setSelected
        }, info));
        var {
          element,
          useRefElementProps
        } = useRefElement();
        var index = info.index;
        y(() => {
          if (element && tabbable && selectionMode == "focus") {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
          }
        }, [element, tabbable, selectionMode, index]);
        return {
          useListboxSingleItemProps,
          tabbable,
          selected,
          getSelected
        };

        function useListboxSingleItemProps(props) {
          var newProps = useButtonLikeEventHandlers(info.tag, e => {
            navigateToIndex(info.index);
            if (element) stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
            e.preventDefault();
          }, undefined)({});
          props.role = "option";
          props["aria-setsize"] = childCount.toString();
          props["aria-posinset"] = (info.index + 1).toString();
          props["aria-selected"] = selected.toString();
          return useListNavigationChildProps(useMergedProps()(newProps, useRefElementProps(props)));
        }
      }, [useListNavigationChild, selectionMode, childCount]);
      var useListboxSingleLabel = A$1(function useListboxSingleLabel() {
        function useListboxSingleLabelProps(props) {
          var {
            useGenericLabelLabelProps
          } = useGenericLabelLabel();
          useGenericLabelLabelProps(props);
        }

        return {
          useListboxSingleLabelProps
        };
      }, [useGenericLabelLabel]);
      return {
        useListboxSingleItem,
        useListboxSingleProps,
        useListboxSingleLabel,
        tabbableIndex,
        focus: focusCurrent,
        currentTypeahead,
        invalidTypeahead
      };

      function useListboxSingleProps(props) {
        props.role = "listbox";
        return useHasFocusProps(useGenericLabelInputProps(props));
      }
    }

    var _excluded$l = ["collator", "keyNavigation", "noTypeahead", "noWrap", "typeaheadTimeout"];
    function useAriaMenu(_ref) {
      var {
        collator,
        keyNavigation,
        noTypeahead,
        noWrap,
        typeaheadTimeout
      } = _ref,
          args = _objectWithoutProperties(_ref, _excluded$l);

      var [focusTrapActive, setFocusTrapActive] = l(null);
      var onClose = args.onClose;
      var onOpen = args.onOpen;
      var menubar = args.menubar;
      var open = menubar ? true : args.open;
      var stableOnClose = useStableCallback(onClose !== null && onClose !== void 0 ? onClose : () => {}); // TODO: It's awkward that the button focus props are out here where we don't have its type,
      // but focus management is super sensitive, and even waiting for a useLayoutEffect to sync state here
      // would be too late, so it would look like there's a moment between menu focus lost and button focus gained
      // where nothing is focused. 

      var {
        focusedInner: menuHasFocus,
        useHasFocusProps: useMenuHasFocusProps
      } = useHasFocus();
      var {
        focusedInner: buttonHasFocus,
        useHasFocusProps: useButtonHasFocusProps
      } = useHasFocus();
      var {
        activeElement,
        lastActiveElement,
        windowFocused
      } = useActiveElement();
      var {
        managedChildren,
        useListNavigationChild,
        tabbableIndex,
        focusCurrent: focusMenu
      } = useListNavigation({
        collator,
        keyNavigation,
        noTypeahead,
        noWrap,
        typeaheadTimeout,
        focusOnChange: menuHasFocus || buttonHasFocus
      });
      var {
        useRandomIdProps: useMenuIdProps,
        useReferencedIdProps: useMenuIdReferencingProps
      } = useRandomId({
        prefix: "aria-menu-"
      });
      var [openerElement, setOpenerElement] = l(null);
      var {
        useSoftDismissProps
      } = useSoftDismiss({
        onClose: stableOnClose
      });
      y(() => {
        setFocusTrapActive(open);
      }, [open]);
      var focusMenuStable = useStableCallback(focusMenu !== null && focusMenu !== void 0 ? focusMenu : () => {});
      y(() => {
        if (focusTrapActive) {
          focusMenuStable === null || focusMenuStable === void 0 ? void 0 : focusMenuStable();
        } else if (focusTrapActive === false) {
          openerElement === null || openerElement === void 0 ? void 0 : openerElement.focus();
        } else ;
      }, [focusTrapActive]); // Focus management is really finicky, and there's always going to be 
      // an edge case where nothing's focused for two consecutive frames 
      // on iOS or whatever, which would immediately close the menu 
      // any time it's been opened. So any time it *looks* like we should close,
      // try waiting 100ms. If it's still true then, then yeah, we should close.

      var shouldClose = focusTrapActive && windowFocused && !menuHasFocus && !buttonHasFocus;
      useTimeout({
        timeout: 100,
        callback: () => {
          if (shouldClose) {
            onClose === null || onClose === void 0 ? void 0 : onClose();
          }
        },
        triggerIndex: "".concat(shouldClose)
      }); // A menu sentinal is a hidden but focusable element that comes at the start or end of the element
      // that, when activated or focused over, closes the menu.
      // (if focused within 100ms of the open prop changing, instead of
      // closing the menu, focusing the sentinel immediately asks the menu to focus itself).
      // This exists because while mouse users can click out of a menu
      // and keyboard users can escape to close the menu,
      // screen readers and other input methods that don't use those two become stuck.

      var useMenuSentinel = A$1(() => {
        var [firstSentinelIsActive, setFirstSentinelIsActive] = l(false);
        useTimeout({
          callback: () => {
            setFirstSentinelIsActive(open);
          },
          timeout: 100,
          triggerIndex: "".concat(firstSentinelIsActive)
        });
        var onFocus = firstSentinelIsActive ? () => stableOnClose() : () => focusMenu === null || focusMenu === void 0 ? void 0 : focusMenu();

        var onClick = () => stableOnClose();

        return {
          useMenuSentinelProps: function (p) {
            return useMergedProps()({
              onFocus,
              onClick
            }, p);
          }
        };
      }, [focusMenu, open]);
      var useMenuButton = A$1(({
        tag
      }) => {
        var {
          element,
          getElement,
          useRefElementProps
        } = useRefElement();
        useLayoutEffect(() => {
          setOpenerElement(element);
        }, [element]);
        return {
          useMenuButtonProps: function (p) {
            var props = useRefElementProps(useMergedProps()({
              onClick: () => {
                return open ? onClose === null || onClose === void 0 ? void 0 : onClose() : onOpen === null || onOpen === void 0 ? void 0 : onOpen();
              }
            }, useMenuIdReferencingProps("aria-controls")(useButtonHasFocusProps(p))));
            props["aria-haspopup"] = "menu";
            props["aria-expanded"] = open ? "true" : undefined;
            return props;
          }
        };
      }, [open, onClose, onOpen, useMenuIdReferencingProps]);
      var useMenuSubmenuItem = A$1(args => {
        var {
          useMenuProps,
          useMenuButton
        } = useAriaMenu(args);
        var {
          useMenuButtonProps
        } = useMenuButton({
          tag: "li"
        });
        var {
          element,
          getElement,
          useRefElementProps
        } = useRefElement();
        useLayoutEffect(() => {
          setOpenerElement(element);
        }, [element]);
        return {
          element,
          getElement,
          useMenuProps,
          useMenuSubmenuItemProps: function (_ref2) {
            var props = _extends({}, _ref2);

            props.role = "menuitem";
            return useRefElementProps(useMenuButtonProps(useMenuIdReferencingProps("aria-controls")(props)));
          }
        };
      }, []);
      var useMenuItem = A$1(args => {
        var {
          useListNavigationChildProps
        } = useListNavigationChild(args); // const { getSyncHandler, ...asyncInfo } = useAsyncHandler<E>()({ capture: _ => void (0) });
        // const onClick = getSyncHandler(asyncInfo.pending ? null : (args.onClick ?? null));

        var onClick = args.onClick;

        function useMenuItemProps(_ref3) {
          var props = _extends({}, _ref3);

          props.role = "menuitem";
          return useMergedProps()({
            onClick
          }, useListNavigationChildProps(props));
        }

        return {
          useMenuItemProps
        };
      }, []);
      var useMenuItemCheckbox = A$1(args => {
        //const { getSyncHandler, ...asyncInfo } = useAsyncHandler<E>()({ capture: _ => !args.checked });
        //const onClick = getSyncHandler(asyncInfo.pending ? null : args.onChange);
        var onClick = e => args.onChange(enhanceEvent(e, {
          checked: !args.checked
        }));

        function useMenuItemProps(_ref4) {
          var props = _extends({}, _ref4);

          props.role = "menuitemcheckbox";
          return useMergedProps()({
            onClick
          }, props);
        }

        return {
          useMenuItemProps
        };
      }, []);

      function useMenuProps(_ref5) {
        var props = _extends({}, _ref5);

        props.role = "menu";

        function onKeyDown(e) {
          if (e.key == "Escape" && onClose) {
            onClose();
          }
        }

        return useMenuIdProps(useMenuHasFocusProps(useMergedProps()({
          onKeyDown
        }, useSoftDismissProps(props))));
      }

      return {
        useMenuProps,
        useMenuButton,
        useMenuItem,
        useMenuSentinel,
        useMenuItemCheckbox,
        useMenuSubmenuItem,
        focusMenu
      };
    }

    var _excluded$k = ["selectionMode", "selectedIndex", "onSelect", "orientation"];
    function useAriaTabs(_ref) {
      var {
        selectionMode,
        selectedIndex,
        onSelect,
        orientation: logicalOrientation
      } = _ref,
          args = _objectWithoutProperties(_ref, _excluded$k);

      var {
        useHasFocusProps: useTabListHasFocusProps,
        focusedInner: tabListFocused
      } = useHasFocus();
      var {
        element: listElement,
        useRefElementProps
      } = useRefElement();
      var {
        getLogicalDirection,
        convertToPhysicalOrientation
      } = useLogicalDirection(listElement);
      var physicalOrientation = convertToPhysicalOrientation(logicalOrientation);
      useRandomId({
        prefix: "aria-tab-list-"
      });
      var {
        useRandomIdProps: useTabLabelIdProps,
        useReferencedIdProps: useReferencedTabLabelId
      } = useRandomId({
        prefix: "aria-tab-label-"
      });
      var {
        managedChildren: managedTabs,
        navigateToIndex,
        useListNavigationChild,
        tabbableIndex,
        invalidTypeahead,
        currentTypeahead,
        focusCurrent
      } = useListNavigation(_objectSpread2(_objectSpread2({}, args), {}, {
        focusOnChange: tabListFocused,
        keyNavigation: logicalOrientation
      }));
      var {
        managedChildren: managedPanels,
        useManagedChild: useManagedTabPanel
      } = useChildManager();
      useStableCallback(onSelect);
      var childCount = managedTabs.length;
      useLayoutEffect(() => {
        for (var child of managedTabs) {
          child.setSelectionMode(selectionMode);
        }
      }, [selectionMode]);
      useChildFlag(selectedIndex, managedTabs.length, (i, selected) => {
        var _managedTabs$i;

        return (_managedTabs$i = managedTabs[i]) === null || _managedTabs$i === void 0 ? void 0 : _managedTabs$i.setSelected(selected);
      });
      useChildFlag(selectedIndex, managedPanels.length, (i, visible) => {
        var _managedPanels$i;

        return (_managedPanels$i = managedPanels[i]) === null || _managedPanels$i === void 0 ? void 0 : _managedPanels$i.setVisible(visible);
      });
      useLayoutEffect(([prevChildCount, prevSelectedIndex]) => {
        if (selectedIndex != null && selectionMode == "activate") {
          var _managedPanels$select;

          (_managedPanels$select = managedPanels[selectedIndex]) === null || _managedPanels$select === void 0 ? void 0 : _managedPanels$select.focus();
        }
      }, [childCount, selectedIndex, selectionMode]);
      var getTabListIsFocused = useStableGetter(tabListFocused);
      var useTab = A$1(function useTab(info) {
        //const [selectedTabId, setSelectedTabId, getSelectedTabId] = useState<string | undefined>(undefined);
        var [selectionModeL, setSelectionModeL] = useState(selectionMode);
        var {
          element,
          useRefElementProps
        } = useRefElement();
        var [tabPanelId, setTabPanelId] = useState(undefined);
        var {
          useRandomIdProps: useTabIdProps,
          id: tabId,
          getId: getTabId
        } = useRandomId({
          prefix: "aria-tab-"
        });
        var [selected, setSelected, getSelected] = useState(null);
        var {
          tabbable,
          useListNavigationChildProps,
          useListNavigationSiblingProps
        } = useListNavigationChild(_objectSpread2(_objectSpread2({}, info), {}, {
          setSelected,
          tabId,
          setTabPanelId,
          setSelectionMode: setSelectionModeL
        }));
        var getIndex = useStableGetter(info.index); // const { getSyncHandler, ...asyncInfo } = useAsyncHandler<Element>()({ capture: (e: unknown) => info.index });
        // const onSelect = getSyncHandler(asyncInfo.pending? null : (stableAsyncOnSelect ?? null));

        y(() => {
          if (tabbable && selectionModeL == "focus") {
            onSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: getIndex()
              }
            });
          }
        }, [tabbable, selectionModeL, element]);
        y(() => {
          var _managedPanels$info$i;

          (_managedPanels$info$i = managedPanels[info.index]) === null || _managedPanels$info$i === void 0 ? void 0 : _managedPanels$info$i.setTabId(tabId);
        }, [tabId, info.index]);
        /*useEffect(() => {
            if (selected)
                setSelectedTabId(tabId);
        }, [selected, tabId])*/

        function useTabProps(_ref2) {
          var props = _extends({}, _ref2);

          var newProps = useButtonLikeEventHandlers(info.tag, e => {
            navigateToIndex(info.index);
            onSelect === null || onSelect === void 0 ? void 0 : onSelect(enhanceEvent(e, {
              selectedIndex: getIndex()
            }));
            e.preventDefault();
          }, undefined)(props);
          newProps.role = "tab";
          newProps["aria-selected"] = (selected !== null && selected !== void 0 ? selected : false).toString();
          newProps["aria-controls"] = tabPanelId;
          return useMergedProps()({}, useTabIdProps(useListNavigationChildProps(useRefElementProps(newProps))));
        }

        return {
          useTabProps,
          selected
        };
      }, []);
      var useTabPanel = A$1(function usePanel(info) {
        //const [selectedTabPanelId, setSelectedTabPanelId, getSelectedTabPanelId] = useState<string | undefined>(undefined);
        var [shouldFocus, setShouldFocus] = useState(false);
        var [tabId, setTabId] = useState(undefined);
        var [selected, setSelected, getSelected] = useState(null);
        var {
          useRandomIdProps: usePanelIdProps,
          useReferencedIdProps: useReferencedPanelId,
          id: tabPanelId
        } = useRandomId({
          prefix: "aria-tab-panel-"
        });
        var {
          element,
          useManagedChildProps
        } = useManagedTabPanel(_objectSpread2(_objectSpread2({}, info), {}, {
          tabPanelId,
          setTabId,
          focus,
          setVisible: setSelected
        }));

        function focus() {
          if (getTabListIsFocused()) {
            setShouldFocus(true);
          }
        }

        y(() => {
          if (shouldFocus) {
            element === null || element === void 0 ? void 0 : element.focus();
            setShouldFocus(false);
          }
        }, [element, shouldFocus]);
        y(() => {
          var _managedTabs$info$ind;

          (_managedTabs$info$ind = managedTabs[info.index]) === null || _managedTabs$info$ind === void 0 ? void 0 : _managedTabs$info$ind.setTabPanelId(tabPanelId);
        }, [tabPanelId, info.index]);

        function useTabPanelProps(_ref3) {
          var _managedTabs$info$ind2, _props$tabIndex;

          var props = _extends({}, _ref3);

          props["aria-labelledby"] = (_managedTabs$info$ind2 = managedTabs[info.index]) === null || _managedTabs$info$ind2 === void 0 ? void 0 : _managedTabs$info$ind2.tabId;
          props.role = "tabpanel";
          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1; // Make sure the tab panel is tabbable.

          return useMergedProps()({}, usePanelIdProps(useManagedChildProps(props)));
        }

        return {
          useTabPanelProps,
          selected
        };
      }, []);
      var useTabsList = A$1(function useTabList() {
        function useTabListProps(_ref4) {
          var props = _extends({}, _ref4);

          props.role = "tablist";
          props["aria-orientation"] = physicalOrientation;
          return useReferencedTabLabelId("aria-labelledby")(useTabListHasFocusProps(useRefElementProps(props)));
        }

        return {
          useTabListProps
        };
      }, [physicalOrientation]);
      var useTabsLabel = A$1(function useTabsLabel() {
        function useTabsLabelProps(_ref5) {
          var props = _extends({}, _ref5);

          return useTabLabelIdProps(props);
        }

        return {
          useTabsLabelProps
        };
      }, []);
      return {
        useTab,
        useTabPanel,
        useTabsList,
        useTabsLabel,
        tabbableIndex,
        focusTabList: focusCurrent,
        currentTypeahead,
        invalidTypeahead
      };
    }

    var _excluded$j = ["value", "index", "text", "disabled", "labelPosition"];
    function useAriaRadioGroup({
      name,
      selectedValue,
      onInput
    }) {
      var {
        element,
        useRefElementProps
      } = useRefElement();
      var [selectedIndex, setSelectedIndex, getSelectedIndex] = useState(null);
      var byName = s(new Map());
      var stableOnInput = useStableCallback(onInput);
      var {
        useHasFocusProps,
        lastFocusedInner
      } = useHasFocus();
      var {
        managedChildren,
        useListNavigationChild,
        setTabbableIndex,
        tabbableIndex,
        focusCurrent,
        currentTypeahead,
        invalidTypeahead
      } = useListNavigation({
        focusOnChange: lastFocusedInner
      });
      var useRadioGroupProps = A$1(_ref => {
        var props = _extends({}, _ref);

        props.role = "radiogroup";
        return useRefElementProps(useHasFocusProps(props));
      }, [useHasFocusProps, useRefElementProps]);
      useChildFlag(selectedIndex, managedChildren.length, (i, checked) => {
        var _managedChildren$i;

        return (_managedChildren$i = managedChildren[i]) === null || _managedChildren$i === void 0 ? void 0 : _managedChildren$i.setChecked(checked);
      });
      var {
        lastActiveElement
      } = useActiveElement();
      var anyRadiosFocused = !!(element !== null && element !== void 0 && element.contains(lastActiveElement));
      y(() => {
        if (!anyRadiosFocused && selectedIndex != null) setTabbableIndex(selectedIndex);
      }, [anyRadiosFocused, selectedIndex, setTabbableIndex]);
      y(() => {
        getSelectedIndex();
        var newIndex = byName.current.get(selectedValue);
        setSelectedIndex(newIndex);
      }, [selectedValue]);
      var useRadio = A$1(function useAriaRadio(_ref2) {
        var {
          value,
          index,
          text,
          disabled,
          labelPosition
        } = _ref2,
            rest = _objectWithoutProperties(_ref2, _excluded$j);

        var [checked, setChecked] = useState(false);
        var onInput = A$1(e => {
          stableOnInput(enhanceEvent(e, {
            selectedValue: value
          }));
        }, [stableOnInput, value, index]);
        var {
          getInputElement,
          getLabelElement,
          useCheckboxLikeInputElement,
          useCheckboxLikeLabelElement
        } = useCheckboxLike({
          checked,
          disabled,
          labelPosition,
          onInput,
          role: "radio"
        }); //const {} = useCheckboxLikeInputElement({  })

        var byName2 = byName.current;
        h(() => {
          console.assert(!byName2.has(value));
          byName2.set(value, index);
          return () => {
            byName2.delete(value);
          };
        }, [value, index]);
        var {
          tabbable,
          useListNavigationChildProps,
          useListNavigationSiblingProps
        } = useListNavigationChild(_objectSpread2({
          index,
          setChecked,
          text
        }, rest));

        var useRadioInput = ({
          tag
        }) => {
          var useRadioInputProps = props => {
            if (tag == "input") {
              props.name = name;
              props.checked = checked;
            } else {
              props["aria-checked"] = checked.toString();
            }

            var {
              useCheckboxLikeInputElementProps
            } = useCheckboxLikeInputElement({
              tag
            });
            return useMergedProps()(useListNavigationChildProps(useCheckboxLikeInputElementProps({})), props);
          };

          return {
            useRadioInputProps
          };
        };

        var useRadioLabel = A$1(({
          tag
        }) => {
          var useRadioLabelProps = props => {
            var {
              useCheckboxLikeLabelElementProps
            } = useCheckboxLikeLabelElement({
              tag
            });
            return useCheckboxLikeLabelElementProps(useMergedProps()({}, props));
          };

          return {
            useRadioLabelProps
          };
        }, [useCheckboxLikeLabelElement]);
        return {
          useRadioInput,
          useRadioLabel
        };
      }, [byName, useListNavigationChild]);
      return {
        useRadio,
        useRadioGroupProps,
        managedChildren,
        getIndex: A$1(value => {
          return byName.current.get(value);
        }, [byName]),
        tabbableIndex,
        focusRadio: focusCurrent,
        currentTypeahead,
        invalidTypeahead
      };
    }

    var _excluded$i = ["role", "aria-live", "aria-relevant"];
    function useToasts({}) {
      // "Pointer" to whatever index toast is currently being shown.
      // E.g. it's 0 when the first toast is shown, then when dismissed, it becomes 1.
      // When the second toast is shown, it stays at 1 until dismissed, when it then becomes 2, etc.
      // Because toasts can potentially be dismissed out of order, this represents the "oldest" toast that still hasn't been dismissed,
      // even if "younger" ones have.
      var [activeToastIndex, setActiveToastIndex, getActiveToastIndex] = useState(-1);
      var [politeness, setPoliteness] = useState("polite");
      var {
        element,
        getElement,
        useRefElementProps
      } = useRefElement();
      var {
        indicesByElement,
        managedChildren,
        mountedChildren: toastQueue,
        useManagedChild,
        getMountIndex
      } = useChildManager(); // Any time a new toast mounts, update our bottommostToastIndex to point to it if necessary
      // ("necessary" just meaning if it's the first toast ever or all prior toasts have been dismissed)

      var onAnyToastMounted = A$1(index => {
        var bottom = getActiveToastIndex();

        while (bottom < toastQueue.length && (bottom < 0 || (_toastQueue$bottom = toastQueue[bottom]) !== null && _toastQueue$bottom !== void 0 && _toastQueue$bottom.dismissed)) {
          var _toastQueue$bottom;

          ++bottom;
        }

        setActiveToastIndex(bottom);
      }, [setActiveToastIndex]); // Any time a toast is dismissed, update our bottommostToastIndex to point to the next toast in the queue, if one exists.

      var onAnyToastDismissed = A$1(index => {
        var _getElement, _toastQueue$bottom3;

        var bottom = getActiveToastIndex();

        while (bottom < toastQueue.length && (bottom < 0 || bottom === index || (_toastQueue$bottom2 = toastQueue[bottom]) !== null && _toastQueue$bottom2 !== void 0 && _toastQueue$bottom2.dismissed)) {
          var _toastQueue$bottom2;

          ++bottom;
        }

        setActiveToastIndex(bottom);
        if ((_getElement = getElement()) !== null && _getElement !== void 0 && _getElement.contains(document.activeElement)) (_toastQueue$bottom3 = toastQueue[bottom]) === null || _toastQueue$bottom3 === void 0 ? void 0 : _toastQueue$bottom3.focus();
      }, [setActiveToastIndex]); // Any time the index pointing to the currently-showing toast changes,
      // update the relevant children and let them know that they're now either active or dismissed.

      useChildFlag(activeToastIndex, toastQueue.length, (i, set) => {
        var _toastQueue$i;

        if (set) console.assert(i <= getActiveToastIndex());
        (_toastQueue$i = toastQueue[i]) === null || _toastQueue$i === void 0 ? void 0 : _toastQueue$i.setStatus(set ? "active" : i < getActiveToastIndex() ? "dismissed" : "pending");
      });
      var useToast = A$1(({
        politeness,
        timeout
      }) => {
        var [status, setStatus, getStatus] = useState("pending");
        var dismissed = status === "dismissed";
        var dismiss = A$1(() => {
          setStatus("dismissed");
        }, []);
        var {
          randomId: toastId
        } = useRandomId({
          prefix: "toast-"
        }); //const [toastId, setToastId] = useState(() => generateRandomId("toast-"));

        h(() => {
          setPoliteness(politeness !== null && politeness !== void 0 ? politeness : "polite");
        }, [politeness]);
        var focus = A$1(() => {
          var element = getElement();

          if (element) {
            var firstFocusable = findFirstFocusable(element);
            firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
          }
        }, []);
        var {
          element,
          useManagedChildProps,
          getElement
        } = useManagedChild({
          dismissed,
          index: toastId,
          setStatus,
          focus
        });
        var isActive = status === "active";
        y(() => {
          onAnyToastMounted(getMountIndex(toastId));
        }, []);
        y(() => {
          if (dismissed) onAnyToastDismissed(getMountIndex(toastId));
        }, [dismissed]);
        useTimeout({
          timeout,
          callback: () => {
            if (isActive) setStatus("dismissed");
          },
          triggerIndex: isActive
        });
        return {
          status,
          getStatus,
          dismiss,
          useToastProps: function (_ref) {
            var props = _extends({}, _ref);

            return useMergedProps()(useManagedChildProps({}), props);
          }
        };
      }, []);

      function useToastContainerProps(_ref2) {
        var _ref3;

        var {
          role,
          "aria-live": ariaLive,
          "aria-relevant": ariaRelevant
        } = _ref2,
            props = _objectWithoutProperties(_ref2, _excluded$i);

        return useMergedProps()(useRefElementProps({
          class: "toasts-container",
          role: "status",
          "aria-live": (_ref3 = politeness !== null && politeness !== void 0 ? politeness : ariaLive) !== null && _ref3 !== void 0 ? _ref3 : "polite",
          "aria-relevant": ariaRelevant !== null && ariaRelevant !== void 0 ? ariaRelevant : "additions"
        }), props);
      }

      return {
        useToast,
        useToastContainerProps
      };
    }

    var _excluded$h = ["data-pseudo-active"];
    function forwardElementRef(component) {
      return x(component);
    }
    function usePseudoActive(_ref) {
      var {
        "data-pseudo-active": active
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$h);

      return useMergedProps()({
        className: clsx((active == true || active == "true") && "active")
      }, props);
    }
    var SpinnerDelayContext = D$1(1000);
    function useSpinnerDelay(pending, timeout) {
      var _ref2;

      var [showSpinner, setShowSpinner] = useState(false);
      y(() => {
        if (!pending) {
          setShowSpinner(false);
        }
      }, [pending]);
      var defaultDelay = F(SpinnerDelayContext);
      useTimeout({
        timeout: (_ref2 = timeout !== null && timeout !== void 0 ? timeout : defaultDelay) !== null && _ref2 !== void 0 ? _ref2 : 1000,
        callback: () => {
          setShowSpinner(pending);
        },
        triggerIndex: pending
      });
      return showSpinner;
    }

    var _excluded$g = ["expandedIndex", "setExpandedIndex", "children"],
        _excluded2$c = ["index", "open", "header", "headerLevel", "children", "Transition"];
    var UseAriaAccordionSectionContext = D$1(null);
    var Accordion = forwardElementRef(function Accordion(_ref, ref) {
      var {
        expandedIndex,
        setExpandedIndex,
        children
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$g);

      var {
        useAriaAccordionSection
      } = useAriaAccordion({
        expandedIndex,
        setExpandedIndex
      });
      return v$1("div", _objectSpread2({}, useMergedProps()({
        ref,
        className: "accordian"
      }, props)), v$1(UseAriaAccordionSectionContext.Provider, {
        value: useAriaAccordionSection
      }, children));
    });
    var AccordionSection = forwardElementRef(function AccordionSection(_ref2, ref) {
      var _Transition, _headerLevel;

      var {
        index,
        open,
        header,
        headerLevel,
        children,
        Transition
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$c);

      var useAriaAccordionSection = F(UseAriaAccordionSectionContext);
      var {
        expanded,
        useAriaAccordionSectionHeader,
        useAriaAccordionSectionBody
      } = useAriaAccordionSection({
        index,
        open
      });
      var {
        useAriaAccordionSectionHeaderProps
      } = useAriaAccordionSectionHeader({
        tag: "button"
      });
      var {
        useAriaAccordionSectionBodyProps
      } = useAriaAccordionSectionBody();
      (_Transition = Transition) !== null && _Transition !== void 0 ? _Transition : Transition = Collapse;
      (_headerLevel = headerLevel) !== null && _headerLevel !== void 0 ? _headerLevel : headerLevel = 2;
      console.log("".concat(index, ": ").concat(expanded === null || expanded === void 0 ? void 0 : expanded.toString()));
      var headerButtonProps = useAriaAccordionSectionHeaderProps({
        type: "button",
        class: clsx("accordion-button", !expanded ? " collapsed" : "")
      });
      var headerProps = {
        class: "accordion-header",
        children: v$1("button", _objectSpread2({}, headerButtonProps), header)
      };
      var headerJsx = headerLevel >= 1 && headerLevel <= 6 ? v$1("h".concat(headerLevel), headerProps) : v$1("div", useMergedProps()(headerProps, {
        role: "heading",
        "aria-level": "".concat(headerLevel)
      }));
      return v$1("div", _objectSpread2({}, {
        ref,
        class: "accordion-item"
      }), headerJsx, v$1(Transition, _objectSpread2({
        open: expanded
      }, useAriaAccordionSectionBodyProps(useMergedProps()(props, {
        class: ""
      }))), v$1("div", null, v$1("div", {
        class: "accordion-body"
      }, children))));
    });

    var _excluded$f = ["aria-valuemax", "aria-valuenow", "aria-valuetext", "role"],
        _excluded3$6 = ["loadingLabel", "spinnerTimeout", "mode", "colorFill", "childrenPosition", "children", "color"];
    // resumably because the number of elements changes. 
    // (and in really weird ways -- changing the animation speed in the console fixes it until you put it back at 100% speed???).
    // Assuming that's the case, it's easier to just take care of the element count on page load.

    var gimmickCount = 8;

    (() => {
      var _getFromLocalStorage;

      var lastSet = (_getFromLocalStorage = getFromLocalStorage()("circular-progress-gimmick-last-set", str => new Date(str))) !== null && _getFromLocalStorage !== void 0 ? _getFromLocalStorage : new Date(1970, 0, 1);
      var daysSinceLastGimmickSet = Math.floor((+new Date() - +lastSet) / 1000 / 60 / 60 / 24);

      if (daysSinceLastGimmickSet > 0) {
        var newCount = 4 + Math.round(Math.random() * 2 + Math.random() * 2);
        gimmickCount = newCount;
        storeToLocalStorage()("circular-progress-gimmick-last-set", new Date(), d => d.toISOString());
        storeToLocalStorage()("circular-progress-gimmick-count", gimmickCount, JSON.stringify);
      } else {
        var _getFromLocalStorage2;

        gimmickCount = (_getFromLocalStorage2 = getFromLocalStorage()("circular-progress-gimmick-count", JSON.parse)) !== null && _getFromLocalStorage2 !== void 0 ? _getFromLocalStorage2 : 8;
      }
    })();

    function useAriaProgressBar({
      tag,
      max,
      value,
      valueText
    }) {
      //const { inputId, labelId, useGenericLabelInput, useGenericLabelLabel, useReferencedInputIdProps, useReferencedLabelIdProps } = useGenericLabel({ inputPrefix: "progressbar-", labelPrefix: "progressbar-reference-" });
      var {
        id: progressBarId,
        getId,
        useRandomIdProps,
        useReferencedIdProps
      } = useRandomId({
        prefix: "progressbar-"
      });

      function useProgressProps(_ref) {
        var p = _objectWithoutProperties(_ref, _excluded$f);

        var extraProps = tag === "progress" ? {
          max,
          value: value !== null && value !== void 0 ? value : undefined,
          "aria-valuenow": value == null ? undefined : "".concat(value)
        } : {
          "aria-valuemax": max == null ? undefined : "".concat(max),
          "aria-valuetext": valueText == null ? undefined : "".concat(valueText),
          "aria-valuenow": value == null ? undefined : "".concat(value),
          role: "progressbar"
        };
        return useRandomIdProps(useMergedProps()(extraProps, p));
      }

      var useReferencedElement = A$1(function useReferencedElement() {
        function useReferencedProps(props) {
          return useReferencedIdProps("aria-controls")(props);
        }

        return {
          useReferencedProps
        };
      }, [useReferencedIdProps]);
      return {
        useProgressProps,
        useReferencedElement
      };
    }
    D$1(undefined);
    D$1(undefined);
    D$1(undefined);
    D$1(undefined);

    new Date().getDate() % 2;

    function Check() {
      return v$1("i", {
        class: "bi bi-check"
      });
    }

    function Cross() {
      return v$1("i", {
        class: "bi bi-x"
      });
    }

    var ProgressCircular = forwardElementRef(function (_ref3, ref) {
      var _childrenPosition;

      var {
        loadingLabel,
        spinnerTimeout,
        mode,
        colorFill,
        childrenPosition,
        children,
        color
      } = _ref3,
          p = _objectWithoutProperties(_ref3, _excluded3$6);

      var {
        useProgressProps,
        useReferencedElement
      } = useAriaProgressBar({
        value: null,
        valueText: undefined,
        max: undefined,
        tag: "div"
      }); //useLayoutEffect(() => { provideParentWithHook?.(useReferencedElement) }, [useReferencedElement, provideParentWithHook])

      var {
        useReferencedProps
      } = useReferencedElement();
      var showSpinner = useSpinnerDelay(mode === "pending", spinnerTimeout); //const [spinnerShowCount, setSpinnerShowCount] = useState(0);
      //useEffect(() => { setSpinnerShowCount(s => ++s) }, [showSpinner]);

      y(() => {
        setShownStatusLongEnough(false);
      }, [mode]);
      var [shownStatusLongEnough, setShownStatusLongEnough] = useState(false);
      useTimeout({
        callback: () => {
          if (mode == "failed" || mode == "succeeded") setShownStatusLongEnough(true);
        },
        timeout: 1000,
        triggerIndex: mode
      });
      var progressProps = useProgressProps({
        "aria-hidden": "".concat(mode != "pending"),
        "aria-valuetext": "Operation pending"
      });
      var progressElement = v$1("div", _objectSpread2({}, useMergedProps()({
        ref,
        className: clsx("circular-progress-container")
      }, useMergedProps()(progressProps, p))), mode === "pending" && !!loadingLabel && v$1("div", {
        role: "alert",
        "aria-live": "assertive",
        class: "visually-hidden"
      }, loadingLabel), v$1(Swappable, null, v$1("div", {
        className: "circular-progress-swappable"
      }, v$1(Fade, {
        open: mode === "pending" && showSpinner
      }, v$1("div", {
        style: {
          "--count": gimmickCount
        },
        className: clsx("circular-progress", color ? "circular-progress-".concat(color) : undefined, colorFill == "foreground" && "inverse-fill", colorFill === "foreground-only" && "no-fill")
      }, Array.from(function* () {
        for (var i = 0; i < gimmickCount; ++i) {
          yield v$1("div", null, v$1("div", null));
        }
      }()))), v$1(Fade, {
        open: !shownStatusLongEnough && mode === "succeeded"
      }, v$1("div", {
        class: "circular-progress-succeeded"
      }, v$1(Check, null))), v$1(Fade, {
        open: !shownStatusLongEnough && mode === "failed"
      }, v$1("div", {
        class: "circular-progress-failed"
      }, v$1(Cross, null))))));
      (_childrenPosition = childrenPosition) !== null && _childrenPosition !== void 0 ? _childrenPosition : childrenPosition = "after";
      return v$1(d$1, null, childrenPosition == "before" && progressElement, children && v$1(children.type, useMergedProps()({
        children: childrenPosition === "child" ? progressElement : undefined,
        ref: children.ref
      }, useReferencedProps(children.props))), childrenPosition == "after" && progressElement);
    });

    var UseButtonGroupChild = D$1(null);
    var DefaultFillStyleContext = D$1("fill");
    var DefaultColorStyleContext = D$1("primary");
    var DefaultSizeContext = D$1("md");
    var DefaultDisabledContext = D$1(false);
    var ProvideDefaultButtonFill = g(function ProvideDefaultButtonFill({
      value,
      children
    }) {
      return v$1(DefaultFillStyleContext.Provider, {
        value: value
      }, children);
    });
    var ProvideDefaultButtonColor = g(function ProvideDefaultButtonColor({
      value,
      children
    }) {
      return v$1(DefaultColorStyleContext.Provider, {
        value: value
      }, children);
    });
    var ProvideDefaultButtonSize = g(function ProvideDefaultButtonSize({
      value,
      children
    }) {
      return v$1(DefaultSizeContext.Provider, {
        value: value
      }, children);
    });
    var ProvideDefaultButtonDisabled = g(function ProvideDefaultButtonDisabled({
      value,
      children
    }) {
      return v$1(DefaultDisabledContext.Provider, {
        value: value
      }, children);
    });
    function useButtonFillVariant(providedValue) {
      var defaultFill = F(DefaultFillStyleContext);
      return providedValue !== null && providedValue !== void 0 ? providedValue : defaultFill;
    }
    function useButtonColorVariant(providedValue) {
      var defaultColor = F(DefaultColorStyleContext);
      return providedValue !== null && providedValue !== void 0 ? providedValue : defaultColor;
    }
    function useButtonSize(providedValue) {
      var defaultSize = F(DefaultSizeContext);
      return providedValue !== null && providedValue !== void 0 ? providedValue : defaultSize;
    }
    function useButtonDisabled(providedValue) {
      var defaultDisabled = F(DefaultDisabledContext);
      return providedValue !== null && providedValue !== void 0 ? providedValue : defaultDisabled;
    }
    function useButtonStyles(p) {
      var {
        colorVariant,
        size,
        fillVariant,
        disabled
      } = p;
      colorVariant = useButtonColorVariant(colorVariant);
      size = useButtonSize(size);
      fillVariant = useButtonFillVariant(fillVariant);
      disabled = useButtonDisabled(disabled);

      var useButtonStylesProps = props => useMergedProps()({
        "aria-disabled": disabled ? "true" : undefined,
        className: clsx(disabled && "disabled", "btn", "btn-".concat(fillVariant == "outline" ? "outline-" : "").concat(colorVariant), "btn-".concat(size), disabled && "disabled")
      }, props);

      return {
        colorVariant,
        size,
        fillVariant,
        disabled,
        useButtonStylesProps
      };
    }

    var _excluded$e = ["colorVariant", "size", "fillVariant", "disabled"],
        _excluded2$b = ["colorVariant", "size", "fillVariant", "disabled", "debounce", "showAsyncSuccess", "onClick"],
        _excluded3$5 = ["colorVariant", "size", "disabled", "pressed", "debounce", "onInput", "showAsyncSuccess"];

    function ButtonR(p, ref) {
      var _p$tag;

      if (((_p$tag = p.tag) === null || _p$tag === void 0 ? void 0 : _p$tag.toLowerCase()) === "a" || !!p.href) return v$1(AnchorButton, _objectSpread2({
        ref: ref
      }, p));else if (p.pressed != null) return v$1(ToggleButton, _objectSpread2({
        ref: ref
      }, p));else return v$1(ButtonButton, _objectSpread2({
        ref: ref
      }, p));
    }

    var AnchorButton = forwardElementRef(function AnchorButton(p, ref) {
      var {
        colorVariant,
        size,
        fillVariant,
        disabled
      } = p,
          props = _objectWithoutProperties(p, _excluded$e);

      var buttonStyleInfo = useButtonStyles({
        colorVariant,
        size,
        fillVariant,
        disabled
      });
      disabled = buttonStyleInfo.disabled;
      colorVariant = buttonStyleInfo.colorVariant;
      size = buttonStyleInfo.size;
      fillVariant = buttonStyleInfo.fillVariant;
      var useButtonStylesProps = buttonStyleInfo.useButtonStylesProps;
      return v$1("a", _objectSpread2({}, useButtonStylesProps(_objectSpread2(_objectSpread2({}, props), {}, {
        ref
      }))));
    });
    var ButtonButton = forwardElementRef(function ButtonButton(p, ref) {
      var {
        colorVariant,
        size,
        fillVariant,
        disabled,
        debounce,
        showAsyncSuccess,
        onClick: onClickAsync
      } = p,
          props = _objectWithoutProperties(p, _excluded2$b);

      var {
        getSyncHandler,
        pending,
        settleCount,
        hasError
      } = useAsyncHandler()({
        debounce,
        capture: A$1(() => {
          return undefined;
        }, [])
      });
      disabled || (disabled = pending);
      var {
        useAriaButtonProps
      } = useAriaButton({
        tag: "button"
      });
      var buttonStyleInfo = useButtonStyles({
        colorVariant,
        size,
        fillVariant,
        disabled
      });
      disabled = buttonStyleInfo.disabled;
      colorVariant = buttonStyleInfo.colorVariant;
      size = buttonStyleInfo.size;
      fillVariant = buttonStyleInfo.fillVariant;
      var useButtonStylesProps = buttonStyleInfo.useButtonStylesProps;
      var onClick = getSyncHandler(pending ? null : onClickAsync);
      return v$1(ProgressCircular, {
        mode: hasError ? "failed" : pending ? "pending" : settleCount && showAsyncSuccess ? "succeeded" : null,
        childrenPosition: "child",
        colorFill: fillVariant == "fill" ? "foreground" : "background"
      }, v$1("button", _objectSpread2({}, useAriaButtonProps(useButtonStylesProps(useMergedProps()({
        className: clsx(pending && "pending active", disabled && "disabled")
      }, _objectSpread2(_objectSpread2({}, props), {}, {
        onClick,
        ref
      })))))));
    });
    var ToggleButton = forwardElementRef(function ToggleButton(p, ref) {
      var {
        colorVariant,
        size,
        disabled,
        pressed,
        debounce,
        onInput: onPressAsync,
        showAsyncSuccess
      } = p,
          props = _objectWithoutProperties(p, _excluded3$5);

      var fillVariant = pressed ? "fill" : "outline";
      var inButtonGroup = !!F(UseButtonGroupChild);
      var getPressed = useStableGetter(pressed);
      var {
        getSyncHandler,
        pending,
        hasError,
        settleCount,
        hasCapture,
        currentCapture
      } = useAsyncHandler()({
        debounce,
        capture: A$1(() => {
          return !getPressed();
        }, [])
      });
      disabled || (disabled = pending);
      if (hasCapture && pending) pressed = currentCapture;
      var {
        useAriaButtonProps
      } = useAriaButton({
        tag: "button",
        pressed
      });
      var buttonStyleInfo = useButtonStyles({
        colorVariant,
        size,
        fillVariant,
        disabled
      });
      disabled = buttonStyleInfo.disabled;
      colorVariant = buttonStyleInfo.colorVariant;
      size = buttonStyleInfo.size;
      var useButtonStylesProps = buttonStyleInfo.useButtonStylesProps;
      var onClick = getSyncHandler(pending ? null : onPressAsync);
      return v$1(ProgressCircular, {
        mode: hasError ? "failed" : pending ? "pending" : settleCount && showAsyncSuccess ? "succeeded" : null,
        childrenPosition: "child",
        colorFill: fillVariant == "fill" ? "foreground" : "background"
      }, v$1("button", _objectSpread2({}, useAriaButtonProps(useButtonStylesProps(_objectSpread2({}, useMergedProps()({
        className: clsx("toggle-button", (pending || inButtonGroup && pressed) && "active"),
        onClick,
        ref
      }, props)))))));
    });
    var Button = forwardElementRef(ButtonR);

    var _excluded$d = ["colorVariant", "fillVariant", "size", "disabled", "selectedIndex", "wrap"],
        _excluded2$a = ["index"];
    var ButtonGroup = forwardElementRef(function ButtonGroup(p, ref) {
      var {
        lastFocusedInner,
        useHasFocusProps
      } = useHasFocus();
      var {
        indicesByElement,
        managedChildren,
        useListNavigationChild,
        navigateToIndex,
        childCount
      } = useListNavigation({
        focusOnChange: lastFocusedInner
      }); // Styling props

      var {
        colorVariant,
        fillVariant,
        size,
        disabled,
        selectedIndex,
        wrap
      } = p,
          p3 = _objectWithoutProperties(p, _excluded$d);

      y(() => {
        if (selectedIndex != null) navigateToIndex(selectedIndex);
      }, [selectedIndex]); // Build new DOM props to merge based off the styling props

      colorVariant = useButtonColorVariant(colorVariant);
      size = useButtonSize(size);
      fillVariant = useButtonFillVariant(fillVariant);
      disabled = useButtonDisabled(disabled);
      var newDomProps = {
        ref,
        role: "group",
        disabled,
        className: clsx("btn-group", wrap && "wrap")
      }; // Remaining props, forwarded onto the DOM

      var domProps = useHasFocusProps(useMergedProps()(newDomProps, p3));
      domProps["data-child-count"] = "".concat(childCount);
      return v$1(UseButtonGroupChild.Provider, {
        value: useListNavigationChild
      }, v$1(ProvideDefaultButtonColor, {
        value: colorVariant
      }, v$1(ProvideDefaultButtonFill, {
        value: fillVariant
      }, v$1(ProvideDefaultButtonSize, {
        value: size
      }, v$1(ProvideDefaultButtonDisabled, {
        value: disabled
      }, v$1("div", _objectSpread2({}, domProps)))))));
    });
    var ButtonGroupChild = forwardElementRef(function ButtonGroupChild1(_ref, ref) {
      var {
        index
      } = _ref,
          buttonProps = _objectWithoutProperties(_ref, _excluded2$a);

      // This is more-or-less forced to be a separate component because of the index prop.
      // It would be really nice to find a way to make that implicit based on DOM location,
      // specifically for small things like button groups...
      var useButtonGroupChild = F(UseButtonGroupChild);
      var {
        tabbable,
        useListNavigationChildProps,
        useListNavigationSiblingProps
      } = useButtonGroupChild({
        index,
        text: null
      }); // TODO: It's kinda fragile here how the sync onClick of listNavigation 
      // and the async onClick of button are mixing.

      var p = useListNavigationChildProps(_objectSpread2({
        ref
      }, buttonProps));
      return v$1(Button, _objectSpread2({}, p));
    });

    var baseId = generateRandomId("render-portal-container-");
    function BodyPortal({
      children
    }) {
      var id = s(null);
      var [portalElement, setPortalElement] = l(null);
      y(() => {
        if (id.current == null) {
          id.current = generateRandomId();
        }

        var container = document.getElementById(baseId);

        if (!container) {
          container = document.createElement("div");
          container.id = baseId;
          container.className = "body-portal-container";
          document.body.appendChild(container);
        }

        var element = document.getElementById(id.current);

        if (!element) {
          element = document.createElement("div");
          element.className = "body-portal";
          element.id = id.current;
          container.appendChild(element);
        }

        setPortalElement(element);
        return () => document.removeChild(element);
      }, []);
      if (portalElement) return W(children, portalElement);else return null;
    }

    var _excluded$c = ["onClose", "open", "descriptive", "title", "footer", "Transition", "children"];
    var Dialog = forwardElementRef(function Dialog(_ref, ref) {
      var {
        onClose,
        open,
        descriptive,
        title,
        footer,
        Transition,
        children
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$c);

      var {
        useDialogBackdrop,
        useDialogBody,
        useDialogProps,
        useDialogTitle
      } = useAriaDialog({
        open,
        onClose
      });
      var {
        useDialogBackdropProps
      } = useDialogBackdrop();
      var {
        useDialogBodyProps
      } = useDialogBody({
        descriptive
      });
      var {
        useDialogTitleProps
      } = useDialogTitle();
      return v$1(BodyPortal, null, v$1("div", {
        class: "modal-portal-container"
      }, v$1(Fade, {
        open: open
      }, v$1("div", _objectSpread2({}, useDialogBackdropProps({
        class: "modal-backdrop  backdrop-filter-transition"
      })))), v$1(Transition, _objectSpread2({}, _objectSpread2({
        ref,
        open
      }, rest)), v$1("div", _objectSpread2({}, useDialogProps({
        class: "modal-dialog modal-dialog-scrollable"
      })), v$1("div", {
        class: "modal-content "
      }, title != null && v$1("div", _objectSpread2({}, useDialogTitleProps({
        class: "modal-header"
      })), v$1("h1", {
        class: "modal-title"
      }, title)), v$1("div", _objectSpread2({}, useDialogBodyProps({
        class: "modal-body"
      })), children), footer != null && v$1("div", {
        class: "modal-footer"
      }, footer))))));
    });

    var _excluded$b = ["onClose", "open", "descriptive", "title", "footer", "Transition", "children"];
    function Drawer(_ref) {
      var {
        onClose,
        open,
        descriptive,
        title,
        footer,
        Transition,
        children
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$b);

      var {
        useDrawerBackdrop,
        useDrawerBody,
        useDrawerProps,
        useDrawerTitle
      } = useDrawer({
        open,
        onClose
      });
      var {
        useDrawerBackdropProps
      } = useDrawerBackdrop();
      var {
        useDrawerBodyProps
      } = useDrawerBody({
        descriptive
      });
      var {
        useDrawerTitleProps
      } = useDrawerTitle();
      return v$1(BodyPortal, null, v$1("div", null, v$1(Fade, {
        open: open
      }, v$1("div", _objectSpread2({}, useDrawerBackdropProps({
        class: "offcanvas-backdrop backdrop-filter-transition"
      })))), v$1(Transition, _objectSpread2({}, _objectSpread2({
        open
      }, rest)), v$1("div", _objectSpread2({}, useDrawerProps({
        class: "offcanvas offcanvas-start",
        tabindex: -1
      })), v$1("div", {
        class: "offcanvas-header"
      }, v$1("h5", _objectSpread2({}, useDrawerTitleProps({
        class: "offcanvas-title"
      })), "Drawer"), v$1(Button, {
        tag: "button",
        class: "btn-close text-reset",
        "aria-label": "Close",
        onClick: () => onClose("escape")
      })), v$1("div", _objectSpread2({}, useDrawerBodyProps({
        class: "offcanvas-body"
      })), children)))));
    }

    var InInputGroupContext = D$1(false);
    var InInputGridContext = D$1(0);
    function useInputCaptures(type) {
      var capture = A$1(event => {
        switch (type) {
          case "text":
            return event.currentTarget.value;

          case "number":
            return event.currentTarget.valueAsNumber;
        }
      }, [type]);
      var uncapture = A$1(value => {
        switch (type) {
          case "text":
            return value;

          case "number":
            return "".concat(value);
        }
      }, [type]);
      return {
        capture,
        uncapture
      };
    }

    var _excluded$a = ["tag", "children"],
        _excluded2$9 = ["children", "tag"],
        _excluded3$4 = ["tag", "children", "disabled"];
    var InputGrid = forwardElementRef(function InputGrid(_ref, ref) {
      var {
        tag,
        children
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$a);

      return v$1(tag !== null && tag !== void 0 ? tag : "div", useMergedProps()({
        class: "input-grid",
        ref
      }, props), v$1(InInputGridContext.Provider, {
        value: F(InInputGridContext) + 1
      }, children));
    });
    /**
     * An InputGroup, that puts an Input and its Label together, visually, into one component.
     *
     * All Input-type components automatically detect when they're in an InputGroup and render different accordingly.
     */

    var InputGroup = forwardElementRef(function InputGroup(_ref2, ref) {
      var {
        children,
        tag
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$9);

      return v$1(tag !== null && tag !== void 0 ? tag : "div", useMergedProps()({
        class: "input-group",
        ref
      }, props), v$1(InInputGroupContext.Provider, {
        value: true
      }, children));
    });
    /**
     * Not generally needed, since most input components come with labels that do this for you.
     *
     * That being said, if you just need a static block of text not hooked up to any input element, this is your component.
     */

    var InputGroupText = forwardElementRef(function InputGroupText(_ref3, ref) {
      var {
        tag,
        children,
        disabled
      } = _ref3,
          props = _objectWithoutProperties(_ref3, _excluded3$4);

      /*
          return (
              cloneElement(children,
                  useMergedProps<any>()({ class: "input-group", ref }, children.props),
                  <InInputGroupContext.Provider value={true}>
                      {children}
                  </InInputGroupContext.Provider>
              )
          );*/

      /*const inInputGrid = !!useContext(InInputGridContext);
      if (inInputGrid) {
          children = <div class="form-control faux-form-control">{children}</div>
      }*/
      return v$1(tag !== null && tag !== void 0 ? tag : "div", useMergedProps()({
        class: clsx(disabled && "disabled", "input-group-text"),
        ref
      }, props), children);
    });

    var _excluded$9 = ["type", "disabled", "value", "onInput"],
        _excluded2$8 = ["getSyncHandler", "currentCapture", "pending", "hasError", "settleCount", "flushDebouncedPromise", "currentType"],
        _excluded3$3 = ["children", "width", "labelPosition"];

    function UnlabelledInput(_ref) {
      var {
        type,
        disabled,
        value,
        onInput: onInputAsync
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$9);

      var {
        capture,
        uncapture
      } = useInputCaptures(type);
      var {
        focusedInner,
        useHasFocusProps
      } = useHasFocus();

      var _useAsyncHandler = useAsyncHandler()({
        capture,
        debounce: 1500
      }),
          {
        getSyncHandler,
        currentCapture,
        pending,
        hasError,
        settleCount,
        flushDebouncedPromise,
        currentType
      } = _useAsyncHandler;
          _objectWithoutProperties(_useAsyncHandler, _excluded2$8);

      var onInput = getSyncHandler(disabled ? null : onInputAsync);
      var asyncState = hasError ? "failed" : pending ? "pending" : settleCount ? "succeeded" : null;
      var onBlur = flushDebouncedPromise;
      return v$1(ProgressCircular, {
        spinnerTimeout: 10,
        mode: currentType === "async" ? asyncState : null,
        childrenPosition: "after",
        color: "info"
      }, v$1("input", _objectSpread2({}, useHasFocusProps(useMergedProps()(props, {
        "aria-disabled": disabled ? "true" : undefined,
        readOnly: disabled,
        onBlur,
        class: clsx("form-control", disabled && "disabled", pending && "with-end-icon"),
        type,
        value: pending || focusedInner ? currentCapture : uncapture(value),
        onInput
      })))));
    }

    function Input(_ref2) {
      var _labelPosition;

      var {
        children,
        width,
        labelPosition
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded3$3);

      (_labelPosition = labelPosition) !== null && _labelPosition !== void 0 ? _labelPosition : labelPosition = "start";
      var {
        inputId,
        labelId,
        useInputLabelInput,
        useInputLabelLabel
      } = useInputLabel({
        inputPrefix: "input-",
        labelPrefix: "input-label-"
      });
      var {
        useInputLabelInputProps
      } = useInputLabelInput();
      var {
        useInputLabelLabelProps
      } = useInputLabelLabel({
        tag: "label"
      });
      var isInInputGroup = F(InInputGroupContext);
      var isInInputGrid = F(InInputGridContext);
      var stringLabel = "".concat(children);

      if (children != null && labelPosition === "hidden") {
        if (!["string", "number", "boolean"].includes(typeof children)) console.error("Hidden labels require a string-based label for the aria-label attribute.");else props["aria-label"] = stringLabel;
      }

      var labelJsx = v$1("label", _objectSpread2({}, useInputLabelLabelProps({
        class: clsx(props.disabled && "disabled", isInInputGroup ? "input-group-text" : labelPosition != "floating" ? "form-label" : "")
      })), children);
      var inputJsx = v$1(UnlabelledInput, _objectSpread2({}, useInputLabelInputProps(props)));

      if (isInInputGrid) {
        inputJsx = v$1("div", {
          class: "form-control faux-form-control",
          style: width !== null && width !== void 0 && width.endsWith("ch") ? {
            "--form-control-width": width !== null && width !== void 0 ? width : "20ch"
          } : width ? {
            width
          } : undefined
        }, inputJsx);
      }

      var inputWithLabel = v$1(d$1, null, labelPosition === "start" && labelJsx, inputJsx, (labelPosition === "end" || labelPosition == "floating") && labelJsx);
      if (labelPosition !== "floating") return inputWithLabel;else return v$1("div", {
        class: "form-floating"
      }, inputJsx);
    }

    var _excluded$8 = ["checked", "disabled", "onInput", "labelPosition", "children"],
        _excluded2$7 = ["tag", "children", "isInput"];

    function capture(e) {
      return e[EventDetail].checked;
    }
    /**
     * TODO: When inside an InputGroup, Checkboxes don't forward any properties or refs because there's no one DOM element to attach to.
     *
     * Probably need separate `inputRef` & `labelRef` properties for that,
     * but given there's also no easy way to forward props to just them a solution like that feels incomplete.
     */


    function Checkbox(_ref, ref) {
      var _labelPosition, _disabled;

      var {
        checked,
        disabled,
        onInput: onInputAsync,
        labelPosition,
        children: label
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$8);

      (_labelPosition = labelPosition) !== null && _labelPosition !== void 0 ? _labelPosition : labelPosition = "end";
      var {
        getSyncHandler,
        pending,
        hasError,
        settleCount,
        hasCapture,
        currentCapture,
        currentType
      } = useAsyncHandler()({
        capture
      });
      disabled || (disabled = pending);
      var onInput = getSyncHandler(onInputAsync);
      var {
        useCheckboxInputElement,
        useCheckboxLabelElement
      } = useAriaCheckbox({
        checked: pending ? currentCapture : checked === "indeterminate" ? "mixed" : checked,
        disabled: (_disabled = disabled) !== null && _disabled !== void 0 ? _disabled : false,
        onInput,
        labelPosition: "separate"
      });
      var {
        useCheckboxInputElementProps
      } = useCheckboxInputElement({
        tag: "input"
      });
      var {
        useCheckboxLabelElementProps
      } = useCheckboxLabelElement({
        tag: "label"
      });
      var inInputGroup = F(InInputGroupContext);
      var stringLabel = "".concat(label);

      if (label != null && labelPosition === "hidden" && !["string", "number", "boolean"].includes(typeof label)) {
        console.error("Hidden labels require a string-based label for the aria-label attribute.");
      }

      var asyncState = hasError ? "failed" : pending ? "pending" : settleCount ? "succeeded" : null;
      var p = useCheckboxInputElementProps({
        type: "checkbox",
        className: clsx("form-check-input", pending && "pending", disabled && "disabled", inInputGroup && "mt-0"),
        "aria-label": labelPosition === "hidden" ? stringLabel : undefined
      });
      var inputElement = v$1(OptionallyInputGroup$1, {
        isInput: true,
        tag: inInputGroup ? "label" : null,
        tabIndex: -1,
        disabled: disabled
      }, v$1(ProgressCircular, {
        childrenPosition: "after",
        colorFill: "foreground-only",
        mode: currentType === "async" ? asyncState : null,
        color: "info"
      }, v$1("input", _objectSpread2({}, p))));
      var labelElement = v$1(d$1, null, label != null && v$1(OptionallyInputGroup$1, _objectSpread2({
        isInput: false,
        tag: "label"
      }, useCheckboxLabelElementProps({
        className: clsx(pending && "pending", disabled && "disabled", "form-check-label"),
        "aria-hidden": "true"
      })), label));
      var ret = v$1(d$1, null, labelPosition == "start" && labelElement, inputElement, labelPosition == "end" && labelElement);
      if (!inInputGroup) return v$1("div", _objectSpread2({}, useMergedProps()(rest, {
        ref,
        class: "form-check"
      })), ret);
      return ret;
    }
    D$1(null);
    D$1(null);
    function OptionallyInputGroup$1(_ref2) {
      var {
        tag,
        children,
        isInput
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$7);

      var inInputGroup = F(InInputGroupContext);
      var inInputGrid = !!F(InInputGridContext);
      if (!inInputGroup) return v$1(tag !== null && tag !== void 0 ? tag : d$1, props, children); // If we're in an InputGrid's InputGroup, then create a 
      // new child that's, CSS-wise, the "true" input.
      // The other one is used for its border styles and relative positioning.

      if (inInputGrid && isInput) children = v$1("div", {
        className: "input-group-text"
      }, children);
      return v$1(InputGroupText, _objectSpread2({
        tag: tag !== null && tag !== void 0 ? tag : "div"
      }, useMergedProps()({
        className: clsx(isInput && inInputGrid && "faux-input-group-text")
      }, props)), children);
    }

    var _excluded$7 = ["checked", "disabled", "onInput", "children", "labelPosition"],
        _excluded2$6 = ["tag", "isInput", "children"];
    /**
     * @see Checkbox
     * @param ref
     * @returns
     */

    function Switch(_ref, ref) {
      var _labelPosition, _disabled;

      var {
        checked,
        disabled,
        onInput: onInputAsync,
        children: label,
        labelPosition
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$7);

      (_labelPosition = labelPosition) !== null && _labelPosition !== void 0 ? _labelPosition : labelPosition = "end";
      var {
        getSyncHandler,
        pending,
        currentType,
        hasError,
        settleCount,
        currentCapture
      } = useAsyncHandler()({
        capture: e => e[EventDetail].checked
      });
      var asyncState = hasError ? "failed" : pending ? "pending" : settleCount ? "succeeded" : null;
      disabled || (disabled = pending);
      var onInput = getSyncHandler(onInputAsync);
      var {
        useCheckboxInputElement: useSwitchInputElement,
        useCheckboxLabelElement: useSwitchLabelElement
      } = useAriaCheckbox({
        checked: pending ? currentCapture : checked,
        disabled: (_disabled = disabled) !== null && _disabled !== void 0 ? _disabled : false,
        onInput,
        labelPosition: "separate"
      });
      var {
        useCheckboxInputElementProps: useSwitchInputElementProps
      } = useSwitchInputElement({
        tag: "input"
      });
      var {
        useCheckboxLabelElementProps: useSwitchLabelElementProps
      } = useSwitchLabelElement({
        tag: "label"
      });
      var inInputGroup = F(InInputGroupContext);
      var stringLabel = "".concat(label);

      if (label != null && labelPosition === "hidden" && !["string", "number", "boolean"].includes(typeof label)) {
        console.error("Hidden labels require a string-based label for the aria-label attribute.");
      }

      var inputElement = v$1(OptionallyInputGroup, {
        tag: inInputGroup ? "label" : null,
        disabled: disabled,
        tabIndex: -1,
        isInput: true
      }, v$1(ProgressCircular, {
        childrenPosition: "after",
        colorFill: "foreground-only",
        mode: currentType === "async" ? asyncState : null,
        color: "info"
      }, v$1("input", _objectSpread2({}, useSwitchInputElementProps({
        type: "checkbox",
        className: clsx(pending && "pending", "form-check-input", disabled && "disabled"),
        "aria-label": labelPosition === "hidden" ? stringLabel : undefined
      })))));
      var labelElement = v$1(d$1, null, label != null && v$1(OptionallyInputGroup, _objectSpread2({
        tag: "label",
        isInput: false
      }, useSwitchLabelElementProps({
        className: clsx(pending && "pending", "form-check-label", disabled && "disabled"),
        "aria-hidden": "true"
      })), label));
      var ret = v$1(d$1, null, labelPosition == "start" && labelElement, inputElement, labelPosition == "end" && labelElement);
      if (!inInputGroup) return v$1("div", _objectSpread2({}, useMergedProps()(rest, {
        ref,
        class: "form-check form-switch"
      })), ret);
      return ret;
    } // Note: Slightly different from the others
    // (^^^^ I'm really glad I left that there)

    function OptionallyInputGroup(_ref2) {
      var {
        tag,
        isInput,
        children
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$6);

      var inInputGroup = F(InInputGroupContext);
      var inInputGrid = F(InInputGridContext);
      if (!inInputGroup) return v$1(tag !== null && tag !== void 0 ? tag : d$1, props, children);
      if (inInputGrid && isInput) children = v$1("div", {
        className: clsx(isInput && inInputGrid && "form-switch", "input-group-text")
      }, children);
      return v$1(InputGroupText, _objectSpread2({
        tag: tag !== null && tag !== void 0 ? tag : "div"
      }, useMergedProps()({
        className: clsx("input-group-text", isInput && !inInputGrid && "form-switch", isInput && inInputGrid && "faux-input-group-text")
      }, props)), children);
    }

    var knownNames = new Set();
    var CurrentHandlerTypeContext = D$1("sync");
    var RadioGroupContext = D$1(null);
    function RadioGroup({
      children,
      name,
      selectedValue,
      label,
      labelPosition,
      onInput: onInputAsync
    }) {
      var {
        getSyncHandler,
        pending,
        hasError,
        settleCount,
        currentCapture,
        currentType
      } = useAsyncHandler()({
        capture: e => e[EventDetail].selectedValue
      });
      var onInput = getSyncHandler(onInputAsync);
      var {
        useRadio,
        useRadioGroupProps,
        managedChildren,
        getIndex
      } = useAriaRadioGroup({
        name,
        selectedValue: pending ? currentCapture : selectedValue,
        onInput: onInput
      });
      var stringLabel = undefined;

      if (labelPosition === "hidden") {
        if (label != null && !["string", "number", "boolean"].includes(typeof label)) {
          console.error("Hidden labels require a string-based label for the aria-label attribute.");
        } else {
          stringLabel = "".concat(label);
        }
      } // Debugging check -- multiple groups with the same name can cause weird glitches from native radio selection behavior.


      y(() => {
        if (knownNames.has(name)) {
          console.error("Multiple radio groups with the name \"".concat(name, "\" exist on the same page at the same time!"));
        }

        knownNames.add(name);
        return () => knownNames.delete(name);
      }, [name]);
      var selectedIndex = getIndex(currentCapture !== null && currentCapture !== void 0 ? currentCapture : selectedValue); //const capturedIndex = getIndex(currentCapture!);

      useChildFlag(selectedIndex, managedChildren.length, (index, isSelected) => managedChildren[index].setAsyncState(isSelected ? hasError ? "failed" : pending ? "pending" : "succeeded" : null)); // useChildFlag(pending ? capturedIndex : null, managedChildren.length, useCallback((index, isCaptured) => managedChildren[index].setPending(isCaptured? "in" : false), []));

      var {
        useGenericLabelLabel,
        useGenericLabelInput
      } = useGenericLabel({
        inputPrefix: "aria-radiogroup",
        labelPrefix: "aria-radiogroup-label",
        backupText: stringLabel
      });
      var {
        useGenericLabelInputProps
      } = useGenericLabelInput();
      var {
        useGenericLabelLabelProps
      } = useGenericLabelLabel();
      var labelJsx = v$1("div", _objectSpread2({}, useGenericLabelLabelProps({})));
      var groupJsx = v$1("div", _objectSpread2({}, useGenericLabelInputProps(useRadioGroupProps({
        "aria-label": labelPosition === "hidden" ? stringLabel : undefined
      }))), children);
      return v$1(CurrentHandlerTypeContext.Provider, {
        value: currentType !== null && currentType !== void 0 ? currentType : "sync"
      }, v$1(RadioGroupContext.Provider, {
        value: useRadio
      }, labelPosition == "start" && labelJsx, groupJsx, labelPosition == "end" && labelJsx));
    }
    function Radio({
      disabled,
      children: label,
      index,
      value,
      labelPosition
    }) {
      var _labelPosition, _disabled, _label;

      var useAriaRadio = F(RadioGroupContext);
      (_labelPosition = labelPosition) !== null && _labelPosition !== void 0 ? _labelPosition : labelPosition = "end";
      var text = null;
      var currentHandlerType = F(CurrentHandlerTypeContext);
      var [asyncState, setAsyncState] = useState(null);
      disabled || (disabled = asyncState === "pending");
      var {
        useRadioInput,
        useRadioLabel
      } = useAriaRadio({
        disabled: (_disabled = disabled) !== null && _disabled !== void 0 ? _disabled : false,
        labelPosition: "separate",
        index,
        text,
        value,
        setAsyncState
      });
      var {
        useRadioInputProps
      } = useRadioInput({
        tag: "input"
      });
      var {
        useRadioLabelProps
      } = useRadioLabel({
        tag: "label"
      });
      var inInputGroup = F(InInputGroupContext);
      (_label = label) !== null && _label !== void 0 ? _label : label = value;
      var stringLabel = "".concat(label);

      if (label != null && labelPosition === "hidden" && !["string", "number", "boolean"].includes(typeof label)) {
        console.error("Hidden labels require a string-based label for the aria-label attribute.");
      }

      var inputElement = v$1(OptionallyInputGroup$1, {
        isInput: true,
        tag: inInputGroup ? "label" : null,
        disabled: disabled,
        tabIndex: -1
      }, v$1(ProgressCircular, {
        childrenPosition: "after",
        colorFill: "foreground-only",
        mode: currentHandlerType == "async" ? asyncState : null,
        color: "info"
      }, v$1("input", _objectSpread2({}, useRadioInputProps({
        type: "radio",
        className: clsx(asyncState === "pending" && "pending", disabled && "disabled", "form-check-input"),
        "aria-label": labelPosition === "hidden" ? stringLabel : undefined
      })))));
      var labelElement = v$1(d$1, null, label != null && v$1(OptionallyInputGroup$1, _objectSpread2({
        isInput: false,
        tag: "label"
      }, useRadioLabelProps({
        className: clsx(asyncState === "pending" && "pending", disabled && "disabled", "form-check-label"),
        "aria-hidden": "true"
      })), label));
      var ret = v$1(d$1, null, labelPosition == "start" && labelElement, inputElement, labelPosition == "end" && labelElement);
      if (!inInputGroup) return v$1("div", {
        class: "form-check"
      }, ret);
      return ret;
    }

    var _excluded$6 = ["tag", "minWidth", "children"],
        _excluded2$5 = ["tag", "columns", "children"];
    /**
     * Very simple, easy responsive grid that guarantees each column is the minimum size.
     *
     * Easy one-liners all around here!
     */

    var GridResponsive = forwardElementRef(function ResponsiveGrid(_ref, ref) {
      var {
        tag,
        minWidth,
        children
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$6);

      return v$1(tag !== null && tag !== void 0 ? tag : "div", useMergedProps()({
        className: "responsive-grid",
        style: minWidth ? {
          "--grid-min-width": "".concat(minWidth)
        } : {},
        ref
      }, props), children);
    });
    /**
     * Very simple, easy static grid that guarantees the number of columns is displayed,
     * no matter how janky it looks.
     */

    forwardElementRef(function ResponsiveGrid(_ref2, ref) {
      var {
        tag,
        columns,
        children
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$5);

      return v$1(tag !== null && tag !== void 0 ? tag : "div", useMergedProps()({
        className: "static-grid",
        style: typeof columns === "string" ? {
          "--static-grid-columns": columns
        } : {
          "--grid-column-count": columns
        },
        ref
      }, props), children);
    });

    var _excluded$5 = ["onSelect", "selectedIndex", "selectionMode", "collator", "keyNavigation", "noTypeahead", "noWrap", "typeaheadTimeout", "tag", "select"],
        _excluded2$4 = ["index"];
    var UseListboxSingleItemContext = D$1(null);
    function ListSingle(props, ref) {
      var {
        onSelect: onSelectAsync,
        selectedIndex,
        selectionMode,
        collator,
        keyNavigation,
        noTypeahead,
        noWrap,
        typeaheadTimeout,
        tag,
        select
      } = props,
          domProps = _objectWithoutProperties(props, _excluded$5);

      var {
        getSyncHandler
      } = useAsyncHandler()({
        capture: e => e[EventDetail].selectedIndex
      });
      var onSelect = getSyncHandler(onSelectAsync);
      var {
        useListboxSingleItem,
        useListboxSingleLabel,
        useListboxSingleProps
      } = useAriaListboxSingle({
        onSelect,
        selectedIndex,
        selectionMode,
        typeaheadTimeout,
        noWrap,
        noTypeahead,
        keyNavigation,
        collator
      });
      return v$1(UseListboxSingleItemContext.Provider, {
        value: useListboxSingleItem
      }, v$1(tag, useMergedProps()({
        class: "list-group",
        ref
      }, useListboxSingleProps(domProps))));
    }
    function ListItemSingle(props, ref) {
      var useListItemSingle = F(UseListboxSingleItemContext);

      var _props$ref = _objectSpread2(_objectSpread2({}, props), {}, {
        ref
      }),
          {
        index
      } = _props$ref,
          domProps = _objectWithoutProperties(_props$ref, _excluded2$4);

      var [text, setText] = useState(null);
      var {
        useRefElementProps,
        element
      } = useRefElement();
      h(() => {
        if (element) setText(element.innerText);
      }, [element]);
      var {
        getSelected,
        tabbable,
        selected,
        useListboxSingleItemProps
      } = useListItemSingle({
        index,
        text,
        tag: "li"
      });
      return v$1("li", _objectSpread2({}, usePseudoActive(useMergedProps()({
        class: clsx("list-group-item", "list-group-item-action", selected && "active")
      }, useListboxSingleItemProps(useRefElementProps(domProps))))));
    }

    var _globalThis$process, _globalThis$process2, _globalThis$process2$, _globalThis$process$e, _globalThis$process$e2;

    (_globalThis$process = globalThis.process) !== null && _globalThis$process !== void 0 ? _globalThis$process : globalThis.process = {};
    (_globalThis$process2$ = (_globalThis$process2 = globalThis.process).env) !== null && _globalThis$process2$ !== void 0 ? _globalThis$process2$ : _globalThis$process2.env = {};
    (_globalThis$process$e2 = (_globalThis$process$e = globalThis.process.env).NODE_ENV) !== null && _globalThis$process$e2 !== void 0 ? _globalThis$process$e2 : _globalThis$process$e.NODE_ENV = "development";

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }

      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }

      return node;
    }

    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }

    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }

      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }

          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$2,
      requires: ['computeStyles']
    };

    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }

    var round$1 = Math.round;
    function getBoundingClientRect(element, includeScale) {
      if (includeScale === void 0) {
        includeScale = false;
      }

      var rect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;

      if (isHTMLElement(element) && includeScale) {
        var offsetHeight = element.offsetHeight;
        var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
        // Fallback to 1 in case both values are `0`

        if (offsetWidth > 0) {
          scaleX = rect.width / offsetWidth || 1;
        }

        if (offsetHeight > 0) {
          scaleY = rect.height / offsetHeight || 1;
        }
      }

      return {
        width: round$1(rect.width / scaleX),
        height: round$1(rect.height / scaleY),
        top: round$1(rect.top / scaleY),
        right: round$1(rect.right / scaleX),
        bottom: round$1(rect.bottom / scaleY),
        left: round$1(rect.left / scaleX),
        x: round$1(rect.left / scaleX),
        y: round$1(rect.top / scaleY)
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;

      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }

      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }

      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;

        do {
          if (next && parent.isSameNode(next)) {
            return true;
          } // $FlowFixMe[prop-missing]: need a better way to handle this...


          next = next.parentNode || next.host;
        } while (next);
      } // Give up, the result is false


      return false;
    }

    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === 'fixed') {
        return null;
      }

      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
      var isIE = navigator.userAgent.indexOf('Trident') !== -1;

      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle$1(element);

        if (elementCss.position === 'fixed') {
          return null;
        }
      }

      var currentNode = getParentNode(element);

      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    var max = Math.max;
    var min = Math.min;
    var round = Math.round;

    function within(min$1, value, max$1) {
      return max(min$1, min(value, max$1));
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect$1(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      if (process.env.NODE_ENV !== "production") {
        if (!isHTMLElement(arrowElement)) {
          console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
        }
      }

      if (!contains(state.elements.popper, arrowElement)) {
        if (process.env.NODE_ENV !== "production") {
          console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
        }

        return;
      }

      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$1,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(round(x * dpr) / dpr) || 0,
        y: round(round(y * dpr) / dpr) || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          variation = _ref2.variation,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets;

      var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,
          _ref3$x = _ref3.x,
          x = _ref3$x === void 0 ? 0 : _ref3$x,
          _ref3$y = _ref3.y,
          y = _ref3$y === void 0 ? 0 : _ref3$y;

      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);

          if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


        offsetParent = offsetParent;

        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom; // $FlowFixMe[prop-missing]

          y -= offsetParent[heightProp] - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right; // $FlowFixMe[prop-missing]

          x -= offsetParent[widthProp] - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref4) {
      var state = _ref4.state,
          options = _ref4.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

      if (process.env.NODE_ENV !== "production") {
        var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';

        if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
          return transitionProperty.indexOf(property) >= 0;
        })) {
          console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
        }
      }

      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }

      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    var passive = {
      passive: true
    };

    function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getViewportRect(element) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
      // can be obscured underneath it.
      // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
      // if it isn't open, so if this isn't available, the popper will be detected
      // to overflow the bottom of the screen too early.

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent

        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;

      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle$1(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;

      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element) {
      var rect = getBoundingClientRect(element);
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

      if (!isElement(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;

        if (process.env.NODE_ENV !== "production") {
          console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
        }
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement(placement);

        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases  research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name; // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step

      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis || checkAltAxis) {
        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
        var max$1 = popperOffsets[mainAxis] - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
        var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;

        if (checkMainAxis) {
          var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
          popperOffsets[mainAxis] = preventedOffset;
          data[mainAxis] = preventedOffset - offset;
        }

        if (checkAltAxis) {
          var _mainSide = mainAxis === 'x' ? top : left;

          var _altSide = mainAxis === 'x' ? bottom : right;

          var _offset = popperOffsets[altAxis];

          var _min = _offset + overflow[_mainSide];

          var _max = _offset - overflow[_altSide];

          var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);

          popperOffsets[altAxis] = _preventedOffset;
          data[altAxis] = _preventedOffset - _offset;
        }
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = rect.width / element.offsetWidth || 1;
      var scaleY = rect.height / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.


    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function format(str) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return [].concat(args).reduce(function (p, c) {
        return p.replace(/%s/, c);
      }, str);
    }

    var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
    var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
    var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
    function validateModifiers(modifiers) {
      modifiers.forEach(function (modifier) {
        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
        .filter(function (value, index, self) {
          return self.indexOf(value) === index;
        }).forEach(function (key) {
          switch (key) {
            case 'name':
              if (typeof modifier.name !== 'string') {
                console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
              }

              break;

            case 'enabled':
              if (typeof modifier.enabled !== 'boolean') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
              }

              break;

            case 'phase':
              if (modifierPhases.indexOf(modifier.phase) < 0) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
              }

              break;

            case 'fn':
              if (typeof modifier.fn !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'effect':
              if (modifier.effect != null && typeof modifier.effect !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'requires':
              if (modifier.requires != null && !Array.isArray(modifier.requires)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
              }

              break;

            case 'requiresIfExists':
              if (!Array.isArray(modifier.requiresIfExists)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
              }

              break;

            case 'options':
            case 'data':
              break;

            default:
              console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
                return "\"" + s + "\"";
              }).join(', ') + "; but \"" + key + "\" was provided.");
          }

          modifier.requires && modifier.requires.forEach(function (requirement) {
            if (modifiers.find(function (mod) {
              return mod.name === requirement;
            }) == null) {
              console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
            }
          });
        });
      });
    }

    function uniqueBy(arr, fn) {
      var identifiers = new Set();
      return arr.filter(function (item) {
        var identifier = fn(item);

        if (!identifiers.has(identifier)) {
          identifiers.add(identifier);
          return true;
        }
      });
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
    var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(setOptionsAction) {
            var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned
            // if one of the modifiers is invalid for any reason

            if (process.env.NODE_ENV !== "production") {
              var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
                var name = _ref.name;
                return name;
              });
              validateModifiers(modifiers);

              if (getBasePlacement(state.options.placement) === auto) {
                var flipModifier = state.orderedModifiers.find(function (_ref2) {
                  var name = _ref2.name;
                  return name === 'flip';
                });

                if (!flipModifier) {
                  console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
                }
              }

              var _getComputedStyle = getComputedStyle$1(popper),
                  marginTop = _getComputedStyle.marginTop,
                  marginRight = _getComputedStyle.marginRight,
                  marginBottom = _getComputedStyle.marginBottom,
                  marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
              // cause bugs with positioning, so we'll warn the consumer


              if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
                return parseFloat(margin);
              })) {
                console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
              }
            }

            runModifierEffects();
            return instance.update();
          },
          // Sync update  it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {
              if (process.env.NODE_ENV !== "production") {
                console.error(INVALID_ELEMENT_ERROR);
              }

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            var __debug_loops__ = 0;

            for (var index = 0; index < state.orderedModifiers.length; index++) {
              if (process.env.NODE_ENV !== "production") {
                __debug_loops__ += 1;

                if (__debug_loops__ > 100) {
                  console.error(INFINITE_LOOP_ERROR);
                  break;
                }
              }

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update  it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    function usePopperApi({
      updating,
      position,
      skidding,
      distance,
      paddingTop,
      paddingBottom,
      paddingLeft,
      paddingRight
    }) {
      var [popperInstance, setPopperInstance, getPopperInstance] = useState(null);
      var [usedPlacement, setUsedPlacement] = useState(null);
      var {
        element: sourceElement,
        getElement: getSourceElement,
        useRefElementProps: useSourceElementRefProps
      } = useRefElement();
      var {
        element: popperElement,
        getElement: getPopperElement,
        useRefElementProps: usePopperElementRefProps
      } = useRefElement();
      var {
        element: arrowElement,
        getElement: getArrowElement,
        useRefElementProps: useArrowElementRefProps
      } = useRefElement();
      var [sourceStyle, setSourceStyle] = useState(null);
      var [sourceAttributes, setSourceAttributes] = useState({});
      var [popperStyle, setPopperStyle] = useState(null);
      var [popperAttributes, setPopperAttributes] = useState({});
      var [arrowStyle, setArrowStyle] = useState(null);
      var [arrowAttributes, setArrowAttributes] = useState({});
      y(() => {
        if (updating) {
          var rafHandle = 0;

          function raf() {
            var _ref, _getPopperInstance;

            var p = (_ref = closed ? Promise.resolve() : (_getPopperInstance = getPopperInstance()) === null || _getPopperInstance === void 0 ? void 0 : _getPopperInstance.update()) !== null && _ref !== void 0 ? _ref : Promise.resolve();
            p.then(_ => {
              if (rafHandle != 0) {
                rafHandle = requestAnimationFrame(raf);
              }
            });
          }

          rafHandle = requestAnimationFrame(raf);
          return () => {
            cancelAnimationFrame(rafHandle); // Single-threaded languages are nice sometimes.

            rafHandle = 0;
          };
        }
      }, [updating]);
      var updateStateModifier = d(() => {
        var modifier = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({
            state,
            options,
            name,
            instance
          }) => {
            var usedPlacement = state.placement;
            if (usedPlacement.includes("-")) usedPlacement = usedPlacement.substr(0, usedPlacement.indexOf("-"));
            setUsedPlacement(usedPlacement);
            if (state.styles.reference) setSourceStyle(state.styles.reference);
            if (state.attributes.reference) setSourceAttributes(state.attributes.reference);
            if (state.styles.popper) setPopperStyle(state.styles.popper);
            if (state.attributes.popper) setPopperAttributes(state.attributes.popper);
            if (state.styles.arrow) setArrowStyle(state.styles.arrow);
            if (state.attributes.arrow) setArrowAttributes(state.attributes.arrow);
          },
          requires: ["computeStyles", "flip"]
        };
        return modifier;
      }, []);
      var {
        convertElementSize,
        getLogicalDirection
      } = useLogicalDirection(sourceElement);
      y(() => {
        if (sourceElement && popperElement) {
          var onFirstUpdate = () => {};

          var strategy = "absolute";
          var placement = logicalToPlacement(getLogicalDirection(), position);
          setPopperInstance(createPopper(sourceElement, popperElement, {
            modifiers: [{
              name: "flip",
              options: {}
            }, {
              name: "preventOverflow",
              options: {
                padding: {
                  bottom: paddingBottom,
                  top: paddingTop,
                  left: paddingLeft,
                  right: paddingRight
                }
              }
            }, updateStateModifier, {
              name: 'eventListeners',
              enabled: false
            }, {
              name: "applyStyles",
              enabled: false
            }],
            onFirstUpdate,
            placement,
            strategy
          }));
        }
      }, [sourceElement, popperElement, position, skidding, distance, paddingTop, paddingBottom, paddingLeft, paddingRight]);

      function usePopperSource() {
        function usePopperSourceProps(props) {
          var style = _objectSpread2({}, sourceStyle);

          return useMergedProps()(sourceAttributes, useMergedProps()({
            style
          }, useSourceElementRefProps(props)));
        }

        return {
          usePopperSourceProps
        };
      }

      function usePopperPopup({
        open
      }) {
        function usePopperPopupProps(props) {
          var style = _objectSpread2(_objectSpread2({}, popperStyle), {}, {
            pointerEvents: open ? undefined : "none"
          });

          return useMergedProps()(popperAttributes, useMergedProps()({
            style
          }, usePopperElementRefProps(props)));
        }

        return {
          usePopperPopupProps
        };
      }

      function usePopperArrow() {
        function usePopperArrowProps(props) {
          var style = _objectSpread2({}, arrowStyle);

          return useMergedProps()(popperAttributes, useMergedProps()({
            style
          }, useArrowElementRefProps(props)));
        }

        return {
          usePopperArrowProps
        };
      }

      return {
        usePopperSource,
        usePopperPopup,
        usePopperArrow,
        usedPlacement,
        getLogicalDirection
      };
    }
    function placementToLogical(logicalDirection, placement) {
      var {
        blockDirection,
        blockOrientation,
        inlineDirection,
        inlineOrientation
      } = logicalDirection;
      var logical;

      switch ("".concat(inlineDirection, "-").concat(blockDirection, ",").concat(placement)) {
        // There's a pattern, and it could be coded as a pattern
        case "ltr-ttb,top":
          logical = "block-start";
          break;

        case "ltr-btt,bottom":
          logical = "block-start";
          break;

        case "rtl-ttb,top":
          logical = "block-start";
          break;

        case "rtl-btt,bottom":
          logical = "block-start";
          break;

        case "ttb-ltr,left":
          logical = "block-start";
          break;

        case "btt-ltr,right":
          logical = "block-start";
          break;

        case "ttb-rtl,left":
          logical = "block-start";
          break;

        case "btt-rtl,right":
          logical = "block-start";
          break;

        case "ltr-ttb,bottom":
          logical = "block-end";
          break;

        case "rtl-ttb,bottom":
          logical = "block-end";
          break;

        case "ltr-btt,top":
          logical = "block-end";
          break;

        case "rtl-btt,top":
          logical = "block-end";
          break;

        case "ttb-ltr,right":
          logical = "block-end";
          break;

        case "ttb-rtl,right":
          logical = "block-end";
          break;

        case "btt-ltr,left":
          logical = "block-end";
          break;

        case "btt-rtl,left":
          logical = "block-end";
          break;

        case "ttb-ltr,top":
          logical = "inline-start";
          break;

        case "ttb-rtl,top":
          logical = "inline-start";
          break;

        case "btt-ltr,bottom":
          logical = "inline-start";
          break;

        case "btt-rtl,bottom":
          logical = "inline-start";
          break;

        case "ltr-ttb,left":
          logical = "inline-start";
          break;

        case "rtl-ttb,left":
          logical = "inline-start";
          break;

        case "ltr-btt,right":
          logical = "inline-start";
          break;

        case "rtl-btt,right":
          logical = "inline-start";
          break;

        case "ttb-ltr,bottom":
          logical = "inline-end";
          break;

        case "ttb-rtl,bottom":
          logical = "inline-end";
          break;

        case "btt-ltr,top":
          logical = "inline-end";
          break;

        case "btt-rtl,top":
          logical = "inline-end";
          break;

        case "ltr-ttb,right":
          logical = "inline-end";
          break;

        case "rtl-ttb,right":
          logical = "inline-end";
          break;

        case "ltr-btt,left":
          logical = "inline-end";
          break;

        case "rtl-btt,left":
          logical = "inline-end";
          break;
        // Shouldn't happen, but here for type correctness.

        case "ttb-ttb,bottom":
        case "ttb-ttb,top":
        case "btt-btt,bottom":
        case "btt-btt,top":
        case "ltr-ltr,bottom":
        case "ltr-ltr,top":
        case "rtl-rtl,bottom":
        case "rtl-rtl,top":
        case "ttb-btt,bottom":
        case "btt-ttb,top":
        case "btt-ttb,bottom":
        case "ttb-btt,top":
        case "ltr-rtl,bottom":
        case "rtl-ltr,top":
        case "rtl-ltr,bottom":
        case "ltr-rtl,top":
        case "ttb-ttb,right":
        case "ttb-ttb,left":
        case "btt-btt,right":
        case "btt-btt,left":
        case "ltr-ltr,right":
        case "ltr-ltr,left":
        case "rtl-rtl,right":
        case "rtl-rtl,left":
        case "ttb-btt,right":
        case "btt-ttb,left":
        case "btt-ttb,right":
        case "ttb-btt,left":
        case "ltr-rtl,right":
        case "rtl-ltr,left":
        case "rtl-ltr,right":
        case "ltr-rtl,left":
          debugger;
          logical = logical;
          break;
      }

      return logical;
    }
    function logicalToPlacement(logicalDirection, position) {
      var placement;
      var {
        blockDirection,
        blockOrientation,
        inlineDirection,
        inlineOrientation
      } = logicalDirection;

      if (position === "block-start" || position == "block-end") {
        switch ("".concat(position, "-").concat(blockDirection)) {
          case "block-start-ttb":
            placement = "top";
            break;

          case "block-end-btt":
            placement = "top";
            break;

          case "block-start-btt":
            placement = "bottom";
            break;

          case "block-end-ttb":
            placement = "bottom";
            break;

          case "block-start-ltr":
            placement = "left";
            break;

          case "block-end-rtl":
            placement = "left";
            break;

          case "block-end-ltr":
            placement = "right";
            break;

          case "block-start-rtl":
            placement = "right";
            break;

          default:
            placement = "bottom";
            break;
        }
      } else {
        switch ("".concat(position, "-").concat(inlineDirection)) {
          case "inline-start-ltr":
            placement = "left";
            break;

          case "inline-end-rtl":
            placement = "left";
            break;

          case "inline-end-ltr":
            placement = "right";
            break;

          case "inline-start-rtl":
            placement = "right";
            break;

          case "inline-start-ttb":
            placement = "top";
            break;

          case "inline-end-btt":
            placement = "top";
            break;

          case "inline-end-ttb":
            placement = "bottom";
            break;

          case "inline-start-btt":
            placement = "bottom";
            break;

          default:
            placement = "right";
            break;
        }
      }

      return placement;
    }
    function useShouldUpdatePopper(open, elementSize) {
      // Since scroll events are asynchronous, especially on iOS devices,
      // just manually adjust the position of the popper for a bit
      // any time basically any user interaction happens.
      var [updatingForABit, setUpdatingForABit] = useState(0);
      useTimeout({
        callback: () => {
          setUpdatingForABit(0);
        },
        timeout: 100,
        triggerIndex: updatingForABit
      });
      var onInteraction = A$1(() => {
        setUpdatingForABit(u => ++u);
      }, [closed]);
      if (!open) onInteraction = null;
      useGlobalHandler(document, "keydown", onInteraction, {
        passive: true,
        capture: true
      });
      useGlobalHandler(window, "scroll", onInteraction, {
        passive: true,
        capture: true
      });
      useGlobalHandler(window, "pointermove", onInteraction, {
        passive: true,
        capture: true
      });
      useGlobalHandler(window, "click", onInteraction, {
        passive: true,
        capture: true
      });
      useGlobalHandler(window, "resize", onInteraction, {
        passive: true,
        capture: true
      });
      y(() => {
        var _onInteraction;

        (_onInteraction = onInteraction) === null || _onInteraction === void 0 ? void 0 : _onInteraction();
      }, Object.values(elementSize !== null && elementSize !== void 0 ? elementSize : {}));
      return {
        shouldUpdate: !!updatingForABit,
        onInteraction
      };
    }
    /**
     * Handle the e.g. zoomOriginDynamic props, to turn them into zoomOriginInline or zoomOriginBlock as appropriate.
     * TODO: Right now, all *Dynamic props are just handled as 1 - prop. Some probably need to be -1 * prop though.
     */

    function fixProps(logicalDirection, requestedPlacement, usedPlacement, props) {
      var logicalSnake = placementToLogical(logicalDirection, usedPlacement);
      var propAxis;
      var reverse;

      switch (logicalSnake) {
        case "block-start":
          propAxis = "Block";
          reverse = requestedPlacement == "block-end";
          break;

        case "block-end":
          propAxis = "Block";
          reverse = requestedPlacement == "block-start";
          break;

        case "inline-start":
          propAxis = "Inline";
          reverse = requestedPlacement == "inline-end";
          break;

        case "inline-end":
          propAxis = "Inline";
          reverse = requestedPlacement == "inline-start";
          break;
      }

      var newProps = _objectSpread2({}, props);

      for (var propName in props) {
        if (propName.endsWith("Dynamic") && typeof props[propName] === "number") {
          var newPropName = "".concat(propName.substr(0, propName.indexOf("Dynamic"))).concat(propAxis);
          newProps[newPropName] = !reverse ? newProps[propName] : 1 - newProps[propName];
          delete newProps[propName];
        }
      }

      return newProps;
    }

    var _excluded$4 = ["anchor", "anchorTag", "children", "tag", "Transition"],
        _excluded2$3 = ["children", "index"];

    var OnCloseContext = D$1(undefined);
    var UseMenuItemContext = D$1(null);
    function Menu(_ref) {
      var {
        anchor,
        anchorTag,
        children,
        tag,
        Transition
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$4);

      var [open, setOpen] = useState(false);
      var onClose = A$1(() => setOpen(false), []);

      var onOpen = () => setOpen(true);

      var {
        useElementSizeProps,
        elementSize
      } = useElementSize();
      var {
        shouldUpdate: updatingForABit,
        onInteraction
      } = useShouldUpdatePopper(open, elementSize);
      var {
        usePopperArrow,
        usePopperPopup,
        usePopperSource,
        usedPlacement,
        getLogicalDirection
      } = usePopperApi({
        position: "block-end",
        updating: updatingForABit
      });
      var {
        useMenuButton,
        useMenuItem,
        useMenuItemCheckbox,
        useMenuProps,
        useMenuSubmenuItem,
        focusMenu
      } = useAriaMenu({
        open,
        onClose,
        onOpen
      });
      var {
        useMenuButtonProps
      } = useMenuButton({
        tag: anchorTag !== null && anchorTag !== void 0 ? anchorTag : "button"
      });
      var {
        usePopperSourceProps
      } = usePopperSource();
      var {
        usePopperPopupProps
      } = usePopperPopup({
        open
      });
      var {
        usePopperArrowProps
      } = usePopperArrow();
      /*const [sentinelFocused, setSentinelFocused] = useState(false);
      useTimeout({ callback: () => { if (sentinelFocused) onClose(); setSentinelFocused(false); }, timeout: 1000, triggerIndex: sentinelFocused.toString() })*/

      var [firstSentinelIsActive, setFirstSentinelIsActive] = useState(false);
      useTimeout({
        callback: () => {
          setFirstSentinelIsActive(open);
        },
        timeout: 100,
        triggerIndex: "".concat(firstSentinelIsActive)
      });
      var menuChildren = v$1(d$1, null, v$1("div", _objectSpread2({}, usePopperArrowProps({}))), v$1("button", {
        className: "visually-hidden",
        onFocus: !firstSentinelIsActive ? () => focusMenu === null || focusMenu === void 0 ? void 0 : focusMenu() : () => onClose(),
        onClick: onClose
      }, "Close menu"), children, v$1("button", {
        className: "visually-hidden",
        onFocus: onClose,
        onClick: onClose
      }, "Close menu"));
      var logicalDirection = getLogicalDirection();
      if (logicalDirection && usedPlacement) rest = fixProps(logicalDirection, "block-end", usedPlacement, rest);
      return v$1(d$1, null, v$1(OnCloseContext.Provider, {
        value: onClose
      }, v$1(UseMenuItemContext.Provider, {
        value: useMenuItem
      }, B(anchor, useMergedProps()(useElementSizeProps({
        ref: anchor.ref,
        class: "dropdown-toggle ".concat(open ? "active" : "")
      }), usePopperSourceProps(useMenuButtonProps(anchor.props)))), v$1(BodyPortal, null, v$1("div", _objectSpread2({}, usePopperPopupProps({
        class: "dropdown-menu-popper"
      })), v$1(Transition, _objectSpread2(_objectSpread2({}, useMenuProps(rest)), {}, {
        open: open,
        onTransitionUpdate: onInteraction,
        exitVisibility: "hidden"
      }), v$1("div", null, v$1(tag, {
        children: menuChildren,
        className: "dropdown-menu"
      }))))))));
    }
    function MenuItem(_ref2) {
      var {
        children,
        index
      } = _ref2,
          rest = _objectWithoutProperties(_ref2, _excluded2$3);

      var useMenuItem = F(UseMenuItemContext);
      var [text, setText] = useState(null);
      var {
        useRefElementProps,
        element
      } = useRefElement();
      h(() => {
        if (element) setText(element.innerText);
      }, [element]);
      var {
        useMenuItemProps
      } = useMenuItem({
        index,
        text
      });
      return v$1("li", null, v$1("button", _objectSpread2({}, useMenuItemProps(useRefElementProps(useMergedProps()(rest, {
        class: "dropdown-item"
      })))), children));
    }

    var _excluded$3 = ["onSelect", "orientation", "selectedIndex", "selectionMode", "tag", "children", "visualVariant"],
        _excluded2$2 = ["index", "children"],
        _excluded3$2 = ["index", "children", "Transition"];
    var UseTabContext = D$1(null);
    var UseTabPanelContext = D$1(null);
    function Tabs(_ref) {
      var _orientation;

      var {
        onSelect: onSelectAsync,
        orientation,
        selectedIndex,
        selectionMode,
        tag,
        children,
        visualVariant
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$3);

      var capture = e => {
        return e[EventDetail].selectedIndex;
      };

      (_orientation = orientation) !== null && _orientation !== void 0 ? _orientation : orientation = "inline";
      var {
        getSyncHandler
      } = useAsyncHandler()({
        capture: capture
      });
      var onSelect = getSyncHandler(onSelectAsync);
      var {
        useTab,
        useTabPanel,
        useTabsLabel,
        useTabsList
      } = useAriaTabs({
        onSelect,
        selectedIndex,
        selectionMode,
        orientation
      });
      var {
        useTabListProps
      } = useTabsList();
      return v$1("div", {
        class: clsx("tabs-container", "tabs-orientation-".concat(orientation))
      }, v$1(UseTabContext.Provider, {
        value: useTab
      }, B(children[0], useTabListProps(useMergedProps()({
        className: clsx("nav", visualVariant == "pills" ? "nav-pills" : "nav-tabs")
      }, _objectSpread2({}, props))), children[0].props.children)), v$1(UseTabPanelContext.Provider, {
        value: useTabPanel
      }, v$1(Swappable, null, v$1("div", {
        class: "tab-content"
      }, children.slice(1)))));
    }
    function Tab(_ref2) {
      var {
        index,
        children
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$2);

      var useTabContext = F(UseTabContext);
      var {
        useTabProps,
        selected
      } = useTabContext({
        index,
        text: null,
        tag: "button"
      });
      return v$1("li", {
        className: "nav-item",
        role: "presentation"
      }, v$1("button", _objectSpread2({}, useTabProps(useMergedProps()({
        class: clsx("nav-link", selected && "active")
      }, props))), children));
    }
    function TabPanel(_ref3) {
      var {
        index,
        children,
        Transition
      } = _ref3,
          rest = _objectWithoutProperties(_ref3, _excluded3$2);

      var useTabPanel = F(UseTabPanelContext);
      var {
        useTabPanelProps,
        selected
      } = useTabPanel({
        index
      });
      return v$1(Transition, useTabPanelProps(_objectSpread2({
        class: "",
        open: selected,
        children
      }, rest)));
    }

    var PushToastContext = D$1(null);
    var DefaultToastTimeout = D$1(5000);
    function ToastsProvider({
      children,
      defaultTimeout
    }) {
      var [pushToast, setPushToast] = useState(null);
      var pushToastStable = useStableCallback(toast => {
        pushToast === null || pushToast === void 0 ? void 0 : pushToast(toast);
      });
      return v$1(d$1, null, v$1(DefaultToastTimeout.Provider, {
        value: defaultTimeout !== null && defaultTimeout !== void 0 ? defaultTimeout : 5000
      }, v$1(ToastsProviderHelper, {
        setPushToast: setPushToast
      }), pushToast && v$1(PushToastContext.Provider, {
        value: pushToastStable
      }, children)));
    }
    function usePushToast() {
      var pushToast = F(PushToastContext);
      return pushToast;
    } // Extracted to a separate component to avoid rerendering all non-toast children

    function ToastsProviderHelper({
      setPushToast
    }) {
      var [children, setChildren] = useState([]);
      var pushToast = A$1(toast => {
        var randomKey = generateRandomId();
        setChildren(prev => [...prev, B(toast, {
          key: randomKey
        })]);
      }, []);
      h(() => {
        setPushToast(_ => pushToast);
      }, [pushToast]);
      return v$1(BodyPortal, null, v$1(ToastsContainerChildrenContext.Provider, {
        value: children
      }, v$1(ToastsContainer, null)));
    }

    var ToastsContainerChildrenContext = D$1([]);
    var UseToastContext = D$1(null);

    function ToastsContainer(props) {
      var children = F(ToastsContainerChildrenContext);
      var {
        useToast,
        useToastContainerProps
      } = useToasts(props);
      return v$1(UseToastContext.Provider, {
        value: useToast
      }, v$1("div", _objectSpread2({}, useToastContainerProps(props)), children));
    }

    var ToastDismissContext = D$1(null);
    function Toast({
      timeout,
      politeness,
      children
    }) {
      var useToast = F(UseToastContext);
      var defaultTimeout = F(DefaultToastTimeout);
      var {
        useToastProps,
        dismiss,
        status
      } = useToast({
        timeout: timeout !== null && timeout !== void 0 ? timeout : defaultTimeout,
        politeness
      });
      return v$1(ToastDismissContext.Provider, {
        value: dismiss
      }, v$1(SlideFade, {
        open: status != "dismissed",
        slideTargetInline: 1,
        animateOnMount: true,
        exitVisibility: "removed"
      }, v$1("div", _objectSpread2({}, useToastProps({
        class: "toast show"
      })), v$1("div", {
        class: "d-flex"
      }, v$1("div", {
        class: "toast-body"
      }, children), v$1(Button, {
        class: "btn-close me-2 m-auto",
        "aria-label": "Dismiss alert",
        onClick: dismiss
      })))));
    }
    /*
    export function ToastHeader({ children }: { children: ComponentChildren }) {
        return (
            <div class="toast-header">
                <div class="me-auto">
                    {children}
                </div>
                <Button class="btn-close" aria-label="Close" />
            </div>
        )
    }*/

    var _excluded$2 = ["children", "position", "tooltip", "Transition", "mouseoverDelay"];
    function Tooltip(_ref) {
      var {
        children,
        position,
        tooltip,
        Transition,
        mouseoverDelay
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$2);

      var {
        getIsOpen,
        isOpen,
        useTooltip,
        useTooltipTrigger
      } = useAriaTooltip({
        mouseoverDelay
      });
      var {
        useElementSizeProps,
        elementSize
      } = useElementSize();
      var cloneable;

      if (typeof children === "string" || typeof children === "number" || typeof children == "boolean" || typeof children === "bigint") {
        cloneable = v$1("span", null, children);
      } else if (Array.isArray(children)) {
        cloneable = v$1("span", null, children);
      } else {
        cloneable = children;
      }

      var {
        useTooltipProps
      } = useTooltip();
      var {
        useTooltipTriggerProps
      } = useTooltipTrigger();
      var {
        shouldUpdate,
        onInteraction
      } = useShouldUpdatePopper(isOpen, elementSize);
      var {
        getLogicalDirection,
        usePopperArrow,
        usePopperPopup,
        usePopperSource,
        usedPlacement
      } = usePopperApi({
        updating: shouldUpdate,
        position
      });
      var {
        usePopperPopupProps
      } = usePopperPopup({
        open: isOpen
      });
      var {
        usePopperArrowProps
      } = usePopperArrow();
      var {
        usePopperSourceProps
      } = usePopperSource();
      var logicalDirection = getLogicalDirection();
      if (logicalDirection && usedPlacement) rest = fixProps(logicalDirection, "block-end", usedPlacement, rest); // TODO: It's required for this to be exitVisibility="hidden" for transforms to work?
      // Probably an issue in the Transition element itself because it's not browser-specific but it's a little weird

      return v$1(d$1, null, B(cloneable, useMergedProps()({
        ref: cloneable.ref
      }, useTooltipTriggerProps(useElementSizeProps(usePopperSourceProps(cloneable.props))))), v$1(BodyPortal, null, v$1("div", _objectSpread2({}, usePopperPopupProps({
        class: "tooltip-wrapper"
      })), v$1(Transition, _objectSpread2(_objectSpread2({}, rest), {}, {
        open: isOpen,
        onTransitionUpdate: onInteraction,
        exitVisibility: "hidden"
      }), v$1("div", _objectSpread2({}, useTooltipProps(useMergedProps()({
        class: "tooltip show",
        role: "tooltip"
      }, {}))), v$1("div", _objectSpread2({}, usePopperArrowProps({
        class: "tooltip-arrow"
      }))), v$1("div", {
        class: "tooltip-inner"
      }, tooltip))))));
    }

    var _excluded$1 = ["children"],
        _excluded2$1 = ["children"],
        _excluded3$1 = ["type"],
        _excluded4$1 = ["type"],
        _excluded5$1 = ["type", "tag"],
        _excluded6$1 = ["type", "tag"],
        _excluded7$1 = ["type", "src"],
        _excluded8 = ["tag"],
        _excluded9 = ["position"],
        _excluded10 = ["tag"],
        _excluded11 = ["tag"];
    var Card = forwardElementRef(function Card(p, ref) {
      var {
        children
      } = p,
          props = _objectWithoutProperties(p, _excluded$1);

      return v$1("div", _objectSpread2({}, useMergedProps()({
        ref,
        className: "card"
      }, props)), children);
    });

    function CardElement2(_ref, ref) {
      var {
        children
      } = _ref,
          p = _objectWithoutProperties(_ref, _excluded2$1);

      switch (p.type) {
        default:
        case "paragraph":
          {
            var props = _objectWithoutProperties(p, _excluded3$1);

            return v$1(CardBody, _objectSpread2(_objectSpread2({}, props), {}, {
              ref: ref
            }), v$1(CardText, null, children));
          }

        case "footer":
          {
            var props = _objectWithoutProperties(p, _excluded4$1);

            return v$1(CardFooter, _objectSpread2(_objectSpread2({}, props), {}, {
              ref: ref
            }), children);
          }

        case "subtitle":
          {
            var {
              type: _type2,
              tag
            } = p,
                props = _objectWithoutProperties(p, _excluded5$1);

            return v$1(CardBody, _objectSpread2(_objectSpread2({}, props), {}, {
              ref: ref
            }), v$1(CardSubtitle, {
              tag: tag
            }, children));
          }

        case "title":
          {
            var {
              type: _type3,
              tag: _tag
            } = p,
                props = _objectWithoutProperties(p, _excluded6$1);

            return v$1(CardBody, _objectSpread2(_objectSpread2({}, props), {}, {
              ref: ref
            }), v$1(CardTitle, {
              tag: _tag
            }, children));
          }

        case "image":
          {
            var {
              type: _type4,
              src
            } = p,
                props = _objectWithoutProperties(p, _excluded7$1);

            return v$1(CardImage, _objectSpread2(_objectSpread2({
              src: src,
              position: "both"
            }, props), {}, {
              ref: ref
            }), children);
          }

        case "flush":
          {
            var {
              tag: _tag2
            } = p,
                props = _objectWithoutProperties(p, _excluded8);

            return v$1(_tag2, props, children);
          }
      }
    }

    var CardElement = forwardElementRef(CardElement2);
    var CardImage = forwardElementRef(function CardImage(p, ref) {
      var {
        position
      } = p,
          props = _objectWithoutProperties(p, _excluded9);

      return v$1("img", _objectSpread2({}, useMergedProps()(props, {
        ref,
        className: "card-img".concat(position == "both" ? "" : "-".concat(position))
      })));
    });
    var CardBody = forwardElementRef(function CardBody(props, ref) {
      return v$1("div", _objectSpread2({}, useMergedProps()(props, {
        ref,
        className: "card-body"
      })));
    });
    var CardFooter = forwardElementRef(function CardHeader(props, ref) {
      return v$1("div", _objectSpread2({}, useMergedProps()(props, {
        ref,
        className: "card"
      })));
    });
    var CardTitle = forwardElementRef(function CardTitle(p, ref) {
      var {
        tag
      } = p,
          props = _objectWithoutProperties(p, _excluded10);

      return v$1(tag !== null && tag !== void 0 ? tag : "h5", useMergedProps()(props, {
        ref,
        className: "card-title"
      }));
    });
    var CardSubtitle = forwardElementRef(function CardSubtitle(p, ref) {
      var {
        tag
      } = p,
          props = _objectWithoutProperties(p, _excluded11);

      return v$1(tag !== null && tag !== void 0 ? tag : "h5", useMergedProps()(props, {
        ref,
        className: clsx("card-subtitle", "mb-2", "text-muted")
      }));
    });
    var CardText = forwardElementRef(function CardText(props, ref) {
      return v$1("div", _objectSpread2({}, useMergedProps()(props, {
        ref,
        className: "card-text"
      })));
    });
    forwardElementRef(function CardHeader(props, ref) {
      return v$1("div", _objectSpread2({}, useMergedProps()(props, {
        ref,
        className: "card-header"
      })));
    });
    v$1(CardElement, {
      type: "title",
      tag: "h1",
      children: "",
      class: ""
    });

    function DemoButtons() {
        var _this = this;
        var _a = useState("outline"), buttonsFill = _a[0], setButtonsFill = _a[1];
        var _b = useState("md"), buttonsSize = _b[0];
        var _c = useState("primary"), buttonsColor = _c[0], setButtonsColor = _c[1];
        var _d = useState(false), toggleOn = _d[0], setToggleOn = _d[1];
        var _e = useState(3000), asyncTimeout = _e[0], setAsyncTimeout = _e[1];
        var _f = useState(true), usesAsync = _f[0], setUsesAsync = _f[1];
        var _g = useState(false), asyncFails = _g[0], setAsyncFails = _g[1];
        var _h = useState(true), usesLinkButton = _h[0], setUsesLinkButton = _h[1];
        var pushToast = usePushToast();
        var onClickSync = function () { return pushToast(v$1(Toast, null, "Button was clicked")); };
        var onClickAsync = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$4(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Button operation failed.");
                        else
                            onClickSync();
                        return [2 /*return*/];
                }
            });
        }); };
        var onClick = usesAsync ? onClickAsync : onClickSync;
        var onToggleInputAsync = function (b) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$4(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Button operation failed.");
                        else
                            setToggleOn(b);
                        return [2 /*return*/];
                }
            });
        }); };
        var onToggleInput = usesAsync ? onToggleInputAsync : setToggleOn;
        return (v$1(ProvideDefaultButtonFill, { value: buttonsFill },
            v$1(ProvideDefaultButtonSize, { value: buttonsSize },
                v$1(ProvideDefaultButtonColor, { value: buttonsColor },
                    v$1("div", { class: "demo" },
                        v$1(Card, null,
                            v$1(CardElement, { type: "title", tag: "h2" }, "Buttons"),
                            v$1(CardElement, null,
                                v$1(Button, { onClick: onClick }, "I'm a button")),
                            v$1(CardElement, null,
                                "A ",
                                v$1("code", null, "Button"),
                                " is a ",
                                v$1("code", null, "Button"),
                                " is a ",
                                v$1("code", null, "Button"),
                                " \u2013 you can click, tap, or Space-key it to activate it and do something.  If the given action is asynchronous, then the button will disable itself and display a spinner during the operation."),
                            v$1(CardElement, { type: "subtitle", tag: "h3" }, "Async inputs"),
                            v$1(CardElement, null,
                                "The ",
                                v$1("code", null, "onClick"),
                                " event handler for buttons can be sync or async, and they will react appropriately if the operation takes long enough.",
                                v$1(InputGrid, null,
                                    v$1(InputGroup, null,
                                        v$1(Checkbox, { onInput: setUsesAsync, checked: usesAsync, labelPosition: "start" }, "Use async handler")),
                                    v$1(InputGroup, null,
                                        v$1(Checkbox, { onInput: setAsyncFails, checked: asyncFails, labelPosition: "start", disabled: !usesAsync }, "Async handler rejects")),
                                    v$1(InputGroup, null,
                                        v$1(Input, { width: "8ch", disabled: !usesAsync, type: "number", onInput: setAsyncTimeout, value: asyncTimeout }, "Async timeout")))),
                            v$1(CardElement, null,
                                v$1(Button, { onClick: onClick }, "Click me")),
                            v$1(CardElement, { type: "paragraph" },
                                v$1("code", null, "const onClick = " + (usesAsync ? "async " : "") + "() => { " + (usesAsync ? "await sleep(" + asyncTimeout + "); " : "") + "pushToast(<Toast ... />); }\n<Button onClick={onClick}>Click me</Button>")),
                            v$1("hr", null),
                            v$1(CardElement, { type: "subtitle", tag: "h3" }, "Color & fill"),
                            v$1(CardElement, { type: "paragraph" },
                                "Buttons can be styled in different colors and fill styles. You can provide a global default with ",
                                v$1("code", null, "Context"),
                                " objects, like ",
                                v$1("code", null, "<ProvideDefaultButtonFill>"),
                                "."),
                            v$1(CardElement, null,
                                "All outline styles have extra CSS applied to make them have correct contrast ratios on the default body background, partially because toggle buttons don't allow their ",
                                v$1("code", null, "fill"),
                                " to be controlled."),
                            v$1(CardElement, null,
                                v$1(ButtonGroup, null,
                                    v$1(ButtonGroupChild, { index: 0, onInput: function () { return setButtonsFill("fill"); }, pressed: buttonsFill === "fill", colorVariant: "primary" }, "Fill"),
                                    v$1(ButtonGroupChild, { index: 1, onInput: function () { return setButtonsFill("outline"); }, pressed: buttonsFill === "outline", colorVariant: "primary" }, "Outline"))),
                            v$1(CardElement, null,
                                v$1(ButtonGroup, { wrap: true },
                                    v$1(ButtonGroupChild, { index: 0, colorVariant: "primary", pressed: buttonsColor == "primary", onInput: function () { return setButtonsColor("primary"); } }, "Primary"),
                                    v$1(ButtonGroupChild, { index: 1, colorVariant: "secondary", pressed: buttonsColor == "secondary", onInput: function () { return setButtonsColor("secondary"); } }, "Secondary"),
                                    v$1(ButtonGroupChild, { index: 2, colorVariant: "success", pressed: buttonsColor == "success", onInput: function () { return setButtonsColor("success"); } }, "Success"),
                                    v$1(ButtonGroupChild, { index: 3, colorVariant: "warning", pressed: buttonsColor == "warning", onInput: function () { return setButtonsColor("warning"); } }, "Warning"),
                                    v$1(ButtonGroupChild, { index: 4, colorVariant: "danger", pressed: buttonsColor == "danger", onInput: function () { return setButtonsColor("danger"); } }, "Danger"),
                                    v$1(ButtonGroupChild, { index: 5, colorVariant: "info", pressed: buttonsColor == "info", onInput: function () { return setButtonsColor("info"); } }, "Info"),
                                    v$1(ButtonGroupChild, { index: 6, colorVariant: "light", pressed: buttonsColor == "light", onInput: function () { return setButtonsColor("light"); } }, "Light"),
                                    v$1(ButtonGroupChild, { index: 7, colorVariant: "dark", pressed: buttonsColor == "dark", onInput: function () { return setButtonsColor("dark"); } }, "Dark"))),
                            v$1(CardElement, null,
                                v$1(Button, { onClick: onClick },
                                    buttonsFill === "fill" ? "Filled" : "Outlined",
                                    " ",
                                    buttonsColor,
                                    " button")),
                            v$1(CardElement, null,
                                v$1("code", null, "<Button fillVariant=\"" + buttonsFill + "\" colorVariant=\"" + buttonsColor + "\">Variant button</Button>")),
                            v$1("hr", null),
                            v$1(CardElement, { type: "subtitle", tag: "h3" }, "Link buttons"),
                            v$1(CardElement, null,
                                "A link can be styled as a button while retaining native link functionality (middle clicks, etc.). These buttons have no ",
                                v$1("code", null, "onClick"),
                                " handler, instead taking ",
                                v$1("code", null, "href"),
                                " and the other ",
                                v$1("code", null, "<a>"),
                                " props."),
                            v$1(CardElement, null,
                                "A ",
                                v$1("code", null, "<Button>"),
                                " will use an anchor link internally if you provide it with an ",
                                v$1("code", null, "href"),
                                " prop, or optionally setting the ",
                                v$1("code", null, "tag"),
                                " prop to ",
                                v$1("code", null, "a"),
                                ".",
                                v$1(InputGroup, null,
                                    v$1(Checkbox, { onInput: setUsesLinkButton, checked: usesLinkButton, labelPosition: "start" }, "Use link button"))),
                            v$1(CardElement, null, usesLinkButton ? v$1(Button, { target: "_blank", href: "https://www.example.com" },
                                "example.com ",
                                v$1("i", { class: "bi bi-box-arrow-up-right" })) : v$1(Button, { onClick: onClick }, "Regular button")),
                            v$1(CardElement, { type: "paragraph" },
                                v$1("code", null, usesLinkButton ? "<Button href=\"https://www.example.com\">Link button</Button>" : "<Button onClick={onClick}>Regular button</Button>")),
                            v$1("hr", null),
                            v$1(CardElement, { type: "subtitle", tag: "h3" }, "Toggle buttons"),
                            v$1(CardElement, null,
                                "If given a ",
                                v$1("code", null, "pressed"),
                                " prop, a button will become a toggle button, with an off/on state.  It will style itself as outlined when unpressed, and filled when pressed, so they are best used in groups."),
                            v$1(CardElement, null,
                                v$1(Button, { pressed: toggleOn, onInput: onToggleInput }, "Toggle button")),
                            v$1(CardElement, { type: "paragraph" },
                                v$1("code", null, "<Button pressed={pressed} onInput={onInput}>Toggle button</Button>")),
                            v$1("hr", null),
                            v$1(CardElement, { type: "subtitle", tag: "h3" }, "Button Groups"),
                            v$1(CardElement, null,
                                "A ",
                                v$1("code", null, "<ButtonGroup>"),
                                " can be used to group a set of ",
                                v$1("code", null, "<ButtonGroupChild>"),
                                " (which is the exact same as a ",
                                v$1("code", null, "<Button>"),
                                ", but with an ",
                                v$1("code", null, "index"),
                                " prop). This gives them keyboard navigation abilities."),
                            v$1(CardElement, null,
                                v$1(ButtonGroup, { wrap: true },
                                    v$1(ButtonGroupChild, { index: 0, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "First button"),
                                    v$1(ButtonGroupChild, { index: 1, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Second button"),
                                    v$1(ButtonGroupChild, { index: 2, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Third button"),
                                    v$1(ButtonGroupChild, { index: 3, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Fourth button"),
                                    v$1(ButtonGroupChild, { index: 4, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Fifth button"),
                                    v$1(ButtonGroupChild, { index: 5, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Sixth button"),
                                    v$1(ButtonGroupChild, { index: 6, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Seventh button"),
                                    v$1(ButtonGroupChild, { index: 7, fillVariant: buttonsFill, colorVariant: buttonsColor, onClick: onClick }, "Eighth button"))),
                            v$1(CardElement, { type: "paragraph" },
                                v$1("code", null, "<ButtonGroup wrap>\n    <ButtonGroupChild index={0}>First button</ButtonGroupChild>\n    <ButtonGroupChild index={1}>Second button</ButtonGroupChild>\n    <ButtonGroupChild index={2}>Third button</ButtonGroupChild>\n    <ButtonGroupChild index={3}>Fourth button</ButtonGroupChild>\n    <ButtonGroupChild index={4}>Fifth button</ButtonGroupChild>\n    <ButtonGroupChild index={5}>Sixth button</ButtonGroupChild>\n    <ButtonGroupChild index={6}>Seventh button</ButtonGroupChild>\n    <ButtonGroupChild index={7}>Eighth button</ButtonGroupChild>\n</ButtonGroup>"))))))));
    }
    function sleep$4(arg0) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, arg0); })];
            });
        });
    }

    function DemoChecks() {
        var _this = this;
        var _a = useState(false), asyncFails = _a[0], setAsyncFails = _a[1];
        var _b = useState(3000), asyncTimeout = _b[0], setAsyncTimeout = _b[1];
        var _c = useState(true), usesAsync = _c[0], setUsesAsync = _c[1];
        var _d = useState(false), demoChecked = _d[0], setDemoChecked = _d[1];
        var _e = useState(0), demoRadio = _e[0], setDemoRadio = _e[1];
        var _f = useState(false), disabled = _f[0], setDisabled = _f[1];
        var _g = useState("end"), labelPosition = _g[0], setLabelPosition = _g[1];
        var asyncCheckboxInput = A$1(function (checked) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$3(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Attempt to change checkbox & radio failed");
                        setDemoChecked(checked);
                        return [2 /*return*/];
                }
            });
        }); }, [asyncTimeout, asyncFails]);
        var asyncRadioInput = A$1(function (value) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$3(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Attempt to change radio failed");
                        setDemoRadio(value);
                        return [2 /*return*/];
                }
            });
        }); }, [asyncTimeout, asyncFails]);
        return (v$1("div", { class: "demo" },
            v$1(Card, null,
                v$1(CardElement, { type: "title", tag: "h2" }, "Checkboxes, switches, & radios"),
                v$1(CardElement, null,
                    v$1(Checkbox, { checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "I'm a checkbox")),
                v$1(CardElement, null,
                    "Several components related to on/off togglable form-like selection controls are provided:",
                    v$1("ul", null,
                        v$1("li", null,
                            v$1("code", null, "Checkbox")),
                        v$1("li", null,
                            v$1("code", null, "Switch")),
                        v$1("li", null,
                            v$1("code", null, "Radio")),
                        v$1("li", null,
                            v$1("code", null, "Checkbox Group"))),
                    v$1("code", null, "Checkbox"),
                    " and ",
                    v$1("code", null, "Switch"),
                    " work as you'd expect. ",
                    v$1("code", null, "RadioGroup"),
                    " is a parent around a set of ",
                    v$1("code", null, "Radio"),
                    " components that communicate with each other. The children ",
                    v$1("code", null, "Radio"),
                    " components can be any descendant of the parent ",
                    v$1("code", null, "RadioGroup"),
                    " \u2013 the DOM structure ",
                    v$1("em", null, "does not"),
                    " matter beyond requiring they be somewhere descendant. ",
                    v$1("code", null, "CheckboxGroup"),
                    " works similarly to ",
                    v$1("code", null, "RadioGroup"),
                    " in that way."),
                v$1(CardElement, null,
                    "See Also: Single Select lists for an alternative to ",
                    v$1("code", null, "RadioGroup"),
                    ", and Multi Select lists for an alternative to ",
                    v$1("code", null, "CheckboxGroup"),
                    "."),
                v$1(CardElement, { type: "subtitle", tag: "h3" }, "Async inputs"),
                v$1(CardElement, null,
                    "The ",
                    v$1("code", null, "onInput"),
                    " event handler for all types of inputs can be sync or async.",
                    v$1(InputGrid, null,
                        v$1(InputGroup, null,
                            v$1(Checkbox, { onInput: setUsesAsync, checked: usesAsync, labelPosition: "start" }, "Async event handler")),
                        v$1(InputGroup, null,
                            v$1(Checkbox, { onInput: setAsyncFails, checked: asyncFails, labelPosition: "start", disabled: !usesAsync }, "Async handler rejects")),
                        v$1(InputGroup, null,
                            v$1(Input, { disabled: !usesAsync, type: "number", onInput: setAsyncTimeout, value: asyncTimeout }, "Async timeout")))),
                v$1(CardElement, null,
                    v$1(Checkbox, { checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Checkbox"),
                    v$1(Switch, { checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Switch")),
                v$1(CardElement, null,
                    v$1(RadioGroup, { name: "radio-demo-1", selectedValue: demoRadio, onInput: usesAsync ? asyncRadioInput : setDemoRadio },
                        v$1(Radio, { index: 0, value: 0 }, "Radio #1"),
                        v$1(Radio, { index: 1, value: 1 }, "Radio #2"),
                        v$1(Radio, { index: 2, value: 2 }, "Radio #3"))),
                v$1(CardElement, { type: "paragraph" },
                    v$1("code", null, "<Checkbox checked={checked} onInput={setChecked}>Checkbox</Checkbox>\n<Switch checked={checked} onInput={onInput}>Switch</Switch>\n<RadioGroup name=\"radio-demo-1\" selectedValue={value} onInput={setValue}>\n<Radio index={0} value=\"value1\">Radio #1</Radio>\n<Radio index={1} value=\"value2\">Radio #2</Radio>\n<Radio index={2} value=\"value3\">Radio #3</Radio>\n</RadioGroup>")),
                v$1("hr", null),
                v$1(CardElement, { type: "subtitle", tag: "h3" }, "Disabling"),
                v$1(CardElement, null,
                    "When disabled, all inputs remain focusable so that they can still be announced by screen readers, have tooltips via mouseover, etc.",
                    v$1(InputGroup, null,
                        v$1(Checkbox, { onInput: setDisabled, checked: disabled, labelPosition: "start" }, "Inputs disabled"))),
                v$1(CardElement, null,
                    v$1(Checkbox, { disabled: disabled, checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Checkbox "),
                    v$1(Switch, { disabled: disabled, checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Switch")),
                v$1(CardElement, null,
                    v$1(RadioGroup, { name: "radio-demo-2", selectedValue: demoRadio, onInput: usesAsync ? asyncRadioInput : setDemoRadio },
                        v$1(Radio, { disabled: disabled, index: 0, value: 0 }, "Radio #1"),
                        v$1(Radio, { disabled: disabled, index: 1, value: 1 }, "Radio #2"),
                        v$1(Radio, { disabled: disabled, index: 2, value: 2 }, "Radio #3"))),
                v$1("hr", null),
                v$1(CardElement, { type: "subtitle", tag: "h3" },
                    v$1("code", null, "InputGroup"),
                    " styling"),
                v$1(CardElement, { type: "paragraph" },
                    "An ",
                    v$1("code", null, "<InputGroup>"),
                    " can be used to significantly change the styling of input components. The inputs and their labels will style themselves or automatically wrap themselves in ",
                    v$1("code", null, "<InputGroupText>"),
                    " as appropriate."),
                v$1(CardElement, null,
                    v$1(InputGrid, null,
                        v$1(InputGroup, null,
                            v$1(Checkbox, { checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Checkbox")),
                        v$1(InputGroup, null,
                            v$1(Switch, { checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Switch")),
                        v$1(RadioGroup, { name: "radio-demo-5", selectedValue: demoRadio, onInput: usesAsync ? asyncRadioInput : setDemoRadio },
                            v$1(InputGroup, null,
                                v$1(Radio, { index: 0, value: 0 }, "Radio #1")),
                            v$1(InputGroup, null,
                                v$1(Radio, { index: 1, value: 1 }, "Radio #2")),
                            v$1(InputGroup, null,
                                v$1(Radio, { index: 2, value: 2 }, "Radio #3"))))),
                v$1(CardElement, { type: "paragraph" },
                    v$1("code", null, "<InputGroup>\n    <Checkbox checked={checked} onInput={setChecked}>Checkbox</Checkbox>\n</InputGroup>\n<InputGroup>\n    <Switch checked={checked} onInput={onInput}>Switch</Switch>\n</InputGroup>\n<RadioGroup name=\"radio-demo-5\" selectedValue={value} onInput={setValue}>\n    <InputGroup>\n        <Radio index={0} value=\"value1\" labelPosition=\"start\">Radio #1</Radio>\n        <Radio index={1} value=\"value2\" labelPosition=\"hidden\">Radio #2</Radio>\n        <Radio index={2} value=\"value3\" labelPosition=\"end\">Radio #3</Radio>\n    </InputGroup>\n</RadioGroup>")),
                v$1("hr", null),
                v$1(CardElement, { type: "subtitle", tag: "h3" }, "Labels"),
                v$1(CardElement, null,
                    "By default, the label is positioned after the checkbox, radio, or switch.  You can change this with ",
                    v$1("code", null, "labelPosition"),
                    "."),
                v$1(CardElement, null,
                    "Note that the ",
                    v$1("code", null, "start"),
                    " label position only has any visual effect while in an ",
                    v$1("code", null, "InputGroup"),
                    ", as Bootstrap places \"naked\" checkboxes and such in the margin area before the label no matter what order they come in the DOM."),
                v$1(CardElement, null,
                    v$1(RadioGroup, { name: "radio-demo-6", selectedValue: labelPosition, onInput: setLabelPosition, labelPosition: labelPosition },
                        v$1(Radio, { labelPosition: labelPosition, index: 0, value: "start" }, "Before"),
                        v$1(Radio, { labelPosition: labelPosition, index: 1, value: "end" }, "After"),
                        v$1(Radio, { labelPosition: labelPosition, index: 2, value: "hidden" }, "Hidden (still announced verbally)"))),
                v$1(CardElement, null,
                    v$1(InputGrid, null,
                        v$1(InputGroup, null,
                            v$1(Checkbox, { labelPosition: labelPosition, checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Checkbox")),
                        v$1(InputGroup, null,
                            v$1(Switch, { labelPosition: labelPosition, checked: demoChecked, onInput: usesAsync ? asyncCheckboxInput : setDemoChecked }, "Switch")),
                        v$1(RadioGroup, { name: "radio-demo-7", selectedValue: demoRadio, onInput: usesAsync ? asyncRadioInput : setDemoRadio },
                            v$1(InputGroup, null,
                                v$1(Radio, { labelPosition: labelPosition, index: 0, value: 0 }, "Radio #1")),
                            v$1(InputGroup, null,
                                v$1(Radio, { labelPosition: labelPosition, index: 1, value: 1 }, "Radio #2")),
                            v$1(InputGroup, null,
                                v$1(Radio, { labelPosition: labelPosition, index: 2, value: 2 }, "Radio #3"))))))));
    }
    function sleep$3(arg0) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, arg0); })];
            });
        });
    }

    function DemoInputs() {
        var _this = this;
        var _a = useState(false), asyncFails = _a[0], setAsyncFails = _a[1];
        var _b = useState(3000), asyncTimeout = _b[0], setAsyncTimeout = _b[1];
        var _c = useState(true), usesAsync = _c[0], setUsesAsync = _c[1];
        var _d = useState(""), text = _d[0], setText = _d[1];
        var _e = useState(0), number = _e[0], setNumber = _e[1];
        var asyncTextInput = A$1(function (text) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$2(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Attempt to change text failed");
                        setText(text);
                        return [2 /*return*/];
                }
            });
        }); }, [asyncTimeout, asyncFails]);
        var asyncNumberInput = A$1(function (value) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$2(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Attempt to change number failed");
                        setNumber(value);
                        return [2 /*return*/];
                }
            });
        }); }, [asyncTimeout, asyncFails]);
        var onTextInput = usesAsync ? asyncTextInput : setText;
        var onNumberInput = usesAsync ? asyncNumberInput : setNumber;
        return (v$1("div", { class: "demo" },
            v$1(Card, null,
                v$1(CardElement, { type: "title", tag: "h2" }, "Text boxes"),
                v$1(CardElement, null,
                    v$1("div", { class: "position-relative" },
                        v$1(Input, { type: "text", value: text, onInput: onTextInput }, "I'm a text box"))),
                v$1(CardElement, null,
                    "The ",
                    v$1("code", null, "onInput"),
                    " event handler for all types of inputs can be sync or async.",
                    v$1(InputGrid, null,
                        v$1(InputGroup, null,
                            v$1(Checkbox, { onInput: setUsesAsync, checked: usesAsync, labelPosition: "start" }, "Async event handler")),
                        v$1(InputGroup, null,
                            v$1(Checkbox, { onInput: setAsyncFails, checked: asyncFails, labelPosition: "start", disabled: !usesAsync }, "Async handler rejects")),
                        v$1(InputGroup, null,
                            v$1(Input, { disabled: !usesAsync, type: "number", onInput: setAsyncTimeout, value: asyncTimeout }, "Async timeout")))),
                v$1(CardElement, null,
                    v$1("div", { class: "position-relative" },
                        v$1(Input, { type: "text", value: text, onInput: onTextInput }, "Text-based input")),
                    v$1("div", { class: "position-relative" },
                        v$1(Input, { type: "number", value: number, onInput: onNumberInput, min: -5 }, "Number-based input"))),
                v$1(CardElement, { type: "paragraph" },
                    v$1("code", null, "<Input type=\"text\" value={text} onInput={onTextInput}>Text-based input</Input>\n<Input type=\"number\" value={number} onInput={onNumberInput} min={-5}>Number-based input</Input>")),
                v$1(CardElement, { type: "paragraph" },
                    "When placed in an ",
                    v$1("code", null, "<InputGroup>"),
                    ", the styling will be significantly different:"),
                v$1(CardElement, null,
                    v$1(InputGrid, null,
                        v$1(InputGroup, null,
                            v$1(Input, { type: "text", value: text, onInput: onTextInput }, "Text-based input")),
                        v$1(InputGroup, null,
                            v$1(Input, { type: "number", value: number, onInput: onNumberInput, min: -5 }, "Number-based input")))),
                v$1(CardElement, { type: "paragraph" },
                    v$1("code", null, "<InputGroup>\n    <Checkbox checked={checked} onInput={setChecked}>Checkbox</Checkbox>\n</InputGroup>\n<InputGroup>\n    <Switch checked={checked} onInput={onInput}>Switch</Switch>\n</InputGroup>\n<RadioGroup name=\"radio-demo-2\" selectedValue={value} onInput={setValue}>\n    <InputGroup>\n        <Radio index={0} value=\"value1\" labelPosition=\"start\">Radio #1</Radio>\n        <Radio index={1} value=\"value2\" labelPosition=\"hidden\">Radio #2</Radio>\n        <Radio index={2} value=\"value3\" labelPosition=\"end\">Radio #3</Radio>\n    </InputGroup>\n</RadioGroup>")))));
    }
    function sleep$2(arg0) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, arg0); })];
            });
        });
    }

    function DemoLayout() {
        var _this = this;
        var _a = useState(false), asyncFails = _a[0];
        var _b = useState(3000), asyncTimeout = _b[0];
        var _c = useState(true), usesAsync = _c[0];
        var _d = useState(""), text = _d[0], setText = _d[1];
        var _e = useState(0), setNumber = _e[1];
        var asyncTextInput = A$1(function (text) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$1(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Attempt to change text failed");
                        setText(text);
                        return [2 /*return*/];
                }
            });
        }); }, [asyncTimeout, asyncFails]);
        A$1(function (value) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep$1(asyncTimeout)];
                    case 1:
                        _a.sent();
                        if (asyncFails)
                            throw new Error("Attempt to change number failed");
                        setNumber(value);
                        return [2 /*return*/];
                }
            });
        }); }, [asyncTimeout, asyncFails]);
        var onTextInput = usesAsync ? asyncTextInput : setText;
        return (v$1("div", { class: "demo" },
            v$1(Card, null,
                v$1(CardElement, { type: "title", tag: "h2" }, "Text boxes"),
                v$1(CardElement, null,
                    v$1("div", { class: "position-relative" },
                        v$1(Input, { type: "text", value: text, onInput: onTextInput }, "I'm a text box"))),
                v$1(CardElement, null,
                    "Inputs can be placed within an ",
                    v$1("code", null, "InputGroup"),
                    ", but those ",
                    v$1("code", null, "InputGroup"),
                    "s can also be placed within an ",
                    v$1("code", null, "InputGrid"),
                    " that offers alignment for simple cases"),
                v$1(CardElement, null,
                    v$1(InputGrid, null,
                        v$1(InputGroup, null,
                            v$1(Checkbox, { disabled: true, checked: true, labelPosition: "start" }, "Checkbox")),
                        v$1(InputGroup, null,
                            v$1(Checkbox, { disabled: true, checked: true, labelPosition: "start" }, "Another checkbox")),
                        v$1(InputGroup, null,
                            v$1(Input, { onInput: function () { }, type: "number", value: 0, disabled: true }, "Numeric input")))),
                v$1(CardElement, null,
                    v$1(InputGroup, null,
                        v$1(Checkbox, { disabled: true, checked: true, labelPosition: "start" }, "Checkbox")),
                    v$1(InputGroup, null,
                        v$1(Checkbox, { disabled: true, checked: true, labelPosition: "start" }, "Another checkbox")),
                    v$1(InputGroup, null,
                        v$1(Input, { onInput: function () { }, type: "number", value: 0, disabled: true }, "Numeric input"))))));
    }
    function sleep$1(arg0) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, arg0); })];
            });
        });
    }

    var _excluded = ["children", "small", "striped", "hoverable", "border", "variant", "borderColor"],
        _excluded2 = ["children", "variant"],
        _excluded3 = ["children", "variant"],
        _excluded4 = ["children", "variant"],
        _excluded5 = ["children", "index", "variant"],
        _excluded6 = ["value", "children", "index", "variant", "focus", "active"],
        _excluded7 = ["index", "focus", "value", "children", "variant", "active"];
    var CurrentSortedColumnContext = D$1(null);
    var SetCurrentSortedColumnContext = D$1(null); // This is the hook that rows use for navigation

    var UseGridNavigationRowContext = D$1(null); // This is the hook that cells use for navigation

    var UseGridNavigationCellContext = D$1(null); // This is, internally, what the header cell calls when the user clicks it.
    // The body creates it--it sorts the known rows and updates the children.

    var InternalSortHandlerContext = D$1(null); // This is used by the body. It creates the sort handler, but in order
    // to get it to the head, where the clickable header cells are, we need
    // this Context, used by the parent Table, to fascilitate communication.

    var SetInternalSortHandlerContext = D$1(null);
    var Table = forwardElementRef(function Table(_ref, ref) {
      var {
        children,
        small,
        striped,
        hoverable,
        border,
        variant,
        borderColor
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded);

      var [sortedColumn, setSortedColumn] = useState(null); // This is the one that's used for the button in the table head

      var [internalSortHandler, setInternalSortHandler] = useState(null);
      return v$1("table", _objectSpread2({}, useMergedProps()({
        ref,
        role: "group",
        className: clsx("table", small && "table-sm", striped && "table-striped", hoverable && "table-hover", border === "all" && "table-bordered", border === "none" && "table-borderless", variant && "table-".concat(variant), borderColor && "border-".concat(borderColor))
      }, props)), v$1(SetInternalSortHandlerContext.Provider, {
        value: setInternalSortHandler
      }, v$1(InternalSortHandlerContext.Provider, {
        value: internalSortHandler
      }, v$1(CurrentSortedColumnContext.Provider, {
        value: sortedColumn
      }, v$1(SetCurrentSortedColumnContext.Provider, {
        value: setSortedColumn
      }, children)))));
    });
    var CellIsInHeaderContext = D$1(false);

    function noop() {}
    var TableHead = forwardElementRef(function TableHead(_ref2, ref) {
      var {
        children,
        variant
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2);

      var {
        focusedInner,
        useHasFocusProps
      } = useHasFocus({});
      var {
        cellIndex,
        rowIndex,
        rowCount,
        useGridNavigationRow
      } = useGridNavigation({
        focusOnChange: focusedInner
      });
      return v$1(UseGridNavigationRowContext.Provider, {
        value: useGridNavigationRow
      }, v$1(CellIsInHeaderContext.Provider, {
        value: true
      }, v$1("thead", _objectSpread2({}, useHasFocusProps(useMergedProps()({
        ref,
        role: "rowgroup",
        "data-current-row": rowIndex,
        "data-current-column": cellIndex,
        "data-row-count": rowCount,
        className: clsx(variant && "table-".concat(variant))
      }, props))), children)));
    });

    function compare3(lhs, rhs) {
      if ("".concat(+lhs) === lhs) lhs = +lhs;
      if ("".concat(+rhs) === rhs) rhs = +rhs;
      if (typeof lhs === "string") rhs = "".concat(rhs);
      if (typeof rhs === "string") lhs = "".concat(lhs);
      console.assert(typeof lhs === typeof rhs);
      if (typeof lhs === "string") return lhs.localeCompare(rhs);
      if (typeof lhs === "number") return +lhs - +rhs;
      return 0;
    }

    function compare2(lhs, rhs) {
      if (typeof lhs === "boolean" || lhs instanceof Date) lhs = +lhs;
      if (typeof rhs === "boolean" || rhs instanceof Date) rhs = +rhs;
      return compare3(lhs, rhs);
    }

    function compare1(lhs, rhs) {
      if (lhs == null && rhs == null) {
        // They're both null
        return 0;
      } else if (lhs == null || rhs == null) {
        // One of the two is null -- easy case
        return lhs != null ? -1 : 1;
      }

      return compare2(lhs, rhs);
    }

    var SortContext = D$1(null);
    var TableBody = forwardElementRef(function TableBody(_ref3, ref) {
      var {
        children,
        variant
      } = _ref3,
          props = _objectWithoutProperties(_ref3, _excluded3);

      var {
        focusedInner,
        useHasFocusProps
      } = useHasFocus({});
      var {
        cellIndex,
        rowIndex,
        rowCount,
        useGridNavigationRow,
        managedRows
      } = useGridNavigation({
        focusOnChange: focusedInner
      }); // This hooks up to internalSortHandler, used by the table head.

      var sort = A$1((column, direction) => {
        var sortedRows = managedRows.slice().sort((lhsRow, rhsRow) => {
          var result = compare1(lhsRow.getManagedCells()[column].literalValue, rhsRow.getManagedCells()[column].literalValue);
          if (direction[0] == "d") return -result;
          return result;
        });

        var _loop = function (literalIndex) {
          var displayIndex = sortedRows[literalIndex].index;
          var displayCells = sortedRows[displayIndex].getManagedCells();
          var literalCells = sortedRows[literalIndex].getManagedCells();
          managedRows[literalIndex].setDisplayRowIndex(displayIndex);

          var _loop2 = function (_cellIndex) {
            displayCells[_cellIndex].provideWithSiblingsSetDisplayValue(() => literalCells[_cellIndex].setDisplayValue);
          };

          for (var _cellIndex = 0; _cellIndex < displayCells.length; ++_cellIndex) {
            _loop2(_cellIndex);
          }
        };

        for (var literalIndex = 0; literalIndex < sortedRows.length; ++literalIndex) {
          _loop(literalIndex);
        }
      }, []);
      var setInternalSortHandler = F(SetInternalSortHandlerContext);
      y(() => {
        setInternalSortHandler(() => sort);
      }, [setInternalSortHandler, sort]);
      return v$1("tbody", _objectSpread2({}, useHasFocusProps(useMergedProps()({
        ref,
        role: "rowgroup",
        "data-current-row": rowIndex,
        "data-current-column": cellIndex,
        "data-row-count": rowCount,
        className: clsx(variant && "table-".concat(variant))
      }, props))), v$1(UseGridNavigationRowContext.Provider, {
        value: useGridNavigationRow
      }, v$1(SortContext.Provider, {
        value: sort
      }, children)));
    });
    forwardElementRef(function TableFoot(_ref4, ref) {
      var {
        children,
        variant
      } = _ref4,
          props = _objectWithoutProperties(_ref4, _excluded4);

      var {
        focusedInner,
        useHasFocusProps
      } = useHasFocus({});
      var {
        cellIndex,
        rowIndex,
        rowCount,
        useGridNavigationRow
      } = useGridNavigation({
        focusOnChange: focusedInner
      });
      return v$1(UseGridNavigationRowContext.Provider, {
        value: useGridNavigationRow
      }, v$1("tfoot", _objectSpread2({}, useHasFocusProps(useMergedProps()({
        ref,
        "data-current-row": rowIndex,
        "data-current-column": cellIndex,
        "data-row-count": rowCount,
        className: clsx(variant && "table-".concat(variant))
      }, props))), children));
    });
    var TableRow = forwardElementRef(function TableRow(_ref5, ref) {
      var {
        children,
        index: literalIndex,
        variant
      } = _ref5,
          props = _objectWithoutProperties(_ref5, _excluded5);

      var useGridNavigationRow = F(UseGridNavigationRowContext);
      var [displayIndex, setDisplayIndex] = useState(literalIndex);
      var {
        cellCount,
        useGridNavigationRowProps,
        useGridNavigationCell,
        tabbableCell,
        isTabbableRow,
        managedCells
      } = useGridNavigationRow({
        index: literalIndex,
        setDisplayRowIndex: setDisplayIndex,
        getManagedCells: useStableCallback(() => managedCells)
      });
      F(CellIsInHeaderContext);

      var rowProps = _objectSpread2({
        children
      }, useMergedProps()({
        ref,
        role: "row",
        "data-literal-index": literalIndex,
        "data-display-index": displayIndex,
        "data-tabbable": "".concat(isTabbableRow),
        "data-tabbable-cell": "".concat(tabbableCell),
        className: clsx(variant && "table-".concat(variant)),
        "data-cell-count": cellCount
      }, props)); // This is what we display under the default circumstance (we're displaying our own row)


      var rowJsx = v$1("tr", _objectSpread2({}, useGridNavigationRowProps(rowProps)), children);
      return v$1(UseGridNavigationCellContext.Provider, {
        value: useGridNavigationCell
      }, v$1(DisplayRowIndexContext.Provider, {
        value: displayIndex
      }, rowJsx));
    });
    var DisplayRowIndexContext = D$1(null);
    var TableCell = forwardElementRef(function TableCell(_ref6, ref) {
      var _focus;

      var {
        value: literalValue,
        children,
        index,
        variant,
        focus,
        active
      } = _ref6,
          props = _objectWithoutProperties(_ref6, _excluded6);

      (_focus = focus) !== null && _focus !== void 0 ? _focus : focus = "cell";
      var useGridNavigationCell = F(UseGridNavigationCellContext);
      var [displayValue, setDisplayValue] = useState(literalValue);
      var [setSiblingDisplayValue, provideWithSiblingsSetDisplayValue] = useState(null);
      var {
        tabbable,
        useGridNavigationCellProps
      } = useGridNavigationCell({
        index,
        text: null,
        value: displayValue,
        literalValue,
        provideWithSiblingsSetDisplayValue,
        setDisplayValue
      });
      var displayRowIndex = F(DisplayRowIndexContext);
      var cellProps = useMergedProps()({
        ref,
        role: "gridcell",
        "data-literal-value": literalValue,
        "data-display-value": displayValue,
        "data-display-row": displayRowIndex,
        className: clsx(variant && "table-".concat(variant))
      }, props);
      y(() => {
        setSiblingDisplayValue === null || setSiblingDisplayValue === void 0 ? void 0 : setSiblingDisplayValue(literalValue);
      }, [setSiblingDisplayValue, literalValue]);

      if (children) {
        return v$1("td", _objectSpread2({}, cellProps), v$1(children, useGridNavigationCellProps({
          displayRowIndex,
          displayValue,
          className: "test"
        })));
      } else {
        return v$1("td", _objectSpread2({}, useGridNavigationCellProps(cellProps)), stringify(displayValue));
      }
    });
    var TableHeaderCell = forwardElementRef(function TableHeaderCell(_ref7, ref) {
      var _focus2;

      var {
        index,
        focus,
        value,
        children,
        variant,
        active
      } = _ref7,
          props = _objectWithoutProperties(_ref7, _excluded7);

      (_focus2 = focus) !== null && _focus2 !== void 0 ? _focus2 : focus = "cell";
      var [sortDirection, setSortDirection, getSortDirection] = useState(null);
      var isInTHead = F(CellIsInHeaderContext);
      var useGridNavigationCell = F(UseGridNavigationCellContext);
      var {
        useRefElementProps,
        element
      } = useRefElement();
      var [text, setText] = useState(null);
      h(() => {
        if (element) {
          setText(element.innerText);
        }
      }, [element]);
      var {
        tabbable,
        useGridNavigationCellProps
      } = useGridNavigationCell({
        index,
        text,
        value,
        literalValue: value,
        setDisplayValue: noop,
        provideWithSiblingsSetDisplayValue: noop
      });
      var currentSortedColumn = F(CurrentSortedColumnContext);
      var setCurrentSortedColumn = F(SetCurrentSortedColumnContext);
      y(() => {
        if (currentSortedColumn != index) setSortDirection(null);
      }, [currentSortedColumn, index]);
      var onSort = F(InternalSortHandlerContext);
      var onSortClick = A$1(() => {
        var nextSortDirection = getSortDirection();
        if (nextSortDirection === "ascending") nextSortDirection = "descending";else nextSortDirection = "ascending";
        setSortDirection(nextSortDirection);
        onSort === null || onSort === void 0 ? void 0 : onSort(index, nextSortDirection);
        setCurrentSortedColumn(prev => index);
      }, [onSort, index]);
      var cellProps = useButtonLikeEventHandlers("th", onSortClick, undefined)(useRefElementProps(useMergedProps()({
        ref,
        role: "columnheader",
        scope: isInTHead ? "col" : "row",
        className: clsx(variant && "table-".concat(variant))
      }, props)));
      var sortIcon = v$1(Swappable, null, v$1("div", {
        class: clsx("table-sort-icon-container", "sort-direction-".concat(sortDirection !== null && sortDirection !== void 0 ? sortDirection : "null"))
      }, v$1(Fade, {
        open: sortDirection == null
      }, v$1("i", {
        class: "bi bi-sort-down-alt hover-only"
      })), v$1(Fade, {
        open: sortDirection == "descending"
      }, v$1("i", {
        class: "bi bi-sort-up no-hover-only"
      })), v$1(Fade, {
        open: sortDirection == "descending"
      }, v$1("i", {
        class: "bi bi-sort-down-alt hover-only"
      })), v$1(Fade, {
        open: sortDirection == "ascending"
      }, v$1("i", {
        class: "bi bi-sort-down-alt no-hover-only"
      })), v$1(Fade, {
        open: sortDirection == "ascending"
      }, v$1("i", {
        class: "bi bi-sort-up hover-only"
      }))));

      if (focus === "child") {
        return v$1("th", _objectSpread2({}, cellProps), v$1("div", null, B(children, useGridNavigationCellProps({}), children.props.children), sortIcon));
      } else {
        return v$1("th", _objectSpread2({}, useGridNavigationCellProps(cellProps)), v$1("div", null, children !== null && children !== void 0 ? children : stringify(value), sortIcon));
      }
    });

    function stringify(value) {
      if (value == null) return null; // TODO: This could be a lot better

      if (value instanceof Date) return value.toLocaleString();
      return "".concat(value);
    }

    var RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    g(function (_a) {
        var depth = _a.depth;
        var _b = useState(false), active = _b[0], setActive = _b[1];
        var useFocusTrapProps = useFocusTrap({ trapActive: active }).useFocusTrapProps;
        //const { useRovingTabIndexChild, useRovingTabIndexProps } = useRovingTabIndex<HTMLUListElement, RovingTabIndexChildInfo>({ tabbableIndex, focusOnChange: false });
        var divProps = useFocusTrapProps({ ref: undefined, className: "focus-trap-demo" });
        if (depth == 2)
            return v$1("div", null);
        return (v$1("div", { className: "demo" },
            v$1("label", null,
                "Active: ",
                v$1("input", { type: "checkbox", checked: active, onInput: function (e) { e.preventDefault(); setActive(e.currentTarget.checked); } })),
            v$1("div", __assign({}, divProps),
                v$1(DemoUseFocusTrapChild, { active: active, setActive: setActive, depth: depth !== null && depth !== void 0 ? depth : 0 }))));
    });
    var DemoUseFocusTrapChild = g(function (_a) {
        var setActive = _a.setActive, active = _a.active; _a.depth;
        return (v$1(d$1, null,
            v$1("button", null, "Button 1"),
            v$1("button", null, "Button 2"),
            v$1("button", null, "Button 3"),
            v$1("label", null,
                "Active: ",
                v$1("input", { type: "checkbox", checked: active, onInput: function (e) { e.preventDefault(); setActive(e.currentTarget.checked); } }))));
    });
    var DemoDialog = g(function () {
        var onClose = (function () { return setOpen(false); });
        var _a = useState(false), open = _a[0], setOpen = _a[1];
        return (v$1("div", { class: "demo" },
            v$1(Tooltip, { tooltip: "Open dialog", position: "block-start", Transition: ZoomFade, zoomOriginDynamic: 0, zoomMin: 0.85 },
                v$1(InputGroup, null,
                    v$1(Checkbox, { checked: open, onInput: setOpen }, "Open dialog"))),
            v$1(Dialog, { Transition: ClipFade, clipOriginBlock: 0, open: open, onClose: onClose, descriptive: false, title: "Dialog Title", footer: v$1("button", { onClick: onClose }, "Close") },
                v$1("p", { tabIndex: -1 }, "Dialog body content"),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")))));
    });
    var DemoDrawer = g(function () {
        var onClose = (function () { return setOpen(false); });
        var _a = useState(false), open = _a[0], setOpen = _a[1];
        //open = true;
        return (v$1("div", { class: "demo" },
            v$1(Checkbox, { checked: open, onInput: setOpen }, "Open Drawer"),
            v$1(Drawer, { Transition: Slide, slideTargetInline: -1, open: open, onClose: onClose, descriptive: false, title: "Dialog Title" },
                v$1("p", { tabIndex: -1 }, "Dialog body content"),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")))));
    });
    var DemoMenu = g(function () {
        return (v$1("div", { class: "demo" },
            v$1(Menu, { Transition: ZoomFade, zoomOriginDynamic: 0, zoomMin: 0.85, tag: "ul", anchor: v$1(Button, null, "Open menu") },
                v$1(MenuItem, { index: 0 }, "AItem #1"),
                v$1(MenuItem, { index: 1 }, "BItem #2"),
                v$1(MenuItem, { index: 2 }, "CItem #3"),
                v$1(MenuItem, { index: 3 }, "DItem #4"))));
    });
    g(function () {
        var _a = useHasFocus(), focused = _a.focused, focusedInner = _a.focusedInner, useHasFocusProps = _a.useHasFocusProps;
        return (v$1("div", { class: "demo" },
            v$1("h2", null, "useHasFocus"),
            v$1("div", __assign({}, useHasFocusProps({ style: { border: "1px solid black" }, tabIndex: 0 })),
                "Outer ",
                v$1("div", { tabIndex: 0, style: { border: "1px solid black" } }, "Inner element")),
            v$1("div", null,
                v$1("ul", null,
                    v$1("li", null,
                        "Strictly focused: ",
                        focused.toString()),
                    v$1("li", null,
                        "Inner focused: ",
                        focusedInner.toString())))));
    });
    var DemoTabs = g(function () {
        var _a = useState(0), selectedIndex = _a[0], setSelectedIndex = _a[1];
        var _b = useState("activate"), selectionMode = _b[0];
        return (v$1("div", { class: "demo" },
            v$1("div", null,
                v$1(Tabs, { orientation: "block", onSelect: setSelectedIndex, selectedIndex: selectedIndex, selectionMode: selectionMode, tag: "ol" },
                    v$1("ol", null,
                        v$1(Tab, { index: 0 }, "Tab #1"),
                        v$1(Tab, { index: 1 }, "Tab #2"),
                        v$1(Tab, { index: 2 }, "Tab #3")),
                    v$1(TabPanel, { index: 0, Transition: ZoomFade, zoomMin: 0.8, zoomOriginBlock: 0 },
                        v$1("div", null, RandomWords.slice(0, Math.floor((1 / 3) * RandomWords.length)).join(" "))),
                    v$1(TabPanel, { index: 1, Transition: ZoomFade, zoomMin: 0.8, zoomOriginBlock: 0 },
                        v$1("div", null, RandomWords.slice(0, Math.floor((2 / 3) * RandomWords.length)).join(" "))),
                    v$1(TabPanel, { index: 2, Transition: ZoomFade, zoomMin: 0.8, zoomOriginBlock: 0 },
                        v$1("div", null, RandomWords.slice(0, Math.floor((3 / 3) * RandomWords.length)).join(" ")))))));
    });
    g(function () {
        var _a = useAriaTooltip({}), useTooltip = _a.useTooltip, useTooltipTrigger = _a.useTooltipTrigger, isOpen = _a.isOpen;
        var useTooltipProps = useTooltip().useTooltipProps;
        var useTooltipTriggerProps = useTooltipTrigger().useTooltipTriggerProps;
        return (v$1("div", { class: "demo" },
            v$1("p", null,
                "This is a paragraph with a ",
                v$1("span", __assign({}, useTooltipTriggerProps({})), "tooltip right here."),
                v$1("span", __assign({}, useTooltipProps({ hidden: !isOpen })), "This is the tooltip content."))));
    });
    function sleep(ms) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, ms); })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    }
    /*
    const DemoButtons = memo(() => {
        const [buttonsFill, setButtonsFill] = useState<"fill" | "outline">("outline");
        const [buttonsSize, setButtonsSize] = useState<"sm" | "md" | "lg">("md");

        const pushToast = usePushToast();
        function onClick(str: string) {
            return async function onClick() {
                await sleep(5000);
                pushToast(<Toast>Button was clicked ({str})</Toast>)
            }
        }

        return (
            <div class="demo">

                <ButtonGroup>
                    <ButtonGroupChild index={0} onClick={() => setButtonsFill("fill")} pressed={buttonsFill === "fill"} colorVariant="primary">Fill</ButtonGroupChild>
                    <ButtonGroupChild index={1} onClick={() => setButtonsFill("outline")} pressed={buttonsFill === "outline"} colorVariant="primary">Outline</ButtonGroupChild>
                </ButtonGroup>

                <ProvideDefaultButtonFill value={buttonsFill}>
                    <ProvideDefaultButtonSize value={buttonsSize}>
                        <ButtonGroup>
                            <ButtonGroupChild onClick={onClick("primary")} index={0} tag="button" colorVariant="primary">Primary</ButtonGroupChild>
                            <ButtonGroupChild onClick={onClick("secondary")} index={1} tag="button" colorVariant="secondary">Secondary</ButtonGroupChild>
                            <ButtonGroupChild onClick={onClick("success")} index={2} tag="button" colorVariant="success">Success</ButtonGroupChild>
                            <ButtonGroupChild onClick={onClick("warning")} index={3} tag="button" colorVariant="warning">Warning</ButtonGroupChild>
                        </ButtonGroup>
                        <ButtonGroup>
                            <ButtonGroupChild onClick={onClick("danger")} index={0} tag="button" colorVariant="danger">Danger</ButtonGroupChild>
                            <ButtonGroupChild onClick={onClick("info")} index={1} tag="button" colorVariant="info">Info</ButtonGroupChild>
                            <ButtonGroupChild onClick={onClick("light")} index={2} tag="button" colorVariant="light">Light</ButtonGroupChild>
                            <ButtonGroupChild onClick={onClick("dark")} index={3} tag="button" colorVariant="dark">Dark</ButtonGroupChild>
                            <ButtonGroupChild tag="a" index={4} href="#" colorVariant="link">Link</ButtonGroupChild>
                        </ButtonGroup>
                    </ProvideDefaultButtonSize>
                </ProvideDefaultButtonFill>
            </div>
        )
    });*/
    var DemoAccordion = g(function () {
        var _a = useState(-1), expandedIndex = _a[0], setExpandedIndex = _a[1];
        return (v$1("div", { class: "demo" },
            v$1("div", null,
                v$1(Accordion, { expandedIndex: expandedIndex, setExpandedIndex: setExpandedIndex },
                    v$1(AccordionSection, { index: 0, header: "Accordion Item #1" },
                        v$1("div", null,
                            v$1("strong", null, "This is the 1st item's accordion body."),
                            " It is visible by default, You can modify any of this with custom CSS or overriding our default variables. It's also worth noting that just about any HTML can go within the ",
                            v$1("code", null, "AccordionSection"),
                            ".")),
                    v$1(AccordionSection, { index: 1, header: "Accordion Item #2" },
                        v$1("div", null,
                            v$1("strong", null, "This is the 2nd item's accordion body."),
                            " It is hidden by default,  You can modify any of this with custom CSS or overriding our default variables. It's also worth noting that just about any HTML can go within the ",
                            v$1("code", null, "AccordionSection"),
                            ".")),
                    v$1(AccordionSection, { index: 2, header: "Accordion Item #3" },
                        v$1("div", null,
                            v$1("strong", null, "This is the 3rd item's accordion body."),
                            " It is hidden by default,  You can modify any of this with custom CSS or overriding our default variables. It's also worth noting that just about any HTML can go within the ",
                            v$1("code", null, "AccordionSection"),
                            "."))))));
    });
    var DemoList = g(function () {
        var _a = useState(0), index = _a[0], setIndex = _a[1];
        return (v$1("div", { class: "demo" },
            "Selected: ",
            index,
            v$1(ListSingle, { select: "single", onSelect: setIndex, selectedIndex: index, selectionMode: "activate", tag: "ul" },
                v$1(ListItemSingle, { index: 0 }, "Primary"),
                v$1(ListItemSingle, { index: 1 }, "Secondary"),
                v$1(ListItemSingle, { index: 2 }, "Success"),
                v$1(ListItemSingle, { index: 3 }, "Warning"),
                v$1(ListItemSingle, { index: 4 }, "Danger"),
                v$1(ListItemSingle, { index: 5 }, "Info"),
                v$1(ListItemSingle, { index: 6 }, "Light"),
                v$1(ListItemSingle, { index: 7 }, "Dark"),
                v$1(ListItemSingle, { index: 8 }, "Link"))));
    });
    var DemoInput = g(function () {
        var _a = useState(""), text = _a[0], setText = _a[1];
        var _b = useState(""), radioValue = _b[0], setRadioValue = _b[1];
        var onInput1 = A$1(function (value) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep(5000)];
                    case 1:
                        _a.sent();
                        setText(value);
                        return [2 /*return*/];
                }
            });
        }); }, [setRadioValue]);
        var onInput2 = A$1(function (value) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep(5000)];
                    case 1:
                        _a.sent();
                        setRadioValue(value);
                        return [2 /*return*/];
                }
            });
        }); }, [setRadioValue]);
        return (v$1("div", { class: "demo" },
            v$1(InputGroup, null,
                v$1(Input, { type: "text", onInput: onInput1, value: text, width: "100%" }, "Test input")),
            v$1(RadioGroup, { selectedValue: radioValue, name: "demo-radio", onInput: onInput2 },
                v$1(InputGroup, null,
                    v$1(Radio, { index: 0, value: "ARadio" })),
                v$1(InputGroup, null,
                    v$1(Radio, { index: 1, value: "BRadio" })),
                v$1(InputGroup, null,
                    v$1(Radio, { index: 2, value: "CRadio" })))));
    });
    var C = function (_a) {
        var i = _a.index;
        return (v$1(d$1, null,
            v$1(TableCell, { index: 0, value: i }),
            v$1(TableCell, { index: 1, value: "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[d(function () { return Math.floor(Math.random() * 26); }, [])] }),
            v$1(TableCell, { index: 2, value: "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i] }),
            v$1(TableCell, { index: 3, value: "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i] }, forwardElementRef(function (_a, ref) { var displayValue = _a.displayValue, props = __rest(_a, ["displayValue"]); return v$1(Button, __assign({ ref: ref }, props), displayValue); }))));
    };
    var Component = function () {
        return v$1(GridResponsive, { minWidth: "35em" },
            v$1(ToastsProvider, null,
                v$1("div", { class: "demo" },
                    v$1(Table, null,
                        v$1(TableHead, null,
                            v$1(TableRow, { index: 0 },
                                v$1(TableHeaderCell, { index: 0, value: "Number" }),
                                v$1(TableHeaderCell, { index: 1, value: "Random text" }),
                                v$1(TableHeaderCell, { index: 2, value: "Ordered text" }),
                                v$1(TableHeaderCell, { index: 3, value: "Button" }))),
                        v$1(TableBody, null, Array.from((function () {
                            var i;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        i = 0;
                                        _a.label = 1;
                                    case 1:
                                        if (!(i < 10)) return [3 /*break*/, 4];
                                        return [4 /*yield*/, v$1(TableRow, { key: i, index: i },
                                                v$1(C, { index: i }))];
                                    case 2:
                                        _a.sent();
                                        _a.label = 3;
                                    case 3:
                                        ++i;
                                        return [3 /*break*/, 1];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        })())))),
                v$1(DemoButtons, null),
                v$1(DemoChecks, null),
                v$1(DemoInputs, null),
                v$1(DemoLayout, null),
                v$1(DemoAccordion, null),
                v$1(DemoDialog, null),
                v$1(DemoDrawer, null),
                v$1(DemoInput, null),
                v$1(DemoList, null),
                v$1(DemoTabs, null),
                v$1(DemoMenu, null),
                v$1("input", null)));
    };
    requestAnimationFrame(function () {
        S$1(v$1(Component, null), document.getElementById("root"));
    });

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5tanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL2Rpc3QvaG9va3MubWpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1jaGlsZHJlbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1jbGFzc2VzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1yZWZzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1zdHlsZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXN0YXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXJlZi1lbGVtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWVsZW1lbnQtc2l6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1sb2dpY2FsLWRpcmVjdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1zdGFibGUtZ2V0dGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXN0YWJsZS1jYWxsYmFjay5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1sYXlvdXQtZWZmZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXRpbWVvdXQuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtYXN5bmMtaGFuZGxlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWNoaWxkLW1hbmFnZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2Utcm92aW5nLXRhYmluZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxpc3QtbmF2aWdhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1hY3RpdmUtZWxlbWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1oYXMtZm9jdXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtZWZmZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWdyaWQtbmF2aWdhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1ldmVudC1oYW5kbGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXBlcnNpc3RlbnQtc3RhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtcmFuZG9tLWlkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3RhYmJhYmxlL2Rpc3QvaW5kZXguZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jsb2NraW5nLWVsZW1lbnRzL2Rpc3QvYmxvY2tpbmctZWxlbWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvd2ljZy1pbmVydC9kaXN0L2luZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWJsb2NraW5nLWVsZW1lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtZm9jdXMtdHJhcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS10b29sdGlwLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvZGlzdC9jb21wYXQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL2ZvcndhcmQtZWxlbWVudC1yZWYuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vdHJhbnNpdGlvbmFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vY2xpcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9mYWRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL2NsaXAtZmFkZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9jb2xsYXBzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9jb2xsYXBzZS1mYWRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NsaWRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NsaWRlLWZhZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vem9vbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi96b29tLWZhZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc2xpZGUtem9vbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zbGlkZS16b29tLWZhZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vZmxpcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zd2FwcGFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy9wcm9wcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1idXR0b24uanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtYWNjb3JkaW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWxhYmVsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWNoZWNrYm94LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLW1vZGFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWRpYWxvZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1kcmF3ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtbGlzdGJveC1zaW5nbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtbWVudS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS10YWJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLXJhZGlvLWdyb3VwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLXRvYXN0cy5qcyIsIi4uL3Byb3BzLmpzIiwiLi4vYWNjb3JkaW9uL2FjY29yZGlvbi5qcyIsIi4uL3Byb2dyZXNzL2xpbmVhci5qcyIsIi4uL2J1dHRvbi9kZWZhdWx0cy5qcyIsIi4uL2J1dHRvbi9idXR0b24uanMiLCIuLi9idXR0b24vYnV0dG9uLWdyb3VwLmpzIiwiLi4vcG9ydGFsL2luZGV4LmpzIiwiLi4vZGlhbG9nL2RpYWxvZy5qcyIsIi4uL2RyYXdlci9kcmF3ZXIuanMiLCIuLi9pbnB1dC1ncm91cC9wcm9wcy5qcyIsIi4uL2lucHV0LWdyb3VwL2lucHV0LWdyb3VwLmpzIiwiLi4vaW5wdXQtZ3JvdXAvaW5wdXQtdGV4dC5qcyIsIi4uL2lucHV0LWdyb3VwL2lucHV0LWNoZWNrLmpzIiwiLi4vaW5wdXQtZ3JvdXAvaW5wdXQtc3dpdGNoLmpzIiwiLi4vaW5wdXQtZ3JvdXAvaW5wdXQtcmFkaW8uanMiLCIuLi9sYXlvdXQvZ3JpZC5qcyIsIi4uL2xpc3QvbGlzdC1zaW5nbGUuanMiLCIuLi9tZW51L3BvcHBlci1jb25maWcuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvY29udGFpbnMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2hpZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRBbHRBeGlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvb3JkZXJNb2RpZmllcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9mb3JtYXQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy91bmlxdWVCeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzIiwiLi4vbWVudS9wb3BwZXItYXBpLmpzIiwiLi4vbWVudS9tZW51LmpzIiwiLi4vdGFicy90YWJzLmpzIiwiLi4vdG9hc3QvdG9hc3QuanMiLCIuLi90b29sdGlwL3Rvb2x0aXAuanMiLCIuLi9jYXJkL2NhcmQuanMiLCJkZW1vcy9idXR0b25zLnRzeCIsImRlbW9zL2NoZWNrcy50c3giLCJkZW1vcy9pbnB1dHMudHN4IiwiZGVtb3MvbGF5b3V0LnRzeCIsIi4uL3RhYmxlL3RhYmxlLmpzIiwiaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuIiwidmFyIG4sbCx1LGksdCxvLHIsZixlPXt9LGM9W10scz0vYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO2Z1bmN0aW9uIGEobixsKXtmb3IodmFyIHUgaW4gbCluW3VdPWxbdV07cmV0dXJuIG59ZnVuY3Rpb24gaChuKXt2YXIgbD1uLnBhcmVudE5vZGU7bCYmbC5yZW1vdmVDaGlsZChuKX1mdW5jdGlvbiB2KGwsdSxpKXt2YXIgdCxvLHIsZj17fTtmb3IociBpbiB1KVwia2V5XCI9PXI/dD11W3JdOlwicmVmXCI9PXI/bz11W3JdOmZbcl09dVtyXTtpZihhcmd1bWVudHMubGVuZ3RoPjImJihmLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOmkpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGwmJm51bGwhPWwuZGVmYXVsdFByb3BzKWZvcihyIGluIGwuZGVmYXVsdFByb3BzKXZvaWQgMD09PWZbcl0mJihmW3JdPWwuZGVmYXVsdFByb3BzW3JdKTtyZXR1cm4geShsLGYsdCxvLG51bGwpfWZ1bmN0aW9uIHkobixpLHQsbyxyKXt2YXIgZj17dHlwZTpuLHByb3BzOmksa2V5OnQscmVmOm8sX19rOm51bGwsX186bnVsbCxfX2I6MCxfX2U6bnVsbCxfX2Q6dm9pZCAwLF9fYzpudWxsLF9faDpudWxsLGNvbnN0cnVjdG9yOnZvaWQgMCxfX3Y6bnVsbD09cj8rK3U6cn07cmV0dXJuIG51bGwhPWwudm5vZGUmJmwudm5vZGUoZiksZn1mdW5jdGlvbiBwKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19ZnVuY3Rpb24gZChuKXtyZXR1cm4gbi5jaGlsZHJlbn1mdW5jdGlvbiBfKG4sbCl7dGhpcy5wcm9wcz1uLHRoaXMuY29udGV4dD1sfWZ1bmN0aW9uIGsobixsKXtpZihudWxsPT1sKXJldHVybiBuLl9fP2sobi5fXyxuLl9fLl9fay5pbmRleE9mKG4pKzEpOm51bGw7Zm9yKHZhciB1O2w8bi5fX2subGVuZ3RoO2wrKylpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXJldHVybiB1Ll9fZTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuLnR5cGU/ayhuKTpudWxsfWZ1bmN0aW9uIGIobil7dmFyIGwsdTtpZihudWxsIT0obj1uLl9fKSYmbnVsbCE9bi5fX2Mpe2ZvcihuLl9fZT1uLl9fYy5iYXNlPW51bGwsbD0wO2w8bi5fX2subGVuZ3RoO2wrKylpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXtuLl9fZT1uLl9fYy5iYXNlPXUuX19lO2JyZWFrfXJldHVybiBiKG4pfX1mdW5jdGlvbiBtKG4peyghbi5fX2QmJihuLl9fZD0hMCkmJnQucHVzaChuKSYmIWcuX19yKyt8fHIhPT1sLmRlYm91bmNlUmVuZGVyaW5nKSYmKChyPWwuZGVib3VuY2VSZW5kZXJpbmcpfHxvKShnKX1mdW5jdGlvbiBnKCl7Zm9yKHZhciBuO2cuX19yPXQubGVuZ3RoOyluPXQuc29ydChmdW5jdGlvbihuLGwpe3JldHVybiBuLl9fdi5fX2ItbC5fX3YuX19ifSksdD1bXSxuLnNvbWUoZnVuY3Rpb24obil7dmFyIGwsdSxpLHQsbyxyO24uX19kJiYobz0odD0obD1uKS5fX3YpLl9fZSwocj1sLl9fUCkmJih1PVtdLChpPWEoe30sdCkpLl9fdj10Ll9fdisxLGoocix0LGksbC5fX24sdm9pZCAwIT09ci5vd25lclNWR0VsZW1lbnQsbnVsbCE9dC5fX2g/W29dOm51bGwsdSxudWxsPT1vP2sodCk6byx0Ll9faCkseih1LHQpLHQuX19lIT1vJiZiKHQpKSl9KX1mdW5jdGlvbiB3KG4sbCx1LGksdCxvLHIsZixzLGEpe3ZhciBoLHYscCxfLGIsbSxnLHc9aSYmaS5fX2t8fGMsQT13Lmxlbmd0aDtmb3IodS5fX2s9W10saD0wO2g8bC5sZW5ndGg7aCsrKWlmKG51bGwhPShfPXUuX19rW2hdPW51bGw9PShfPWxbaF0pfHxcImJvb2xlYW5cIj09dHlwZW9mIF8/bnVsbDpcInN0cmluZ1wiPT10eXBlb2YgX3x8XCJudW1iZXJcIj09dHlwZW9mIF98fFwiYmlnaW50XCI9PXR5cGVvZiBfP3kobnVsbCxfLG51bGwsbnVsbCxfKTpBcnJheS5pc0FycmF5KF8pP3koZCx7Y2hpbGRyZW46X30sbnVsbCxudWxsLG51bGwpOl8uX19iPjA/eShfLnR5cGUsXy5wcm9wcyxfLmtleSxudWxsLF8uX192KTpfKSl7aWYoXy5fXz11LF8uX19iPXUuX19iKzEsbnVsbD09PShwPXdbaF0pfHxwJiZfLmtleT09cC5rZXkmJl8udHlwZT09PXAudHlwZSl3W2hdPXZvaWQgMDtlbHNlIGZvcih2PTA7djxBO3YrKyl7aWYoKHA9d1t2XSkmJl8ua2V5PT1wLmtleSYmXy50eXBlPT09cC50eXBlKXt3W3ZdPXZvaWQgMDticmVha31wPW51bGx9aihuLF8scD1wfHxlLHQsbyxyLGYscyxhKSxiPV8uX19lLCh2PV8ucmVmKSYmcC5yZWYhPXYmJihnfHwoZz1bXSkscC5yZWYmJmcucHVzaChwLnJlZixudWxsLF8pLGcucHVzaCh2LF8uX19jfHxiLF8pKSxudWxsIT1iPyhudWxsPT1tJiYobT1iKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBfLnR5cGUmJm51bGwhPV8uX19rJiZfLl9faz09PXAuX19rP18uX19kPXM9eChfLHMsbik6cz1QKG4sXyxwLHcsYixzKSxhfHxcIm9wdGlvblwiIT09dS50eXBlP1wiZnVuY3Rpb25cIj09dHlwZW9mIHUudHlwZSYmKHUuX19kPXMpOm4udmFsdWU9XCJcIik6cyYmcC5fX2U9PXMmJnMucGFyZW50Tm9kZSE9biYmKHM9ayhwKSl9Zm9yKHUuX19lPW0saD1BO2gtLTspbnVsbCE9d1toXSYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHUudHlwZSYmbnVsbCE9d1toXS5fX2UmJndbaF0uX19lPT11Ll9fZCYmKHUuX19kPWsoaSxoKzEpKSxOKHdbaF0sd1toXSkpO2lmKGcpZm9yKGg9MDtoPGcubGVuZ3RoO2grKylNKGdbaF0sZ1srK2hdLGdbKytoXSl9ZnVuY3Rpb24geChuLGwsdSl7dmFyIGksdDtmb3IoaT0wO2k8bi5fX2subGVuZ3RoO2krKykodD1uLl9fa1tpXSkmJih0Ll9fPW4sbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnR5cGU/eCh0LGwsdSk6UCh1LHQsdCxuLl9fayx0Ll9fZSxsKSk7cmV0dXJuIGx9ZnVuY3Rpb24gQShuLGwpe3JldHVybiBsPWx8fFtdLG51bGw9PW58fFwiYm9vbGVhblwiPT10eXBlb2Ygbnx8KEFycmF5LmlzQXJyYXkobik/bi5zb21lKGZ1bmN0aW9uKG4pe0EobixsKX0pOmwucHVzaChuKSksbH1mdW5jdGlvbiBQKG4sbCx1LGksdCxvKXt2YXIgcixmLGU7aWYodm9pZCAwIT09bC5fX2Qpcj1sLl9fZCxsLl9fZD12b2lkIDA7ZWxzZSBpZihudWxsPT11fHx0IT1vfHxudWxsPT10LnBhcmVudE5vZGUpbjppZihudWxsPT1vfHxvLnBhcmVudE5vZGUhPT1uKW4uYXBwZW5kQ2hpbGQodCkscj1udWxsO2Vsc2V7Zm9yKGY9byxlPTA7KGY9Zi5uZXh0U2libGluZykmJmU8aS5sZW5ndGg7ZSs9MilpZihmPT10KWJyZWFrIG47bi5pbnNlcnRCZWZvcmUodCxvKSxyPW99cmV0dXJuIHZvaWQgMCE9PXI/cjp0Lm5leHRTaWJsaW5nfWZ1bmN0aW9uIEMobixsLHUsaSx0KXt2YXIgbztmb3IobyBpbiB1KVwiY2hpbGRyZW5cIj09PW98fFwia2V5XCI9PT1vfHxvIGluIGx8fEgobixvLG51bGwsdVtvXSxpKTtmb3IobyBpbiBsKXQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGxbb118fFwiY2hpbGRyZW5cIj09PW98fFwia2V5XCI9PT1vfHxcInZhbHVlXCI9PT1vfHxcImNoZWNrZWRcIj09PW98fHVbb109PT1sW29dfHxIKG4sbyxsW29dLHVbb10saSl9ZnVuY3Rpb24gJChuLGwsdSl7XCItXCI9PT1sWzBdP24uc2V0UHJvcGVydHkobCx1KTpuW2xdPW51bGw9PXU/XCJcIjpcIm51bWJlclwiIT10eXBlb2YgdXx8cy50ZXN0KGwpP3U6dStcInB4XCJ9ZnVuY3Rpb24gSChuLGwsdSxpLHQpe3ZhciBvO246aWYoXCJzdHlsZVwiPT09bClpZihcInN0cmluZ1wiPT10eXBlb2YgdSluLnN0eWxlLmNzc1RleHQ9dTtlbHNle2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpJiYobi5zdHlsZS5jc3NUZXh0PWk9XCJcIiksaSlmb3IobCBpbiBpKXUmJmwgaW4gdXx8JChuLnN0eWxlLGwsXCJcIik7aWYodSlmb3IobCBpbiB1KWkmJnVbbF09PT1pW2xdfHwkKG4uc3R5bGUsbCx1W2xdKX1lbHNlIGlmKFwib1wiPT09bFswXSYmXCJuXCI9PT1sWzFdKW89bCE9PShsPWwucmVwbGFjZSgvQ2FwdHVyZSQvLFwiXCIpKSxsPWwudG9Mb3dlckNhc2UoKWluIG4/bC50b0xvd2VyQ2FzZSgpLnNsaWNlKDIpOmwuc2xpY2UoMiksbi5sfHwobi5sPXt9KSxuLmxbbCtvXT11LHU/aXx8bi5hZGRFdmVudExpc3RlbmVyKGwsbz9UOkksbyk6bi5yZW1vdmVFdmVudExpc3RlbmVyKGwsbz9UOkksbyk7ZWxzZSBpZihcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1sKXtpZih0KWw9bC5yZXBsYWNlKC94bGlua1tIOmhdLyxcImhcIikucmVwbGFjZSgvc05hbWUkLyxcInNcIik7ZWxzZSBpZihcImhyZWZcIiE9PWwmJlwibGlzdFwiIT09bCYmXCJmb3JtXCIhPT1sJiZcInRhYkluZGV4XCIhPT1sJiZcImRvd25sb2FkXCIhPT1sJiZsIGluIG4pdHJ5e25bbF09bnVsbD09dT9cIlwiOnU7YnJlYWsgbn1jYXRjaChuKXt9XCJmdW5jdGlvblwiPT10eXBlb2YgdXx8KG51bGwhPXUmJighMSE9PXV8fFwiYVwiPT09bFswXSYmXCJyXCI9PT1sWzFdKT9uLnNldEF0dHJpYnV0ZShsLHUpOm4ucmVtb3ZlQXR0cmlidXRlKGwpKX19ZnVuY3Rpb24gSShuKXt0aGlzLmxbbi50eXBlKyExXShsLmV2ZW50P2wuZXZlbnQobik6bil9ZnVuY3Rpb24gVChuKXt0aGlzLmxbbi50eXBlKyEwXShsLmV2ZW50P2wuZXZlbnQobik6bil9ZnVuY3Rpb24gaihuLHUsaSx0LG8scixmLGUsYyl7dmFyIHMsaCx2LHkscCxrLGIsbSxnLHgsQSxQPXUudHlwZTtpZih2b2lkIDAhPT11LmNvbnN0cnVjdG9yKXJldHVybiBudWxsO251bGwhPWkuX19oJiYoYz1pLl9faCxlPXUuX19lPWkuX19lLHUuX19oPW51bGwscj1bZV0pLChzPWwuX19iKSYmcyh1KTt0cnl7bjppZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQKXtpZihtPXUucHJvcHMsZz0ocz1QLmNvbnRleHRUeXBlKSYmdFtzLl9fY10seD1zP2c/Zy5wcm9wcy52YWx1ZTpzLl9fOnQsaS5fX2M/Yj0oaD11Ll9fYz1pLl9fYykuX189aC5fX0U6KFwicHJvdG90eXBlXCJpbiBQJiZQLnByb3RvdHlwZS5yZW5kZXI/dS5fX2M9aD1uZXcgUChtLHgpOih1Ll9fYz1oPW5ldyBfKG0seCksaC5jb25zdHJ1Y3Rvcj1QLGgucmVuZGVyPU8pLGcmJmcuc3ViKGgpLGgucHJvcHM9bSxoLnN0YXRlfHwoaC5zdGF0ZT17fSksaC5jb250ZXh0PXgsaC5fX249dCx2PWguX19kPSEwLGguX19oPVtdKSxudWxsPT1oLl9fcyYmKGguX19zPWguc3RhdGUpLG51bGwhPVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiYoaC5fX3M9PWguc3RhdGUmJihoLl9fcz1hKHt9LGguX19zKSksYShoLl9fcyxQLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhtLGguX19zKSkpLHk9aC5wcm9wcyxwPWguc3RhdGUsdiludWxsPT1QLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmbnVsbCE9aC5jb21wb25lbnRXaWxsTW91bnQmJmguY29tcG9uZW50V2lsbE1vdW50KCksbnVsbCE9aC5jb21wb25lbnREaWRNb3VudCYmaC5fX2gucHVzaChoLmNvbXBvbmVudERpZE1vdW50KTtlbHNle2lmKG51bGw9PVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiZtIT09eSYmbnVsbCE9aC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZoLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobSx4KSwhaC5fX2UmJm51bGwhPWguc2hvdWxkQ29tcG9uZW50VXBkYXRlJiYhMT09PWguc2hvdWxkQ29tcG9uZW50VXBkYXRlKG0saC5fX3MseCl8fHUuX192PT09aS5fX3Ype2gucHJvcHM9bSxoLnN0YXRlPWguX19zLHUuX192IT09aS5fX3YmJihoLl9fZD0hMSksaC5fX3Y9dSx1Ll9fZT1pLl9fZSx1Ll9faz1pLl9fayx1Ll9fay5mb3JFYWNoKGZ1bmN0aW9uKG4pe24mJihuLl9fPXUpfSksaC5fX2gubGVuZ3RoJiZmLnB1c2goaCk7YnJlYWsgbn1udWxsIT1oLmNvbXBvbmVudFdpbGxVcGRhdGUmJmguY29tcG9uZW50V2lsbFVwZGF0ZShtLGguX19zLHgpLG51bGwhPWguY29tcG9uZW50RGlkVXBkYXRlJiZoLl9faC5wdXNoKGZ1bmN0aW9uKCl7aC5jb21wb25lbnREaWRVcGRhdGUoeSxwLGspfSl9aC5jb250ZXh0PXgsaC5wcm9wcz1tLGguc3RhdGU9aC5fX3MsKHM9bC5fX3IpJiZzKHUpLGguX19kPSExLGguX192PXUsaC5fX1A9bixzPWgucmVuZGVyKGgucHJvcHMsaC5zdGF0ZSxoLmNvbnRleHQpLGguc3RhdGU9aC5fX3MsbnVsbCE9aC5nZXRDaGlsZENvbnRleHQmJih0PWEoYSh7fSx0KSxoLmdldENoaWxkQ29udGV4dCgpKSksdnx8bnVsbD09aC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8KGs9aC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSh5LHApKSxBPW51bGwhPXMmJnMudHlwZT09PWQmJm51bGw9PXMua2V5P3MucHJvcHMuY2hpbGRyZW46cyx3KG4sQXJyYXkuaXNBcnJheShBKT9BOltBXSx1LGksdCxvLHIsZixlLGMpLGguYmFzZT11Ll9fZSx1Ll9faD1udWxsLGguX19oLmxlbmd0aCYmZi5wdXNoKGgpLGImJihoLl9fRT1oLl9fPW51bGwpLGguX19lPSExfWVsc2UgbnVsbD09ciYmdS5fX3Y9PT1pLl9fdj8odS5fX2s9aS5fX2ssdS5fX2U9aS5fX2UpOnUuX19lPUwoaS5fX2UsdSxpLHQsbyxyLGYsYyk7KHM9bC5kaWZmZWQpJiZzKHUpfWNhdGNoKG4pe3UuX192PW51bGwsKGN8fG51bGwhPXIpJiYodS5fX2U9ZSx1Ll9faD0hIWMscltyLmluZGV4T2YoZSldPW51bGwpLGwuX19lKG4sdSxpKX19ZnVuY3Rpb24geihuLHUpe2wuX19jJiZsLl9fYyh1LG4pLG4uc29tZShmdW5jdGlvbih1KXt0cnl7bj11Ll9faCx1Ll9faD1bXSxuLnNvbWUoZnVuY3Rpb24obil7bi5jYWxsKHUpfSl9Y2F0Y2gobil7bC5fX2Uobix1Ll9fdil9fSl9ZnVuY3Rpb24gTChsLHUsaSx0LG8scixmLGMpe3ZhciBzLGEsdix5PWkucHJvcHMscD11LnByb3BzLGQ9dS50eXBlLF89MDtpZihcInN2Z1wiPT09ZCYmKG89ITApLG51bGwhPXIpZm9yKDtfPHIubGVuZ3RoO18rKylpZigocz1yW19dKSYmKHM9PT1sfHwoZD9zLmxvY2FsTmFtZT09ZDozPT1zLm5vZGVUeXBlKSkpe2w9cyxyW19dPW51bGw7YnJlYWt9aWYobnVsbD09bCl7aWYobnVsbD09PWQpcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHApO2w9bz9kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLGQpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZCxwLmlzJiZwKSxyPW51bGwsYz0hMX1pZihudWxsPT09ZCl5PT09cHx8YyYmbC5kYXRhPT09cHx8KGwuZGF0YT1wKTtlbHNle2lmKHI9ciYmbi5jYWxsKGwuY2hpbGROb2RlcyksYT0oeT1pLnByb3BzfHxlKS5kYW5nZXJvdXNseVNldElubmVySFRNTCx2PXAuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIWMpe2lmKG51bGwhPXIpZm9yKHk9e30sXz0wO188bC5hdHRyaWJ1dGVzLmxlbmd0aDtfKyspeVtsLmF0dHJpYnV0ZXNbX10ubmFtZV09bC5hdHRyaWJ1dGVzW19dLnZhbHVlOyh2fHxhKSYmKHYmJihhJiZ2Ll9faHRtbD09YS5fX2h0bWx8fHYuX19odG1sPT09bC5pbm5lckhUTUwpfHwobC5pbm5lckhUTUw9diYmdi5fX2h0bWx8fFwiXCIpKX1pZihDKGwscCx5LG8sYyksdil1Ll9faz1bXTtlbHNlIGlmKF89dS5wcm9wcy5jaGlsZHJlbix3KGwsQXJyYXkuaXNBcnJheShfKT9fOltfXSx1LGksdCxvJiZcImZvcmVpZ25PYmplY3RcIiE9PWQscixmLHI/clswXTppLl9fayYmayhpLDApLGMpLG51bGwhPXIpZm9yKF89ci5sZW5ndGg7Xy0tOyludWxsIT1yW19dJiZoKHJbX10pO2N8fChcInZhbHVlXCJpbiBwJiZ2b2lkIDAhPT0oXz1wLnZhbHVlKSYmKF8hPT1sLnZhbHVlfHxcInByb2dyZXNzXCI9PT1kJiYhXykmJkgobCxcInZhbHVlXCIsXyx5LnZhbHVlLCExKSxcImNoZWNrZWRcImluIHAmJnZvaWQgMCE9PShfPXAuY2hlY2tlZCkmJl8hPT1sLmNoZWNrZWQmJkgobCxcImNoZWNrZWRcIixfLHkuY2hlY2tlZCwhMSkpfXJldHVybiBsfWZ1bmN0aW9uIE0obix1LGkpe3RyeXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP24odSk6bi5jdXJyZW50PXV9Y2F0Y2gobil7bC5fX2UobixpKX19ZnVuY3Rpb24gTihuLHUsaSl7dmFyIHQsbztpZihsLnVubW91bnQmJmwudW5tb3VudChuKSwodD1uLnJlZikmJih0LmN1cnJlbnQmJnQuY3VycmVudCE9PW4uX19lfHxNKHQsbnVsbCx1KSksbnVsbCE9KHQ9bi5fX2MpKXtpZih0LmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXt0LmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2gobil7bC5fX2Uobix1KX10LmJhc2U9dC5fX1A9bnVsbH1pZih0PW4uX19rKWZvcihvPTA7bzx0Lmxlbmd0aDtvKyspdFtvXSYmTih0W29dLHUsXCJmdW5jdGlvblwiIT10eXBlb2Ygbi50eXBlKTtpfHxudWxsPT1uLl9fZXx8aChuLl9fZSksbi5fX2U9bi5fX2Q9dm9pZCAwfWZ1bmN0aW9uIE8obixsLHUpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yKG4sdSl9ZnVuY3Rpb24gUyh1LGksdCl7dmFyIG8scixmO2wuX18mJmwuX18odSxpKSxyPShvPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQpP251bGw6dCYmdC5fX2t8fGkuX19rLGY9W10saihpLHU9KCFvJiZ0fHxpKS5fX2s9dihkLG51bGwsW3VdKSxyfHxlLGUsdm9pZCAwIT09aS5vd25lclNWR0VsZW1lbnQsIW8mJnQ/W3RdOnI/bnVsbDppLmZpcnN0Q2hpbGQ/bi5jYWxsKGkuY2hpbGROb2Rlcyk6bnVsbCxmLCFvJiZ0P3Q6cj9yLl9fZTppLmZpcnN0Q2hpbGQsbykseihmLHUpfWZ1bmN0aW9uIHEobixsKXtTKG4sbCxxKX1mdW5jdGlvbiBCKGwsdSxpKXt2YXIgdCxvLHIsZj1hKHt9LGwucHJvcHMpO2ZvcihyIGluIHUpXCJrZXlcIj09cj90PXVbcl06XCJyZWZcIj09cj9vPXVbcl06ZltyXT11W3JdO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPjImJihmLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOmkpLHkobC50eXBlLGYsdHx8bC5rZXksb3x8bC5yZWYsbnVsbCl9ZnVuY3Rpb24gRChuLGwpe3ZhciB1PXtfX2M6bD1cIl9fY0NcIitmKyssX186bixDb25zdW1lcjpmdW5jdGlvbihuLGwpe3JldHVybiBuLmNoaWxkcmVuKGwpfSxQcm92aWRlcjpmdW5jdGlvbihuKXt2YXIgdSxpO3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dHx8KHU9W10sKGk9e30pW2xdPXRoaXMsdGhpcy5nZXRDaGlsZENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gaX0sdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5wcm9wcy52YWx1ZSE9PW4udmFsdWUmJnUuc29tZShtKX0sdGhpcy5zdWI9ZnVuY3Rpb24obil7dS5wdXNoKG4pO3ZhciBsPW4uY29tcG9uZW50V2lsbFVubW91bnQ7bi5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3Uuc3BsaWNlKHUuaW5kZXhPZihuKSwxKSxsJiZsLmNhbGwobil9fSksbi5jaGlsZHJlbn19O3JldHVybiB1LlByb3ZpZGVyLl9fPXUuQ29uc3VtZXIuY29udGV4dFR5cGU9dX1uPWMuc2xpY2UsbD17X19lOmZ1bmN0aW9uKG4sbCl7Zm9yKHZhciB1LGksdDtsPWwuX187KWlmKCh1PWwuX19jKSYmIXUuX18pdHJ5e2lmKChpPXUuY29uc3RydWN0b3IpJiZudWxsIT1pLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciYmKHUuc2V0U3RhdGUoaS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IobikpLHQ9dS5fX2QpLG51bGwhPXUuY29tcG9uZW50RGlkQ2F0Y2gmJih1LmNvbXBvbmVudERpZENhdGNoKG4pLHQ9dS5fX2QpLHQpcmV0dXJuIHUuX19FPXV9Y2F0Y2gobCl7bj1sfXRocm93IG59fSx1PTAsaT1mdW5jdGlvbihuKXtyZXR1cm4gbnVsbCE9biYmdm9pZCAwPT09bi5jb25zdHJ1Y3Rvcn0sXy5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24obixsKXt2YXIgdTt1PW51bGwhPXRoaXMuX19zJiZ0aGlzLl9fcyE9PXRoaXMuc3RhdGU/dGhpcy5fX3M6dGhpcy5fX3M9YSh7fSx0aGlzLnN0YXRlKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiYobj1uKGEoe30sdSksdGhpcy5wcm9wcykpLG4mJmEodSxuKSxudWxsIT1uJiZ0aGlzLl9fdiYmKGwmJnRoaXMuX19oLnB1c2gobCksbSh0aGlzKSl9LF8ucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKG4pe3RoaXMuX192JiYodGhpcy5fX2U9ITAsbiYmdGhpcy5fX2gucHVzaChuKSxtKHRoaXMpKX0sXy5wcm90b3R5cGUucmVuZGVyPWQsdD1bXSxvPVwiZnVuY3Rpb25cIj09dHlwZW9mIFByb21pc2U/UHJvbWlzZS5wcm90b3R5cGUudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKTpzZXRUaW1lb3V0LGcuX19yPTAsZj0wO2V4cG9ydHtTIGFzIHJlbmRlcixxIGFzIGh5ZHJhdGUsdiBhcyBjcmVhdGVFbGVtZW50LHYgYXMgaCxkIGFzIEZyYWdtZW50LHAgYXMgY3JlYXRlUmVmLGkgYXMgaXNWYWxpZEVsZW1lbnQsXyBhcyBDb21wb25lbnQsQiBhcyBjbG9uZUVsZW1lbnQsRCBhcyBjcmVhdGVDb250ZXh0LEEgYXMgdG9DaGlsZEFycmF5LGwgYXMgb3B0aW9uc307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhY3QubW9kdWxlLmpzLm1hcFxuIiwiaW1wb3J0e29wdGlvbnMgYXMgbn1mcm9tXCJwcmVhY3RcIjt2YXIgdCx1LHIsbz0wLGk9W10sYz1uLl9fYixmPW4uX19yLGU9bi5kaWZmZWQsYT1uLl9fYyx2PW4udW5tb3VudDtmdW5jdGlvbiBtKHQscil7bi5fX2gmJm4uX19oKHUsdCxvfHxyKSxvPTA7dmFyIGk9dS5fX0h8fCh1Ll9fSD17X186W10sX19oOltdfSk7cmV0dXJuIHQ+PWkuX18ubGVuZ3RoJiZpLl9fLnB1c2goe30pLGkuX19bdF19ZnVuY3Rpb24gbChuKXtyZXR1cm4gbz0xLHAodyxuKX1mdW5jdGlvbiBwKG4scixvKXt2YXIgaT1tKHQrKywyKTtyZXR1cm4gaS50PW4saS5fX2N8fChpLl9fPVtvP28ocik6dyh2b2lkIDAsciksZnVuY3Rpb24obil7dmFyIHQ9aS50KGkuX19bMF0sbik7aS5fX1swXSE9PXQmJihpLl9fPVt0LGkuX19bMV1dLGkuX19jLnNldFN0YXRlKHt9KSl9XSxpLl9fYz11KSxpLl9ffWZ1bmN0aW9uIHkocixvKXt2YXIgaT1tKHQrKywzKTshbi5fX3MmJmsoaS5fX0gsbykmJihpLl9fPXIsaS5fX0g9byx1Ll9fSC5fX2gucHVzaChpKSl9ZnVuY3Rpb24gaChyLG8pe3ZhciBpPW0odCsrLDQpOyFuLl9fcyYmayhpLl9fSCxvKSYmKGkuX189cixpLl9fSD1vLHUuX19oLnB1c2goaSkpfWZ1bmN0aW9uIHMobil7cmV0dXJuIG89NSxkKGZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bn19LFtdKX1mdW5jdGlvbiBfKG4sdCx1KXtvPTYsaChmdW5jdGlvbigpe1wiZnVuY3Rpb25cIj09dHlwZW9mIG4/bih0KCkpOm4mJihuLmN1cnJlbnQ9dCgpKX0sbnVsbD09dT91OnUuY29uY2F0KG4pKX1mdW5jdGlvbiBkKG4sdSl7dmFyIHI9bSh0KyssNyk7cmV0dXJuIGsoci5fX0gsdSkmJihyLl9fPW4oKSxyLl9fSD11LHIuX19oPW4pLHIuX199ZnVuY3Rpb24gQShuLHQpe3JldHVybiBvPTgsZChmdW5jdGlvbigpe3JldHVybiBufSx0KX1mdW5jdGlvbiBGKG4pe3ZhciByPXUuY29udGV4dFtuLl9fY10sbz1tKHQrKyw5KTtyZXR1cm4gby5jPW4scj8obnVsbD09by5fXyYmKG8uX189ITAsci5zdWIodSkpLHIucHJvcHMudmFsdWUpOm4uX199ZnVuY3Rpb24gVCh0LHUpe24udXNlRGVidWdWYWx1ZSYmbi51c2VEZWJ1Z1ZhbHVlKHU/dSh0KTp0KX1mdW5jdGlvbiBxKG4pe3ZhciByPW0odCsrLDEwKSxvPWwoKTtyZXR1cm4gci5fXz1uLHUuY29tcG9uZW50RGlkQ2F0Y2h8fCh1LmNvbXBvbmVudERpZENhdGNoPWZ1bmN0aW9uKG4pe3IuX18mJnIuX18obiksb1sxXShuKX0pLFtvWzBdLGZ1bmN0aW9uKCl7b1sxXSh2b2lkIDApfV19ZnVuY3Rpb24geCgpe2kuZm9yRWFjaChmdW5jdGlvbih0KXtpZih0Ll9fUCl0cnl7dC5fX0guX19oLmZvckVhY2goZyksdC5fX0guX19oLmZvckVhY2goaiksdC5fX0guX19oPVtdfWNhdGNoKHUpe3QuX19ILl9faD1bXSxuLl9fZSh1LHQuX192KX19KSxpPVtdfW4uX19iPWZ1bmN0aW9uKG4pe3U9bnVsbCxjJiZjKG4pfSxuLl9fcj1mdW5jdGlvbihuKXtmJiZmKG4pLHQ9MDt2YXIgcj0odT1uLl9fYykuX19IO3ImJihyLl9faC5mb3JFYWNoKGcpLHIuX19oLmZvckVhY2goaiksci5fX2g9W10pfSxuLmRpZmZlZD1mdW5jdGlvbih0KXtlJiZlKHQpO3ZhciBvPXQuX19jO28mJm8uX19IJiZvLl9fSC5fX2gubGVuZ3RoJiYoMSE9PWkucHVzaChvKSYmcj09PW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHwoKHI9bi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpfHxmdW5jdGlvbihuKXt2YXIgdCx1PWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHIpLGImJmNhbmNlbEFuaW1hdGlvbkZyYW1lKHQpLHNldFRpbWVvdXQobil9LHI9c2V0VGltZW91dCh1LDEwMCk7YiYmKHQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHUpKX0pKHgpKSx1PXZvaWQgMH0sbi5fX2M9ZnVuY3Rpb24odCx1KXt1LnNvbWUoZnVuY3Rpb24odCl7dHJ5e3QuX19oLmZvckVhY2goZyksdC5fX2g9dC5fX2guZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiFuLl9ffHxqKG4pfSl9Y2F0Y2gocil7dS5zb21lKGZ1bmN0aW9uKG4pe24uX19oJiYobi5fX2g9W10pfSksdT1bXSxuLl9fZShyLHQuX192KX19KSxhJiZhKHQsdSl9LG4udW5tb3VudD1mdW5jdGlvbih0KXt2JiZ2KHQpO3ZhciB1PXQuX19jO2lmKHUmJnUuX19IKXRyeXt1Ll9fSC5fXy5mb3JFYWNoKGcpfWNhdGNoKHQpe24uX19lKHQsdS5fX3YpfX07dmFyIGI9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO2Z1bmN0aW9uIGcobil7dmFyIHQ9dTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLl9fYyYmbi5fX2MoKSx1PXR9ZnVuY3Rpb24gaihuKXt2YXIgdD11O24uX19jPW4uX18oKSx1PXR9ZnVuY3Rpb24gayhuLHQpe3JldHVybiFufHxuLmxlbmd0aCE9PXQubGVuZ3RofHx0LnNvbWUoZnVuY3Rpb24odCx1KXtyZXR1cm4gdCE9PW5bdV19KX1mdW5jdGlvbiB3KG4sdCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD90KG4pOnR9ZXhwb3J0e2wgYXMgdXNlU3RhdGUscCBhcyB1c2VSZWR1Y2VyLHkgYXMgdXNlRWZmZWN0LGggYXMgdXNlTGF5b3V0RWZmZWN0LHMgYXMgdXNlUmVmLF8gYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZSxkIGFzIHVzZU1lbW8sQSBhcyB1c2VDYWxsYmFjayxGIGFzIHVzZUNvbnRleHQsVCBhcyB1c2VEZWJ1Z1ZhbHVlLHEgYXMgdXNlRXJyb3JCb3VuZGFyeX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rcy5tb2R1bGUuanMubWFwXG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gXCJwcmVhY3RcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENoaWxkcmVuKGxoc1Byb3BzLCByaHNQcm9wcykge1xyXG4gICAgY29uc3QgbGhzID0gbGhzUHJvcHM/LmNoaWxkcmVuO1xyXG4gICAgY29uc3QgcmhzID0gcmhzUHJvcHM/LmNoaWxkcmVuO1xyXG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJocztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxocztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCByZXQgPSBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgbGhzLCByaHMpO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW1lcmdlZC1jaGlsZHJlbi5qcy5tYXAiLCJmdW5jdGlvbiB0b1ZhbChtaXgpIHtcblx0dmFyIGssIHksIHN0cj0nJztcblxuXHRpZiAodHlwZW9mIG1peCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG1peCA9PT0gJ251bWJlcicpIHtcblx0XHRzdHIgKz0gbWl4O1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtaXggPT09ICdvYmplY3QnKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkobWl4KSkge1xuXHRcdFx0Zm9yIChrPTA7IGsgPCBtaXgubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0aWYgKG1peFtrXSkge1xuXHRcdFx0XHRcdGlmICh5ID0gdG9WYWwobWl4W2tdKSkge1xuXHRcdFx0XHRcdFx0c3RyICYmIChzdHIgKz0gJyAnKTtcblx0XHRcdFx0XHRcdHN0ciArPSB5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGsgaW4gbWl4KSB7XG5cdFx0XHRcdGlmIChtaXhba10pIHtcblx0XHRcdFx0XHRzdHIgJiYgKHN0ciArPSAnICcpO1xuXHRcdFx0XHRcdHN0ciArPSBrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHN0cjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuXHR2YXIgaT0wLCB0bXAsIHgsIHN0cj0nJztcblx0d2hpbGUgKGkgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0aWYgKHRtcCA9IGFyZ3VtZW50c1tpKytdKSB7XG5cdFx0XHRpZiAoeCA9IHRvVmFsKHRtcCkpIHtcblx0XHRcdFx0c3RyICYmIChzdHIgKz0gJyAnKTtcblx0XHRcdFx0c3RyICs9IHhcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHN0cjtcbn1cbiIsImltcG9ydCB7IGRlZmF1bHQgYXMgY2xzeCB9IGZyb20gXCJjbHN4XCI7XHJcbi8qKlxyXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXHJcbiAqIER1cGxpY2F0ZSBjbGFzc2VzIGFyZSByZW1vdmVkIChvcmRlciBkb2Vzbid0IG1hdHRlciBhbnl3YXkpLlxyXG4gKlxyXG4gKiBAcGFyYW0gbGhzIENsYXNzZXMgb2YgdGhlIGZpcnN0IGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gcmhzIENsYXNzZXMgb2YgdGhlIHNlY29uZCBjb21wb25lbnRcclxuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIGFsbCBjb21iaW5lZCBjbGFzc2VzIGZyb20gYm90aCBhcmd1bWVudHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkQ2xhc3NlcyhsaHMsIHJocykge1xyXG4gICAgLy8gTm90ZTogRm9yIHRoZSBzYWtlIG9mIGZvcndhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmdW5jdGlvbiBpcyBsYWJlbGxlZCBhc1xyXG4gICAgLy8gYSBob29rLCBidXQgYXMgaXQgdXNlcyBubyBvdGhlciBob29rcyBpdCB0ZWNobmljYWxseSBpc24ndCBvbmUuXHJcbiAgICByZXR1cm4gbWVyZ2VDbGFzc2VzKGxocywgcmhzKTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUNsYXNzZXMobGhzLCByaHMpIHtcclxuICAgIGNvbnN0IGxoc0NsYXNzID0gbGhzPy5jbGFzcztcclxuICAgIGNvbnN0IGxoc0NsYXNzTmFtZSA9IGxocz8uY2xhc3NOYW1lO1xyXG4gICAgY29uc3QgcmhzQ2xhc3MgPSByaHM/LmNsYXNzO1xyXG4gICAgY29uc3QgcmhzQ2xhc3NOYW1lID0gcmhzPy5jbGFzc05hbWU7XHJcbiAgICBpZiAobGhzQ2xhc3MgfHwgcmhzQ2xhc3MgfHwgbGhzQ2xhc3NOYW1lIHx8IHJoc0NsYXNzTmFtZSkge1xyXG4gICAgICAgIGxldCBsaHNDbGFzc2VzID0gY2xzeChsaHNDbGFzcywgbGhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgbGV0IHJoc0NsYXNzZXMgPSBjbHN4KHJoc0NsYXNzLCByaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBsZXQgYWxsQ2xhc3NlcyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20obGhzQ2xhc3NlcyksIC4uLkFycmF5LmZyb20ocmhzQ2xhc3NlcyldKTtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHlwZXRlc3QoKSB7XHJcbiAgICBjb25zdCBjID0gW1xyXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXModW5kZWZpbmVkLCB1bmRlZmluZWQpLFxyXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoe30sIHVuZGVmaW5lZCksXHJcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh1bmRlZmluZWQsIHt9KSxcclxuICAgICAgICB1c2VNZXJnZWRDbGFzc2VzKHt9LCB7fSksXHJcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh7IGNsYXNzOiBcInN0cmluZ1wiIH0sIHt9KSxcclxuICAgICAgICB1c2VNZXJnZWRDbGFzc2VzKHsgY2xhc3M6IFwic3RyaW5nXCIgfSwgeyBjbGFzczogdW5kZWZpbmVkIH0pLFxyXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoeyBjbGFzczogdW5kZWZpbmVkIH0sIHsgY2xhc3M6IFwic3RyaW5nXCIgfSksXHJcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh7IGNsYXNzTmFtZTogXCJzdHJpbmdcIiB9LCB7IGNsYXNzTmFtZTogdW5kZWZpbmVkIH0pLFxyXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoeyBjbGFzc05hbWU6IHVuZGVmaW5lZCB9LCB7IGNsYXNzTmFtZTogXCJzdHJpbmdcIiB9KSxcclxuICAgICAgICB1c2VNZXJnZWRDbGFzc2VzKHsgY2xhc3M6IFwic3RyaW5nXCIgfSwgeyBjbGFzc05hbWU6IHVuZGVmaW5lZCB9KSxcclxuICAgICAgICB1c2VNZXJnZWRDbGFzc2VzKHsgY2xhc3NOYW1lOiB1bmRlZmluZWQgfSwgeyBjbGFzczogXCJzdHJpbmdcIiB9KSxcclxuICAgICAgICB1c2VNZXJnZWRDbGFzc2VzKHsgY2xhc3NOYW1lOiBcInN0cmluZ1wiIH0sIHsgY2xhc3M6IHVuZGVmaW5lZCB9KSxcclxuICAgICAgICB1c2VNZXJnZWRDbGFzc2VzKHsgY2xhc3M6IHVuZGVmaW5lZCB9LCB7IGNsYXNzTmFtZTogXCJzdHJpbmdcIiB9KSxcclxuICAgIF07XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgY1swXS5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgY1sxXS5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgY1syXS5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgY1szXS5jb25jYXQoXCJcIik7XHJcbiAgICBjWzRdLmNvbmNhdChcIlwiKTtcclxuICAgIGNbNV0uY29uY2F0KFwiXCIpO1xyXG4gICAgY1s2XS5jb25jYXQoXCJcIik7XHJcbiAgICBjWzddLmNvbmNhdChcIlwiKTtcclxuICAgIGNbOF0uY29uY2F0KFwiXCIpO1xyXG4gICAgY1s5XS5jb25jYXQoXCJcIik7XHJcbiAgICBjWzEwXS5jb25jYXQoXCJcIik7XHJcbiAgICBjWzExXS5jb25jYXQoXCJcIik7XHJcbiAgICBjWzEyXS5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgY1sxM107XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW1lcmdlZC1jbGFzc2VzLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5mdW5jdGlvbiBwcm9jZXNzUmVmKGluc3RhbmNlLCByZWYpIHtcclxuICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZWYoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVmICE9IG51bGwpIHtcclxuICAgICAgICByZWYuY3VycmVudCA9IGluc3RhbmNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb21iaW5lcyB0d28gcmVmcyBpbnRvIG9uZS4gVGhpcyBhbGxvd3MgYSBjb21wb25lbnQgdG8gYm90aCB1c2UgaXRzIG93biByZWYgKmFuZCogZm9yd2FyZCBhIHJlZiB0aGF0IHdhcyBnaXZlbiB0byBpdC5cclxuICogQHBhcmFtIGxoc1xyXG4gKiBAcGFyYW0gcmhzXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmcygpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobGhzUHJvcHMsIHJoc1Byb3BzKSB7XHJcbiAgICAgICAgY29uc3QgbGhzID0gbGhzUHJvcHM/LnJlZjtcclxuICAgICAgICBjb25zdCByaHMgPSByaHNQcm9wcz8ucmVmO1xyXG4gICAgICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGhzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHJldCA9IHVzZUNhbGxiYWNrKChjdXJyZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIGxocyk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIHJocyk7XHJcbiAgICAgICAgICAgIH0sIFtsaHMsIHJoc10pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLypcclxuZnVuY3Rpb24gdHlwZXRlc3Q8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG5cclxuICAgIGNvbnN0IHJlZjogUmVmT2JqZWN0PEhUTUxJbnB1dEVsZW1lbnQ+ID0gdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQ+KG51bGwpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGFjY2VwdHNSZWYocmVmOiBSZWY8YW55PikgeyB9XHJcbiAgICBmdW5jdGlvbiBhY2NlcHRzT3B0aW9uYWxSZWYocmVmOiBSZWY8YW55PiB8IHVuZGVmaW5lZCkgeyB9XHJcblxyXG4gICAgY29uc3QgYyA9IFtcclxuICAgICAgICB1c2VNZXJnZWRSZWZzPEhUTUxJbnB1dEVsZW1lbnQ+KCkodW5kZWZpbmVkLCB1bmRlZmluZWQpLFxyXG4gICAgICAgIHVzZU1lcmdlZFJlZnM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgdW5kZWZpbmVkKSxcclxuICAgICAgICB1c2VNZXJnZWRSZWZzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHVuZGVmaW5lZCksXHJcbiAgICAgICAgdXNlTWVyZ2VkUmVmczxIVE1MSW5wdXRFbGVtZW50PigpKHVuZGVmaW5lZCwgcHJvcHMpLFxyXG4gICAgICAgIHVzZU1lcmdlZFJlZnM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcHJvcHMpLFxyXG4gICAgICAgIHVzZU1lcmdlZFJlZnM8SFRNTElucHV0RWxlbWVudD4oKSh7IHJlZiB9LCBwcm9wcyksXHJcbiAgICAgICAgdXNlTWVyZ2VkUmVmczxIVE1MSW5wdXRFbGVtZW50PigpKHsgcmVmIH0sIHsgcmVmOiB1bmRlZmluZWQgfSksXHJcbiAgICAgICAgdXNlTWVyZ2VkUmVmczxIVE1MSW5wdXRFbGVtZW50PigpKHsgcmVmOiB1bmRlZmluZWQgfSwgeyByZWYgfSksXHJcbiAgICAgICAgdXNlTWVyZ2VkUmVmczxIVE1MSW5wdXRFbGVtZW50PigpKHsgcmVmIH0sIHsgcmVmIH0pLFxyXG4gICAgXSBhcyBjb25zdDtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgYWNjZXB0c1JlZihjWzBdKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBhY2NlcHRzUmVmKGNbMV0pO1xyXG5cclxuICAgIGFjY2VwdHNPcHRpb25hbFJlZihjWzJdKTtcclxuICAgIGFjY2VwdHNPcHRpb25hbFJlZihjWzNdKTtcclxuICAgIGFjY2VwdHNPcHRpb25hbFJlZihjWzRdKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPXHJcbiAgICBhY2NlcHRzUmVmKGNbNV0pO1xyXG4gICAgYWNjZXB0c1JlZihjWzZdKTtcclxuICAgIGFjY2VwdHNSZWYoY1s3XSk7XHJcbiAgICBhY2NlcHRzUmVmKGNbOF0pO1xyXG59XHJcbiovXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1tZXJnZWQtcmVmcy5qcy5tYXAiLCIvKipcclxuICogTWVyZ2VzIHR3byBzdHlsZSBvYmplY3RzLCByZXR1cm5pbmcgdGhlIHJlc3VsdC5cclxuICpcclxuICogQHBhcmFtIHN0eWxlIFRoZSB1c2VyLWdpdmVuIHN0eWxlIHByb3AgZm9yIHRoaXMgY29tcG9uZW50XHJcbiAqIEBwYXJhbSBvYmogVGhlIENTUyBwcm9wZXJ0aWVzIHlvdSB3YW50IGFkZGVkIHRvIHRoZSB1c2VyLWdpdmVuIHN0eWxlXHJcbiAqIEByZXR1cm5zIEEgQ1NTIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIGJvdGggb2JqZWN0cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRTdHlsZXMobGhzLCByaHMpIHtcclxuICAgIC8vIEVhc3kgY2FzZSwgd2hlbiB0aGVyZSBhcmUgbm8gc3R5bGVzIHRvIG1lcmdlIHJldHVybiBub3RoaW5nLlxyXG4gICAgaWYgKCFsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XHJcbiAgICAgICAgLy8gRWFzeSBjYXNlcywgd2hlbiBvbmUgaXMgbnVsbCBhbmQgdGhlIG90aGVyIGlzbid0LlxyXG4gICAgICAgIGlmIChsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gbGhzLnN0eWxlO1xyXG4gICAgICAgIGlmICghbGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzLnN0eWxlO1xyXG4gICAgICAgIC8vIFRoZXkncmUgYm90aCBub24tbnVsbCBidXQgZGlmZmVyZW50IHR5cGVzLlxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZyB0eXBlIHRvIGFuIG9iamVjdCBiYWcgdHlwZSBhbmQgcnVuIGl0IGFnYWluLlxyXG4gICAgICAgIGlmIChsaHM/LnN0eWxlICYmIHJocz8uc3R5bGUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKHsgc3R5bGU6IE9iamVjdC5mcm9tRW50cmllcyhsaHM/LnN0eWxlLnNwbGl0KFwiO1wiKS5tYXAoc3RhdGVtZW50ID0+IHN0YXRlbWVudC5zcGxpdChcIjpcIikpKSB9LCByaHMpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJocz8uc3R5bGUgPT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRTdHlsZXMobGhzPy5zdHlsZSwgeyBzdHlsZTogT2JqZWN0LmZyb21FbnRyaWVzKGxocz8uc3R5bGUuc3BsaXQoXCI7XCIpLm1hcChzdGF0ZW1lbnQgPT4gc3RhdGVtZW50LnNwbGl0KFwiOlwiKSkpIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBMb2dpYz8/P1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBUaGV5J3JlIGJvdGggc3RyaW5ncywganVzdCBjb25jYXRlbmF0ZSB0aGVtLlxyXG4gICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gYCR7bGhzLnN0eWxlfTske3Jocz8uc3R5bGUgPz8gXCJcIn1gO1xyXG4gICAgfVxyXG4gICAgLy8gVGhleSdyZSBib3RoIG9iamVjdHMsIGp1c3QgbWVyZ2UgdGhlbS5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uKGxocz8uc3R5bGUgPz8ge30pLFxyXG4gICAgICAgIC4uLihyaHM/LnN0eWxlID8/IHt9KVxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbWVyZ2VkLXN0eWxlcy5qcy5tYXAiLCJpbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW5cIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2xhc3NlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2xhc3Nlc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1yZWZzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzXCI7XHJcbmxldCBsb2cgPSAoc3RyKSA9PiB7IGRlYnVnZ2VyOyAvKiBJbnRlbnRpb25hbCAqLyB9O1xyXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1Byb3BDb25mbGljdHMobG9nMikge1xyXG4gICAgbG9nID0gbG9nMjtcclxufVxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAqXHJcbiAqIFRoZSBob29rIGlzIGF3YXJlIG9mIGFuZCBjYW4gaW50ZWxsaWdlbnRseSBtZXJnZSBgY2xhc3NOYW1lYCwgYGNsYXNzYCwgYHN0eWxlYCwgYHJlZmAsIGFuZCBhbGwgZXZlbnQgaGFuZGxlcnMuXHJcbiAqIEBwYXJhbSBsaHMyXHJcbiAqIEBwYXJhbSByaHMyXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHMoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGxoczIsIHJoczIpIHtcclxuICAgICAgICAvLyBGaXJzdCwgcHV0IGluIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IGFyZSBlYXN5IHRvIHJlYXNvbiBhYm91dFxyXG4gICAgICAgIC8vIGFuZCBhbGwgbGhzIHByb3BzLiBXZSdyZSBnb2luZyB0byBtZXJnZSBpbiByaHMganVzdCBhZnRlci5cclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBsaHNDaGlsZHJlbiwgY2xhc3M6IGxoc0NsYXNzLCBjbGFzc05hbWU6IGxoc0NsYXNzTmFtZSwgc3R5bGU6IGxoc1N0eWxlLCByZWY6IGxoc1JlZiwgLi4ubGhzIH0gPSBsaHMyO1xyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IHJoc0NoaWxkcmVuLCBjbGFzczogcmhzQ2xhc3MsIGNsYXNzTmFtZTogcmhzQ2xhc3NOYW1lLCBzdHlsZTogcmhzU3R5bGUsIHJlZjogcmhzUmVmLCAuLi5yaHMgfSA9IHJoczI7XHJcbiAgICAgICAgbGV0IHJldCA9IHtcclxuICAgICAgICAgICAgLi4ubGhzLFxyXG4gICAgICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnMoKShsaHMyLCByaHMyKSxcclxuICAgICAgICAgICAgc3R5bGU6IHVzZU1lcmdlZFN0eWxlcyhsaHMyLCByaHMyKSxcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiB1c2VNZXJnZWRDbGFzc2VzKGxoczIsIHJoczIpLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogdXNlTWVyZ2VkQ2hpbGRyZW4obGhzMiwgcmhzMilcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGRlbGV0ZSByZXQucmVmO1xyXG4gICAgICAgIGlmIChyZXQuc3R5bGUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgZGVsZXRlIHJldC5zdHlsZTtcclxuICAgICAgICBpZiAocmV0LmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBkZWxldGUgcmV0LmNsYXNzTmFtZTtcclxuICAgICAgICBpZiAocmV0LmNoaWxkcmVuID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGRlbGV0ZSByZXQuY2hpbGRyZW47XHJcbiAgICAgICAgLy8gTm93LCBkbyAqZXZlcnl0aGluZyogZWxzZVxyXG4gICAgICAgIC8vIE1lcmdlIGV2ZXJ5IHJlbWFpbmluZyBleGlzdGluZyBlbnRyeSBpbiBsaHMgd2l0aCB3aGF0IHdlJ3ZlIGFscmVhZHkgcHV0IGluIHJldC5cclxuICAgICAgICAvL2NvbnN0IGxoc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhsaHMpIGFzIFtrZXlvZiBULCBUW2tleW9mIFRdXVtdO1xyXG4gICAgICAgIGNvbnN0IHJoc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhyaHMpO1xyXG4gICAgICAgIGZvciAoY29uc3QgW3Joc0tleSwgcmhzVmFsdWVdIG9mIHJoc0VudHJpZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbGhzVmFsdWUgPSBsaHNbcmhzS2V5XTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGV5J3JlIGJvdGggZnVuY3Rpb25zIHRoYXQgY2FuIGJlIG1lcmdlZCAob3Igb25lJ3MgYSBmdW5jdGlvbiBhbmQgdGhlIG90aGVyJ3MgbnVsbCkuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3QgYW4gKmVhc3kqIGNhc2UsIGJ1dCBhIHdlbGwtZGVmaW5lZCBvbmUuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZUZ1bmN0aW9ucyhsaHNWYWx1ZSwgcmhzVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBtZXJnZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVaC4uLndlJ3JlIGhlcmUgYmVjYXVzZSBvbmUgb2YgdGhlbSdzIG51bGwsIHJpZ2h0P1xyXG4gICAgICAgICAgICAgICAgaWYgKGxoc1ZhbHVlID09IG51bGwgJiYgcmhzVmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IHJoc1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWU7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyaHNWYWx1ZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gbGhzVmFsdWU7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyaHNWYWx1ZSA9PSBsaHNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEkgbWVhbiwgdGhleSdyZSB0aGUgc2FtZSB2YWx1ZSBhdCBsZWFzdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVZ2guXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gZ29vZCBzdHJhdGVnaWVzIGhlcmUsIGp1c3QgbG9nIGl0IGlmIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICAgICAgICAgIGxvZz8uKGBDb3VsZCBub3QgbWVyZ2UgaW5jb21wYXRpYmxlIHByb3AgXCIke3Joc0tleX1cIiAodHlwZTogJHt0eXBlb2YgcmhzVmFsdWV9LCB2YWx1ZXM6IFske2xoc1ZhbHVlfSwgJHtyaHNWYWx1ZX1dKWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VGdW5jdGlvbnMobGhzLCByaHMpIHtcclxuICAgIGlmICghbGhzKVxyXG4gICAgICAgIHJldHVybiByaHM7XHJcbiAgICBpZiAoIXJocylcclxuICAgICAgICByZXR1cm4gbGhzO1xyXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgbGV0IGx2ID0gbGhzPy4oLi4uYXJncyk7XHJcbiAgICAgICAgbGV0IHJ2ID0gcmhzPy4oLi4uYXJncyk7XHJcbiAgICAgICAgaWYgKGx2IGluc3RhbmNlb2YgUHJvbWlzZSB8fCBydiBpbnN0YW5jZW9mIFByb21pc2UpXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbHYsIHJ2XSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdlbmVyaWNHZXRUZXN0KCkge1xyXG4gICAgY29uc3QgdDEgPSBudWxsO1xyXG4gICAgY29uc3QgdDIgPSBudWxsO1xyXG4gICAgY29uc3QgdDMgPSBudWxsO1xyXG4gICAgaWYgKHQzLmlkID09IG51bGwpIHtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHQzLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIH1cclxufVxyXG4vKlxyXG5mdW5jdGlvbiB0ZXN0PFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxIVE1MSW5wdXRFbGVtZW50Pj4ocHJvcHM6IFApIHtcclxuXHJcbiAgICBjb25zdCBpZDA6IEdlbmVyaWNHZXQ8e30sIFwiaWRcIiwgc3RyaW5nPiA9IFwiXCI7XHJcbiAgICBjb25zdCBpZDM6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNDogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ1OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDY6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIC8vY29uc3QgaWQyOiBaaXBTaW5nbGU8c3RyaW5nIHwgdW5kZWZpbmVkLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQxOiBaaXBPYmplY3Q8eyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IHN0cmluZyB9PiA9IHsgaWQ6IHVuZGVmaW5lZCB9O1xyXG5cclxuICAgIHR5cGUgTTEgPSBHZW5lcmljR2V0PFAsIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIHR5cGUgTTIgPSBHZW5lcmljR2V0PHt9LCBcInN0eWxlXCIsIHN0cmluZz47XHJcbiAgICBjb25zdCBtMTogTTEgPSBcIlwiO1xyXG4gICAgY29uc3QgbTI6IE0xID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG0zOiBNMSA9IDA7XHJcblxyXG4gICAgY29uc3QgbTQ6IE0yID0gXCJcIjtcclxuICAgIGNvbnN0IG01OiBNMiA9IHVuZGVmaW5lZDtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIEJlY2F1c2UgbnVtYmVyIGlzbid0IGFzc2lnbmFibGUgdG8gc3RyaW5nXHJcbiAgICBjb25zdCBtNjogTTIgPSAwO1xyXG5cclxuICAgIGNvbnN0IHAxOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7fSwgeyBpZDogc3RyaW5nIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgeyBpZDogXCJzdHJpbmdcIiB9KTtcclxuICAgIGNvbnN0IHAyOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogXCJzdHJpbmdcIiB9KTtcclxuICAgIGNvbnN0IHAzOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogdW5kZWZpbmVkIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uc3QgcDQ6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7fT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7fSk7XHJcbiAgICBjb25zdCBwNSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHt9KTtcclxuICAgIGNvbnN0IHA2ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgeyBpZDogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uc3QgcDcgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG5cclxuXHJcbiAgICBwMS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHAzLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXHJcbiAgICBwNC5pZD8uY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICBwNS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDYuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHA3LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcDUuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcDYuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcDcuaWQuY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICBpZiAocDUuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDUuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA1LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChwNi5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDYuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA3LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA3LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNy5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgaXQgd29ya3MgcmVjdXJzaXZlbHlcclxuICAgIGNvbnN0IHIxYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAxKTtcclxuICAgIGNvbnN0IHIxYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAxKTtcclxuICAgIGNvbnN0IHIyYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAyKTtcclxuICAgIGNvbnN0IHIyYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAyKTtcclxuICAgIGNvbnN0IHIzYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAzKTtcclxuICAgIGNvbnN0IHIzYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAzKTtcclxuICAgIGNvbnN0IHI0YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA0KTtcclxuICAgIGNvbnN0IHI0YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA0KTtcclxuICAgIGNvbnN0IHI1YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA1KTtcclxuICAgIGNvbnN0IHI1YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA1KTtcclxuICAgIGNvbnN0IHI2YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA2KTtcclxuICAgIGNvbnN0IHI2YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA2KTtcclxuICAgIGNvbnN0IHI3YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA3KTtcclxuICAgIGNvbnN0IHI3YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA3KTtcclxuXHJcblxyXG4gICAgcjFhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMWIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIyYS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJiLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHIzYS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjNiLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXHJcbiAgICByNGEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI0Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICByNWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI1Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjZhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI3YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjVhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI1Yi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjZiLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByN2IuaWQuY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICBpZiAocjVhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjVhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI1YS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjViLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjViLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI1Yi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjZhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjZhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI2YS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjZiLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjZiLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI2Yi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjdhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjdhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI3YS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjdiLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjdiLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI3Yi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxufVxyXG5mdW5jdGlvbiBhY2NlcHRzTmV2ZXIobjogbmV2ZXIpIHt9XHJcbiovIFxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbWVyZ2VkLXByb3BzLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuLyoqXHJcbiAqIFNsaWdodGx5IGVuaGFuY2VkIHZlcnNpb24gb2YgYHVzZVN0YXRlYCB0aGF0IGluY2x1ZGVzIGEgZ2V0dGVyIHRoYXQgcmVtYWlucyBjb25zdGFudFxyXG4gKiAoaS5lLiB5b3UgY2FuIHVzZSBpdCBpbiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcyB3aXRob3V0IGl0IGJlaW5nIGEgZGVwZW5kZW5jeSkuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbml0aWFsU3RhdGVcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcclxuICAgIC8vIFdlIGtlZXAgYm90aFxyXG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcclxuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihzdGF0ZSk7XHJcbiAgICAvLyBIaWphY2sgdGhlIG5vcm1hbCBzZXR0ZXIgZnVuY3Rpb24gXHJcbiAgICAvLyB0byBhbHNvIHNldCBvdXIgcmVmIHRvIHRoZSBuZXcgdmFsdWVcclxuICAgIGNvbnN0IHNldCA9IHVzZUNhbGxiYWNrKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBsZXQgY2FsbGJhY2sgPSB2YWx1ZTtcclxuICAgICAgICAgICAgc2V0U3RhdGUocHJldlZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXh0VmFsdWUgPSBjYWxsYmFjayhwcmV2VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCBnZXQgPSAoKSA9PiB7IHJldHVybiByZWYuY3VycmVudDsgfTtcclxuICAgIGNvbnNvbGUuYXNzZXJ0KHJlZi5jdXJyZW50ID09PSBzdGF0ZSk7XHJcbiAgICByZXR1cm4gW3N0YXRlLCBzZXQsIGdldF07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXN0YXRlLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuLyoqXHJcbiAqIEFsbG93cyBhY2Nlc3NpbmcgdGhlIGVsZW1lbnQgYSByZWYgcmVmZXJlbmNlcyBhcyBzb29uIGFzIGl0IGRvZXMgc28uXHJcbiAqICpUaGlzIGhvb2sgaXRzZWxmIHJldHVybnMgYSBob29rKi0tdXNlUmVmRWxlbWVudFByb3BzIG1vZGlmaWVzIHRoZSBwcm9wcyB0aGF0IHlvdSB3ZXJlIGdvaW5nIHRvIHBhc3MgdG8gYW4gSFRNTEVsZW1lbnQsXHJcbiAqIGFkZGluZyBhIFJlZkNhbGxiYWNrIGFuZCBtZXJnaW5nIGl0IHdpdGggYW55IGV4aXN0aW5nIHJlZiB0aGF0IGV4aXN0ZWQgb24gdGhlIHByb3BzLlxyXG4gKlxyXG4gKiBEb24ndCBmb3JnZXQgdG8gcHJvdmlkZSB0aGUgRWxlbWVudCBhcyB0aGUgdHlwZSBhcmd1bWVudCFcclxuICpcclxuICogQHJldHVybnMgVGhlIGVsZW1lbnQsIGFuZCB0aGUgc3ViLWhvb2sgdGhhdCBtYWtlcyBpdCByZXRyaWV2YWJsZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWZFbGVtZW50KCkge1xyXG4gICAgLy8gTGV0IHVzIHN0b3JlIHRoZSBhY3R1YWwgKHJlZmVyZW5jZSB0bykgdGhlIGVsZW1lbnQgd2UgY2FwdHVyZVxyXG4gICAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnQsIGdldEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICAvLyBDcmVhdGUgYSBSZWZDYWxsYmFjayB0aGF0J3MgZmlyZWQgd2hlbiBtb3VudGVkIFxyXG4gICAgLy8gYW5kIHRoYXQgbm90aWZpZXMgdXMgb2Ygb3VyIGVsZW1lbnQgd2hlbiB3ZSBoYXZlIGl0XHJcbiAgICBjb25zdCBteVJlZiA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGUpXHJcbiAgICAgICAgICAgIHNldEVsZW1lbnQoKCkgPT4gZSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCB1c2VSZWZFbGVtZW50UHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHMpID0+IHVzZU1lcmdlZFByb3BzKCkoeyByZWY6IG15UmVmIH0sIHByb3BzKSwgW10pO1xyXG4gICAgLy8gUmV0dXJuIGJvdGggdGhlIGVsZW1lbnQgYW5kIHRoZSBob29rIHRoYXQgbW9kaWZpZXMgXHJcbiAgICAvLyB0aGUgcHJvcHMgYW5kIGFsbG93cyB1cyB0byBhY3R1YWxseSBmaW5kIHRoZSBlbGVtZW50XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVJlZkVsZW1lbnRQcm9wcyxcclxuICAgICAgICBlbGVtZW50LFxyXG4gICAgICAgIGdldEVsZW1lbnRcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdGVzdCgpIHtcclxuICAgIGZ1bmN0aW9uIGZvbyhwcm9wcykge1xyXG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICAgICAgY29uc3QgcDEgPSB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpO1xyXG4gICAgICAgIGlmIChwMS5zdHlsZSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHAxLnN0eWxlID09PSBcInN0cmluZ1wiKSB7IH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcDEuc3R5bGU/LmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXJlZi1lbGVtZW50LmpzLm1hcCIsImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlRWxlbWVudFNpemUoeyBvYnNlcnZlQm94IH0gPSB7fSkge1xyXG4gICAgY29uc3QgeyBlbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgIGNvbnN0IFtzaXplLCBzZXRTaXplLCBnZXRTaXplXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVVcGRhdGUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBzY3JvbGxXaWR0aCwgb2Zmc2V0V2lkdGgsIGNsaWVudEhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBvZmZzZXRIZWlnaHQsIGNsaWVudExlZnQsIHNjcm9sbExlZnQsIG9mZnNldExlZnQsIGNsaWVudFRvcCwgc2Nyb2xsVG9wLCBvZmZzZXRUb3AgfSA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBzZXRTaXplKHsgY2xpZW50V2lkdGgsIHNjcm9sbFdpZHRoLCBvZmZzZXRXaWR0aCwgY2xpZW50SGVpZ2h0LCBzY3JvbGxIZWlnaHQsIG9mZnNldEhlaWdodCwgY2xpZW50TGVmdCwgc2Nyb2xsTGVmdCwgb2Zmc2V0TGVmdCwgY2xpZW50VG9wLCBzY3JvbGxUb3AsIG9mZnNldFRvcCB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCEoXCJSZXNpemVPYnNlcnZlclwiIGluIHdpbmRvdykpIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlVXBkYXRlLCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVVcGRhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHsgaGFuZGxlVXBkYXRlKCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGJveDogb2JzZXJ2ZUJveCB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbZWxlbWVudCwgb2JzZXJ2ZUJveF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBlbGVtZW50LFxyXG4gICAgICAgIGVsZW1lbnRTaXplOiBzaXplLFxyXG4gICAgICAgIGdldEVsZW1lbnRTaXplOiBnZXRTaXplLFxyXG4gICAgICAgIHVzZUVsZW1lbnRTaXplUHJvcHM6IHVzZVJlZkVsZW1lbnRQcm9wc1xyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtZWxlbWVudC1zaXplLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XHJcbiAgICByZXR1cm4gKHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cigxKSk7XHJcbn1cclxuLyoqXHJcbiAqIEluc3BlY3RzIHRoZSBlbGVtZW50J3Mgc3R5bGUgYW5kIGRldGVybWluZXMgdGhlIGxvZ2ljYWwgZGlyZWN0aW9uIHRoYXQgdGV4dCBmbG93cy5cclxuICpcclxuICogQ2VydGFpbiBDU1MgcHJvcGVydGllcywgbGlrZSBgYmxvY2stc2l6ZWAsIHJlc3BlY3QgdGhlIGN1cnJlbnQgd3JpdGluZyBtb2RlIGFuZCB0ZXh0IGRpcmVjdGlvbi5cclxuICogQnV0IGB0cmFuc2Zvcm1gLCBgY2xpcGAsIGV0Yy4gZG9uJ3QuXHJcbiAqXHJcbiAqIFRoaXMgaXMgcHJvdmlkZWQgc28gdGhhdCBDU1MgcHJvcGVydGllcyBjYW4gY29uc2lzdGVudGx5IHVzZSB0aG9zZSBsb2dpY2FsIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXdyaXRpbmctbW9kZXMvI2xvZ2ljYWwtdG8tcGh5c2ljYWxcclxuICpcclxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnM6XHJcbiAqICogYGdldExvZ2ljYWxEaXJlY3Rpb25gOiByZXRyaWV2ZXMgYSBgTG9naWNhbERpcmVjdGlvbkluZm9gIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudC4gKEZ1bmN0aW9uIGlzIGNvbnN0YW50IGJldHdlZW4gcmVuZGVycylcclxuICogKiBgY29udmVydEVsZW1lbnRTaXplYDogV2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUVsZW1lbnRTaXplYCwgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSB0aGUgbG9naWNhbCBzaXplIG9mIGFuIGVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgcGh5c2ljYWwgc2l6ZS5cclxuICogKiBgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uYDogQmFzZWQgb24gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBjb252ZXJ0cyBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIgdG8gXCJpbmxpbmVcIiBvciBcImJsb2NrXCIuXHJcbiAqICogYGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb25gOiAgQmFzZWQgb24gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBjb252ZXJ0cyBcImlubGluZVwiIG9yIFwiYmxvY2tcIiB0byBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9naWNhbERpcmVjdGlvbihlbGVtZW50KSB7XHJcbiAgICBjb25zdCBbd3JpdGluZ01vZGUsIHNldFdyaXRpbmdNb2RlXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgW2RpcmVjdGlvbiwgc2V0RGlyZWN0aW9uXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgW3RleHRPcmllbnRhdGlvbiwgc2V0VGV4dE9yaWVudGF0aW9uXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3Qgd3JpdGluZ01vZGVSZWYgPSB1c2VSZWYod3JpdGluZ01vZGUpO1xyXG4gICAgY29uc3QgZGlyZWN0aW9uUmVmID0gdXNlUmVmKGRpcmVjdGlvbik7XHJcbiAgICBjb25zdCB0ZXh0T3JpZW50YXRpb25SZWYgPSB1c2VSZWYodGV4dE9yaWVudGF0aW9uKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHdyaXRpbmdNb2RlUmVmLmN1cnJlbnQgPSB3cml0aW5nTW9kZTsgfSwgW3dyaXRpbmdNb2RlXSk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBkaXJlY3Rpb25SZWYuY3VycmVudCA9IGRpcmVjdGlvbjsgfSwgW2RpcmVjdGlvbl0pO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgdGV4dE9yaWVudGF0aW9uUmVmLmN1cnJlbnQgPSB0ZXh0T3JpZW50YXRpb247IH0sIFt0ZXh0T3JpZW50YXRpb25dKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcclxuICAgICAgICAgICAgY29uc3QgdyA9IGNvbXB1dGVkU3R5bGVzLndyaXRpbmdNb2RlO1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gY29tcHV0ZWRTdHlsZXMudGV4dE9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICBjb25zdCBkID0gY29tcHV0ZWRTdHlsZXMuZGlyZWN0aW9uO1xyXG4gICAgICAgICAgICBzZXRXcml0aW5nTW9kZSh3IHx8IFwiaG9yaXpvbnRhbC10YlwiKTtcclxuICAgICAgICAgICAgc2V0RGlyZWN0aW9uKGQgfHwgXCJydGxcIik7XHJcbiAgICAgICAgICAgIHNldFRleHRPcmllbnRhdGlvbih0IHx8IFwibWl4ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBnZXRMb2dpY2FsRGlyZWN0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGxldCB3cml0aW5nTW9kZSA9IHdyaXRpbmdNb2RlUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9IGRpcmVjdGlvblJlZi5jdXJyZW50O1xyXG4gICAgICAgIGxldCB0ZXh0T3JpZW50YXRpb24gPSB0ZXh0T3JpZW50YXRpb25SZWYuY3VycmVudDtcclxuICAgICAgICBpZiAoIXdyaXRpbmdNb2RlIHx8ICFkaXJlY3Rpb24gfHwgIXRleHRPcmllbnRhdGlvbilcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYgKHRleHRPcmllbnRhdGlvbiA9PSBcInVwcmlnaHRcIilcclxuICAgICAgICAgICAgZGlyZWN0aW9uID0gXCJsdHJcIjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5Xcml0aW5nTW9kZXNbd3JpdGluZ01vZGUgPz8gXCJob3Jpem9udGFsLXRiXCJdW2RpcmVjdGlvbiA/PyBcImx0clwiXVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbd3JpdGluZ01vZGVSZWYsIGRpcmVjdGlvblJlZiwgdGV4dE9yaWVudGF0aW9uUmVmXSk7XHJcbiAgICBjb25zdCBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb24gPSB1c2VDYWxsYmFjaygoZWxlbWVudE9yaWVudGF0aW9uLCBkaXJlY3Rpb24pID0+IHtcclxuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb24oKTtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gZWxlbWVudE9yaWVudGF0aW9uKVxyXG4gICAgICAgICAgICByZXR1cm4gXCJpbmxpbmVcIjtcclxuICAgICAgICByZXR1cm4gXCJibG9ja1wiO1xyXG4gICAgfSwgW2dldExvZ2ljYWxEaXJlY3Rpb25dKTtcclxuICAgIGNvbnN0IGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb24gPSB1c2VDYWxsYmFjaygoZWxlbWVudE9yaWVudGF0aW9uLCBkaXJlY3Rpb24pID0+IHtcclxuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb24oKTtcclxuICAgICAgICBpZiAoZWxlbWVudE9yaWVudGF0aW9uID09IFwiaW5saW5lXCIpIHtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT0gXCJob3Jpem9udGFsXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBcInZlcnRpY2FsXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uPy5ibG9ja09yaWVudGF0aW9uID09IFwidmVydGljYWxcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInZlcnRpY2FsXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBcImhvcml6b250YWxcIjtcclxuICAgICAgICB9XHJcbiAgICB9LCBbZ2V0TG9naWNhbERpcmVjdGlvbl0pO1xyXG4gICAgY29uc3QgY29udmVydEVsZW1lbnRTaXplID0gdXNlQ2FsbGJhY2soKGVsZW1lbnRTaXplLCBkaXJlY3Rpb24pID0+IHtcclxuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb24oKTtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaW5saW5lU2l6ZSwgYmxvY2tTaXplLCBpbmxpbmVEaXJlY3Rpb24sIGJsb2NrRGlyZWN0aW9uIH0gPSBkaXJlY3Rpb247XHJcbiAgICAgICAgICAgIC8vIFNpemUgaXMgcmVsYXRpdmVseSBzaW1wbGVcclxuICAgICAgICAgICAgbGV0IGNsaWVudElubGluZVNpemUgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGlubGluZVNpemUpfWBdO1xyXG4gICAgICAgICAgICBsZXQgY2xpZW50QmxvY2tTaXplID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShibG9ja1NpemUpfWBdO1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0SW5saW5lU2l6ZSA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoaW5saW5lU2l6ZSl9YF07XHJcbiAgICAgICAgICAgIGxldCBvZmZzZXRCbG9ja1NpemUgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGJsb2NrU2l6ZSl9YF07XHJcbiAgICAgICAgICAgIGxldCBzY3JvbGxJbmxpbmVTaXplID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShpbmxpbmVTaXplKX1gXTtcclxuICAgICAgICAgICAgbGV0IHNjcm9sbEJsb2NrU2l6ZSA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoYmxvY2tTaXplKX1gXTtcclxuICAgICAgICAgICAgLy8gUG9zaXRpb24gcmVxdWlyZXMgdXMgdG8gc29tZXRpbWVzIHVzZSBvbmUgcHJvcGVydHkgKGxpa2UgYGxlZnRgKVxyXG4gICAgICAgICAgICAvLyBvciBzb21ldGltZXMgdHdvIChsaWtlIGBsZWZ0YCArIGB3aWR0aGApXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFBoeXNpY2FsTGVmdFRvcChkaXIpIHsgaWYgKGRpciA9PT0gXCJsdHJcIiB8fCBkaXIgPT0gXCJydGxcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImxlZnRcIjsgcmV0dXJuIFwidG9wXCI7IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShkaXIpIHsgaWYgKGRpciA9PT0gXCJydGxcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIndpZHRoXCI7IGlmIChkaXIgPT09IFwiYnR0XCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJoZWlnaHRcIjsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICAgICAgY29uc3QgZjEgPSBnZXRQaHlzaWNhbExlZnRUb3AoaW5saW5lRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgZjIgPSBnZXRQaHlzaWNhbFJpZ2h0Qm90dG9tKGlubGluZURpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IGYzID0gZ2V0UGh5c2ljYWxMZWZ0VG9wKGJsb2NrRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgZjQgPSBnZXRQaHlzaWNhbFJpZ2h0Qm90dG9tKGJsb2NrRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgbGV0IGNsaWVudElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmMSl9YF0gKyAoIWYyID8gMCA6IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjIpfWBdKTtcclxuICAgICAgICAgICAgbGV0IHNjcm9sbElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMSl9YF0gKyAoIWYyID8gMCA6IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjIpfWBdKTtcclxuICAgICAgICAgICAgbGV0IG9mZnNldElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMSl9YF0gKyAoIWYyID8gMCA6IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjIpfWBdKTtcclxuICAgICAgICAgICAgbGV0IGNsaWVudEJsb2NrSW5zZXQgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGYzKX1gXSArICghZjQgPyAwIDogZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmNCl9YF0pO1xyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsQmxvY2tJbnNldCA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjMpfWBdICsgKCFmNCA/IDAgOiBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGY0KX1gXSk7XHJcbiAgICAgICAgICAgIGxldCBvZmZzZXRCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMyl9YF0gKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjQpfWBdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGNsaWVudElubGluZVNpemUsXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxJbmxpbmVTaXplLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0SW5saW5lU2l6ZSxcclxuICAgICAgICAgICAgICAgIGNsaWVudEJsb2NrU2l6ZSxcclxuICAgICAgICAgICAgICAgIHNjcm9sbEJsb2NrU2l6ZSxcclxuICAgICAgICAgICAgICAgIG9mZnNldEJsb2NrU2l6ZSxcclxuICAgICAgICAgICAgICAgIGNsaWVudElubGluZUluc2V0LFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW5saW5lSW5zZXQsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRJbmxpbmVJbnNldCxcclxuICAgICAgICAgICAgICAgIGNsaWVudEJsb2NrSW5zZXQsXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxCbG9ja0luc2V0LFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0QmxvY2tJbnNldCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LCBbZ2V0TG9naWNhbERpcmVjdGlvbl0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRMb2dpY2FsRGlyZWN0aW9uLFxyXG4gICAgICAgIGNvbnZlcnRFbGVtZW50U2l6ZSxcclxuICAgICAgICBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb24sXHJcbiAgICAgICAgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvblxyXG4gICAgfTtcclxufVxyXG47XHJcbmNvbnN0IEhvcml6b250YWxUYkx0ciA9IHtcclxuICAgIGlubGluZURpcmVjdGlvbjogXCJsdHJcIixcclxuICAgIGJsb2NrRGlyZWN0aW9uOiBcInR0YlwiLFxyXG4gICAgaW5saW5lT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgYmxvY2tPcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgaW5saW5lU2l6ZTogXCJ3aWR0aFwiLFxyXG4gICAgYmxvY2tTaXplOiBcImhlaWdodFwiLFxyXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcImx0clwiLFxyXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcInR0YlwiXHJcbn07XHJcbmNvbnN0IEhvcml6b250YWxUYlJ0bCA9IHtcclxuICAgIC4uLkhvcml6b250YWxUYkx0cixcclxuICAgIGlubGluZURpcmVjdGlvbjogXCJydGxcIixcclxufTtcclxuY29uc3QgVmVydGljYWxSbEx0ciA9IHtcclxuICAgIGlubGluZURpcmVjdGlvbjogXCJ0dGJcIixcclxuICAgIGJsb2NrRGlyZWN0aW9uOiBcInJ0bFwiLFxyXG4gICAgaW5saW5lT3JpZW50YXRpb246IFwidmVydGljYWxcIixcclxuICAgIGJsb2NrT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgaW5saW5lU2l6ZTogXCJoZWlnaHRcIixcclxuICAgIGJsb2NrU2l6ZTogXCJ3aWR0aFwiLFxyXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcInR0YlwiLFxyXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcInJ0bFwiXHJcbn07XHJcbmNvbnN0IFZlcnRpY2FsUmxSdGwgPSB7XHJcbiAgICAuLi5WZXJ0aWNhbFJsTHRyLFxyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcImJ0dFwiXHJcbn07XHJcbmNvbnN0IFNpZGV3YXlzUmxMdHIgPSB7IC4uLlZlcnRpY2FsUmxMdHIgfTtcclxuY29uc3QgU2lkZXdheXNSbFJ0bCA9IHsgLi4uVmVydGljYWxSbFJ0bCB9O1xyXG5jb25zdCBWZXJ0aWNhbExyTHRyID0ge1xyXG4gICAgLi4uVmVydGljYWxSbEx0cixcclxuICAgIGJsb2NrRGlyZWN0aW9uOiBcImx0clwiLFxyXG59O1xyXG5jb25zdCBWZXJ0aWNhbExyUnRsID0ge1xyXG4gICAgLi4uVmVydGljYWxSbFJ0bCxcclxuICAgIGJsb2NrRGlyZWN0aW9uOiBcImx0clwiLFxyXG59O1xyXG5jb25zdCBTaWRld2F5c0x0THRyID0ge1xyXG4gICAgLi4uVmVydGljYWxMckx0cixcclxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIixcclxuICAgIGxlZnRSaWdodERpcmVjdGlvbjogXCJidHRcIixcclxuICAgIG92ZXJVbmRlckRpcmVjdGlvbjogXCJsdHJcIlxyXG59O1xyXG5jb25zdCBTaWRld2F5c0x0UnRsID0ge1xyXG4gICAgLi4uU2lkZXdheXNMdEx0cixcclxuICAgIGlubGluZURpcmVjdGlvbjogXCJ0dGJcIlxyXG59O1xyXG5jb25zdCBIb3Jpem9udGFsVGIgPSB7XHJcbiAgICBsdHI6IEhvcml6b250YWxUYkx0cixcclxuICAgIHJ0bDogSG9yaXpvbnRhbFRiUnRsXHJcbn07XHJcbmNvbnN0IFZlcnRpY2FsUmwgPSB7XHJcbiAgICBsdHI6IFZlcnRpY2FsUmxMdHIsXHJcbiAgICBydGw6IFZlcnRpY2FsUmxSdGxcclxufTtcclxuY29uc3QgVmVydGljYWxMciA9IHtcclxuICAgIGx0cjogVmVydGljYWxMckx0cixcclxuICAgIHJ0bDogVmVydGljYWxMclJ0bFxyXG59O1xyXG5jb25zdCBTaWRld2F5c1JsID0ge1xyXG4gICAgbHRyOiBTaWRld2F5c1JsTHRyLFxyXG4gICAgcnRsOiBTaWRld2F5c1JsUnRsXHJcbn07XHJcbmNvbnN0IFNpZGV3YXlzTHIgPSB7XHJcbiAgICBsdHI6IFNpZGV3YXlzTHRMdHIsXHJcbiAgICBydGw6IFNpZGV3YXlzTHRSdGxcclxufTtcclxuY29uc3QgV3JpdGluZ01vZGVzID0ge1xyXG4gICAgXCJob3Jpem9udGFsLXRiXCI6IEhvcml6b250YWxUYixcclxuICAgIFwidmVydGljYWwtbHJcIjogVmVydGljYWxMcixcclxuICAgIFwidmVydGljYWwtcmxcIjogVmVydGljYWxSbCxcclxuICAgIFwic2lkZXdheXMtbHJcIjogU2lkZXdheXNMcixcclxuICAgIFwic2lkZXdheXMtcmxcIjogU2lkZXdheXNSbFxyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbG9naWNhbC1kaXJlY3Rpb24uanMubWFwIiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuLyoqXHJcbiAqIEdpdmVuIGFuIGlucHV0IHZhbHVlLCByZXR1cm5zIGEgY29uc3RhbnQgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWRcclxuICogaW5zaWRlIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaW5jbHVkaW5nIGl0IGluIHRoZSBkZXBlbmRlbmN5IGFycmF5LlxyXG4gKlxyXG4gKiBVc2Ugd2l0aCBjYXV0aW9uLCBhbmQgKipkbyBub3QgdXNlIHRoZSBnZXR0ZXIgaW4gdXNlTGF5b3V0RWZmZWN0ISEqKlxyXG4gKiBgc2V0U3RhdGVgJ3MgZ2V0dGVyIGRvZXMgbm90IGhhdmUgdGhpcyBwcm9ibGVtLCBidXQgdGhlbiB5b3UncmUgdXNpbmcgeW91ciBvd24gc3RhdGVcclxuICogaW5zdGVhZCBvZiBhbiBleGlzdGluZyB2YWx1ZSwgd2hpY2ggbWlnaHQgbm90IGFsd2F5cyBiZSBmZWFzaWJsZS5cclxuICpcclxuICogV2VpZ2ggeW91ciBvcHRpb25zLCBhbmQgaG9wZWZ1bGx5IG9uZSBvZiB0aGVtIGdldHMgdGhlIGpvYiBkb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVHZXR0ZXIodmFsdWUpIHtcclxuICAgIGNvbnN0IHJlZiA9IHVzZVJlZih2YWx1ZSk7XHJcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gdmFsdWUpO1xyXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHsgcmV0dXJuIHJlZi5jdXJyZW50OyB9LCBbXSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXN0YWJsZS1nZXR0ZXIuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XHJcbi8qKlxyXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXHJcbiAqIHNvIHRoYXQgaXQgY2FuIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGRlcGVuZGVuY3kgYXJyYXlzIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzLlxyXG4gKlxyXG4gKiBETyBOT1QgVVNFIFRIRSBSRVNVTFQgSU4gdXNlTGF5b3V0RWZmZWN0ISFcclxuICpcclxuICogVE9ETzogSW52ZXN0aWdhdGUgb3B0aW9ucy5kaWZmZWQgaWYgdGhlIHVzZUxheW91dEVmZmVjdCBsaW1pdGF0aW9uIGJlY29tZXMgbGltaXRsZXNzbHkgbGltaXRpbmcuXHJcbiAqXHJcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDA5OSNpc3N1ZWNvbW1lbnQtNjU5Mjk4NDIyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlQ2FsbGJhY2soZm4pIHtcclxuICAgIGNvbnN0IGN1cnJlbnRDYWxsYmFja0dldHRlciA9IHVzZVN0YWJsZUdldHRlcihmbik7XHJcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50RnVuYyA9IGN1cnJlbnRDYWxsYmFja0dldHRlcigpO1xyXG4gICAgICAgIGlmICghY3VycmVudEZ1bmMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayByZXRyaWV2ZWQgZnJvbSB1c2VTdGFibGVDYWxsYmFjaygpIGNhbm5vdCBiZSBjYWxsZWQgZnJvbSB1c2VMYXlvdXRFZmZlY3QoKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRGdW5jKC4uLmFyZ3MpO1xyXG4gICAgfSwgW10pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1zdGFibGUtY2FsbGJhY2suanMubWFwIiwiaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdE5hdGl2ZSwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG4vKipcclxuICogV3JhcCB0aGUgbmF0aXZlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGFkZCBhcmd1bWVudHNcclxuICogdGhhdCBhbGxvdyBhY2Nlc3NpbmcgdGhlIHByZXZpb3VzIHZhbHVlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCxcclxuICogYXMgd2VsbCBhcyB0aGUgY2hhbmdlcyB0aGF0IGNhdXNlZCB0aGUgaG9vayB0byBiZSBjYWxsZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cclxuICpcclxuICogQHBhcmFtIGVmZmVjdFxyXG4gKiBAcGFyYW0gaW5wdXRzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGVmZmVjdCwgaW5wdXRzKSB7XHJcbiAgICBjb25zdCBwcmV2SW5wdXRzID0gdXNlUmVmKGlucHV0cyk7XHJcbiAgICBjb25zdCBlZmZlY3QyID0gKCkgPT4ge1xyXG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heChwcmV2SW5wdXRzLmN1cnJlbnQubGVuZ3RoLCBpbnB1dHMubGVuZ3RoKTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2SW5wdXRzLmN1cnJlbnRbaV0gIT0gaW5wdXRzW2ldKVxyXG4gICAgICAgICAgICAgICAgY2hhbmdlc1tpXSA9IHsgZnJvbTogcHJldklucHV0cy5jdXJyZW50W2ldLCB0bzogaW5wdXRzW2ldIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVmZmVjdChwcmV2SW5wdXRzLmN1cnJlbnQsIGNoYW5nZXMpO1xyXG4gICAgICAgIHByZXZJbnB1dHMuY3VycmVudCA9IGlucHV0cztcclxuICAgIH07XHJcbiAgICB1c2VMYXlvdXRFZmZlY3ROYXRpdmUoZWZmZWN0MiwgaW5wdXRzKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbGF5b3V0LWVmZmVjdC5qcy5tYXAiLCJpbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGltZW91dCh7IHRpbWVvdXQsIGNhbGxiYWNrLCB0cmlnZ2VySW5kZXggfSkge1xyXG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjayhjYWxsYmFjayk7XHJcbiAgICBjb25zdCBnZXRUaW1lb3V0ID0gdXNlU3RhYmxlR2V0dGVyKHRpbWVvdXQpO1xyXG4gICAgY29uc3QgdGltZW91dElzTnVsbCA9ICh0aW1lb3V0ID09IG51bGwpO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gZ2V0VGltZW91dCgpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRpbWVvdXRJc051bGwgPT0gKHRpbWVvdXQgPT0gbnVsbCkpO1xyXG4gICAgICAgIGlmICh0aW1lb3V0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoc3RhYmxlQ2FsbGJhY2ssIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3RyaWdnZXJJbmRleCwgdGltZW91dElzTnVsbF0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS10aW1lb3V0LmpzLm1hcCIsImltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtbGF5b3V0LWVmZmVjdFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VUaW1lb3V0IH0gZnJvbSBcIi4vdXNlLXRpbWVvdXRcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBhc3luY3Jvbm91cyBldmVudCBoYW5kbGVyLCByZXR1cm5zIGEgc3luY3Jvbm91cyBvbmUgdGhhdCB3b3JrcyBvbiB0aGUgRE9NLFxyXG4gKiBhbG9uZyB3aXRoIHNvbWUgb3RoZXIgaW5mb3JtYXRpb24gcmVsYXRlZCB0byB0aGUgY3VycmVudCBzdGF0ZS5cclxuICogRG9lcyBub3QgbW9kaWZ5IGFueSBwcm9wcy5cclxuICpcclxuICogVGhlIGhhbmRsZXIgaXMgYXV0b21hdGljYWxseSB0aHJvdHRsZWQgdG8gb25seSBydW4gb25lIGF0IGEgdGltZS5cclxuICogSWYgdGhlIGhhbmRsZXIgaXMgY2FsbGVkLCBhbmQgdGhlbiBiZWZvcmUgaXQgZmluaXNoZXMsIGlzIGNhbGxlZCBhZ2FpbixcclxuICogaXQgd2lsbCBiZSBwdXQgb24gaG9sZCB1bnRpbCB0aGUgY3VycmVudCBvbmUgZmluaXNoZXMsIGF0IHdoaWNoIHBvaW50XHJcbiAqIHRoZSBzZWNvbmQgb25lIHdpbGwgcnVuLiAgSWYgdGhlIGhhbmRsZXIgaXMgY2FsbGVkIGEgdGhpcmQgdGltZSBiZWZvcmVcclxuICogdGhlIGZpcnN0IGhhcyBmaW5pc2hlZCwgaXQgd2lsbCAqcmVwbGFjZSogdGhlIHNlY29uZCwgc28gb25seSB0aGUgbW9zdFxyXG4gKiByZWNlbnRseSBjYWxsZWQgaXRlcmF0aW9uIG9mIHRoZSBoYW5kbGVyIHdpbGwgcnVuLlxyXG4gKlxyXG4gKiBZb3UgbWF5IG9wdGlvbmFsbHkgKmFsc28qIHNwZWNpZnkgYSBkZWJvdW5jZSBwYXJhbWV0ZXIgdGhhdCB3YWl0cyB1bnRpbCB0aGVcclxuICogc3luY3Jvbm91cyBoYW5kbGVyIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mXHJcbiAqIG1pbGxpc2Vjb25kcywgYXQgd2hpY2ggcG9pbnQgd2UgKmFjdHVhbGx5KiBydW4gdGhlIGFzeW5jcm9ub3VzIGhhbmRsZXJcclxuICogYWNjb3JkaW5nIHRvIHRoZSBsb2dpYyBpbiB0aGUgcHJldmlvdXMgcGFyYWdyYXBoLiBUaGlzIGlzIGluXHJcbiAqICphZGRpdGlvbiogdG8gdGhyb3R0bGluZyB0aGUgaGFuZGxlciwgYW5kIGRvZXMgbm90IHJlcGxhY2UgdGhhdCBiZWhhdmlvci5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSBwYXJhbWV0ZXJzIHRvIHRoZSBhc3luYyBoYW5kbGVyIGFyZSBzbGlnaHRseSBkaWZmZXJlbnQgdGhhblxyXG4gKiB0aGUgc3luYyBoYW5kbGVyICZuZGFzaDsgdGhlIGZpcnN0IGFyZ3VtZW50LCBhcyBkZWNpZGVkIGJ5IHlvdSB3aXRoIHRoZVxyXG4gKiBgY2FwdHVyZWAgcGFyYW1ldGVyIGZvciB0aGlzIGhvb2ssIGlzIHRoZSBcInNhdmVkXCIgaW5mb3JtYXRpb24gZnJvbSB0aGVcclxuICogZXZlbnQuICBGb3IgZXhhbXBsZSwgdGhlIGV2ZW50J3MgY3VycmVudFRhcmdldCdzIGB2YWx1ZWAsIHdoaWNoIG1heSBoYXZlXHJcbiAqIGNoYW5nZWQgYnkgdGhlIHRpbWUgdGhlIGhhbmRsZXIgaXMgKmFjdHVhbGx5KiBjYWxsZWQuICBUaGUgc2Vjb25kIGFyZ3VtZW50XHJcbiAqIGlzIHRoZSBvcmlnaW5hbCBldmVudCwgd2hpY2ggbWlnaHQgc3RpbGwgaGF2ZSBzb21lIHVzZWZ1bCBmaWVsZHMgb24gaXRcclxuICogbGlrZSBgbW91c2VYYCBvciBzb21ldGhpbmcsIGJ1dCBpcyBzdGFsZSBhdCBsZWFzdCBpbiByZWdhcmRzIHRvIHRoZVxyXG4gKiBlbGVtZW50IGl0IHJlZmVyZW5jZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmNIYW5kbGVyKCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh7IGNhcHR1cmUsIGRlYm91bmNlIH0pIHtcclxuICAgICAgICAvLyBBbHdheXMgcmVwcmVzZW50cyB3aGF0ZXZlciBwcm9taXNlIGlzIGN1cnJlbnRseSBiZWluZyB3YWl0ZWQgb24sIG9yIG51bGwgaWYgbm9uZS5cclxuICAgICAgICBjb25zdCBbcHJvbWlzZSwgc2V0UHJvbWlzZSwgZ2V0UHJvbWlzZV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRpbWVzIHdlJ3ZlIGFjdHVhbGx5IGNhbGxlZCB0aGUgYXN5bmMgaGFuZGxlclxyXG4gICAgICAgIGNvbnN0IFtydW5Db3VudCwgc2V0UnVuQ291bnRdID0gdXNlU3RhdGUoMCk7XHJcbiAgICAgICAgY29uc3QgW3Jlc29sdmVDb3VudCwgc2V0UmVzb2x2ZUNvdW50XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgICAgIGNvbnN0IFtyZWplY3RDb3VudCwgc2V0UmVqZWN0Q291bnRdID0gdXNlU3RhdGUoMCk7XHJcbiAgICAgICAgLy8gXHJcbiAgICAgICAgY29uc3QgW2N1cnJlbnRUeXBlLCBzZXRDdXJyZW50VHlwZV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgICAgICAvLyBJZiB3ZSdyZSBzZXQgdG8gdXNlIGEgZGVib3VuY2UsIHRoZW4gd2hlbiB0aGUgdGltZW91dCBmaW5pc2hlcyxcclxuICAgICAgICAvLyB0aGUgcHJvbWlzZSBmcm9tIHRoaXMgc3RhdGUgb2JqZWN0IGlzIHRyYW5zZmVycmVkIG92ZXIgdG8gZWl0aGVyIFxyXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHByb21pc2Ugb3IgdGhlIHBlbmRpbmcgcHJvbWlzZS5cclxuICAgICAgICBjb25zdCBbZGVib3VuY2VkUHJvbWlzZVN0YXJ0ZXIsIHNldERlYm91bmNlZFByb21pc2VTdGFydGVyLCBnZXREZWJvdW5jZWRQcm9taXNlU3RhcnRlcl0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgICAgICAvLyBXaGVuIHdlIHdhbnQgdG8gc3RhcnQgYSBuZXcgcHJvbWlzZSwgd2Ugd29uJ3QgYWxsb3cgaXQgdG8gc3RhcnQgaWYgb25lIGlzIHN0aWxsIHJ1bm5pbmcuXHJcbiAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSBzdG9yZSB0aGUgcHJvbWlzZSAob3IgcmF0aGVyLCBhIHdheSB0byBzdGFydCB0aGUgcHJvbWlzZSkgaW4gc3RhdGUuXHJcbiAgICAgICAgY29uc3QgW3BlbmRpbmdQcm9taXNlU3RhcnRlciwgc2V0UGVuZGluZ1Byb21pc2VTdGFydGVyLCBnZXRQZW5kaW5nUHJvbWlzZVN0YXJ0ZXJdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gYHVuZGVmaW5lZGAgYW5kIFwibm8gZXJyb3IgaGFzIGJlZW4gdGhyb3duXCIuXHJcbiAgICAgICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvciwgZ2V0RXJyb3JdID0gdXNlU3RhdGUodW5kZWZpbmVkKTtcclxuICAgICAgICBjb25zdCBbaGFzRXJyb3IsIHNldEhhc0Vycm9yLCBnZXRIYXNFcnJvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICAgICAgLy8gU2FtZSB0aGluZywgd2UgbmVlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gXCJub3RoaW5nIGNhcHR1cmVkIHlldFwiIGFuZCBcImB1bmRlZmluZWRgIHdhcyBjYXB0dXJlZFwiXHJcbiAgICAgICAgY29uc3QgW2N1cnJlbnRDYXB0dXJlLCBzZXRDdXJyZW50Q2FwdHVyZSwgZ2V0Q3VycmVudENhcHR1cmVdID0gdXNlU3RhdGUodW5kZWZpbmVkKTtcclxuICAgICAgICBjb25zdCBbaGFzQ2FwdHVyZSwgc2V0SGFzQ2FwdHVyZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICAgICAgLy8gV2hlbiB0aGUgZGVib3VuY2UgdGltZXIgaXMgdXAgKG9yIHdlIG1hbnVhbGx5IHJlcXVlc3QgdGhlIGRlYm91bmNlIHRvIGVuZClcclxuICAgICAgICAvLyBydW4gdGhlIG5vcm1hbCBcInBsZWFzZSBjb25zaWRlciBydW5uaW5nIHRoaXMgcHJvbWlzZVwiIHJvdXRpbmUgdGhhdCB3ZSB3b3VsZFxyXG4gICAgICAgIC8vIGhhdmUganVzdCBydW4gaW1tZWRpYXRlbHkgaWYgd2Ugd2VyZW4ndCBkZWJvdW5jaW5nIG91ciBwcm9taXNlcy5cclxuICAgICAgICBjb25zdCBvbkRlYm91bmNlVGltZVVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkZWJvdW5jZWRQcm9taXNlU3RhcnRlciA9IGdldERlYm91bmNlZFByb21pc2VTdGFydGVyKCk7XHJcbiAgICAgICAgICAgIGlmIChkZWJvdW5jZWRQcm9taXNlU3RhcnRlcilcclxuICAgICAgICAgICAgICAgIHdhbnRUb1N0YXJ0QU5ld1Byb21pc2UoZGVib3VuY2VkUHJvbWlzZVN0YXJ0ZXIpO1xyXG4gICAgICAgICAgICBzZXREZWJvdW5jZWRQcm9taXNlU3RhcnRlcihudWxsKTtcclxuICAgICAgICB9LCBbd2FudFRvU3RhcnRBTmV3UHJvbWlzZSwgc2V0RGVib3VuY2VkUHJvbWlzZVN0YXJ0ZXJdKTtcclxuICAgICAgICAvLyBIYW5kbGUgdGhlIGRlYm91bmNlLiBMb2dpY2FsbHkgdGhpcyBoYXBwZW5zIGJlZm9yZSB0aGUgbWFpbiBzdGVwIGFzIGEgc29ydCBvZiBzdGVwIDAuXHJcbiAgICAgICAgLy8gUmVzZXRzIHRoZSB0aW1lb3V0IGFueSB0aW1lIHRoZSBoYW5kbGVyIHdhcyByZXF1ZXN0ZWQgdG8gYmUgY2FsbGVkIGFnYWluXHJcbiAgICAgICAgLy8gYW5kIHdoZW4gaXQgZmluaXNoZXMsIGFjdHVhbGx5IGNhbGwgdGhlIGhhbmRsZXIgKG9yIHNldCBpdCBhcyB0aGUgcGVuZGluZyBwcm9taXNlKVxyXG4gICAgICAgIHVzZVRpbWVvdXQoe1xyXG4gICAgICAgICAgICB0aW1lb3V0OiBkZWJvdW5jZSA/PyBudWxsLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogb25EZWJvdW5jZVRpbWVVcCxcclxuICAgICAgICAgICAgdHJpZ2dlckluZGV4OiBkZWJvdW5jZWRQcm9taXNlU3RhcnRlclxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFNlZSBpZiB3ZSBzaG91bGQgc2V0IG91ciBjdXJyZW50IHByb21pc2UgdG8gYmUgd2hhdGV2ZXIgdGhlIHBlbmRpbmcgcHJvbWlzZSBpc1xyXG4gICAgICAgIC8vICh1c3VhbGx5IGJlY2F1c2UgdGhlIGN1cnJlbnQgcHJvbWlzZSBmaW5pc2hlZCBhbmQgYmVjYW1lIG51bGwpLlxyXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIE91ciBjdXJyZW50IHByb21pc2UganVzdCBmaW5pc2hlZCBhbmQgdGhlcmUncyBvbmUgd2FpdGluZz9cclxuICAgICAgICAgICAgaWYgKHByb21pc2UgPT0gbnVsbCAmJiBwZW5kaW5nUHJvbWlzZVN0YXJ0ZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgd2FudFRvU3RhcnRBTmV3UHJvbWlzZShwZW5kaW5nUHJvbWlzZVN0YXJ0ZXIpO1xyXG4gICAgICAgICAgICAgICAgc2V0UGVuZGluZ1Byb21pc2VTdGFydGVyKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW3Byb21pc2UsIHBlbmRpbmdQcm9taXNlU3RhcnRlcl0pO1xyXG4gICAgICAgIC8vIENhbGxlZCBhbnkgdGltZSB0aGUgYXN5bmMgaGFuZGxlciBpcyBhYm91dCB0byBiZSBjYWxsZWQgZm9yIHdoYXRldmVyIHJlYXNvbixcclxuICAgICAgICAvLyBleGNlcHQgZm9yIGRlYm91bmNlLCB3aGljaCBjb21lcyBmaXJzdCwgYXMgYSBzb3J0IG9mIFwic3RlcCAwXCIuXHJcbiAgICAgICAgLy8gSGFuZGxlcyBhbGwgdGhlIG5lY2Vzc2FyeSBib2lsZXJwbGF0ZSByZWxhdGVkIHRvIGNob29zaW5nIHdoZXRoZXIgdG9cclxuICAgICAgICAvLyBydW4gb3Igc2V0IGFzIHBlbmRpbmcsIHJlc2V0dGluZyBzdGF0ZSB2YXJpYWJsZXMsIGV0Yy5cclxuICAgICAgICBmdW5jdGlvbiB3YW50VG9TdGFydEFOZXdQcm9taXNlKHN0YXJ0UHJvbWlzZSkge1xyXG4gICAgICAgICAgICBsZXQgYWxyZWFkeVJ1bm5pbmdQcm9taXNlID0gKGdldFByb21pc2UoKSAhPSBudWxsKTtcclxuICAgICAgICAgICAgLy8gQm9pbGVycGxhdGUgd3JhcHBlciBhcm91bmQgdGhlIGdpdmVuIHByb21pc2Ugc3RhcnRlclxyXG4gICAgICAgICAgICBsZXQgc3RhcnRQcm9taXNlV2l0aEJvaWxlcnBsYXRlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBpdCBzdGFydHMsIG5vdGlmeSB0aGUgY2FsbGVyXHJcbiAgICAgICAgICAgICAgICBzZXRSdW5Db3VudChyID0+ICsrcik7XHJcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGl0IGNvbXBsZXRlcywgbm90aWZ5IHRoZSBjYWxsZXJcclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gaXQgZmFpbHMsIHNhdmUgdGhlIGVycm9yIGFuZCBub3RpZnkgdGhlIGNhbGxlclxyXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBpdCBzZXR0bGVzLCByZXNldCBvdXIgc3RhdGUgc28gd2UgY2FuIHJ1biBhIHBlbmRpbmcgcHJvbWlzZSBpZiBpdCBleGlzdHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9uVGhlbiA9ICgpID0+IHsgc2V0UmVzb2x2ZUNvdW50KGMgPT4gKytjKTsgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9uQ2F0Y2ggPSAoZXgpID0+IHsgc2V0RXJyb3IoZXgpOyBzZXRIYXNFcnJvcih0cnVlKTsgc2V0UmVqZWN0Q291bnQoYyA9PiArK2MpOyB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb25GaW5hbGx5ID0gKCkgPT4geyBzZXRQcm9taXNlKG51bGwpOyB9O1xyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlIGhhbmRsZXIgaXMgc3luY2hyb25vdXNcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN0YXJ0UHJvbWlzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0J3Mgc3luY2hyb25vdXMgYW5kIHJldHVybmVkIHN1Y2Nlc3NmdWxseS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgZWFybHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVGhlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkZpbmFsbHkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGUoXCJzeW5jXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KFwidGhlblwiIGluIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIHN5bmNocm9ub3VzIChvciBhc3luY2hyb25vdXMgYnV0IGRpZG4ndCBhd2FpdCBhbnl0aGluZyB5ZXQpIGFuZCB0aHJldyBhbiBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAvLyBCYWlsIG91dCBlYXJseS5cclxuICAgICAgICAgICAgICAgICAgICBvbkNhdGNoKGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBvbkZpbmFsbHkoKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHlwZShcInN5bmNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGhhbmRsZXIgaXMgYXN5bmNocm9ub3VzXHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHlwZShcImFzeW5jXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiB7IGF3YWl0IHJlc3VsdDsgfSkoKS50aGVuKG9uVGhlbikuY2F0Y2gob25DYXRjaCkuZmluYWxseShvbkZpbmFsbHkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoIWFscmVhZHlSdW5uaW5nUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHByb21pc2UgaW1tZWRpYXRlbHksIGJlY2F1c2UgdGhlcmUgd2Fzbid0IG9uZSBydW5uaW5nIGFscmVhZHkuXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFByb21pc2UgPSBzdGFydFByb21pc2VXaXRoQm9pbGVycGxhdGUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJvbWlzZSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBIb2xkIG9uISBUaGUgaGFuZGxlciB3YXMgYWN0dWFsbHkgc3luY2hyb25vdXMsIGFuZCBhbHJlYWR5IGZpbmlzaGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJhaWwgb3V0IGVhcmx5LlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRIYXNFcnJvcihmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvbWlzZShuZXh0UHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzdGFydCB0aGUgcHJvbWlzZSB5ZXQsIFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIGFsbG93IGl0IHRvIHN0YXJ0IGluIHRoZSBmdXR1cmUgaW5zdGVhZC5cclxuICAgICAgICAgICAgICAgIHNldFBlbmRpbmdQcm9taXNlU3RhcnRlcihfID0+IHN0YXJ0UHJvbWlzZVdpdGhCb2lsZXJwbGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJldCA9IHtcclxuICAgICAgICAgICAgZ2V0U3luY0hhbmRsZXIsXHJcbiAgICAgICAgICAgIGdldEN1cnJlbnRDYXB0dXJlLFxyXG4gICAgICAgICAgICBjYWxsQ291bnQ6IHJ1bkNvdW50LFxyXG4gICAgICAgICAgICBjdXJyZW50Q2FwdHVyZSxcclxuICAgICAgICAgICAgaGFzQ2FwdHVyZSxcclxuICAgICAgICAgICAgcGVuZGluZzogKHByb21pc2UgIT0gbnVsbCksXHJcbiAgICAgICAgICAgIGhhc0Vycm9yLFxyXG4gICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgY3VycmVudFR5cGUsXHJcbiAgICAgICAgICAgIGZsdXNoRGVib3VuY2VkUHJvbWlzZTogb25EZWJvdW5jZVRpbWVVcCxcclxuICAgICAgICAgICAgcmVzb2x2ZUNvdW50LFxyXG4gICAgICAgICAgICByZWplY3RDb3VudCxcclxuICAgICAgICAgICAgc2V0dGxlQ291bnQ6IHJlamVjdENvdW50ICsgcmVzb2x2ZUNvdW50XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldFN5bmNIYW5kbGVyKGFzeW5jSGFuZGxlcikge1xyXG4gICAgICAgICAgICBjb25zdCBzeW5jSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrKGZ1bmN0aW9uIHN5bmNIYW5kbGVyKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXN5bmNIYW5kbGVyID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBtb3N0IHNpZ25pZmljYW50IGluZm9ybWF0aW9uIGZyb20gdGhlIGV2ZW50IGF0IHRoaXMgdGltZSxcclxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIG5lY2Vzc2FyeSBzaW5jZSB0aGUgcHJvbWlzZSBjb3VsZCBhY3R1YWxseSBiZSBjYWxsZWQgbXVjaCBsYXRlclxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgZWxlbWVudCdzIHZhbHVlIChldGMuKSBoYXMgY2hhbmdlZC5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVkID0gY2FwdHVyZShldmVudCk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50Q2FwdHVyZShjYXB0dXJlZCk7XHJcbiAgICAgICAgICAgICAgICBzZXRIYXNDYXB0dXJlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRQcm9taXNlID0gKCkgPT4gYXN5bmNIYW5kbGVyKGNhcHR1cmVkLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVib3VuY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhbnRUb1N0YXJ0QU5ld1Byb21pc2Uoc3RhcnRQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERlYm91bmNlZFByb21pc2VTdGFydGVyKF8gPT4gc3RhcnRQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhc3luY0hhbmRsZXIgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHN5bmNIYW5kbGVyO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWFzeW5jLWhhbmRsZXIuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XHJcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1sYXlvdXQtZWZmZWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VUaW1lb3V0IH0gZnJvbSBcIi4vdXNlLXRpbWVvdXRcIjtcclxuaW1wb3J0IHsgdXNlTG9naWNhbERpcmVjdGlvbiB9IGZyb20gXCIuL3VzZS1sb2dpY2FsLWRpcmVjdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuLyoqXHJcbiAqIFdoZW4gdXNlZCBpbiB0YW5kZW0gd2l0aCBgdXNlUm92aW5nVGFiSW5kZXhgLCBhbGxvd3MgY29udHJvbCBvZlxyXG4gKiB0aGUgdGFiYmFibGUgaW5kZXggd2l0aCB0aGUgYXJyb3cga2V5cy5cclxuICpcclxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMaW5lYXJOYXZpZ2F0aW9uKHsgZ2V0SW5kZXgsIHNldEluZGV4LCBtYW5hZ2VkQ2hpbGRyZW4sIG5hdmlnYXRpb25EaXJlY3Rpb24gfSkge1xyXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbiA/Pz0gXCJlaXRoZXJcIjtcclxuICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgoKTtcclxuICAgIGNvbnN0IGNoaWxkQ291bnQgPSBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSB0YWJiYWJsZSBpbmRleCBuZXZlciBlc2NhcGVzIHRoZSBib3VuZHMgb2YgYWxsIGF2YWlsYWJsZSBjaGlsZHJlblxyXG4gICAgLy8gVE9ETzogS2VlcCB0cmFjayBvZiB0aGUgb3JpZ2luYWwgaW5kZXggYW5kIGtlZXAgaXQsIGF0IGxlYXN0IHVudGlsIGtleWJvYXJkIG5hdmlnYXRpb24uXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRJbmRleCgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZENvdW50ID4gMCAmJiBpbmRleCA+PSBjaGlsZENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRJbmRleChjaGlsZENvdW50IC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbaW5kZXgsIGNoaWxkQ291bnRdKTtcclxuICAgIC8vIFRoZXNlIGFsbG93IHVzIHRvIG1hbmlwdWxhdGUgd2hhdCBvdXIgY3VycmVudCB0YWJiYWJsZSBjaGlsZCBpcy5cclxuICAgIGNvbnN0IG5hdmlnYXRlVG9JbmRleCA9IHVzZUNhbGxiYWNrKChpbmRleCkgPT4geyBzZXRJbmRleChpbmRleCA8IDAgPyAobWFuYWdlZENoaWxkcmVuLmxlbmd0aCArIGluZGV4KSA6IGluZGV4KTsgfSwgW10pO1xyXG4gICAgY29uc3QgbmF2aWdhdGVUb05leHQgPSB1c2VDYWxsYmFjaygoKSA9PiB7IHNldEluZGV4KChpKSA9PiBpID09PSBudWxsID8gbnVsbCA6IGkgPj0gbWFuYWdlZENoaWxkcmVuLmxlbmd0aCAtIDEgPyBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoIC0gMSA6ICsraSk7IH0sIFtdKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9QcmV2ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBzZXRJbmRleCgoaSkgPT4gaSA9PT0gbnVsbCA/IG51bGwgOiBpIDwgMCA/IDAgOiAtLWkpOyB9LCBbXSk7XHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvU3RhcnQgPSB1c2VDYWxsYmFjaygoKSA9PiB7IG5hdmlnYXRlVG9JbmRleCgwKTsgfSwgW25hdmlnYXRlVG9JbmRleF0pO1xyXG4gICAgY29uc3QgbmF2aWdhdGVUb0VuZCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgbmF2aWdhdGVUb0luZGV4KC0xKTsgfSwgW25hdmlnYXRlVG9JbmRleF0pO1xyXG4gICAgY29uc3QgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBlbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICAgICAgLy8gUHJlZmVyIHRoZSBwYXJlbnQgZWxlbWVudCdzIGRpcmVjdGlvbiBzbyB0aGF0IHdlJ3JlIG5vdCBjYWxsaW5nIGdldENvbXB1dGVkU3R5bGVcclxuICAgICAgICAvLyBvbiBldmVyeSBzaW5nbGUgaW5kaXZpZHVhbCBjaGlsZCwgd2hpY2ggaXMgbGlrZWx5IHJlZHVuZGFudC5cclxuICAgICAgICAvLyBUT0RPOiBEb2VzIHVzZUxvZ2ljYWxEaXJlY3Rpb24gbmVlZCB0byBob2xkIGEgcGVyLXJlbmRlciAmIHBlci1lbGVtZW50IGNhY2hlIHRvIG1ha2UgdGhpcyB3b3JrP1xyXG4gICAgICAgIC8vIE9yIGRvZXMgdGhlIGJyb3dzZXIgYXV0b21hdGljYWxseSBjYWNoZSB0aGUgY29tcHV0YXRpb25zIHVudGlsIHNvbWV0aGluZyBjaGFuZ2VzP1xyXG4gICAgICAgIC8vIEdpdmVuIHRoYXQgdGhlIHZhbHVlcyBhcmUgbGl2ZSwgaXQgc2VlbXMgbGlrZSBpdCBzaG91bGQgYmUgdGhlIGxhdHRlci4uLlxyXG4gICAgICAgIGNvbnN0IHsgY29udmVydEVsZW1lbnRTaXplLCBnZXRMb2dpY2FsRGlyZWN0aW9uIH0gPSB1c2VMb2dpY2FsRGlyZWN0aW9uKGVsZW1lbnQ/LnBhcmVudEVsZW1lbnQgPz8gZWxlbWVudCk7XHJcbiAgICAgICAgY29uc3QgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkUHJvcHMgPSAocHJvcHMpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxyXG4gICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IGdldExvZ2ljYWxEaXJlY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIGxldCBhbGxvd3NCbG9ja05hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImJsb2NrXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJpbmxpbmVcIiB8fCBuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiZWl0aGVyXCIpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gYWxsb3dzQmxvY2tOYXZpZ2F0aW9uIDogYWxsb3dzSW5saW5lTmF2aWdhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJidHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IFwiYmxvY2tEaXJlY3Rpb25cIiA6IFwiaW5saW5lRGlyZWN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IGFsbG93c0Jsb2NrTmF2aWdhdGlvbiA6IGFsbG93c0lubGluZU5hdmlnYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwiYnR0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImlubGluZURpcmVjdGlvblwiIDogXCJibG9ja0RpcmVjdGlvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uIDogYWxsb3dzQmxvY2tOYXZpZ2F0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcInJ0bFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwiaW5saW5lRGlyZWN0aW9uXCIgOiBcImJsb2NrRGlyZWN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IGFsbG93c0lubGluZU5hdmlnYXRpb24gOiBhbGxvd3NCbG9ja05hdmlnYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwicnRsXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhvbWVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1N0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVuZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IG9uS2V5RG93biB9LCBwcm9wcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkUHJvcHNcclxuICAgICAgICB9O1xyXG4gICAgfSwgW25hdmlnYXRpb25EaXJlY3Rpb24sIG5hdmlnYXRlVG9OZXh0LCBuYXZpZ2F0ZVRvUHJldiwgbmF2aWdhdGVUb1N0YXJ0LCBuYXZpZ2F0ZVRvRW5kXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgsXHJcbiAgICAgICAgbmF2aWdhdGVUb05leHQsXHJcbiAgICAgICAgbmF2aWdhdGVUb1ByZXYsXHJcbiAgICAgICAgbmF2aWdhdGVUb1N0YXJ0LFxyXG4gICAgICAgIG5hdmlnYXRlVG9FbmQsXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBBbGxvd3MgZm9yIHRoZSBzZWxlY3Rpb24gb2YgYSBtYW5hZ2VkIGNoaWxkIGJ5IHR5cGluZyB0aGUgZ2l2ZW4gdGV4dCBhc3NvY2lhdGVkIHdpdGggaXQuXHJcbiAqXHJcbiAqIEBzZWUgdXNlTGlzdE5hdmlnYXRpb24sIHdoaWNoIHBhY2thZ2VzIGV2ZXJ5dGhpbmcgdXAgdG9nZXRoZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbih7IGNvbGxhdG9yLCBnZXRJbmRleCwgdHlwZWFoZWFkVGltZW91dCwgc2V0SW5kZXggfSkge1xyXG4gICAgLy8gRm9yIHR5cGVhaGVhZCwga2VlcCB0cmFjayBvZiB3aGF0IG91ciBjdXJyZW50IFwic2VhcmNoXCIgc3RyaW5nIGlzIChpZiB3ZSBoYXZlIG9uZSlcclxuICAgIC8vIGFuZCBhbHNvIGNsZWFyIGl0IGV2ZXJ5IDEwMDAgbXMgc2luY2UgdGhlIGxhc3QgdGltZSBpdCBjaGFuZ2VkLlxyXG4gICAgLy8gTmV4dCwga2VlcCBhIG1hcHBpbmcgb2YgdHlwZWFoZWFkIHZhbHVlcyB0byBpbmRpY2VzIGZvciBmYXN0ZXIgc2VhcmNoaW5nLlxyXG4gICAgLy8gQW5kLCBmb3IgdGhlIHVzZXIncyBzYWtlLCBsZXQgdGhlbSBrbm93IHdoZW4gdGhlaXIgdHlwZWFoZWFkIGNhbid0IG1hdGNoIGFueXRoaW5nIGFueW1vcmVcclxuICAgIGNvbnN0IFtjdXJyZW50VHlwZWFoZWFkLCBzZXRDdXJyZW50VHlwZWFoZWFkLCBnZXRDdXJyZW50VHlwZWFoZWFkXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgdXNlVGltZW91dCh7IHRpbWVvdXQ6IHR5cGVhaGVhZFRpbWVvdXQgPz8gMTAwMCwgY2FsbGJhY2s6ICgpID0+IHsgc2V0Q3VycmVudFR5cGVhaGVhZChudWxsKTsgc2V0SW52YWxpZFR5cGVhaGVhZChudWxsKTsgfSwgdHJpZ2dlckluZGV4OiBjdXJyZW50VHlwZWFoZWFkIH0pO1xyXG4gICAgY29uc3Qgc29ydGVkVHlwZWFoZWFkSW5mbyA9IHVzZVJlZihbXSk7XHJcbiAgICBjb25zdCBbaW52YWxpZFR5cGVhaGVhZCwgc2V0SW52YWxpZFR5cGVhaGVhZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICAvLyBIYW5kbGUgdHlwZWFoZWFkIGZvciBpbnB1dCBtZXRob2QgZWRpdG9ycyBhcyB3ZWxsXHJcbiAgICAvLyBFc3NlbnRpYWxseSwgd2hlbiBhY3RpdmUsIGlnbm9yZSBmdXJ0aGVyIGtleXMgXHJcbiAgICAvLyBiZWNhdXNlIHdlJ3JlIHdhaXRpbmcgZm9yIGEgQ29tcG9zaXRpb25FbmQgZXZlbnRcclxuICAgIGNvbnN0IFtpbWVBY3RpdmUsIHNldEltZUFjdGl2ZSwgZ2V0SW1lQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIC8vIEJlY2F1c2UgY29tcG9zaXRpb24gZXZlbnRzIGZpcmUgKmFmdGVyKiBrZXlkb3duIGV2ZW50cyBcclxuICAgIC8vIChidXQgd2l0aGluIHRoZSBzYW1lIHRhc2ssIHdoaWNoLCBUT0RPLCBjb3VsZCBiZSBicm93c2VyLWRlcGVuZGVudCksXHJcbiAgICAvLyB3ZSBjYW4gdXNlIHRoaXMgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBldmVudCB3ZSdyZSBsaXN0ZW5pbmcgZm9yIG9uIHRoZSBmaXJzdCBrZXlkb3duLlxyXG4gICAgY29uc3QgW25leHRUeXBlYWhlYWRDaGFyLCBzZXROZXh0VHlwZWFoZWFkQ2hhcl0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKG5leHRUeXBlYWhlYWRDaGFyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlYWhlYWQodHlwZWFoZWFkID0+ICgodHlwZWFoZWFkID8/IFwiXCIpICsgbmV4dFR5cGVhaGVhZENoYXIpKTtcclxuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW25leHRUeXBlYWhlYWRDaGFyXSk7XHJcbiAgICBjb25zdCBjb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxocywgcmhzKSA9PiB7XHJcbiAgICAgICAgbGV0IGNvbXBhcmU7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJocy50ZXh0ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciB0aGUgcHVycG9zZXMgb2YgdHlwZWFoZWFkLCBvbmx5IGNvbXBhcmUgYSBzdHJpbmcgb2YgdGhlIHNhbWUgc2l6ZSBhcyBvdXIgY3VycmVudGx5IHR5cGVkIHN0cmluZy5cclxuICAgICAgICAgICAgLy8gQnkgbm9ybWFsaXppbmcgdGhlbSBmaXJzdCwgd2UgZW5zdXJlIHRoaXMgYnl0ZS1ieS1ieXRlIGhhbmRsaW5nIG9mIHJhdyBjaGFyYWN0ZXIgZGF0YSB3b3JrcyBvdXQgb2theS5cclxuICAgICAgICAgICAgbGV0IHNhZmVMaHMgPSBsaHMubm9ybWFsaXplKFwiTkZEXCIpO1xyXG4gICAgICAgICAgICBsZXQgc2FmZVJocyA9IHJocy50ZXh0Lm5vcm1hbGl6ZShcIk5GRFwiKS5zdWJzdHIoMCwgc2FmZUxocy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAoY29sbGF0b3IpXHJcbiAgICAgICAgICAgICAgICBjb21wYXJlID0gY29sbGF0b3IuY29tcGFyZShzYWZlTGhzLCBzYWZlUmhzKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgY29tcGFyZSA9IHNhZmVMaHMudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKHNhZmVSaHMudG9Mb3dlckNhc2UoKSA/PyBcIlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaHMgLSByaHM7XHJcbiAgICB9KTtcclxuICAgIC8vIEhhbmRsZSBjaGFuZ2VzIGluIHR5cGVhaGVhZCB0aGF0IGNhdXNlIGNoYW5nZXMgdG8gdGhlIHRhYmJhYmxlIGluZGV4XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50VHlwZWFoZWFkICYmIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IHNvcnRlZFR5cGVhaGVhZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgIGlmIChzb3J0ZWRUeXBlYWhlYWRJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGhhcyB0eXBlZCBhbiBlbnRyeSB0aGF0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgIC8vIChvciBtb3JlIHNwZWNpZmljYWxseSBcImZvciB3aGljaCB0aGVyZSBpcyBubyBlbnRyeSB0aGF0IHN0YXJ0cyB3aXRoIHRoYXQgaW5wdXRcIilcclxuICAgICAgICAgICAgICAgIHNldEludmFsaWRUeXBlYWhlYWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgIFdlIGtub3cgcm91Z2hseSB3aGVyZSwgaW4gdGhlIHNvcnRlZCBhcnJheSBvZiBzdHJpbmdzLCBvdXIgbmV4dCB0eXBlYWhlYWQgbG9jYXRpb24gaXMuXHJcbiAgICAgICAgICAgICAgICAgIEJ1dCByb3VnaGx5IGlzbid0IGdvb2QgZW5vdWdoIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzLlxyXG4gICAgICAgICAgICAgICAgICBUbyBjb252ZXJ0IG91ciBzb3J0ZWQgaW5kZXggdG8gdGhlIHVuc29ydGVkIGluZGV4IHdlIG5lZWQsIHdlIGhhdmUgdG8gZmluZCB0aGUgZmlyc3RcclxuICAgICAgICAgICAgICAgICAgZWxlbWVudCB0aGF0IG1hdGNoZXMgdXMgKmFuZCogKGlmIGFueSBzdWNoIGV4aXN0KSBpcyAqYWZ0ZXIqIG91ciBjdXJyZW50IHNlbGVjdGlvbi5cclxuXHJcbiAgICAgICAgICAgICAgICAgIEluIG90aGVyIHdvcmRzLCB0aGUgb25seSB3YXkgdHlwZWFoZWFkIG1vdmVzIGJhY2t3YXJkcyByZWxhdGl2ZSB0byBvdXIgY3VycmVudFxyXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiBpcyBpZiB0aGUgb25seSBvdGhlciBvcHRpb24gaXMgYmVoaW5kIHVzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgSXQncyBub3Qgc3BlY2lmaWVkIGluIFdBSS1BUklBIHdoYXQgdG8gZG8gaW4gdGhhdCBjYXNlLiAgSSBzdXBwb3NlIHdyYXAgYmFjayB0byB0aGUgc3RhcnQ/XHJcbiAgICAgICAgICAgICAgICAgIFRob3VnaCB0aGVyZSdzIGFsc28gYSBjYXNlIGZvciBqdXN0IGdvaW5nIHVwd2FyZHMgdG8gdGhlIG5lYXJlc3QgdG8gcHJldmVudCBqdW1waW5lc3MuXHJcbiAgICAgICAgICAgICAgICAgIEJ1dCBpZiB5b3UncmUgYWxyZWFkeSBkb2luZyB0eXBlYWhlYWQgb24gYW4gdW5zb3J0ZWQgbGlzdCwgbGlrZSwganVtcGluZXNzIGNhbid0IGJlIGF2b2lkZWQuXHJcbiAgICAgICAgICAgICAgICAgIEkgZHVubm8uIEdvaW5nIGJhY2sgdG8gdGhlIHN0YXJ0IGlzIHRoZSBzaW1wbGlzdCB0aG91Z2guXHJcblxyXG4gICAgICAgICAgICAgICAgICBCYXNpY2FsbHkgd2hhdCB0aGlzIGRvZXM6IFN0YXJ0aW5nIGZyb20gd2hlcmUgd2UgZm91bmQgb3Vyc2VsdmVzIGFmdGVyIG91ciBiaW5hcnkgc2VhcmNoLFxyXG4gICAgICAgICAgICAgICAgICBzY2FuIGJhY2t3YXJkcyBhbmQgZm9yd2FyZHMgdGhyb3VnaCBhbGwgYWRqYWNlbnQgZW50cmllcyB0aGF0IGFsc28gY29tcGFyZSBlcXVhbGx5IHNvIHRoYXRcclxuICAgICAgICAgICAgICAgICAgd2UgY2FuIGZpbmQgdGhlIG9uZSB3aG9zZSBgdW5zb3J0ZWRJbmRleGAgaXMgdGhlIGxvd2VzdCBhbW9uZ3N0IGFsbCBvdGhlciBlcXVhbCBzdHJpbmdzXHJcbiAgICAgICAgICAgICAgICAgIChhbmQgYWxzbyB0aGUgbG93ZXN0IGB1bnNvcnRlZEluZGV4YCB5YWRkYSB5YWRkYSBleGNlcHQgdGhhdCBpdCBjb21lcyBhZnRlciB1cykuXHJcblxyXG4gICAgICAgICAgICAgICAgICBUT0RPOiBUaGUgYmluYXJ5IHNlYXJjaCBzdGFydHMgdGhpcyBvZmYgd2l0aCBhIHNvbGlkIE8obG9nIG4pLCBidXQgb25lLWNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICBzZWFyY2hlcyBhcmUsIHRoYW5rcyB0byBwaWdlb25ob2xlIHByaW5jaXBhbCwgZXZlbnR1YWxseSBndWFyYW50ZWVkIHRvIGJlY29tZVxyXG4gICAgICAgICAgICAgICAgICBPKG4qbG9nIG4pLiBUaGlzIGlzIGFubm95aW5nIGJ1dCBwcm9iYWJseSBub3QgZWFzaWx5IHNvbHZhYmxlPyBUaGVyZSBjb3VsZCBiZSBhblxyXG4gICAgICAgICAgICAgICAgICBleGNlcHRpb24gZm9yIG9uZS1jaGFyYWN0ZXIgc3RyaW5ncywgYnV0IHRoYXQncyBqdXN0IGtpY2tpbmcgdGhlIGNhbiBkb3duXHJcbiAgICAgICAgICAgICAgICAgIHRoZSByb2FkLiBNYXliZSBvbmUgb3IgdHdvIGNoYXJhY3RlcnMgd291bGQgYmUgZ29vZCBlbm91Z2ggdGhvdWdoLlxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGFyZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGNhbmRpZGF0ZXMnIHBvc2l0aW9ucyBpbiBib3RoIG91ciBzb3J0ZWQgYXJyYXkgYW5kIHRoZSB1bnNvcnRlZCBET00uXHJcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0U29ydGVkSW5kZXhBbGwgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcclxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIHR3byBhcmUgb25seSBzZXQgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIGFoZWFkIG9mIHVzLCBidXQgdGhlIHByaW5jaXBsZSdzIHRoZSBzYW1lIG90aGVyd2lzZVxyXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUJlc3RGaXQgPSAodSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhBbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9IHU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNvcnRlZEluZGV4QWxsID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9PSBudWxsIHx8IHUgPCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCkgJiYgdSA+IChnZXRJbmRleCgpID8/IC1JbmZpbml0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPSB1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBjb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC0taTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGkgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50Lmxlbmd0aCAmJiBjb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBzZXRJbmRleChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbbG93ZXN0U29ydGVkSW5kZXhOZXh0XS51bnNvcnRlZEluZGV4KTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5kZXgoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2xvd2VzdFNvcnRlZEluZGV4QWxsXS51bnNvcnRlZEluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtjdXJyZW50VHlwZWFoZWFkXSk7XHJcbiAgICBjb25zdCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjaygoeyB0ZXh0LCAuLi5pIH0pID0+IHtcclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGV4dCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRmluZCB3aGVyZSB0byBpbnNlcnQgdGhpcyBpdGVtLlxyXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBhbGwgaW5kZXggdmFsdWVzIHNob3VsZCBiZSB1bmlxdWUsIHRoZSByZXR1cm5lZCBzb3J0ZWRJbmRleFxyXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGFsd2F5cyByZWZlciB0byBhIG5ldyBsb2NhdGlvbiAoaS5lLiBiZSBuZWdhdGl2ZSkgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBsZXQgc29ydGVkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCB0ZXh0LCBjb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZSgtc29ydGVkSW5kZXggLSAxLCAwLCB7IHRleHQsIHVuc29ydGVkSW5kZXg6IGkuaW5kZXggfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdW5tb3VudGluZywgZmluZCB3aGVyZSB3ZSB3ZXJlIGFuZCByZW1vdmUgb3Vyc2VsdmVzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFnYWluLCB3ZSBzaG91bGQgYWx3YXlzIGZpbmQgb3Vyc2VsdmVzIGJlY2F1c2UgdGhlcmUgc2hvdWxkIGJlIG5vIGR1cGxpY2F0ZSB2YWx1ZXMgaWYgZWFjaCBpbmRleCBpcyB1bmlxdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNvcnRlZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgdGV4dCwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoc29ydGVkSW5kZXggPj0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZShzb3J0ZWRJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFt0ZXh0XSk7XHJcbiAgICAgICAgY29uc3QgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUHJvcHMgPSBmdW5jdGlvbiAoeyAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBlbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uQ29tcG9zaXRpb25TdGFydCA9IChlKSA9PiB7IHNldEltZUFjdGl2ZSh0cnVlKTsgfTtcclxuICAgICAgICAgICAgY29uc3Qgb25Db21wb3NpdGlvbkVuZCA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgc2V0SW1lQWN0aXZlKGZhbHNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltZUFjdGl2ZSA9IGdldEltZUFjdGl2ZSgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IGUua2V5O1xyXG4gICAgICAgICAgICAgICAgLy8gTm90IGhhbmRsZWQgYnkgdHlwZWFoZWFkIChpLmUuIGFzc3VtZSB0aGlzIGlzIGEga2V5Ym9hcmQgc2hvcnRjdXQpXHJcbiAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAoIWltZUFjdGl2ZSAmJiBlLmtleSA9PT0gXCJCYWNrc3BhY2VcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gYSB3YXkgdGhhdCBkb2Vzbid0IHNwbGl0IFVURi0xNiBzdXJyb2dhdGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlYWhlYWQodCA9PiB0ID09PSBudWxsID8gbnVsbCA6IFsuLi50XS5yZXZlcnNlKCkuc2xpY2UoMSkucmV2ZXJzZSgpLmpvaW4oXCJcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBrZXkgcHJvcGVydHkgcmVwcmVzZW50cyB0aGUgdHlwZWQgY2hhcmFjdGVyIE9SIHRoZSBcIm5hbWVkIGtleSBhdHRyaWJ1dGVcIiBvZiB0aGUga2V5IHByZXNzZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSdzIG5vIGRlZmluaXRlIHdheSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlLCBidXQgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3Nlc1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgYXJlIG5vIG9uZS1jaGFyYWN0ZXIgbmFtZXMsIGFuZCB0aGVyZSBhcmUgbm8gbm9uLUFTQ0lJLWFscGhhIG5hbWVzLlxyXG4gICAgICAgICAgICAgICAgLy8gVGh1cywgYW55IG9uZS1jaGFyYWN0ZXIgb3Igbm9uLUFTQ0lJIHZhbHVlIGZvciBga2V5YCBpcyAqYWxtb3N0IGNlcnRhaW5seSogYSB0eXBlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0NoYXJhY3RlcktleSA9IChrZXkubGVuZ3RoID09PSAxIHx8ICEvXltBLVphLXpdLy50ZXN0KGtleSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBcIiBcIiAmJiAoZ2V0Q3VycmVudFR5cGVhaGVhZCgpID8/IFwiXCIpLnRyaW0oKS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBiZWNhdXNlIGEgc3BhY2ViYXIgY2FuJ3QgZXZlciBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhdGUgYSB0eXBlYWhlYWQsIG9ubHkgY29udGludWUgb25lLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoU3BlY2lmaWNhbGx5LCBsZXQgdGhlIGV2ZW50IGNvbnRpbnVlIHByb3BhZ2F0aW9uIGluIHRoaXMgY2FzZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogV29uJ3QgYmUgdHJ1ZSBmb3IgdGhlIGZpcnN0IGtleWRvd25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYmVmb3JlIHVzZUxheW91dEVmZmVjdCBpcyBjYWxsZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYWN0dWFsbHkgYXBwbHkgdGhlIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWltZUFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh1c2VSZWZFbGVtZW50UHJvcHMoeyBvbktleURvd24sIG9uQ29tcG9zaXRpb25TdGFydCwgb25Db21wb3NpdGlvbkVuZCwgfSksIHByb3BzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFByb3BzXHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLFxyXG4gICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXHJcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZCxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFlvdXIgdXN1YWwgYmluYXJ5IHNlYXJjaCBpbXBsZW1lbnRhdGlvbi5cclxuICpcclxuICogSXQncyB1c2VkIGhlcmUgdG8gcXVpY2tseSBmaW5kIGEgZ29vZCBzcG90IHRvIHN0YXJ0IHNlYXJjaGluZyBmb3Igb3VyIG5leHQgdHlwZWFoZWFkIGNhbmRpZGF0ZS5cclxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2ggdGhyb3VnaFxyXG4gKiBAcGFyYW0gd2FudGVkIFRoZSB2YWx1ZSB5b3UnZCBsaWtlIHRvIGZpbmRcclxuICogQHBhcmFtIGNvbXBhcmF0b3IgQ29tcGFyZXMgYHdhbnRlZGAgd2l0aCB0aGUgY3VycmVudCB2YWx1ZSBpbiBgYXJyYXlgXHJcbiAqIEByZXR1cm5zIEEgbm9uLW5lZ2F0aXZlIHZhbHVlIGlmIGB3YW50ZWRgIHdhcyBmb3VuZCwgYW5kIGEgbmVnYXRpdmUgbnVtYmVyIGlmIG5vdC5cclxuICogVGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgbnVtYmVyLCBtaW51cyBvbmUsIGlzIHdoZXJlIGB3YW50ZWRgICp3b3VsZCogYmUgZm91bmQgaWYgaXQgKndhcyogaW4gYGFycmF5YFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnJheSwgd2FudGVkLCBjb21wYXJhdG9yKSB7XHJcbiAgICB2YXIgZmlyc3RJbmRleCA9IDA7XHJcbiAgICB2YXIgbGFzdEluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMTtcclxuICAgIHdoaWxlIChmaXJzdEluZGV4IDw9IGxhc3RJbmRleCkge1xyXG4gICAgICAgIHZhciB0ZXN0SW5kZXggPSAobGFzdEluZGV4ICsgZmlyc3RJbmRleCkgPj4gMTtcclxuICAgICAgICB2YXIgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmF0b3Iod2FudGVkLCBhcnJheVt0ZXN0SW5kZXhdKTtcclxuICAgICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcclxuICAgICAgICAgICAgZmlyc3RJbmRleCA9IHRlc3RJbmRleCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XHJcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IHRlc3RJbmRleCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGVzdEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtZmlyc3RJbmRleCAtIDE7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWtleWJvYXJkLW5hdmlnYXRpb24uanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWxheW91dC1lZmZlY3RcIjtcclxuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG4vKipcclxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxyXG4gKiBjaGlsZCBjb21wb25lbnRzIG9uY2UgdGhleSBoYXZlIHJlbmRlcmVkLlxyXG4gKlxyXG4gKiBUaGlzIGhvb2sgaXMgc2xpZ2h0bHkgbW9yZSBjb21wbGljYXRlZCBpbiB0aGF0IGl0IHJldHVybnMgYm90aCBhXHJcbiAqIHByb3AtbW9kaWZ5aW5nIGhvb2ssIGJ1dCBhbHNvIGEgaG9vayB0aGF0IGVhY2ggY2hpbGQgd2lsbCBuZWVkXHJcbiAqIHRvIHVzZTogYHVzZU1hbmFnZWRDaGlsZGAuICBJdCdzIHN0YWJsZSBhY3Jvc3MgcmVuZGVycywgc28ganVzdFxyXG4gKiB0b3NzIGl0IGludG8gYSBgQ29udGV4dGAgc28gdGhlIGNoaWxkcmVuIGNhbiBoYXZlIGFjY2VzcyB0byBpdC5cclxuICogVGhpcyBmdW5jdGlvbiByZWdpc3RlcnMgdGhlIGNoaWxkIHdpdGggdGhlIHBhcmVudCBhbmQgcHJvdmlkZXNcclxuICogaXQgd2l0aCBhbnkgcmVxdWVzdGVkIGluZm9ybWF0aW9uLCBidXQgZG9lc24ndCBkbyBhbnl0aGluZyBlbHNlXHJcbiAqIHVudGlsIGl0IHVubW91bnRzIGFuZCByZXRyYWN0cyB0aGF0IGluZm9ybWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkTWFuYWdlcigpIHtcclxuICAgIC8vIFRoaXMgaXMgYmxpbmRseSB1cGRhdGVkIGFueSB0aW1lIGEgY2hpbGQgbW91bnRzIG9yIHVubW91bnRzIGl0c2VsZi5cclxuICAgIC8vIFVzZWQgdG8gbWFrZSBzdXJlIHRoYXQgYW55IHRpbWUgdGhlIGFycmF5IG9mIG1hbmFnZWQgY2hpbGRyZW4gdXBkYXRlcyxcclxuICAgIC8vIHdlIGFsc28gcmUtcmVuZGVyLlxyXG4gICAgY29uc3QgW2NoaWxkVXBkYXRlSW5kZXgsIHNldENoaWxkVXBkYXRlSW5kZXhdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbdG90YWxDaGlsZHJlbk1vdW50ZWQsIHNldFRvdGFsQ2hpbGRyZW5Nb3VudGVkLCBnZXRUb3RhbENoaWxkcmVuTW91bnRlZF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFt0b3RhbENoaWxkcmVuVW5vdW50ZWQsIHNldFRvdGFsQ2hpbGRyZW5Vbm91bnRlZCwgZ2V0VG90YWxDaGlsZHJlblVub3VudGVkXSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgY2hpbGRyZW5DdXJyZW50bHlNb3VudGVkID0gdG90YWxDaGlsZHJlbk1vdW50ZWQgLSB0b3RhbENoaWxkcmVuVW5vdW50ZWQ7XHJcbiAgICBjb25zdCBtYW5hZ2VkQ2hpbGRyZW4gPSB1c2VSZWYoW10gLyoqIFRPRE86IEFueSBwcm9ibGVtcyBjYXVzZWQgYnkgdXNpbmcgYW4gYXJyYXkgd2hlbiBpdCBzaG91bGQgYmUgYW4gb2JqZWN0PyAqLyk7XHJcbiAgICBjb25zdCBtb3VudGVkQ2hpbGRyZW4gPSB1c2VSZWYoW10pO1xyXG4gICAgY29uc3QgbW91bnRPcmRlciA9IHVzZVJlZihuZXcgTWFwKCkpO1xyXG4gICAgY29uc3QgaW5kaWNlc0J5RWxlbWVudCA9IHVzZVJlZihuZXcgTWFwKCkpO1xyXG4gICAgY29uc3QgZ2V0TW91bnRJbmRleCA9IHVzZUNhbGxiYWNrKChpbmRleCkgPT4geyByZXR1cm4gbW91bnRPcmRlci5jdXJyZW50LmdldChpbmRleCk7IH0sIFtdKTtcclxuICAgIGNvbnN0IHVzZU1hbmFnZWRDaGlsZCA9IHVzZUNhbGxiYWNrKChpbmZvKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBnZXRUb3RhbENoaWxkcmVuTW91bnRlZCgpO1xyXG4gICAgICAgICAgICBtb3VudE9yZGVyLmN1cnJlbnQuc2V0KGluZm8uaW5kZXgsIGluZGV4KTtcclxuICAgICAgICAgICAgbW91bnRlZENoaWxkcmVuLmN1cnJlbnRbaW5kZXhdID0gaW5mbztcclxuICAgICAgICAgICAgc2V0VG90YWxDaGlsZHJlbk1vdW50ZWQodCA9PiArK3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4geyBtb3VudE9yZGVyLmN1cnJlbnQuZGVsZXRlKGluZm8uaW5kZXgpOyBtb3VudGVkQ2hpbGRyZW4uY3VycmVudFtpbmRleF0gPSBudWxsOyBzZXRUb3RhbENoaWxkcmVuVW5vdW50ZWQodCA9PiArK3QpOyB9O1xyXG4gICAgICAgIH0sIFtpbmZvLmluZGV4XSk7XHJcbiAgICAgICAgLy8gQXMgc29vbiBhcyB0aGUgY29tcG9uZW50IG1vdW50cywgbm90aWZ5IHRoZSBwYXJlbnQgYW5kIHJlcXVlc3QgYSByZXJlbmRlci5cclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKFtwcmV2RWxlbWVudCwgcHJldkluZGV4XSwgY2hhbmdlcykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlc0J5RWxlbWVudC5jdXJyZW50LnNldChlbGVtZW50LCBpbmZvLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIGlmIChtYW5hZ2VkQ2hpbGRyZW4uY3VycmVudFtpbmZvLmluZGV4XSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChpbmZvLmluZGV4ID09IHVuZGVmaW5lZCwgXCJUd28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBpbmRleCB3ZXJlIGFkZGVkLCB3aGljaCBtYXkgcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyOyAvLyBJbnRlbnRpb25hbFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2V0Q2hpbGRVcGRhdGVJbmRleChjID0+ICsrYyk7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4uY3VycmVudFtpbmZvLmluZGV4XSA9IHsgLi4uaW5mbyB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRDaGlsZFVwZGF0ZUluZGV4KGMgPT4gKytjKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuLmN1cnJlbnRbaW5mby5pbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlc0J5RWxlbWVudC5jdXJyZW50LmRlbGV0ZShlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbZWxlbWVudCwgaW5mby5pbmRleF0pO1xyXG4gICAgICAgIC8vIEFueSB0aW1lIG91ciBjaGlsZCBwcm9wcyBjaGFuZ2UsIG1ha2UgdGhhdCBpbmZvcm1hdGlvbiBhdmFpbGFibGUgZ2VuZXJhbGx5LlxyXG4gICAgICAgIC8vICpEb24ndCByZS1yZW5kZXIqLCBvdGhlcndpc2Ugd2UnZCBiZSBzdHVjayBpbiBhblxyXG4gICAgICAgIC8vIGluZmluaXRlIGxvb3AgZXZlcnkgdGltZSBhbiBhbm9ueW1vdXMgZnVuY3Rpb24gaXMgcGFzc2VkLlxyXG4gICAgICAgIC8vIEl0IGNvbWVzIGluIGZyb20gdGhlIHByb3BzIHNvIHRoZSBjaGlsZCB3YXMgYWxyZWFkeSB1cGRhdGVkIGJ5IGl0IC0tXHJcbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgcGFyZW50IHRvIHJlLXJlbmRlciBldmVyeSBzaW5nbGUgY2hpbGQgYW55IHRpbWVcclxuICAgICAgICAvLyBcIm9uQ2xpY2tcIiB1cGRhdGVzIG9yIHdoYXRldmVyLiAgVGhlIHJlbGV2YW50IGNoaWxkIGFscmVhZHkga25vd3MsXHJcbiAgICAgICAgLy8gYW5kIHRoYXQncyB3aGF0IG1hdHRlcnMuXHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKG1hbmFnZWRDaGlsZHJlbi5jdXJyZW50W2luZm8uaW5kZXhdICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbi5jdXJyZW50W2luZm8uaW5kZXhdID0geyAuLi5pbmZvIH07XHJcbiAgICAgICAgfSwgWy4uLk9iamVjdC5lbnRyaWVzKGluZm8pLmZsYXQoKV0pO1xyXG4gICAgICAgIHJldHVybiB7IGVsZW1lbnQsIGdldEVsZW1lbnQsIHVzZU1hbmFnZWRDaGlsZFByb3BzOiB1c2VSZWZFbGVtZW50UHJvcHMgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTWFuYWdlZENoaWxkLFxyXG4gICAgICAgIGNoaWxkQ291bnQ6IGNoaWxkcmVuQ3VycmVudGx5TW91bnRlZCxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRDaGlsZHJlbi5jdXJyZW50LFxyXG4gICAgICAgIG1vdW50ZWRDaGlsZHJlbjogbW91bnRlZENoaWxkcmVuLmN1cnJlbnQsXHJcbiAgICAgICAgaW5kaWNlc0J5RWxlbWVudDogaW5kaWNlc0J5RWxlbWVudC5jdXJyZW50LFxyXG4gICAgICAgIHRvdGFsQ2hpbGRyZW5Nb3VudGVkLFxyXG4gICAgICAgIHRvdGFsQ2hpbGRyZW5Vbm91bnRlZCxcclxuICAgICAgICBnZXRNb3VudEluZGV4XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGxldHRpbmcgY2hpbGRyZW4ga25vdyB3aGVuIHRoZXkgYXJlIG9yIGFyZSBub3QgdGhlXHJcbiAqIGN1cnJlbnQgc2VsZWN0ZWQvZXhwYW5kZWQvZm9jdXNlZC93aGF0ZXZlciBjaGlsZC5cclxuICpcclxuICogQXV0b21hdGljYWxseSBoYW5kbGVzIHdoZW4gY2hpbGRyZW4gYXJlIG1vdW50ZWQgJiB1bm1vdW50ZWQgYW5kIHN1Y2guXHJcbiAqXHJcbiAqIEBwYXJhbSBhY3RpdmF0ZWRJbmRleCBXaGF0IGluZGV4IHRoZSBjdXJyZW50IHNlbGVjdGVkIChldGMuKSBjaGlsZCBpc1xyXG4gKiBAcGFyYW0gbGVuZ3RoIEhvdyBtYW55IGNoaWxkcmVuIGV4aXN0IChhcyBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoKVxyXG4gKiBAcGFyYW0gc2V0RmxhZyBBIGZ1bmN0aW9uIHRoYXQgcHJvYmFibHkgbG9va3MgbGlrZSAoaSwgZmxhZykgPT4gbWFuYWdlZENoaWxkcmVuW2ldLnNldEFjdGl2ZShmbGFnKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkRmxhZyhhY3RpdmF0ZWRJbmRleCwgbGVuZ3RoLCBzZXRGbGFnKSB7XHJcbiAgICBjb25zdCBbcHJldkFjdGl2YXRlZEluZGV4LCBzZXRQcmV2QWN0aXZhdGVkSW5kZXgsIGdldFByZXZBY3RpdmF0ZWRJbmRleF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtwcmV2Q2hpbGRDb3VudCwgc2V0UHJldkNoaWxkQ291bnQsIGdldFByZXZDaGlsZENvdW50XSA9IHVzZVN0YXRlKGxlbmd0aCk7XHJcbiAgICAvLyBBbnkgdGltZSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgY2hhbmdlcyxcclxuICAgIC8vIHJlc2V0IGFueSBpbml0aWFsLCBwb3NzaWJseSBpbmNvcnJlY3Qgc3RhdGUgdGhleSBtaWdodCBoYXZlIGhhZCwganVzdCBpbiBjYXNlLlxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBNYXRoLnNpZ24obGVuZ3RoIC0gZ2V0UHJldkNoaWxkQ291bnQoKSk7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZ2V0UHJldkNoaWxkQ291bnQoKSA/PyAwOyBpICE9IGxlbmd0aDsgaSArPSBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHNldEZsYWcoaSwgaSA9PT0gYWN0aXZhdGVkSW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldFByZXZDaGlsZENvdW50KGxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3NldEZsYWcsIGFjdGl2YXRlZEluZGV4LCBsZW5ndGhdKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgLy8gRGVhY3RpdmF0ZSB0aGUgcHJldmlvdXNseSBhY3RpdmF0ZWQgY29tcG9uZW50XHJcbiAgICAgICAgY29uc3QgcHJldkFjdGl2YXRlZEluZGV4ID0gZ2V0UHJldkFjdGl2YXRlZEluZGV4KCk7XHJcbiAgICAgICAgaWYgKHByZXZBY3RpdmF0ZWRJbmRleCAhPSBhY3RpdmF0ZWRJbmRleCkge1xyXG4gICAgICAgICAgICBpZiAocHJldkFjdGl2YXRlZEluZGV4ICE9IG51bGwgJiYgcHJldkFjdGl2YXRlZEluZGV4ID49IDAgJiYgcHJldkFjdGl2YXRlZEluZGV4IDwgbGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgc2V0RmxhZyhwcmV2QWN0aXZhdGVkSW5kZXgsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWN0aXZhdGUgdGhlIGN1cnJlbnQgY29tcG9uZW50XHJcbiAgICAgICAgaWYgKGFjdGl2YXRlZEluZGV4ICE9IG51bGwgJiYgYWN0aXZhdGVkSW5kZXggPj0gMCAmJiBhY3RpdmF0ZWRJbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICBzZXRGbGFnKGFjdGl2YXRlZEluZGV4LCB0cnVlKTtcclxuICAgICAgICAgICAgc2V0UHJldkFjdGl2YXRlZEluZGV4KGFjdGl2YXRlZEluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbc2V0RmxhZywgYWN0aXZhdGVkSW5kZXgsIGxlbmd0aF0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1jaGlsZC1tYW5hZ2VyLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcbmltcG9ydCB7IHVzZUNoaWxkTWFuYWdlciwgdXNlQ2hpbGRGbGFnIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcclxuLyoqXHJcbiAqIEltcGxlbWVudHMgYSByb3ZpbmcgdGFiaW5kZXggc3lzdGVtIHdoZXJlIG9ubHkgb25lIFwiZm9jdXNhYmxlXCJcclxuICogY29tcG9uZW50IGluIGEgc2V0IGlzIGFibGUgdG8gcmVjZWl2ZSBhIHRhYiBmb2N1cy4gKldoaWNoKlxyXG4gKiBvZiB0aG9zZSBlbGVtZW50cyByZWNlaXZlcyBmb2N1cyBpcyBkZXRlcm1pbmVkIGJ5IHlvdSwgYnV0IGl0J3NcclxuICogcmVjb21tZW5kZWQgdG8gb2ZmbG9hZCB0aGF0IGxvZ2ljIHRoZW4gdG8gYW5vdGhlciBob29rLCBsaWtlXHJcbiAqIGB1c2VMaW5lYXJOYXZpZ2F0aW9uYCwgd2hpY2ggbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZVxyXG4gKiBlbGVtZW50IHdpdGggdGhlIGFycm93IGtleXMsIGB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uYCwgd2hpY2hcclxuICogbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZSBpbmRleCB3aXRoIHR5cGVhaGVhZCwgb3JcclxuICogYHVzZUxpc3ROYXZpZ2F0aW9uYCBpZiB5b3UganVzdCB3YW50IGV2ZXJ5dGhpbmcgYnVuZGxlZCB0b2dldGhlci5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSBjaGlsZCBob29rIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkXHJcbiAqIGJ5IGV2ZXJ5IGNoaWxkIHRoYXQgdXNlcyB0aGlzIHJvdmluZyB0YWJpbmRleCBsb2dpYy4gIFRoZVxyXG4gKiBwcm9wLW1vZGlmeWluZyBob29rICp0aGF0KiBob29rIHJldHVybnMgc2hvdWxkIHRoZW4gYmUgdXNlZFxyXG4gKiBvbiB0aGUgY2hpbGQncyBlbGVtZW50LCBhcyB3ZWxsIGFzIGFueSBvdGhlciBlbGVtZW50cyB5b3UnZCBsaWtlXHJcbiAqIHRvIGJlIGV4cGxpY2l0bHkgbWFkZSB1bnRhYmJhYmxlIHRvby5cclxuICpcclxuICogYGZvY3VzT25DaGFuZ2VgIHNob3VsZCBiZSBzZXQgdG8gdHJ1ZSBpZiBmb2N1cyBpc1xyXG4gKiBjb250YWluZWQgd2l0aGluIHdoYXRldmVyIGVsZW1lbnQgY29udGFpbnMgdGhlIHJvdmluZyB0YWIgaW5kZXguXHJcbiAqIEdlbmVyYWxseSBhcyBzaW1wbGUgYXMgdGhlIGZvbGxvd2luZzpcclxuICogYGBgXHJcbiAqIGNvbnN0IHsgZm9jdXNlZCwgZm9jdXNlZElubmVyLCB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxQYXJlbnRFbGVtZW50PigpO1xyXG4gKiBjb25zdCBmb2N1c09uQ2hhbmdlID0gKGZvY3VzZWRJbm5lciAhPSBmYWxzZSk7XHJcbiAqIGBgYFxyXG4gKiBJdCdzIG5vdCBpbmNsdWRlZCBoZXJlIGJlY2F1c2UgYHVzZVJvdmluZ1RhYkluZGV4YCBkb2Vzbid0IGtub3dcclxuICogYW55dGhpbmcgYWJvdXQgdGhlIGNvbnRhaW5lciBlbGVtZW50LCBvbmx5IGNoaWxkcmVuIGVsZW1lbnRzLlxyXG4gKiBBbmQganVzdCBhcyB3ZWxsISBDaGlsZHJlbiBzaG91bGQgYmUgYWxsb3dlZCBhdCB0aGUgcm9vdCxcclxuICogcmVnYXJkbGVzcyBvZiBpZiBpdCdzIHRoZSB3aG9sZSBhcHAgb3IganVzdCBhIGdpdmVuIGNvbXBvbmVudC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleCh7IGZvY3VzT25DaGFuZ2U6IGZvYywgdGFiYmFibGVJbmRleCB9KSB7XHJcbiAgICBjb25zdCBbcmVyZW5kZXJBbmRGb2N1cywgc2V0UmVyZW5kZXJBbmRGb2N1c10gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IGdldEZvY3VzT25DaGFuZ2UgPSB1c2VTdGFibGVHZXR0ZXIoZm9jKTtcclxuICAgIGNvbnN0IGdldFRhYmJhYmxlSW5kZXggPSB1c2VTdGFibGVHZXR0ZXIodGFiYmFibGVJbmRleCk7XHJcbiAgICBjb25zdCBwcmV2VGFiYmFibGUgPSB1c2VSZWYoLUluZmluaXR5KTtcclxuICAgIC8vIENhbGwgdGhlIGhvb2sgdGhhdCBhbGxvd3MgdXMgdG8gY29sbGVjdCBpbmZvcm1hdGlvbiBmcm9tIGNoaWxkcmVuIHdobyBwcm92aWRlIGl0XHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbiwgY2hpbGRDb3VudCwgdXNlTWFuYWdlZENoaWxkLCBpbmRpY2VzQnlFbGVtZW50LCAuLi5yZXN0IH0gPSB1c2VDaGlsZE1hbmFnZXIoKTtcclxuICAgIC8vIEFueSB0aW1lIHRoZSB0YWJiYWJsZSBpbmRleCBjaGFuZ2VzLFxyXG4gICAgLy8gbm90aWZ5IHRoZSBwcmV2aW91cyBjaGlsZCB0aGF0IGl0J3Mgbm8gbG9uZ2VyIHRhYmJhYmxlLFxyXG4gICAgLy8gYW5kIG5vdGlmeSB0aGUgbmV4dCBjaGlsZCB0aGF0IGlzIGFsbG93ZWQgdG8gYmUgdGFiYmVkIHRvLlxyXG4gICAgdXNlQ2hpbGRGbGFnKHRhYmJhYmxlSW5kZXgsIGNoaWxkQ291bnQsIChpbmRleCwgdGFiYmFibGUpID0+IHtcclxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbClcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuW2luZGV4XT8uc2V0VGFiYmFibGUodGFiYmFibGUpO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRhYmJhYmxlSW5kZXggIT0gbnVsbClcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuW3RhYmJhYmxlSW5kZXhdLnNldFRhYmJhYmxlKHRydWUpO1xyXG4gICAgfSwgW3RhYmJhYmxlSW5kZXhdKTtcclxuICAgIGNvbnN0IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQgPSB1c2VDYWxsYmFjaygoaW5mbykgPT4ge1xyXG4gICAgICAgIGNvbnN0IFtycmFmSW5kZXgsIHNldFJyYWZJbmRleF0gPSB1c2VTdGF0ZSgxKTtcclxuICAgICAgICBjb25zdCByZXJlbmRlckFuZEZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4geyBzZXRScmFmSW5kZXgoaSA9PiArK2kpOyB9LCBbXSk7XHJcbiAgICAgICAgbGV0IG5ld0luZm8gPSB7XHJcbiAgICAgICAgICAgIC4uLmluZm8sXHJcbiAgICAgICAgICAgIHJlcmVuZGVyQW5kRm9jdXMsXHJcbiAgICAgICAgICAgIHNldFRhYmJhYmxlOiB1c2VDYWxsYmFjaygodGFiYmFibGUpID0+IHsgc2V0VGFiYmFibGUodGFiYmFibGUpOyB9LCBbXSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgZ2V0RWxlbWVudCwgdXNlTWFuYWdlZENoaWxkUHJvcHMgfSA9IHVzZU1hbmFnZWRDaGlsZChuZXdJbmZvKTtcclxuICAgICAgICAvLyBUT0RPOiBVc2luZyBnZXRUYWJiYWJsZUluZGV4IGR1cmluZyByZW5kZXIgcGhhc2Ugb24gbW91bnRcclxuICAgICAgICBjb25zdCBbdGFiYmFibGUsIHNldFRhYmJhYmxlXSA9IHVzZVN0YXRlKGdldFRhYmJhYmxlSW5kZXgoKSA9PSBpbmZvLmluZGV4KTtcclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiB0YWJiYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0UmVyZW5kZXJBbmRGb2N1cyhfID0+IHJlcmVuZGVyQW5kRm9jdXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdldEZvY3VzT25DaGFuZ2UoKSAmJiBcImZvY3VzXCIgaW4gZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbZWxlbWVudCwgdGFiYmFibGUsIHJyYWZJbmRleF0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVJvdmluZ1RhYkluZGV4U2libGluZ1Byb3BzKHsgdGFiSW5kZXgsIC4uLnByb3BzIH0pIHtcclxuICAgICAgICAgICAgaWYgKHRhYkluZGV4ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YWJiYWJsZSlcclxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IHRhYkluZGV4IH0sIHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzKHsgdGFiSW5kZXgsIC4uLnByb3BzIH0pIHtcclxuICAgICAgICAgICAgaWYgKHRhYkluZGV4ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YWJiYWJsZSlcclxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh1c2VNYW5hZ2VkQ2hpbGRQcm9wcyh7IHRhYkluZGV4IH0pLCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMsXHJcbiAgICAgICAgICAgIHVzZVJvdmluZ1RhYkluZGV4U2libGluZ1Byb3BzLFxyXG4gICAgICAgICAgICB0YWJiYWJsZVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbdXNlTWFuYWdlZENoaWxkXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsXHJcbiAgICAgICAgY2hpbGRDb3VudCxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgaW5kaWNlc0J5RWxlbWVudCxcclxuICAgICAgICBmb2N1c0N1cnJlbnQ6IHJlcmVuZGVyQW5kRm9jdXMsXHJcbiAgICAgICAgLi4ucmVzdFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2Utcm92aW5nLXRhYmluZGV4LmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlUm92aW5nVGFiSW5kZXggfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XHJcbmltcG9ydCB7IHVzZUxpbmVhck5hdmlnYXRpb24sIHVzZVR5cGVhaGVhZE5hdmlnYXRpb24gfSBmcm9tIFwiLi91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvblwiO1xyXG4vKipcclxuICpcclxuICogVE9ETzogVGhpcyB0YWJsZSB3YXMgc2NyYXBwZWQgd2hlbiB0aGlzIHdhcyBjaGFuZ2VkIHRvIGp1c3QgYWNjZXB0IGEgY29sbGF0b3IgZGlyZWN0bHksXHJcbiAqIGJ1dCBpdCdzIG5vdCBiYWQgZm9yIGEgY29sbGF0aW9uIGNyYXNoIGNvdXJzZSBhbmQgSSBtaWdodCB1c2UgaXQgYWdhaW4uXHJcbiAqIEV2ZW4ganVzdCBhcyBhIFwidGhpcyBpcyB3aHkgaXQncyBpbXBvcnRhbnQgYW5kIGdvb2QgdG8gdXNlIHRoZXNlIHRoaW5nc1wiIHRoaW5nLlxyXG4gKlxyXG4gKiB8TGFuZy58VGFyZ2V0fFVzZXIgaW5wdXR8YGJhc2VgfGBhY2NlbnRgfGBjYXNlYHxgdmFyaWFudGB8XHJcbiAqIHwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfFxyXG4gKiB8RU58SGl8SGl84pyFfOKchXzinIV84pyFfFxyXG4gKiB8RU58SGl877yo772JfOKchXzinIV84pyFfOKdjHxcclxuICogfEVOfEhpfGhpfOKchXzinIV84p2MfOKdjHxcclxuICogfEVOfEhpfEjDr3zinIV84p2MfOKdjHzinYx8XHJcbiAqIHxFTnxIaXxCeWV84p2MfOKdjHzinYx84p2MfFxyXG4gKiB8REF8w6V8YWF84pyFfOKchXzinIV84p2MfFxyXG4gKiB8REF8w6V8QUF84pyFfOKchXzinYx84p2MfFxyXG4gKiB8REF8w6V8QWF84pyFfOKchXzinYx84p2MfFxyXG4gKiB8RU58w6V8YWF84p2MfOKdjHzinYx84p2MfFxyXG4gKiB8REF8w6V8YUF84p2MfOKdjHzinYx84p2MfFxyXG4gKiB8RU58w6V8YXzinIV84pyFfOKdjHzinYx8XHJcbiAqIHxEQXzDpXxhfOKchXzinIV84p2MfOKdjHxcclxuICogfEpQfO+qqnznnYB84pyFfOKchXzinIV84pyFfFxyXG4gKiB8SlB844KrfO+9tnzinIV84pyFfOKchXzinIV8XHJcbiAqIHxKUHzjgqt844GLfOKchXzinIV84pyFfOKdjHxcclxuICogfEpQfOOCq3zjg7V84pyFfOKchXzinIV84p2MfFxyXG4gKiB8SlB844KrfOOLlXzinIV84pyFfOKdjHzinYx8XHJcbiAqIHxKUHzjgqt844KsfOKchXzinYx84p2MfOKdjHxcclxuICogfEpQfOOCq3zlipt84p2MfOKdjHzinYx84p2MfFxyXG4gKiB8Wkh857SFfOe6onzinYx84p2MfOKdjHzinYx8XHJcbiAqXHJcbiAqXHJcbiAqIChOb3RlIHRvIHNlbGY6IEF0IHNvbWUgcG9pbnQsIHRoaXMgZmlsZSB3aWxsIHByb2JhYmx5IGJlIG5vcm1hbGl6ZWRcclxuICogYnkgc29tZWJvZHkgYW5kIO+qqiB3aWxsIHR1cm4gYmFjayBpbnRvIOedgC4pXHJcbiAqXHJcbiAqL1xyXG5jb25zdCBkdW1teSA9IG51bGw7XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIHByb3BlciBrZXlib2FyZCBuYXZpZ2F0aW9uIGZvciBjb21wb25lbnRzIGxpa2UgbGlzdGJveGVzLCBidXR0b24gZ3JvdXBzLCBtZW51cywgZXRjLlxyXG4gKlxyXG4gKiBJbiB0aGUgZG9jdW1lbnQgb3JkZXIsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgXCJmb2N1c2VkXCIgb3IgXCJ0YWJiYWJsZVwiIGVsZW1lbnQsIG1ha2luZyBpdCBhY3QgbW9yZSBsaWtlIG9uZSBjb21wbGV0ZSB1bml0IGluIGNvbXBhcmlzb24gdG8gZXZlcnl0aGluZyBhcm91bmQgaXQuXHJcbiAqIE5hdmlnYXRpbmcgZm9yd2FyZHMvYmFja3dhcmRzIGNhbiBiZSBkb25lIHdpdGggdGhlIGFycm93IGtleXMsIEhvbWUvRW5kIGtleXMsIG9yIGFueSBhbnkgdGV4dCBmb3IgdHlwZWFoZWFkIHRvIGZvY3VzIHRoZSBuZXh0IGl0ZW0gdGhhdCBtYXRjaGVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uKHsgaW5pdGlhbEluZGV4LCBmb2N1c09uQ2hhbmdlLCBjb2xsYXRvciwga2V5TmF2aWdhdGlvbiB9KSB7XHJcbiAgICBrZXlOYXZpZ2F0aW9uID8/PSBcImVpdGhlclwiO1xyXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aHJlZSB0aGluZ3MgcmVsYXRlZCB0byB0aGUgY3VycmVudGx5IHRhYmJhYmxlIGVsZW1lbnQncyBpbmRleDpcclxuICAgIC8vIFdoYXQgaXQgaXMsIGFuZCB3aGV0aGVyLCB3aGVuIHdlIHJlbmRlciB0aGlzIGNvbXBvbmVudCBhbmQgaXQncyBjaGFuZ2VkLCB0byBhbHNvIGZvY3VzIHRoZSBlbGVtZW50IHRoYXQgd2FzIG1hZGUgdGFiYmFibGUuXHJcbiAgICBjb25zdCBbdGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleCwgZ2V0VGFiYmFibGVJbmRleF0gPSB1c2VTdGF0ZShpbml0aWFsSW5kZXggPT09IHVuZGVmaW5lZCA/IDAgOiBpbml0aWFsSW5kZXgpO1xyXG4gICAgY29uc3Qgc2V0SW5kZXggPSB1c2VDYWxsYmFjaygoaW5kZXgpID0+IHtcclxuICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGluZGV4KTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuLCBpbmRpY2VzQnlFbGVtZW50LCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCBmb2N1c0N1cnJlbnQsIC4uLnJlc3QgfSA9IHVzZVJvdmluZ1RhYkluZGV4KHsgZm9jdXNPbkNoYW5nZSwgdGFiYmFibGVJbmRleCB9KTtcclxuICAgIGNvbnN0IHsgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCwgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uKHsgY29sbGF0b3IsIGdldEluZGV4OiBnZXRUYWJiYWJsZUluZGV4LCBzZXRJbmRleCwgdHlwZWFoZWFkVGltZW91dDogMTAwMCB9KTtcclxuICAgIGNvbnN0IHsgbmF2aWdhdGVUb0VuZCwgbmF2aWdhdGVUb0luZGV4LCBuYXZpZ2F0ZVRvTmV4dCwgbmF2aWdhdGVUb1ByZXYsIG5hdmlnYXRlVG9TdGFydCwgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkIH0gPSB1c2VMaW5lYXJOYXZpZ2F0aW9uKHsgbmF2aWdhdGlvbkRpcmVjdGlvbjoga2V5TmF2aWdhdGlvbiwgZ2V0SW5kZXg6IGdldFRhYmJhYmxlSW5kZXgsIHNldEluZGV4LCBtYW5hZ2VkQ2hpbGRyZW4gfSk7XHJcbiAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkID0gdXNlQ2FsbGJhY2soKGluZm8pID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFByb3BzIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQoaW5mbyk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkKCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMsIHVzZVJvdmluZ1RhYkluZGV4U2libGluZ1Byb3BzLCB0YWJiYWJsZSB9ID0gdXNlUm92aW5nVGFiSW5kZXhDaGlsZChpbmZvKTtcclxuICAgICAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMgPSBmdW5jdGlvbiAoeyAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyh1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRQcm9wcyh7IG9uQ2xpY2s6IHJvdmVUb1NlbGYgfSkpKSwgcHJvcHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgcm92ZVRvU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHsgbmF2aWdhdGVUb0luZGV4KGluZm8uaW5kZXgpOyB9LCBbXSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLFxyXG4gICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpYmxpbmdQcm9wczogdXNlUm92aW5nVGFiSW5kZXhTaWJsaW5nUHJvcHMsXHJcbiAgICAgICAgICAgIHRhYmJhYmxlLFxyXG4gICAgICAgICAgICAvL3JvdmVUb1NlbGYsXHJcbiAgICAgICAgICAgIC8vZWxlbWVudFxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLCB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGQsIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIG5hdmlnYXRlVG9JbmRleF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxyXG4gICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXHJcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZCxcclxuICAgICAgICB0YWJiYWJsZUluZGV4LFxyXG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXgsXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIGluZGljZXNCeUVsZW1lbnQsXHJcbiAgICAgICAgbmF2aWdhdGVUb0luZGV4LFxyXG4gICAgICAgIG5hdmlnYXRlVG9OZXh0LFxyXG4gICAgICAgIG5hdmlnYXRlVG9QcmV2LFxyXG4gICAgICAgIG5hdmlnYXRlVG9TdGFydCxcclxuICAgICAgICBuYXZpZ2F0ZVRvRW5kLFxyXG4gICAgICAgIGZvY3VzQ3VycmVudCxcclxuICAgICAgICAuLi5yZXN0XHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1saXN0LW5hdmlnYXRpb24uanMubWFwIiwiaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG4vKipcclxuICpcclxuICogVGhlcmUgYXJlIHNldmVyYWwgZGlmZmVyZW50IHdheXMgdGhhdCBhIGZvY3VzIGV2ZW50IGNhbiBoYXBwZW4uICBBc3N1bWVcclxuICogdGhlIGZvbGxvd2luZyBzdGVwcyBoYXBwZW4gaW4gb3JkZXI6XHJcbiAqXHJcbiAqIDEuIFRoZSBwYWdlIGxvYWRzLlxyXG4gKiAgICAqIE5vdGhpbmcgaXMgZm9jdXNlZCwgYnV0IGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBgYm9keWAuXHJcbiAqICAgICogTm8gZm9jdXMgZXZlbnRzIGFyZSBmaXJlZC5cclxuICogMi4gVGhlIHdpbmRvdyBpcyBmb2N1c2VkLCBhbiB1bmZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIHRleHQgaXMgc2VsZWN0ZWQsIGV0Yy5cclxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIHJlbWFpbnMgYXMgYGJvZHlgLlxyXG4gKiAgICAqIEEgYGZvY3VzYC9gZm9jdXNpbmAgZXZlbnQgKk1JR0hUKiBiZSBmaXJlZCBmb3IgYGJvZHlgLiBEZXBlbmRpbmcgb25cclxuICogICAgICB0aGUgYnJvd3NlciwgdGhpcyBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlIGhhbmRsZXIgd2FzIGF0dGFjaGVkIHRvIGB3aW5kb3dgIG9yIGBkb2N1bWVudGAuXHJcbiAqICAgICAgUHJvYmFibHkganVzdCBiZXN0IHRvIG5vdCByZWx5IG9uIGl0LCBvciBsaXN0ZW4gdG8gYHdpbmRvd2AgZm9jdXMgZXZlbnRzIGRpcmVjdGx5LlxyXG4gKiAzLiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cclxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgbmV3IGVsZW1lbnQgYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxyXG4gKiAgICAqIGBmb2N1c291dGAgYW5kIGBibHVyYCBhcmUgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxyXG4gKiAgICAqIGBmb2N1c2AgYW5kIGBmb2N1c2luYCBhcmUgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cclxuICogNC4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXHJcbiAqICAgICogKipUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgYGJvZHlgKiogYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxyXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG5ldyBlbGVtZW50LlxyXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgbm93IHNldCB0byB0aGUgbmV3IGVsZW1lbnQuXHJcbiAqICAgICogYGZvY3VzaW5gIGlzIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBvbGQgZWxlbWVudC5cclxuICogNS4gQW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXHJcbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gYGJvZHlgLlxyXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cclxuICogICAgKiBgZm9jdXNpbmAgaXMgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxyXG4gKlxyXG4gKlxyXG4gKiBJbiBzdW1tYXJ5OlxyXG4gKiAxLiBGb2N1cyBldmVudHMgKmRvKiBub3RpZnkgdXMgb2YgYWxsIGNoYW5nZXMgaW4gZm9jdXMsIGJ1dCB0aGVyZSBpcyBubyBvbmUgc2luZ2xlIGNvbXByZWhlbnNpdmUgZXZlbnQgdGhhdCBwcm92aWRlcyB1cyB3aXRoIGFsbCBhdmFpbGFibGUgaW5mb3JtYXRpb24uXHJcbiAqIDIuIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCAqaXMgbm90KiBhbHdheXMgdGhlIHNhbWUgYXMgd2hhdCdzIGJlaW5nIHJlZmVyZW5jZWQgYnkgYSBmb2N1cyBldmVudC4gSW4gcGFydGljdWxhciwgaXQgbWF5IGJlY29tZSBgYm9keWAgYXQgYW55IGFyYml0cmFyeSB0aW1lLlxyXG4gKiAzLiBBIGBibHVyYCB3aXRob3V0IGEgYGZvY3VzYCBjYW4gYW5kIHdpbGwgb2NjdXIuIFRoaXMgbWVhbnMgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHNvbGVseSB1c2UgYGZvY3VzYCB0byBkZXRlY3QgYWxsIGNoYW5nZXMuXHJcbiAqIDQuIEEgYGJsdXJgIGV2ZW50IHdob3NlIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsIGluZGljYXRlcyB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gZm9sbG93aW5nIGBmb2N1c2AgZXZlbnQuXHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSBjYWxsYmFja1xyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxubGV0IGN1cnJlbnRseUZvY3VzZWRFbGVtZW50ID0gbnVsbDtcclxubGV0IGxhc3RGb2N1c2VkRWxlbWVudCA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldExhc3RGb2N1c2VkRWxlbWVudCgpIHtcclxuICAgIHJldHVybiBsYXN0Rm9jdXNlZEVsZW1lbnQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3VycmVudGx5Rm9jdXNlZEVsZW1lbnQoKSB7XHJcbiAgICByZXR1cm4gY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQ7XHJcbn1cclxuY29uc3QgdXBkYXRlcnMgPSBuZXcgU2V0KCk7XHJcbmZ1bmN0aW9uIGZvY3Vzb3V0KGUpIHtcclxuICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgPT0gbnVsbCkge1xyXG4gICAgICAgIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICBmb3IgKGxldCBmIG9mIHVwZGF0ZXJzKSB7XHJcbiAgICAgICAgICAgIGYoeyBjdXJyZW50OiBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCwgbGFzdDogbGFzdEZvY3VzZWRFbGVtZW50LCB3aW5kb3dGb2N1c2VkIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEp1c3Qgd2FpdCBmb3IgdGhlIGZvY3VzaW4gZXZlbnQuXHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZm9jdXNpbihlKSB7XHJcbiAgICBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCA9IGxhc3RGb2N1c2VkRWxlbWVudCA9IGUudGFyZ2V0O1xyXG4gICAgZm9yIChsZXQgZiBvZiB1cGRhdGVycykge1xyXG4gICAgICAgIGYoeyBjdXJyZW50OiBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCwgbGFzdDogbGFzdEZvY3VzZWRFbGVtZW50LCB3aW5kb3dGb2N1c2VkIH0pO1xyXG4gICAgfVxyXG59XHJcbmxldCB3aW5kb3dGb2N1c2VkID0gdHJ1ZTtcclxuZnVuY3Rpb24gd2luZG93Rm9jdXMoKSB7XHJcbiAgICB3aW5kb3dGb2N1c2VkID0gdHJ1ZTtcclxuICAgIGZvciAobGV0IGYgb2YgdXBkYXRlcnMpIHtcclxuICAgICAgICBmKHsgY3VycmVudDogY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQsIGxhc3Q6IGxhc3RGb2N1c2VkRWxlbWVudCwgd2luZG93Rm9jdXNlZCB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB3aW5kb3dCbHVyKCkge1xyXG4gICAgd2luZG93Rm9jdXNlZCA9IGZhbHNlO1xyXG4gICAgZm9yIChsZXQgZiBvZiB1cGRhdGVycykge1xyXG4gICAgICAgIGYoeyBjdXJyZW50OiBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCwgbGFzdDogbGFzdEZvY3VzZWRFbGVtZW50LCB3aW5kb3dGb2N1c2VkIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3RpdmVFbGVtZW50KGZpbHRlcikge1xyXG4gICAgY29uc3QgW2ksIHNldEldID0gdXNlU3RhdGUoMCk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IEYgPSAoaW5mbykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZmlsdGVyID09IG51bGwgfHwgZmlsdGVyKGluZm8pKVxyXG4gICAgICAgICAgICAgICAgc2V0SShpID0+ICsraSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodXBkYXRlcnMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luLCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBmb2N1c291dCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzLCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZXJzLmFkZChGKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICB1cGRhdGVycy5kZWxldGUoRik7XHJcbiAgICAgICAgICAgIGlmICh1cGRhdGVycy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBmb2N1c291dCk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbZmlsdGVyXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFjdGl2ZUVsZW1lbnQ6IGN1cnJlbnRseUZvY3VzZWRFbGVtZW50LFxyXG4gICAgICAgIGxhc3RBY3RpdmVFbGVtZW50OiBsYXN0Rm9jdXNlZEVsZW1lbnQsXHJcbiAgICAgICAgZ2V0QWN0aXZlRWxlbWVudDogZ2V0Q3VycmVudGx5Rm9jdXNlZEVsZW1lbnQsXHJcbiAgICAgICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQ6IGdldExhc3RGb2N1c2VkRWxlbWVudCxcclxuICAgICAgICB3aW5kb3dGb2N1c2VkXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1hY3RpdmUtZWxlbWVudC5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VNZW1vIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50IH0gZnJvbSBcIi4vdXNlLWFjdGl2ZS1lbGVtZW50XCI7XHJcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhhc0ZvY3VzKHt9ID0ge30pIHtcclxuICAgIC8vIFRoZXNlIGFyZSBzbGlnaHRseSByZWR1bmRhbnQsIGJ1dCBhbnkgdGltZSB0aGUgZm9jdXMgY2hhbmdlcywgd2UgbmVlZCB0byBrbm93IGlmIGl0J3MgXCJyZWxldmFudFwiIHRvIHVzLlxyXG4gICAgLy8gSXQncyBcInJlbGV2YW50XCIgaWYgdGhlIG5ld2x5LWZvY3VzZWQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHVzLFxyXG4gICAgLy8gT1IgaWYgd2UncmUgZm9jdXNlZCBhbmQgZm9jdXMgbW92ZXMgT1VUU0lERSBvZiB1cyBvdXIgb3VyIGNoaWxkcmVuLlxyXG4gICAgLy8gQmVjYXVzZSBvZiB0aGF0IHNlY29uZCBiaXQsIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGVyZSB0aGUgZm9jdXMgd2FzIHRoZSBsYXN0IHRpbWUgd2UgY2hlY2tlZCBmb3IgdGhlIGZpbHRlci5cclxuICAgIGNvbnN0IFtoYXNGb2N1cywgc2V0SGFzRm9jdXMsIGdldEhhc0ZvY3VzXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtoYXNMYXN0Rm9jdXMsIHNldEhhc0xhc3RGb2N1cywgZ2V0SGFzTGFzdEZvY3VzXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IHsgZWxlbWVudCwgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICBjb25zdCB7IGFjdGl2ZUVsZW1lbnQsIGxhc3RBY3RpdmVFbGVtZW50IH0gPSB1c2VBY3RpdmVFbGVtZW50KHVzZUNhbGxiYWNrKCh7IGN1cnJlbnQsIGxhc3QsIHdpbmRvd0ZvY3VzZWQgfSkgPT4ge1xyXG4gICAgICAgIC8vIEtlZXAgaW4gbWluZCB0aGF0IG9uY2Ugd2UgZ2V0IG91ciBlbGVtZW50LCBldmVuIGlmIHRoZSBob29rIGFuZCBmaWx0ZXIgZnVuY3Rpb25zXHJcbiAgICAgICAgLy8gZG9uJ3QgcmUtcnVuLCB0aGUgY3VycmVudGx5LWZvY3VzZWQgZWxlbWVudCB3aWxsIHN0aWxsIGJlIHJldHVybmVkIGJlbG93LCBhbmQsXHJcbiAgICAgICAgLy8gZXZlbiBpZiBpdCdzIG5vdCB1cyBvciBvbmUgb2Ygb3VyIGNoaWxkcmVuLCB3aWxsIHN0aWxsIGJlIHNhZmVseSBmaWx0ZXJlZCBvdXQgYXQgcmVuZGVyIHRpbWUuXHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgbGV0IGhhc0ZvY3VzTm93ID0gKGVsZW1lbnQuY29udGFpbnMoY3VycmVudCkgfHwgZWxlbWVudC5jb250YWlucyhsYXN0KSk7XHJcbiAgICAgICAgaWYgKGhhc0ZvY3VzTm93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGhhZEZvY3VzQmVmb3JlVGhpcyA9IChnZXRIYXNMYXN0Rm9jdXMoKSB8fCBnZXRIYXNGb2N1cygpKTtcclxuICAgICAgICAgICAgaWYgKGhhZEZvY3VzQmVmb3JlVGhpcykge1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRydWUgb25jZSwgc28gdGhhdCB1c2VBY3RpdmVFbGVtZW50IHdpbGwgcmV0dXJuIG9uZSBpbnN0YW5jZSBvZiBhIGRpZmZlcmVudCBlbGVtZW50IGhhdmluZyBmb2N1cy5cclxuICAgICAgICAgICAgICAgIC8vIFRoZW4sIGJhY2sgb3V0c2lkZSB0aGlzIGZpbHRlciBmdW5jdGlvbiwgd2UnbGwga25vdyB0aGF0IHdlJ3JlIG5vIGxvbmdlciBmb2N1c2VkLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKSk7XHJcbiAgICAvLyBUaGVzZSBhcmUgcHJpbWFyaWx5IHVzZWQgZm9yIGJvb2trZWVwaW5nIGR1cmluZyB0aGUgZmlsdGVyIGZ1bmN0aW9uIGFib3ZlLlxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgc2V0SGFzRm9jdXMoZWxlbWVudD8uY29udGFpbnMoYWN0aXZlRWxlbWVudCkgPz8gZmFsc2UpOyB9LCBbZWxlbWVudCwgYWN0aXZlRWxlbWVudF0pO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgc2V0SGFzTGFzdEZvY3VzKGVsZW1lbnQ/LmNvbnRhaW5zKGxhc3RBY3RpdmVFbGVtZW50KSA/PyBmYWxzZSk7IH0sIFtlbGVtZW50LCBsYXN0QWN0aXZlRWxlbWVudF0pO1xyXG4gICAgY29uc3QgdXNlSGFzRm9jdXNQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wcykgPT4geyByZXR1cm4gdXNlUmVmRWxlbWVudFByb3BzKHByb3BzKTsgfSwgW3VzZVJlZkVsZW1lbnRQcm9wc10pO1xyXG4gICAgY29uc3QgZm9jdXNlZCA9IHVzZU1lbW8oKCkgPT4geyByZXR1cm4gZWxlbWVudCA9PSBhY3RpdmVFbGVtZW50OyB9LCBbZWxlbWVudCwgYWN0aXZlRWxlbWVudF0pO1xyXG4gICAgY29uc3QgZm9jdXNlZElubmVyID0gdXNlTWVtbygoKSA9PiB7IHJldHVybiBlbGVtZW50Py5jb250YWlucyhhY3RpdmVFbGVtZW50KSA/PyBmYWxzZTsgfSwgW2VsZW1lbnQsIGFjdGl2ZUVsZW1lbnRdKTtcclxuICAgIGNvbnN0IGxhc3RGb2N1c2VkID0gdXNlTWVtbygoKSA9PiB7IHJldHVybiBlbGVtZW50ID09IGxhc3RBY3RpdmVFbGVtZW50OyB9LCBbZWxlbWVudCwgbGFzdEFjdGl2ZUVsZW1lbnRdKTtcclxuICAgIGNvbnN0IGxhc3RGb2N1c2VkSW5uZXIgPSB1c2VNZW1vKCgpID0+IHsgcmV0dXJuIGVsZW1lbnQ/LmNvbnRhaW5zKGxhc3RBY3RpdmVFbGVtZW50KSA/PyBmYWxzZTsgfSwgW2VsZW1lbnQsIGxhc3RBY3RpdmVFbGVtZW50XSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUhhc0ZvY3VzUHJvcHMsXHJcbiAgICAgICAgZm9jdXNlZCxcclxuICAgICAgICBmb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgbGFzdEZvY3VzZWQsXHJcbiAgICAgICAgbGFzdEZvY3VzZWRJbm5lclxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtaGFzLWZvY3VzLmpzLm1hcCIsImltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3ROYXRpdmUsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuLyoqXHJcbiAqIFdyYXAgdGhlIG5hdGl2ZSBgdXNlRWZmZWN0YCB0byBhZGQgYXJndW1lbnRzXHJcbiAqIHRoYXQgYWxsb3cgYWNjZXNzaW5nIHRoZSBwcmV2aW91cyB2YWx1ZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXHJcbiAqIGFzIHdlbGwgYXMgdGhlIGNoYW5nZXMgdGhhdCBjYXVzZWQgdGhlIGhvb2sgdG8gYmUgY2FsbGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBlZmZlY3RcclxuICogQHBhcmFtIGlucHV0c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdChlZmZlY3QsIGlucHV0cykge1xyXG4gICAgY29uc3QgcHJldklucHV0cyA9IHVzZVJlZihpbnB1dHMpO1xyXG4gICAgY29uc3QgZWZmZWN0MiA9ICgpID0+IHtcclxuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgocHJldklucHV0cy5jdXJyZW50Lmxlbmd0aCwgaW5wdXRzLmxlbmd0aCk7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAocHJldklucHV0cy5jdXJyZW50W2ldICE9IGlucHV0c1tpXSlcclxuICAgICAgICAgICAgICAgIGNoYW5nZXNbaV0gPSB7IGZyb206IHByZXZJbnB1dHMuY3VycmVudFtpXSwgdG86IGlucHV0c1tpXSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlZmZlY3QocHJldklucHV0cy5jdXJyZW50LCBjaGFuZ2VzKTtcclxuICAgICAgICBwcmV2SW5wdXRzLmN1cnJlbnQgPSBpbnB1dHM7XHJcbiAgICB9O1xyXG4gICAgdXNlRWZmZWN0TmF0aXZlKGVmZmVjdDIsIGlucHV0cyk7XHJcbn1cclxuO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtZWZmZWN0LmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtbGF5b3V0LWVmZmVjdFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlQ2hpbGRGbGFnLCB1c2VDaGlsZE1hbmFnZXIgfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xyXG5pbXBvcnQgeyB1c2VMaXN0TmF2aWdhdGlvbiB9IGZyb20gXCIuL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcclxuaW1wb3J0IHsgdXNlSGFzRm9jdXMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCIuL3VzZS1lZmZlY3RcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uKHsgZm9jdXNPbkNoYW5nZTogZm9jIH0pIHtcclxuICAgIGNvbnN0IGdldEZvY3VzQ2VsbE9uUm93Q2hhbmdlID0gdXNlU3RhYmxlR2V0dGVyKGZvYyk7XHJcbiAgICBjb25zdCBbY3VycmVudFJvdywgc2V0Q3VycmVudFJvdywgZ2V0Q3VycmVudFJvd10gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtsYXN0S25vd25DZWxsSW5kZXgsIHNldExhc3RLbm93bkNlbGxJbmRleCwgZ2V0TGFzdEtub3duQ2VsbEluZGV4XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgdXNlRWZmZWN0KChbcHJldl0pID0+IHsgY29uc29sZS5sb2coYGN1cnJlbnRSb3c6ICR7cHJldn0gLT4gJHtjdXJyZW50Um93fWApOyB9LCBbY3VycmVudFJvd10pO1xyXG4gICAgY29uc3QgeyBjaGlsZENvdW50LCBtYW5hZ2VkQ2hpbGRyZW4sIGluZGljZXNCeUVsZW1lbnQsIGdldE1vdW50SW5kZXgsIG1vdW50ZWRDaGlsZHJlbiwgdG90YWxDaGlsZHJlbk1vdW50ZWQsIHRvdGFsQ2hpbGRyZW5Vbm91bnRlZCwgdXNlTWFuYWdlZENoaWxkIH0gPSB1c2VDaGlsZE1hbmFnZXIoKTtcclxuICAgIGNvbnN0IHsgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkIH0gPSB1c2VMaW5lYXJOYXZpZ2F0aW9uKHsgbWFuYWdlZENoaWxkcmVuLCBnZXRJbmRleDogZ2V0Q3VycmVudFJvdywgc2V0SW5kZXg6IHNldEN1cnJlbnRSb3csIG5hdmlnYXRpb25EaXJlY3Rpb246IFwiYmxvY2tcIiB9KTtcclxuICAgIHVzZUNoaWxkRmxhZyhjdXJyZW50Um93LCBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoLCB1c2VDYWxsYmFjaygoaW5kZXgsIHRhYmJhYmxlKSA9PiBtYW5hZ2VkQ2hpbGRyZW5baW5kZXhdPy5zZXRJc1RhYmJhYmxlUm93KHRhYmJhYmxlLCBsYXN0S25vd25DZWxsSW5kZXgpLCBbbGFzdEtub3duQ2VsbEluZGV4LCBtYW5hZ2VkQ2hpbGRyZW5dKSk7XHJcbiAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvblJvdyA9IHVzZUNhbGxiYWNrKCh7IGluZGV4LCAuLi5pbmZvIH0pID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGxhc3RGb2N1c2VkSW5uZXIgfSA9IHVzZUhhc0ZvY3VzKCk7XHJcbiAgICAgICAgY29uc3QgW2lzVGFiYmFibGVSb3csIHNldElzVGFiYmFibGVSb3ddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgIC8vIEJlc2lkZXMganVzdCBiZWluZyBhIGxpc3QgbmF2IGNoaWxkLCBpdCdzIGFsc28gYSBsaXN0IG5hdiBwYXJlbnRcclxuICAgICAgICAvLyB5YWFhYXl5eVxyXG4gICAgICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogdXNlTGlzdE5hdmlnYXRpb25DaGlsZDIsIGNoaWxkQ291bnQ6IGNlbGxDb3VudCwgaW5kaWNlc0J5RWxlbWVudDogY2VsbEluZGljZXNCeUVsZW1lbnQsIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZENlbGxzLCBuYXZpZ2F0ZVRvSW5kZXg6IHNldENlbGxJbmRleCwgdGFiYmFibGVJbmRleDogdGFiYmFibGVDZWxsLCBmb2N1c0N1cnJlbnQgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uKHsgZm9jdXNPbkNoYW5nZTogKGlzVGFiYmFibGVSb3cgJiYgZ2V0Rm9jdXNDZWxsT25Sb3dDaGFuZ2UoKSksIGtleU5hdmlnYXRpb246IFwiaW5saW5lXCIsIGluaXRpYWxJbmRleDogbnVsbCB9KTtcclxuICAgICAgICAvLyBBbnkgdGltZSB3ZSBiZWNvbWUgdGhlIGN1cnJlbnRseSB0YWJiYWJsZSByb3csXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBjb3JyZWN0IGNlbGwgaXMgc2VsZWN0ZWQgYW5kIGZvY3VzZWQuXHJcbiAgICAgICAgLy8gQW55IG90aGVyIHRpbWUsIG1ha2Ugc3VyZSBubyBjZWxsIGlzIHRhYmJhYmxlLlxyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc1RhYmJhYmxlUm93KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDZWxsSW5kZXgoZ2V0TGFzdEtub3duQ2VsbEluZGV4KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0Q2VsbEluZGV4KG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW2lzVGFiYmFibGVSb3ddKTtcclxuICAgICAgICAvLyBBbnkgdGltZSB3ZSBiZWNvbWUgdGhlIGN1cnJlbnRseSB0YWJiYWJsZSByb3csXHJcbiAgICAgICAgLy8gcmVxdWVzdCB0aGUgY29tcG9uZW50IHJlcmVuZGVyIGFuZCBmb2N1cyBpdHNlbGYuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVGFiYmFibGVSb3cgJiYgZ2V0Rm9jdXNDZWxsT25Sb3dDaGFuZ2UoKSkge1xyXG4gICAgICAgICAgICAgICAgZm9jdXNDdXJyZW50Py4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtmb2N1c0N1cnJlbnQsIGlzVGFiYmFibGVSb3ddKTtcclxuICAgICAgICAvLyBBbnkgdGltZSB0aGUgY3VycmVudCBjZWxsIGNoYW5nZXMgXHJcbiAgICAgICAgLy8gKHByb2JhYmx5IGJlY2F1c2Ugd2UgaW50ZXJhY3RlZCB3aXRoIGl0LCB0aHVzIGZvY3VzaW5nIGl0LCBcclxuICAgICAgICAvLyBjaGFuZ2luZyBpdCBmcm9tIG51bGwgaWYgdGhlIHJvdyB3YXNuJ3QgYWxyZWFkeSBmb2N1c2VkKVxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHRoZSBjdXJyZW50bHkgdGFiYmFibGUgcm93IGlmIHdlIHdlcmVuJ3QgYWxyZWFkeS5cclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGFiYmFibGVDZWxsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRMYXN0S25vd25DZWxsSW5kZXgodGFiYmFibGVDZWxsKTtcclxuICAgICAgICAgICAgICAgIHNldElzVGFiYmFibGVSb3codHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50Um93KGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtpbmRleCwgdGFiYmFibGVDZWxsLCBzZXRMYXN0S25vd25DZWxsSW5kZXhdKTtcclxuICAgICAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZFByb3BzIH0gPSB1c2VNYW5hZ2VkQ2hpbGQoe1xyXG4gICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgc2V0SXNUYWJiYWJsZVJvdzogdXNlQ2FsbGJhY2soKHRhYmJhYmxlLCBuZXdJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhYmJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q2VsbEluZGV4KG5ld0luZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNldElzVGFiYmFibGVSb3codGFiYmFibGUpO1xyXG4gICAgICAgICAgICB9LCBbXSksXHJcbiAgICAgICAgICAgIC4uLmluZm9cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB7IHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZFByb3BzIH0gPSB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGQoKTtcclxuICAgICAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzKSA9PiB1c2VNYW5hZ2VkQ2hpbGRQcm9wcyh1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VIYXNGb2N1c1Byb3BzKHByb3BzKSkpLCBbdXNlTWFuYWdlZENoaWxkUHJvcHNdKTtcclxuICAgICAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvbkNlbGwgPSB1c2VDYWxsYmFjaygoeyBpbmRleCwgdGV4dCwgLi4uaW5mbyB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZDIoeyB0ZXh0LCBpbmRleCwgLi4uaW5mbyB9KTtcclxuICAgICAgICAgICAgY29uc3QgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHMpID0+IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcyksIFt1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHNdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdGFiYmFibGUsIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzIH07XHJcbiAgICAgICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQyXSk7XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcywgdXNlR3JpZE5hdmlnYXRpb25DZWxsLCBjZWxsQ291bnQsIHRhYmJhYmxlQ2VsbCwgaXNUYWJiYWJsZVJvdywgbWFuYWdlZENlbGxzIH07XHJcbiAgICB9LCBbc2V0TGFzdEtub3duQ2VsbEluZGV4LCB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGQsIHVzZU1hbmFnZWRDaGlsZF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvdyxcclxuICAgICAgICByb3dDb3VudDogY2hpbGRDb3VudCxcclxuICAgICAgICBjZWxsSW5kZXg6IGxhc3RLbm93bkNlbGxJbmRleCxcclxuICAgICAgICByb3dJbmRleDogY3VycmVudFJvdyxcclxuICAgICAgICBtYW5hZ2VkUm93czogbWFuYWdlZENoaWxkcmVuXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1ncmlkLW5hdmlnYXRpb24uanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG4vKipcclxuICogQWxsb3dzIGF0dGFjaGluZyBhbiBldmVudCBoYW5kbGVyIHRvIGFueSAqbm9uLVByZWFjdCogZWxlbWVudCwgYW5kIHJlbW92aW5nIGl0IHdoZW4gdGhlIGNvbXBvbmVudCB1c2luZyB0aGUgaG9vayB1bm1vdW50cy4gVGhlIGNhbGxiYWNrIGRvZXMgbm90IG5lZWQgdG8gYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxyXG4gKlxyXG4gKiBEdWUgdG8gdHlwaW5nIGxpbWl0YXRpb25zLCB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGxpa2UgdGhpczpcclxuICpcclxuICogYHVzZUV2ZW50SGFuZGxlcihlbGVtZW50LCBcImlucHV0XCIpPElucHV0RXZlbnQ+KGUgPT4ge30pYFxyXG4gKlxyXG4gKiBUaGUgdHlwZSBhcmd1bWVudCBpcyBvcHRpb25hbCwgYnV0IG5hcnJvd3MgZG93biB0aGUgdHlwZSBmcm9tIFwiYSB1bmlvbiBvZiBhbGwgZXZlbnRzXCIgdG8gd2hhdGV2ZXIgeW91IHNwZWNpZnksIGFuZCBlcnJvcnMgaWYgaXQgZG9lc24ndCBleGlzdC5cclxuICpcclxuICogVGhlcmUgaXMgYSBzZXBhcmF0ZSB2ZXJzaW9uIHRoYXQgYXR0YWNoZXMgZXZlbnQgaGFuZGxlcnMgdG8gYSBzZXQgb2YgcHJvcHMuXHJcbiAqIEl0IHRha2VzIGRpZmZlcmVudCBldmVudCBzdHJpbmcgdHlwZXMgKG9uRXZlbnQgdnMgb25ldmVudCkuXHJcbiAqXHJcbiAqIEBwYXJhbSB0YXJnZXQgQSAqbm9uLVByZWFjdCogbm9kZSB0byBhdHRhY2ggdGhlIGV2ZW50IHRvLlxyXG4gKiBAcmV0dXJuc1xyXG4gKiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlcih0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIC8vIE5vdGUgdG8gc2VsZjogVGhlIHR5cGluZyBkb2Vzbid0IGltcHJvdmUgZXZlbiBpZiB0aGlzIGlzIHNwbGl0IHVwIGludG8gYSBzdWItZnVuY3Rpb24uXHJcbiAgICAvLyBObyBtYXR0ZXIgd2hhdCwgaXQgc2VlbXMgaW1wb3NzaWJsZSB0byBnZXQgdGhlIGhhbmRsZXIncyBldmVudCBvYmplY3QgdHlwZWQgcGVyZmVjdGx5LlxyXG4gICAgLy8gSXQgc2VlbXMgbGlrZSBpdCdzIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIGEgdW5pb24gb2YgYWxsIGF2YWlsYWJsZSB0dXBlcy5cclxuICAgIC8vIEFnYWluLCBubyBtYXR0ZXIgd2hhdCBjb21iaW5hdGlvbiBvZiBzdWItIG9yIHN1Yi1zdWItZnVuY3Rpb25zIHVzZWQuXHJcbiAgICBjb25zdCBzdGFibGVIYW5kbGVyID0gdXNlU3RhYmxlQ2FsbGJhY2soaGFuZGxlciA/PyAoKCkgPT4geyB9KSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcclxuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcclxufVxyXG4vKipcclxuICogQW4gYWx0ZXJuYXRpdmUgd2F5IHRvIGFkZCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIGVsZW1lbnQuIFVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpbnRlZ3JhdGluZyAzcmQgcGFydHkgbGlicmFyaWVzIHRoYXQgZXhwZWN0IGEgZ2VuZXJpYyBcImFkZCBldmVudCBoYW5kbGVyXCIgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB5b3UgdG8gbW9kaWZ5IGEgc2V0IG9mIHByb3BzIHRvIGFwcGx5IHRoaXMgaGFuZGxlci5cclxuICpcclxuICogRm9yIHR5cGluZyByZWFzb25zLCB0aGlzIGZ1bmN0aW9uIGlzIHNwbGl0IGludG8gdHdvLiAgVXNhZ2UgaXMgbGlrZSB0aGUgZm9sbG93aW5nOlxyXG4gKlxyXG4gKiBgYGBcclxuICogY29uc3QgeyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH0gPSB1c2VMb2NhbEV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4oKShcIm9uTW91c2VEb3duXCIsIGUgPT4geyAgfSk7XHJcbiAqIGNvbnN0IGRpdlByb3BzID0gdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyhwcm9wcyk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvY2FsSGFuZGxlcigpIHtcclxuICAgIHJldHVybiB1c2VDYWxsYmFjaygodHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0YWJsZUhhbmRsZXIgPSB1c2VTdGFibGVDYWxsYmFjayhoYW5kbGVyKTtcclxuICAgICAgICBjb25zdCB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHsgW3R5cGVdOiBzdGFibGVIYW5kbGVyIH0sIHByb3BzKTtcclxuICAgICAgICB9LCBbdHlwZV0pO1xyXG4gICAgICAgIHJldHVybiB7IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgfTtcclxuICAgIH0sIFtdKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtZXZlbnQtaGFuZGxlci5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlR2xvYmFsSGFuZGxlciB9IGZyb20gXCIuL3VzZS1ldmVudC1oYW5kbGVyXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGcm9tTG9jYWxTdG9yYWdlKCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIGNvbnZlcnRlciA9IEpTT04ucGFyc2UpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFpdGVtKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRlcihpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZGVidWdnZXI7IC8vIEludGVudGlvbmFsXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVUb0xvY2FsU3RvcmFnZSgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgY29udmVydGVyID0gSlNPTi5zdHJpbmdpZnkpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIGNvbnZlcnRlcih2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBkZWJ1Z2dlcjsgLy8gSW50ZW50aW9uYWxcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VQZXJzaXN0ZW50U3RhdGUoKSB7XHJcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKGtleSwgaW5pdGlhbFZhbHVlLCBmcm9tU3RyaW5nID0gSlNPTi5wYXJzZSwgdG9TdHJpbmcgPSBKU09OLnN0cmluZ2lmeSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IFtsb2NhbENvcHksIHNldExvY2FsQ29weSwgZ2V0TG9jYWxDb3B5XSA9IHVzZVN0YXRlKGdldEZyb21Mb2NhbFN0b3JhZ2UoKShrZXksIGZyb21TdHJpbmcpID8/IGluaXRpYWxWYWx1ZSk7XHJcbiAgICAgICAgLy8gTGlzdGVuIGZvciBjaGFuZ2VzIHRvIHRoaXMgc3RvcmFnZSBpbiBvdGhlciBicm93c2VyIHRhYnNcclxuICAgICAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJzdG9yYWdlXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLmtleSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGUubmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBzZXRMb2NhbENvcHkoZnJvbVN0cmluZyhuZXdWYWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3Qgc2V0VmFsdWVXcmFwcGVyID0gdXNlQ2FsbGJhY2soKHZhbHVlT3JTZXR0ZXIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgdmFsdWVPclNldHRlciA9PT0gXCJmdW5jdGlvblwiID8gdmFsdWVPclNldHRlcihnZXRMb2NhbENvcHkoKSkgOiB2YWx1ZU9yU2V0dGVyO1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhpcyB1cGRhdGUgaXMgYXZhaWxhYmxlIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgbmV4dCByZW5kZXJcclxuICAgICAgICAgICAgc2V0TG9jYWxDb3B5KHZhbHVlT3JTZXR0ZXIpO1xyXG4gICAgICAgICAgICAvLyBBY3R1YWxseSBzYXZlIHRoZSB2YWx1ZSB0byBsb2NhbCBzdG9yYWdlLlxyXG4gICAgICAgICAgICBzdG9yZVRvTG9jYWxTdG9yYWdlKCkoa2V5LCB2YWx1ZSwgdG9TdHJpbmcpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChmcm9tU3RyaW5nICE9IEpTT04ucGFyc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW2tleSwgdG9TdHJpbmddKTtcclxuICAgICAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdHJ1ZVZhbHVlID0gZ2V0RnJvbUxvY2FsU3RvcmFnZSgpKGtleSwgZnJvbVN0cmluZyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlVmFsdWUgPz8gbG9jYWxDb3B5O1xyXG4gICAgICAgIH0sIFtrZXksIGZyb21TdHJpbmddKTtcclxuICAgICAgICByZXR1cm4gW2xvY2FsQ29weSwgc2V0VmFsdWVXcmFwcGVyLCBnZXRWYWx1ZV07XHJcbiAgICB9LCBbXSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXBlcnNpc3RlbnQtc3RhdGUuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcbmNvbnN0IFRhYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OV8tXCI7XHJcbmZ1bmN0aW9uIGJhc2U2NCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIFRhYmxlW3ZhbHVlXTtcclxufVxyXG5mdW5jdGlvbiByYW5kb202Qml0cygpIHtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAwYjEwMDAwMDApO1xyXG59XHJcbmZ1bmN0aW9uIHJhbmRvbTY0Qml0cygpIHtcclxuICAgIHJldHVybiBbcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKV07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgd2l0aCBhbiBvcHRpb25hbCBwcmVmaXguXHJcbiAqIE5vdGUgdGhhdCBpZiB0aGUgcHJlZml4IGlzICpleHBsaWNpdGx5KiBzZXQgdG8gXCJcIiwgdGhlblxyXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tSWQocHJlZml4KSB7XHJcbiAgICByZXR1cm4gYCR7cHJlZml4ID8/IFwiaWQtXCJ9JHtyYW5kb202NEJpdHMoKS5tYXAobiA9PiBiYXNlNjQobikpLmpvaW4oXCJcIil9YDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGhvb2sgdGhhdCBtb2RpZmllcyBhIHNldCBvZiBwcm9wcyB0byBwcm92aWRlIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLlxyXG4gKlxyXG4gKiBJZiB5b3UnZCBsaWtlIHRvIHVzZSB0aGUgSUQgaW4gYSBwcm9wZXJ0eSB0aGF0J3MgKm5vdCogbmFtZWQgYGlkYCAobGlrZSBgZm9yYCBvciBgYXJpYS1sYWJlbGxlZGJ5YCBvciB3aGF0bm90KSwgYHVzZVJlZmVyZW5jZWRJZFByb3BzYCBpcyBhbHNvIHByb3ZpZGVkLlxyXG4gKlxyXG4gKiBBbmQgdGhlIHJhbmRvbWx5LWdlbmVyYXRlZCBpZCBpdHNlbGYgaXMgYWxzbyBwcm92aWRlZCBpbiBjYXNlIHlvdSB3YW50IHRvIGhhbmRsZSB0aGUgbG9naWMgeW91cnNlbGYgd2l0aG91dCBgdXNlTWVyZ2VkUHJvcHNgLlxyXG4gKlxyXG4gKiBVbmxpa2UgbW9zdCBvdGhlciBgdXNlKlByb3BzYCBob29rcywgdGhlc2UgYXJlIG1vc3RseSBzdGFibGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlUmFuZG9tSWQoeyBwcmVmaXggfSA9IHt9KSB7XHJcbiAgICBjb25zdCBbcmFuZG9tSWQsIHNldFJhbmRvbUlkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQocHJlZml4KSk7XHJcbiAgICBjb25zdCBbd2F0Y2hQcmVmaXhVcGRhdGVzLCBzZXRXYXRjaFByZWZpeFVwZGF0ZXMsIGdldFdhdGNoUHJlZml4VXBkYXRlc10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHdhdGNoUHJlZml4VXBkYXRlcyA9IGdldFdhdGNoUHJlZml4VXBkYXRlcygpO1xyXG4gICAgICAgIGlmICh3YXRjaFByZWZpeFVwZGF0ZXMpXHJcbiAgICAgICAgICAgIHNldFJhbmRvbUlkKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQocHJlZml4KSk7XHJcbiAgICAgICAgc2V0V2F0Y2hQcmVmaXhVcGRhdGVzKHRydWUpO1xyXG4gICAgfSwgW3ByZWZpeF0pO1xyXG4gICAgLy8gV2hhdGV2ZXIgSUQgd2FzIG1vc3QgcmVjZW50bHkgdXNlZCBieSB0aGUgYWN0dWFsIFwiaWRcIiBwcm9wLlxyXG4gICAgLy8gVXNlZCBzbyB0aGF0IGFueSBJRC1yZWZlcmVuY2luZyBwcm9wcyBkb24ndCBuZWVkIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUuXHJcbiAgICAvL1xyXG4gICAgLy8gVE9ETzogVGhpcyBkb2VzIG1lYW4gdGhhdCBvbiB0aGUgZmlyc3QgcmVuZGVyLCBpZiBqdXN0IHRoZSBJRCBpcyBwcm92aWRlZCxcclxuICAgIC8vIHRoZXJlIHdpbGwgYmUgYSB0ZW1wb3JhcnkgbWlzbWF0Y2gsIGJ1dCBpdCdzIGNvcnJlY3RlZCBiZWZvcmUgcmVuZGVyaW5nIGZpbmlzaGVzLlxyXG4gICAgLy8gSXMgdGhpcyBva2F5P1xyXG4gICAgY29uc3QgW3VzZWRJZCwgc2V0VXNlZElkLCBnZXRVc2VkSWRdID0gdXNlU3RhdGUodW5kZWZpbmVkKTtcclxuICAgIGNvbnN0IHVzZVJlZmVyZW5jZWRJZFByb3BzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlUmVmZXJlbmNlZElkUHJvcHMoaWRQcm9wTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHJldCA9IGZ1bmN0aW9uICh7IFtpZFByb3BOYW1lXTogZ2l2ZW5JZCwgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VkSWQyID0gKGdpdmVuSWQgPz8gdXNlZElkID8/IHJhbmRvbUlkID8/IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIGlmIChpZFByb3BOYW1lID09PSBcImlkXCIpXHJcbiAgICAgICAgICAgICAgICBzZXRVc2VkSWQodXNlZElkMik7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHsgW2lkUHJvcE5hbWVdOiB1c2VkSWQyIH0sIHByb3BzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9LCBbdXNlZElkLCByYW5kb21JZF0pO1xyXG4gICAgY29uc3QgdXNlUmFuZG9tSWRQcm9wcyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVJhbmRvbUlkUHJvcHMocCkge1xyXG4gICAgICAgIHJldHVybiB1c2VSZWZlcmVuY2VkSWRQcm9wcyhcImlkXCIpKHApO1xyXG4gICAgfSwgW3VzZVJlZmVyZW5jZWRJZFByb3BzXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJhbmRvbUlkLFxyXG4gICAgICAgIGlkOiB1c2VkSWQsXHJcbiAgICAgICAgZ2V0SWQ6IGdldFVzZWRJZCxcclxuICAgICAgICB1c2VSYW5kb21JZFByb3BzLFxyXG4gICAgICAgIHVzZVJlZmVyZW5jZWRJZFByb3BzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGFjY2VwdHNTdHJpbmdPckNzc09yVW5kZWZpbmVkKHUpIHsgfVxyXG5mdW5jdGlvbiBhY2NlcHRzU3RyaW5nT3JDc3Moc3RyKSB7IH1cclxuZnVuY3Rpb24gYWNjZXB0c0Nzcyhwcm9wKSB7IH1cclxuZnVuY3Rpb24gdGVzdChwcm9wcykge1xyXG4gICAgY29uc3QgeyBpZCwgcmFuZG9tSWQsIHVzZVJhbmRvbUlkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzIH0gPSB1c2VSYW5kb21JZCgpO1xyXG4gICAgLy9jb25zdCBwMWE6IE1lcmdlZFByb3BzPHsgaWQ6IHN0cmluZyB9LCB7ICB9PiA9IHVzZVJhbmRvbUlkUHJvcHMoeyBpZDogdW5kZWZpbmVkIH0pXHJcbiAgICBjb25zdCBwMWIgPSB1c2VSYW5kb21JZFByb3BzKHsgLi4ucHJvcHMsIGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwMmEgPSB1c2VSZWZlcmVuY2VkSWRQcm9wcyhcImZvclwiKSh7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwMmIgPSB1c2VSZWZlcmVuY2VkSWRQcm9wcyhcImZvclwiKSh7IC4uLnByb3BzLCBpZDogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uc3QgcDJjID0gdXNlUmVmZXJlbmNlZElkUHJvcHMoXCJmb3JcIikocHJvcHMpO1xyXG4gICAgY29uc3QgcDNhID0gdXNlUmFuZG9tSWRQcm9wcyh1c2VSZWZlcmVuY2VkSWRQcm9wcyhcImZvclwiKSh7IGlkOiB1bmRlZmluZWQgfSkpO1xyXG4gICAgY29uc3QgcDNiID0gdXNlUmFuZG9tSWRQcm9wcyh1c2VSZWZlcmVuY2VkSWRQcm9wcyhcImZvclwiKSh7IC4uLnByb3BzLCBpZDogdW5kZWZpbmVkIH0pKTtcclxuICAgIGNvbnN0IHA0YSA9IHVzZVJlZmVyZW5jZWRJZFByb3BzKFwiZm9yXCIpKHVzZVJhbmRvbUlkUHJvcHMoeyBpZDogdW5kZWZpbmVkIH0pKTtcclxuICAgIGNvbnN0IHA0YiA9IHVzZVJlZmVyZW5jZWRJZFByb3BzKFwiZm9yXCIpKHAxYik7XHJcbiAgICAvL3AxYS5pZDtcclxuICAgIHAxYi5pZDtcclxuICAgIHAyYVtcImZvclwiXTtcclxuICAgIHAyYltcImZvclwiXTtcclxuICAgIHAyY1tcImZvclwiXTtcclxuICAgIHAzYS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDNiLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwM2FbXCJmb3JcIl0/LmNvbmNhdChcIlwiKTtcclxuICAgIHAzYltcImZvclwiXT8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDRhW1wiZm9yXCJdPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNGJbXCJmb3JcIl0/LmNvbmNhdChcIlwiKTtcclxuICAgIHA0YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogSXQncyBiZWNhdXNlIGl0IHJlc29sdmVzIHRvIFwiaWQ6IHVuZGVmaW5lZCAmIHN0cmluZ1wiIC0tIHRoaXMgc2hvdWxkbid0IGhhcHBlblxyXG4gICAgcDRiLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBhY2NlcHRzU3RyaW5nT3JDc3NPclVuZGVmaW5lZChwMWIuc3R5bGUpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIGFjY2VwdHNTdHJpbmdPckNzcyhwMWIuc3R5bGUpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHAyYS5zdHlsZT8uYmFja2dyb3VuZENvbG9yO1xyXG4gICAgYWNjZXB0c1N0cmluZ09yQ3NzT3JVbmRlZmluZWQocDJiLnN0eWxlKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBhY2NlcHRzU3RyaW5nT3JDc3MocDJiLnN0eWxlKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBwM2Euc3R5bGU/LmJhY2tncm91bmRDb2xvcjtcclxuICAgIGFjY2VwdHNTdHJpbmdPckNzc09yVW5kZWZpbmVkKHAzYi5zdHlsZSk7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgcDRhLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcclxuICAgIGFjY2VwdHNTdHJpbmdPckNzc09yVW5kZWZpbmVkKHA0Yi5zdHlsZSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXJhbmRvbS1pZC5qcy5tYXAiLCIvKiFcbiogdGFiYmFibGUgNS4yLjFcbiogQGxpY2Vuc2UgTUlULCBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC90YWJiYWJsZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xudmFyIGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFsnaW5wdXQnLCAnc2VsZWN0JywgJ3RleHRhcmVhJywgJ2FbaHJlZl0nLCAnYnV0dG9uJywgJ1t0YWJpbmRleF0nLCAnYXVkaW9bY29udHJvbHNdJywgJ3ZpZGVvW2NvbnRyb2xzXScsICdbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdKScsICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScsICdkZXRhaWxzJ107XG52YXIgY2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi9jYW5kaWRhdGVTZWxlY3RvcnMuam9pbignLCcpO1xudmFyIG1hdGNoZXMgPSB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgPyBmdW5jdGlvbiAoKSB7fSA6IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG52YXIgZ2V0Q2FuZGlkYXRlcyA9IGZ1bmN0aW9uIGdldENhbmRpZGF0ZXMoZWwsIGluY2x1ZGVDb250YWluZXIsIGZpbHRlcikge1xuICB2YXIgY2FuZGlkYXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9yKSk7XG5cbiAgaWYgKGluY2x1ZGVDb250YWluZXIgJiYgbWF0Y2hlcy5jYWxsKGVsLCBjYW5kaWRhdGVTZWxlY3RvcikpIHtcbiAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICB9XG5cbiAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxudmFyIGlzQ29udGVudEVkaXRhYmxlID0gZnVuY3Rpb24gaXNDb250ZW50RWRpdGFibGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJztcbn07XG5cbnZhciBnZXRUYWJpbmRleCA9IGZ1bmN0aW9uIGdldFRhYmluZGV4KG5vZGUpIHtcbiAgdmFyIHRhYmluZGV4QXR0ciA9IHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG5cbiAgaWYgKCFpc05hTih0YWJpbmRleEF0dHIpKSB7XG4gICAgcmV0dXJuIHRhYmluZGV4QXR0cjtcbiAgfSAvLyBCcm93c2VycyBkbyBub3QgcmV0dXJuIGB0YWJJbmRleGAgY29ycmVjdGx5IGZvciBjb250ZW50RWRpdGFibGUgbm9kZXM7XG4gIC8vIHNvIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHRhYmluZGV4IGF0dHJpYnV0ZSBzcGVjaWZpY2FsbHkgc2V0LCBhc3N1bWUgaXQncyAwLlxuXG5cbiAgaWYgKGlzQ29udGVudEVkaXRhYmxlKG5vZGUpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gaW4gQ2hyb21lLCA8ZGV0YWlscy8+LCA8YXVkaW8gY29udHJvbHMvPiBhbmQgPHZpZGVvIGNvbnRyb2xzLz4gZWxlbWVudHMgZ2V0IGEgZGVmYXVsdFxuICAvLyAgYHRhYkluZGV4YCBvZiAtMSB3aGVuIHRoZSAndGFiaW5kZXgnIGF0dHJpYnV0ZSBpc24ndCBzcGVjaWZpZWQgaW4gdGhlIERPTSxcbiAgLy8gIHlldCB0aGV5IGFyZSBzdGlsbCBwYXJ0IG9mIHRoZSByZWd1bGFyIHRhYiBvcmRlcjsgaW4gRkYsIHRoZXkgZ2V0IGEgZGVmYXVsdFxuICAvLyAgYHRhYkluZGV4YCBvZiAwOyBzaW5jZSBDaHJvbWUgc3RpbGwgcHV0cyB0aG9zZSBlbGVtZW50cyBpbiB0aGUgcmVndWxhciB0YWJcbiAgLy8gIG9yZGVyLCBjb25zaWRlciB0aGVpciB0YWIgaW5kZXggdG8gYmUgMC5cblxuXG4gIGlmICgobm9kZS5ub2RlTmFtZSA9PT0gJ0FVRElPJyB8fCBub2RlLm5vZGVOYW1lID09PSAnVklERU8nIHx8IG5vZGUubm9kZU5hbWUgPT09ICdERVRBSUxTJykgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBub2RlLnRhYkluZGV4O1xufTtcblxudmFyIHNvcnRPcmRlcmVkVGFiYmFibGVzID0gZnVuY3Rpb24gc29ydE9yZGVyZWRUYWJiYWJsZXMoYSwgYikge1xuICByZXR1cm4gYS50YWJJbmRleCA9PT0gYi50YWJJbmRleCA/IGEuZG9jdW1lbnRPcmRlciAtIGIuZG9jdW1lbnRPcmRlciA6IGEudGFiSW5kZXggLSBiLnRhYkluZGV4O1xufTtcblxudmFyIGlzSW5wdXQgPSBmdW5jdGlvbiBpc0lucHV0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0lOUFVUJztcbn07XG5cbnZhciBpc0hpZGRlbklucHV0ID0gZnVuY3Rpb24gaXNIaWRkZW5JbnB1dChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ2hpZGRlbic7XG59O1xuXG52YXIgaXNEZXRhaWxzV2l0aFN1bW1hcnkgPSBmdW5jdGlvbiBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB7XG4gIHZhciByID0gbm9kZS50YWdOYW1lID09PSAnREVUQUlMUycgJiYgQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG5vZGUuY2hpbGRyZW4pLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLnRhZ05hbWUgPT09ICdTVU1NQVJZJztcbiAgfSk7XG4gIHJldHVybiByO1xufTtcblxudmFyIGdldENoZWNrZWRSYWRpbyA9IGZ1bmN0aW9uIGdldENoZWNrZWRSYWRpbyhub2RlcywgZm9ybSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldLmNoZWNrZWQgJiYgbm9kZXNbaV0uZm9ybSA9PT0gZm9ybSkge1xuICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGlzVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIGlzVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIGlmICghbm9kZS5uYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgcmFkaW9TY29wZSA9IG5vZGUuZm9ybSB8fCBub2RlLm93bmVyRG9jdW1lbnQ7XG5cbiAgdmFyIHF1ZXJ5UmFkaW9zID0gZnVuY3Rpb24gcXVlcnlSYWRpb3MobmFtZSkge1xuICAgIHJldHVybiByYWRpb1Njb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJyk7XG4gIH07XG5cbiAgdmFyIHJhZGlvU2V0O1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkNTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLCBlcnIubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoZWNrZWQgPSBnZXRDaGVja2VkUmFkaW8ocmFkaW9TZXQsIG5vZGUuZm9ybSk7XG4gIHJldHVybiAhY2hlY2tlZCB8fCBjaGVja2VkID09PSBub2RlO1xufTtcblxudmFyIGlzUmFkaW8gPSBmdW5jdGlvbiBpc1JhZGlvKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAncmFkaW8nO1xufTtcblxudmFyIGlzTm9uVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIHJldHVybiBpc1JhZGlvKG5vZGUpICYmICFpc1RhYmJhYmxlUmFkaW8obm9kZSk7XG59O1xuXG52YXIgaXNIaWRkZW4gPSBmdW5jdGlvbiBpc0hpZGRlbihub2RlLCBkaXNwbGF5Q2hlY2spIHtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUobm9kZSkudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpc0RpcmVjdFN1bW1hcnkgPSBtYXRjaGVzLmNhbGwobm9kZSwgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyk7XG4gIHZhciBub2RlVW5kZXJEZXRhaWxzID0gaXNEaXJlY3RTdW1tYXJ5ID8gbm9kZS5wYXJlbnRFbGVtZW50IDogbm9kZTtcblxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGVVbmRlckRldGFpbHMsICdkZXRhaWxzOm5vdChbb3Blbl0pIConKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCFkaXNwbGF5Q2hlY2sgfHwgZGlzcGxheUNoZWNrID09PSAnZnVsbCcpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUobm9kZSkuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwbGF5Q2hlY2sgPT09ICdub24temVyby1hcmVhJykge1xuICAgIHZhciBfbm9kZSRnZXRCb3VuZGluZ0NsaWUgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICB3aWR0aCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLmhlaWdodDtcblxuICAgIHJldHVybiB3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDA7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59OyAvLyBmb3JtIGZpZWxkcyAobmVzdGVkKSBpbnNpZGUgYSBkaXNhYmxlZCBmaWVsZHNldCBhcmUgbm90IGZvY3VzYWJsZS90YWJiYWJsZVxuLy8gIHVubGVzcyB0aGV5IGFyZSBpbiB0aGUgX2ZpcnN0XyA8bGVnZW5kPiBlbGVtZW50IG9mIHRoZSB0b3AtbW9zdCBkaXNhYmxlZFxuLy8gIGZpZWxkc2V0XG5cblxudmFyIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQgPSBmdW5jdGlvbiBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpIHtcbiAgaWYgKGlzSW5wdXQobm9kZSkgfHwgbm9kZS50YWdOYW1lID09PSAnU0VMRUNUJyB8fCBub2RlLnRhZ05hbWUgPT09ICdURVhUQVJFQScgfHwgbm9kZS50YWdOYW1lID09PSAnQlVUVE9OJykge1xuICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuXG4gICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChwYXJlbnROb2RlLnRhZ05hbWUgPT09ICdGSUVMRFNFVCcgJiYgcGFyZW50Tm9kZS5kaXNhYmxlZCkge1xuICAgICAgICAvLyBsb29rIGZvciB0aGUgZmlyc3QgPGxlZ2VuZD4gYXMgYW4gaW1tZWRpYXRlIGNoaWxkIG9mIHRoZSBkaXNhYmxlZFxuICAgICAgICAvLyAgPGZpZWxkc2V0PjogaWYgdGhlIG5vZGUgaXMgaW4gdGhhdCBsZWdlbmQsIGl0J2xsIGJlIGVuYWJsZWQgZXZlblxuICAgICAgICAvLyAgdGhvdWdoIHRoZSBmaWVsZHNldCBpcyBkaXNhYmxlZDsgb3RoZXJ3aXNlLCB0aGUgbm9kZSBpcyBpbiBhXG4gICAgICAgIC8vICBzZWNvbmRhcnkvc3Vic2VxdWVudCBsZWdlbmQsIG9yIHNvbWV3aGVyZSBlbHNlIHdpdGhpbiB0aGUgZmllbGRzZXRcbiAgICAgICAgLy8gIChob3dldmVyIGRlZXAgbmVzdGVkKSBhbmQgaXQnbGwgYmUgZGlzYWJsZWRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pdGVtKGkpO1xuXG4gICAgICAgICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09ICdMRUdFTkQnKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSAvLyB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZmlyc3QgbGVnZW5kIChpbiBkb2Mgb3JkZXIpLCBzbyBubyBtYXR0ZXJcbiAgICAgICAgICAgIC8vICB3aGVyZSBpdCBpcyBub3csIGl0J2xsIGJlIGRpc2FibGVkXG5cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHRoZSBub2RlIGlzbid0IGluIGEgbGVnZW5kLCBzbyBubyBtYXR0ZXIgd2hlcmUgaXQgaXMgbm93LCBpdCdsbCBiZSBkaXNhYmxlZFxuXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICB9IC8vIGVsc2UsIG5vZGUncyB0YWJiYWJsZS9mb2N1c2FibGUgc3RhdGUgc2hvdWxkIG5vdCBiZSBhZmZlY3RlZCBieSBhIGZpZWxkc2V0J3NcbiAgLy8gIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGVcblxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlID0gZnVuY3Rpb24gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKSB7XG4gIGlmIChub2RlLmRpc2FibGVkIHx8IGlzSGlkZGVuSW5wdXQobm9kZSkgfHwgaXNIaWRkZW4obm9kZSwgb3B0aW9ucy5kaXNwbGF5Q2hlY2spIHx8IC8vIEZvciBhIGRldGFpbHMgZWxlbWVudCB3aXRoIGEgc3VtbWFyeSwgdGhlIHN1bW1hcnkgZWxlbWVudCBnZXRzIHRoZSBmb2N1c1xuICBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB8fCBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlID0gZnVuY3Rpb24gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlKG9wdGlvbnMsIG5vZGUpIHtcbiAgaWYgKCFpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpIHx8IGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB8fCBnZXRUYWJpbmRleChub2RlKSA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciB0YWJiYWJsZSA9IGZ1bmN0aW9uIHRhYmJhYmxlKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICB2YXIgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuICB2YXIgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoZWwsIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICBjYW5kaWRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGNhbmRpZGF0ZSwgaSkge1xuICAgIHZhciBjYW5kaWRhdGVUYWJpbmRleCA9IGdldFRhYmluZGV4KGNhbmRpZGF0ZSk7XG5cbiAgICBpZiAoY2FuZGlkYXRlVGFiaW5kZXggPT09IDApIHtcbiAgICAgIHJlZ3VsYXJUYWJiYWJsZXMucHVzaChjYW5kaWRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxuICAgICAgICB0YWJJbmRleDogY2FuZGlkYXRlVGFiaW5kZXgsXG4gICAgICAgIG5vZGU6IGNhbmRpZGF0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHRhYmJhYmxlTm9kZXMgPSBvcmRlcmVkVGFiYmFibGVzLnNvcnQoc29ydE9yZGVyZWRUYWJiYWJsZXMpLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhLm5vZGU7XG4gIH0pLmNvbmNhdChyZWd1bGFyVGFiYmFibGVzKTtcbiAgcmV0dXJuIHRhYmJhYmxlTm9kZXM7XG59O1xuXG52YXIgZm9jdXNhYmxlID0gZnVuY3Rpb24gZm9jdXNhYmxlKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoZWwsIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG52YXIgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVGFiYmFibGUobm9kZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuXG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgY2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG52YXIgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi9jYW5kaWRhdGVTZWxlY3RvcnMuY29uY2F0KCdpZnJhbWUnKS5qb2luKCcsJyk7XG5cbnZhciBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIGlzRm9jdXNhYmxlKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cblxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmV4cG9ydCB7IGZvY3VzYWJsZSwgaXNGb2N1c2FibGUsIGlzVGFiYmFibGUsIHRhYmJhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuKCgpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHByb3BlcnRpZXMgKi9cbiAgICBjb25zdCBfYmxvY2tpbmdFbGVtZW50cyA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IF9hbHJlYWR5SW5lcnRFbGVtZW50cyA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IF90b3BFbFBhcmVudHMgPSBTeW1ib2woKTtcbiAgICBjb25zdCBfc2libGluZ3NUb1Jlc3RvcmUgPSBTeW1ib2woKTtcbiAgICBjb25zdCBfcGFyZW50TU8gPSBTeW1ib2woKTtcbiAgICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHN0YXRpYyBtZXRob2RzICovXG4gICAgY29uc3QgX3RvcENoYW5nZWQgPSBTeW1ib2woKTtcbiAgICBjb25zdCBfc3dhcEluZXJ0ZWRTaWJsaW5nID0gU3ltYm9sKCk7XG4gICAgY29uc3QgX2luZXJ0U2libGluZ3MgPSBTeW1ib2woKTtcbiAgICBjb25zdCBfcmVzdG9yZUluZXJ0ZWRTaWJsaW5ncyA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IF9nZXRQYXJlbnRzID0gU3ltYm9sKCk7XG4gICAgY29uc3QgX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4gPSBTeW1ib2woKTtcbiAgICBjb25zdCBfaXNJbmVydGFibGUgPSBTeW1ib2woKTtcbiAgICBjb25zdCBfaGFuZGxlTXV0YXRpb25zID0gU3ltYm9sKCk7XG4gICAgY2xhc3MgQmxvY2tpbmdFbGVtZW50c0ltcGwge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGJsb2NraW5nIGVsZW1lbnRzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzW19hXSA9IFtdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHBhcmVudHMgb2YgdGhlIHRvcCBlbGVtZW50LCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgKiBpdHNlbGYgdXAgdG8gYm9keS4gV2hlbiB0b3AgY2hhbmdlcywgdGhlIG9sZCB0b3AgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgICAqIGZyb20gdGhlIGRvY3VtZW50LCBzbyB3ZSBuZWVkIHRvIG1lbW9pemUgdGhlIGluZXJ0ZWQgcGFyZW50cycgc2libGluZ3NcbiAgICAgICAgICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlaXIgaW5lcnRlbmVzcyB3aGVuIHRvcCBjaGFuZ2VzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzW19iXSA9IFtdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbGVtZW50cyB0aGF0IGFyZSBhbHJlYWR5IGluZXJ0IGJlZm9yZSB0aGUgZmlyc3QgYmxvY2tpbmcgZWxlbWVudCBpc1xuICAgICAgICAgICAgICogcHVzaGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzW19jXSA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBpbmVydG5lc3MuXG4gICAgICAgICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXSh0aGlzW190b3BFbFBhcmVudHNdKTtcbiAgICAgICAgICAgIC8vIE5vdGUgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZXNlIHByb3BlcnRpZXMgbnVsbGFibGUgb24gdGhlIGNsYXNzLFxuICAgICAgICAgICAgLy8gc2luY2UgdGhlbiB3ZSdkIG5lZWQgbm9uLW51bGwgY2FzdHMgaW4gbWFueSBwbGFjZXMuIENhbGxpbmcgYSBtZXRob2Qgb25cbiAgICAgICAgICAgIC8vIGEgQmxvY2tpbmdFbGVtZW50cyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRlc3RydWN0b3Igd2lsbCByZXN1bHQgaW4gYW5cbiAgICAgICAgICAgIC8vIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IG51bGxhYmxlID0gdGhpcztcbiAgICAgICAgICAgIG51bGxhYmxlW19ibG9ja2luZ0VsZW1lbnRzXSA9IG51bGw7XG4gICAgICAgICAgICBudWxsYWJsZVtfdG9wRWxQYXJlbnRzXSA9IG51bGw7XG4gICAgICAgICAgICBudWxsYWJsZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgdG9wKCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbXMgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQgPT09IHRoaXMudG9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCB3ZSdsbCBicmluZyBpdCB0byB0aGUgdG9wLlxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzW190b3BDaGFuZ2VkXShlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgLy8gVG9wIGNoYW5nZWQgb25seSBpZiB0aGUgcmVtb3ZlZCBlbGVtZW50IHdhcyB0aGUgdG9wIGVsZW1lbnQuXG4gICAgICAgICAgICBpZiAoaSA9PT0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0odGhpcy50b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcG9wKCkge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy50b3A7XG4gICAgICAgICAgICB0b3AgJiYgdGhpcy5yZW1vdmUodG9wKTtcbiAgICAgICAgICAgIHJldHVybiB0b3A7XG4gICAgICAgIH1cbiAgICAgICAgaGFzKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBgaW5lcnRgIHRvIGFsbCBkb2N1bWVudCBlbGVtZW50cyBleGNlcHQgdGhlIG5ldyB0b3AgZWxlbWVudCwgaXRzXG4gICAgICAgICAqIHBhcmVudHMsIGFuZCBpdHMgZGlzdHJpYnV0ZWQgY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIFsoX2EgPSBfYmxvY2tpbmdFbGVtZW50cywgX2IgPSBfdG9wRWxQYXJlbnRzLCBfYyA9IF9hbHJlYWR5SW5lcnRFbGVtZW50cywgX3RvcENoYW5nZWQpXShuZXdUb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgICAgICAgY29uc3Qgb2xkUGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAgICAgICAvLyBObyBuZXcgdG9wLCByZXNldCBvbGQgdG9wIGlmIGFueS5cbiAgICAgICAgICAgIGlmICghbmV3VG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cyk7XG4gICAgICAgICAgICAgICAgdG9LZWVwSW5lcnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3UGFyZW50cyA9IHRoaXNbX2dldFBhcmVudHNdKG5ld1RvcCk7XG4gICAgICAgICAgICAvLyBOZXcgdG9wIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIG1haW4gZG9jdW1lbnQhXG4gICAgICAgICAgICBpZiAobmV3UGFyZW50c1tuZXdQYXJlbnRzLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignTm9uLWNvbm5lY3RlZCBlbGVtZW50IGNhbm5vdCBiZSBhIGJsb2NraW5nIGVsZW1lbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhc3QgaGVyZSBiZWNhdXNlIHdlIGtub3cgd2UnbGwgY2FsbCBfaW5lcnRTaWJsaW5ncyBvbiBuZXdQYXJlbnRzXG4gICAgICAgICAgICAvLyBiZWxvdy5cbiAgICAgICAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBuZXdQYXJlbnRzO1xuICAgICAgICAgICAgY29uc3QgdG9Ta2lwID0gdGhpc1tfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0obmV3VG9wKTtcbiAgICAgICAgICAgIC8vIE5vIHByZXZpb3VzIHRvcCBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKCFvbGRQYXJlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpID0gb2xkUGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IGogPSBuZXdQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAvLyBGaW5kIGNvbW1vbiBwYXJlbnQuIEluZGV4IDAgaXMgdGhlIGVsZW1lbnQgaXRzZWxmIChzbyBzdG9wIGJlZm9yZSBpdCkuXG4gICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgaiA+IDAgJiYgb2xkUGFyZW50c1tpXSA9PT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB1cCB0aGUgcGFyZW50cyB0cmVlIHRoZXJlIGFyZSAyIGVsZW1lbnRzIHRoYXQgYXJlIHNpYmxpbmdzLCBzd2FwXG4gICAgICAgICAgICAvLyB0aGUgaW5lcnRlZCBzaWJsaW5nLlxuICAgICAgICAgICAgaWYgKG9sZFBhcmVudHNbaV0gIT09IG5ld1BhcmVudHNbal0pIHtcbiAgICAgICAgICAgICAgICB0aGlzW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZFBhcmVudHNbaV0sIG5ld1BhcmVudHNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzdG9yZSBvbGQgcGFyZW50cyBzaWJsaW5ncyBpbmVydG5lc3MuXG4gICAgICAgICAgICBpID4gMCAmJiB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzLnNsaWNlKDAsIGkpKTtcbiAgICAgICAgICAgIC8vIE1ha2UgbmV3IHBhcmVudHMgc2libGluZ3MgaW5lcnQuXG4gICAgICAgICAgICBqID4gMCAmJiB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLnNsaWNlKDAsIGopLCB0b1NraXAsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTd2FwcyBpbmVydG5lc3MgYmV0d2VlbiB0d28gc2libGluZyBlbGVtZW50cy5cbiAgICAgICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgICAgICovXG4gICAgICAgIFtfc3dhcEluZXJ0ZWRTaWJsaW5nXShvbGRJbmVydCwgbmV3SW5lcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdzVG9SZXN0b3JlID0gb2xkSW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgICAgIC8vIG9sZEluZXJ0IGlzIG5vdCBjb250YWluZWQgaW4gc2libGluZ3MgdG8gcmVzdG9yZSwgc28gd2UgaGF2ZSB0byBjaGVja1xuICAgICAgICAgICAgLy8gaWYgaXQncyBpbmVydGFibGUgYW5kIGlmIGFscmVhZHkgaW5lcnQuXG4gICAgICAgICAgICBpZiAodGhpc1tfaXNJbmVydGFibGVdKG9sZEluZXJ0KSAmJiAhb2xkSW5lcnQuaW5lcnQpIHtcbiAgICAgICAgICAgICAgICBvbGRJbmVydC5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuYWRkKG9sZEluZXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG5ld0luZXJ0IHdhcyBhbHJlYWR5IGJldHdlZW4gdGhlIHNpYmxpbmdzIHRvIHJlc3RvcmUsIGl0IG1lYW5zIGl0IGlzXG4gICAgICAgICAgICAvLyBpbmVydGFibGUgYW5kIG11c3QgYmUgcmVzdG9yZWQuXG4gICAgICAgICAgICBpZiAoc2libGluZ3NUb1Jlc3RvcmUuaGFzKG5ld0luZXJ0KSkge1xuICAgICAgICAgICAgICAgIG5ld0luZXJ0LmluZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuZGVsZXRlKG5ld0luZXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0luZXJ0W19wYXJlbnRNT10gPSBvbGRJbmVydFtfcGFyZW50TU9dO1xuICAgICAgICAgICAgbmV3SW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHNpYmxpbmdzVG9SZXN0b3JlO1xuICAgICAgICAgICAgb2xkSW5lcnRbX3BhcmVudE1PXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIGluZXJ0bmVzcyB0byB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAgICAgKi9cbiAgICAgICAgW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShlbGVtZW50cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW8gPSBlbGVtZW50W19wYXJlbnRNT107XG4gICAgICAgICAgICAgICAgbW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNpYmxpbmcgb2Ygc2libGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZXJ0cyB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzIGV4Y2VwdCB0aGUgZWxlbWVudHMgdG8gc2tpcC4gU3RvcmVzXG4gICAgICAgICAqIHRoZSBpbmVydGVkIHNpYmxpbmdzIGludG8gdGhlIGVsZW1lbnQncyBzeW1ib2wgYF9zaWJsaW5nc1RvUmVzdG9yZWAuXG4gICAgICAgICAqIFBhc3MgYHRvS2VlcEluZXJ0YCB0byBjb2xsZWN0IHRoZSBhbHJlYWR5IGluZXJ0IGVsZW1lbnRzLlxuICAgICAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAgICAgKi9cbiAgICAgICAgW19pbmVydFNpYmxpbmdzXShlbGVtZW50cywgdG9Ta2lwLCB0b0tlZXBJbmVydCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgLy8gQXNzdW1lIGVsZW1lbnQgaXMgbm90IGEgRG9jdW1lbnQsIHNvIGl0IG11c3QgaGF2ZSBhIHBhcmVudE5vZGUuXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgaW5wdXQgZWxlbWVudCwgaWYgbm90IGluZXJ0YWJsZSBvciB0byBiZSBza2lwcGVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZyA9PT0gZWxlbWVudCB8fCAhdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodG9Ta2lwICYmIHRvU2tpcC5oYXMoc2libGluZykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgY29sbGVjdGVkIHNpbmNlIGFscmVhZHkgaW5lcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgc2libGluZ3MgdGhhdCB3ZXJlIGluZXJ0ZWQuXG4gICAgICAgICAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gaW5lcnRlZFNpYmxpbmdzO1xuICAgICAgICAgICAgICAgIC8vIE9ic2VydmUgb25seSBpbW1lZGlhdGUgY2hpbGRyZW4gbXV0YXRpb25zIG9uIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICAgICAgY29uc3QgbW8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzW19oYW5kbGVNdXRhdGlvbnNdLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IG1vO1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRUb09ic2VydmUgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgdXNpbmcgdGhlIFNoYWR5RE9NIHBvbHlmaWxsLCB0aGVuIG91ciBwYXJlbnQgY291bGQgYmUgYVxuICAgICAgICAgICAgICAgIC8vIHNoYWR5IHJvb3QsIHdoaWNoIGlzIGFuIG9iamVjdCB0aGF0IGFjdHMgbGlrZSBhIFNoYWRvd1Jvb3QsIGJ1dCBpc24ndFxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbGx5IGEgbm9kZSBpbiB0aGUgcmVhbCBET00uIE9ic2VydmUgdGhlIHJlYWwgRE9NIHBhcmVudCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlU2hhZHlSb290ID0gcGFyZW50VG9PYnNlcnZlO1xuICAgICAgICAgICAgICAgIGlmIChtYXliZVNoYWR5Um9vdC5fX3NoYWR5ICYmIG1heWJlU2hhZHlSb290Lmhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VG9PYnNlcnZlID0gbWF5YmVTaGFkeVJvb3QuaG9zdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW8ub2JzZXJ2ZShwYXJlbnRUb09ic2VydmUsIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIG5ld2x5IGFkZGVkL3JlbW92ZWQgbm9kZXMgYnkgdG9nZ2xpbmcgdGhlaXIgaW5lcnRuZXNzLlxuICAgICAgICAgKiBJdCBhbHNvIGNoZWNrcyBpZiB0aGUgY3VycmVudCB0b3AgQmxvY2tpbmcgRWxlbWVudCBoYXMgYmVlbiByZW1vdmVkLFxuICAgICAgICAgKiBub3RpZnlpbmcgYW5kIHJlbW92aW5nIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgW19oYW5kbGVNdXRhdGlvbnNdKG11dGF0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAgICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHNoYWRvd1Jvb3QsIGdldCBpdHMgaG9zdCBhcyB3ZSBza2lwIHNoYWRvd1Jvb3RzIHdoZW5cbiAgICAgICAgICAgICAgICAvLyBjb21wdXRpbmcgX3RvcEVsUGFyZW50cy5cbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBtdXRhdGlvbi50YXJnZXQuaG9zdCB8fCBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gdGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5ID9cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggOlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLmluZGV4T2YodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmVydGVkQ2hpbGQgPSBwYXJlbnRzW2lkeCAtIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IGluZXJ0ZWRDaGlsZFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgICAgICAgICAgIC8vIFRvIHJlc3RvcmUuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLnJlbW92ZWROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcgPT09IGluZXJ0ZWRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdEZXRlY3RlZCByZW1vdmFsIG9mIHRoZSB0b3AgQmxvY2tpbmcgRWxlbWVudC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZXJ0ZWRTaWJsaW5ncy5oYXMoc2libGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5kZWxldGUoc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVG8gaW5lcnQuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBpZiB0aGUgZWxlbWVudCBpcyBpbmVydGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBbX2lzSW5lcnRhYmxlXShlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2UgPT09IC9eKHN0eWxlfHRlbXBsYXRlfHNjcmlwdCkkLy50ZXN0KGVsZW1lbnQubG9jYWxOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBuZXdQYXJlbnRzIG9mIGFuIGVsZW1lbnQsIHN0YXJ0aW5nIGZyb20gZWxlbWVudFxuICAgICAgICAgKiAoaW5jbHVkZWQpIHVwIHRvIGBkb2N1bWVudC5ib2R5YCAoZXhjbHVkZWQpLlxuICAgICAgICAgKi9cbiAgICAgICAgW19nZXRQYXJlbnRzXShlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAvLyBTdG9wIHRvIGJvZHkuXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBzaGFkb3cgcm9vdHMuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2hhZG93RG9tIHYxXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbGxlY3Qgc2xvdHMgZnJvbSBkZWVwZXN0IHNsb3QgdG8gdG9wLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudCA9IGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgdGhlIHNlYXJjaCBvbiB0aGUgdG9wIHNsb3QuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBwYXJlbnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSB8fFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgICAgICogUmV0dXJucyBudWxsIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhIHNoYWRvdyByb290LlxuICAgICAgICAgKi9cbiAgICAgICAgW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGxldCBqO1xuICAgICAgICAgICAgbGV0IG5vZGVzO1xuICAgICAgICAgICAgY29uc3Qgc2xvdHMgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgICAgICAgIGlmIChzbG90cy5sZW5ndGggJiYgc2xvdHNbMF0uYXNzaWduZWROb2Rlcykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBub2RlcyA9IHNsb3RzW2ldLmFzc2lnbmVkTm9kZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQobm9kZXNbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gc2VhcmNoIGZvciA8Y29udGVudD4uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvY3VtZW50LiRibG9ja2luZ0VsZW1lbnRzID1cbiAgICAgICAgbmV3IEJsb2NraW5nRWxlbWVudHNJbXBsKCk7XG59KSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2tpbmctZWxlbWVudHMuanMubWFwIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdpbmVydCcsIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gICAqIChodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsLzIwMTUvY29weXJpZ2h0LXNvZnR3YXJlLWFuZC1kb2N1bWVudCkuXG4gICAqL1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIHdlJ3JlIG5vdCBydW5uaW5nIGluc2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBOb2RlTGlzdHMuXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICAgKiBAdHlwZSB7dHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXN9XG4gICAgICovXG4gICAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdmFyIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZyA9IFsnYVtocmVmXScsICdhcmVhW2hyZWZdJywgJ2lucHV0Om5vdChbZGlzYWJsZWRdKScsICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJywgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKScsICdidXR0b246bm90KFtkaXNhYmxlZF0pJywgJ2RldGFpbHMnLCAnc3VtbWFyeScsICdpZnJhbWUnLCAnb2JqZWN0JywgJ2VtYmVkJywgJ1tjb250ZW50ZWRpdGFibGVdJ10uam9pbignLCcpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Um9vdGAgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBzdWJ0cmVlLCBpLmUuIGEgRE9NIHN1YnRyZWUgd2hvc2Ugcm9vdCBlbGVtZW50IGhhcyBhbiBgaW5lcnRgXG4gICAgICogYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogSXRzIG1haW4gZnVuY3Rpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgICAqICAgc3VidHJlZS4gVGhlIGBtYWtlU3VidHJlZVVuZm9jdXNhYmxlKClgIG1ldGhvZCBoYW5kbGVzIGNvbGxlY3RpbmcgYEluZXJ0Tm9kZWBzIHZpYSByZWdpc3RlcmluZ1xuICAgICAqICAgZWFjaCBmb2N1c2FibGUgbm9kZSBpbiB0aGUgc3VidHJlZSB3aXRoIHRoZSBzaW5nbGV0b24gYEluZXJ0TWFuYWdlcmAgd2hpY2ggbWFuYWdlcyBhbGwga25vd25cbiAgICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgICAqICAgaW5zdGFuY2UgZXhpc3RzIGZvciBlYWNoIGZvY3VzYWJsZSBub2RlIHdoaWNoIGhhcyBhdCBsZWFzdCBvbmUgaW5lcnQgcm9vdCBhcyBhbiBhbmNlc3Rvci5cbiAgICAgKlxuICAgICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAgICogICBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSByb290IG5vZGUpLiBUaGlzIGlzIGhhbmRsZWQgaW4gdGhlIGRlc3RydWN0b3IsIHdoaWNoIGNhbGxzIHRoZVxuICAgICAqICAgYGRlcmVnaXN0ZXJgIG1ldGhvZCBvbiBgSW5lcnRNYW5hZ2VyYCBmb3IgZWFjaCBtYW5hZ2VkIGluZXJ0IG5vZGUuXG4gICAgICovXG5cbiAgICB2YXIgSW5lcnRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290RWxlbWVudCBUaGUgRWxlbWVudCBhdCB0aGUgcm9vdCBvZiB0aGUgaW5lcnQgc3VidHJlZS5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0Um9vdChyb290RWxlbWVudCwgaW5lcnRNYW5hZ2VyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gaW5lcnRNYW5hZ2VyO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovXG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydE5vZGU+fVxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBmb2N1c2FibGUgbm9kZXMgaW4gdGhpcyBJbmVydFJvb3QncyBzdWJ0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIE1ha2UgdGhlIHN1YnRyZWUgaGlkZGVuIGZyb20gYXNzaXN0aXZlIHRlY2hub2xvZ3lcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSB0aGlzLl9yb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICAvLyBNYWtlIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIHN1YnRyZWUgdW5mb2N1c2FibGUgYW5kIGFkZCB0aGVtIHRvIF9tYW5hZ2VkTm9kZXNcbiAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSh0aGlzLl9yb290RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgICAvLyAtIGFueSBhZGRpdGlvbnMgaW4gdGhlIHN1YnRyZWU6IG1ha2UgdGhlbSB1bmZvY3VzYWJsZSB0b29cbiAgICAgICAgLy8gLSBhbnkgcmVtb3ZhbHMgZnJvbSB0aGUgc3VidHJlZTogcmVtb3ZlIHRoZW0gZnJvbSB0aGlzIGluZXJ0IHJvb3QncyBtYW5hZ2VkIG5vZGVzXG4gICAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgICAvLyAgIGVsZW1lbnQsIG1ha2UgdGhhdCBub2RlIGEgbWFuYWdlZCBub2RlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29uTXV0YXRpb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAgICogc3RvcmVkIGluIHRoaXMgb2JqZWN0IGFuZCB1cGRhdGVzIHRoZSBzdGF0ZSBvZiBhbGwgb2YgdGhlIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBOb3RlIHdlIGNhc3QgdGhlIG51bGxzIHRvIHRoZSBBTlkgdHlwZSBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAgIC8vICAgIG5lZWQgZXZlbiBtb3JlIGNhc3RzIHRocm91Z2hvdXQgdGhpcyBjb2RlLiBBbGwgYmV0cyBhcmUgb2ZmIGlmIGFuXG4gICAgICAgICAgLy8gICAgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkIGFuZCBhIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgICAgLy8gICAgdG8ga25vdyB3aGljaCBwcm9wZXJ0aWVzIHdlJ3JlIHNldHRpbmcuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4geyFTZXQ8IUluZXJ0Tm9kZT59IEEgY29weSBvZiB0aGlzIEluZXJ0Um9vdCdzIG1hbmFnZWQgbm9kZXMgc2V0LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBzdGFydE5vZGUgbWF5IGJlIGluIHNoYWRvdyBET00sIHNvIGZpbmQgaXRzIG5lYXJlc3Qgc2hhZG93Um9vdCB0byBnZXQgdGhlIGFjdGl2ZUVsZW1lbnQuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R9ICovbm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0Tm9kZS5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgICAvLyBjYWxsaW5nIGJsdXIoKSB3aWxsIG5vdCBhY3R1YWxseSBtb3ZlIHRoZSBmb2N1cy5cbiAgICAgICAgICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMgd2UgY2FsbCBmb2N1cygpIG9uIHRoZSBib2R5IGluc3RlYWQuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmlzaXROb2RlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgICAvLyBJZiBhIGRlc2NlbmRhbnQgaW5lcnQgcm9vdCBiZWNvbWVzIHVuLWluZXJ0LCBpdHMgZGVzY2VuZGFudHMgd2lsbCBzdGlsbCBiZSBpbmVydCBiZWNhdXNlIG9mXG4gICAgICAgICAgLy8gdGhpcyBpbmVydCByb290LCBzbyBhbGwgb2YgaXRzIG1hbmFnZWQgbm9kZXMgbmVlZCB0byBiZSBhZG9wdGVkIGJ5IHRoaXMgSW5lcnRSb290LlxuICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QoZWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5yZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdW5tYW5hZ2VOb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXNbJ2RlbGV0ZSddKGluZXJ0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlU3VidHJlZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VTdWJ0cmVlKHN0YXJ0Tm9kZSkge1xuICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLl91bm1hbmFnZU5vZGUobm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2Fkb3B0SW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG5cbiAgICAgICAgICAvLyBEdXJpbmcgaW5pdGlhbGlzYXRpb24gdGhpcyBpbmVydCByb290IG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgeWV0LFxuICAgICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICAgIGlmICghaW5lcnRTdWJyb290KSB7XG4gICAgICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIuc2V0SW5lcnQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0U3Vicm9vdC5tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoc2F2ZWRJbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgc3VidHJlZSBhZGRpdGlvbnMsIHJlbW92YWxzLCBvciBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gcmVjb3Jkc1xuICAgICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk11dGF0aW9uKHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAvLyBVbi1tYW5hZ2UgcmVtb3ZlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5yZW1vdmVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlLWluaXRpYWxpc2UgaW5lcnQgbm9kZSBpZiB0YWJpbmRleCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZSh0YXJnZXQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbmV3IGluZXJ0IHJvb3QgaXMgYWRkZWQsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzIGFuZCBtYWtlIHN1cmUgaXQga25vd3MgYWJvdXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBtYW5hZ2VkIG5vZGVzIGZyb20gdGhpcyBpbmVydCBzdWJyb290LlxuICAgICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRTdWJyb290Ll9tYW5hZ2VOb2RlKG1hbmFnZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5fbWFuYWdlZE5vZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/c3RyaW5nfSBhcmlhSGlkZGVuICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXJpYUhpZGRlbikge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IGFyaWFIaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydFJvb3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Tm9kZWAgaW5pdGlhbGlzZXMgYW5kIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgbm9kZS5cbiAgICAgKiBBIG5vZGUgaXMgaW5lcnQgaWYgaXQgaXMgYSBkZXNjZW5kYW50IG9mIG9uZSBvciBtb3JlIGluZXJ0IHJvb3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBPbiBjb25zdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHNhdmVzIHRoZSBleGlzdGluZyBgdGFiaW5kZXhgIHZhbHVlIGZvciB0aGUgbm9kZSwgaWYgYW55LCBhbmRcbiAgICAgKiBlaXRoZXIgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgb3Igc2V0cyBpdCB0byBgLTFgLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZWxlbWVudFxuICAgICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIGBJbmVydE5vZGVgIG1haW50YWlucyBhIHNldCBvZiBgSW5lcnRSb290YHMgd2hpY2ggYXJlIGRlc2NlbmRhbnRzIG9mIHRoaXMgYEluZXJ0Tm9kZWAuIFdoZW4gYW5cbiAgICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICAgKiBgSW5lcnROb2RlYCB2aWEgYHJlbW92ZUluZXJ0Um9vdCgpYCwgd2hpY2ggaW4gdHVybiBkZXN0cm95cyB0aGUgYEluZXJ0Tm9kZWAgaWYgbm8gYEluZXJ0Um9vdGBzXG4gICAgICogcmVtYWluIGluIHRoZSBzZXQuIE9uIGRlc3RydWN0aW9uLCBgSW5lcnROb2RlYCByZWluc3RhdGVzIHRoZSBzdG9yZWQgYHRhYmluZGV4YCBpZiBvbmUgZXhpc3RzLFxuICAgICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIEEgZm9jdXNhYmxlIGVsZW1lbnQgdG8gYmUgbWFkZSBpbmVydC5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290IFRoZSBpbmVydCByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5lcnQgbm9kZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnROb2RlKTtcblxuICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Um9vdD59IFRoZSBzZXQgb2YgZGVzY2VuZGFudCBpbmVydCByb290cy5cbiAgICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgU2V0KFtpbmVydFJvb3RdKTtcblxuICAgICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2F2ZSBhbnkgcHJpb3IgdGFiaW5kZXggaW5mbyBhbmQgbWFrZSB0aGlzIG5vZGUgdW50YWJiYWJsZVxuICAgICAgICB0aGlzLmVuc3VyZVVudGFiYmFibGUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLlxuICAgICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Tm9kZSwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovdGhpcy5fbm9kZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRoaXMuX3NhdmVkVGFiSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBgZGVsZXRlYCB0byByZXN0b3JlIG5hdGl2ZSBmb2N1cyBtZXRob2QuXG4gICAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudC5mb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZWUgbm90ZSBpbiBJbmVydFJvb3QuZGVzdHJ1Y3RvciBmb3Igd2h5IHdlIGNhc3QgdGhlc2UgbnVsbHMgdG8gQU5ZLlxuICAgICAgICAgIHRoaXMuX25vZGUgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG9iamVjdCBpcyBvYnNvbGV0ZSBiZWNhdXNlIHRoZSBtYW5hZ2VkIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICAgKiBJZiB0aGUgb2JqZWN0IGhhcyBiZWVuIGRlc3Ryb3llZCwgYW55IGF0dGVtcHQgdG8gYWNjZXNzIGl0IHdpbGwgY2F1c2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdGhyb3dJZkRlc3Ryb3llZCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhyb3cgaWYgdXNlciB0cmllcyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBkZXN0cm95ZWQgSW5lcnROb2RlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZW5zdXJlVW50YWJiYWJsZScsXG5cblxuICAgICAgICAvKiogU2F2ZSB0aGUgZXhpc3RpbmcgdGFiaW5kZXggdmFsdWUgYW5kIG1ha2UgdGhlIG5vZGUgdW50YWJiYWJsZSBhbmQgdW5mb2N1c2FibGUgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMubm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL3RoaXMubm9kZTtcbiAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICAgIGlmICggLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleCA9PT0gLTEgJiYgdGhpcy5oYXNTYXZlZFRhYkluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkSW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cy5hZGQoaW5lcnRSb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGluZXJ0IHJvb3QgZnJvbSB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIElmIHRoZSBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydCxcbiAgICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmVJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShpbmVydFJvb3QpO1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXN0cm95ZWQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHshTm9kZX0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdub2RlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzYXZlZFRhYkluZGV4JyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IHRhYkluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4gez9udW1iZXJ9ICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4O1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydE5vZGU7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogSW5lcnRNYW5hZ2VyIGlzIGEgcGVyLWRvY3VtZW50IHNpbmdsZXRvbiBvYmplY3Qgd2hpY2ggbWFuYWdlcyBhbGwgaW5lcnQgcm9vdHMgYW5kIG5vZGVzLlxuICAgICAqXG4gICAgICogV2hlbiBhbiBlbGVtZW50IGJlY29tZXMgYW4gaW5lcnQgcm9vdCBieSBoYXZpbmcgYW4gYGluZXJ0YCBhdHRyaWJ1dGUgc2V0IGFuZC9vciBpdHMgYGluZXJ0YFxuICAgICAqIHByb3BlcnR5IHNldCB0byBgdHJ1ZWAsIHRoZSBgc2V0SW5lcnRgIG1ldGhvZCBjcmVhdGVzIGFuIGBJbmVydFJvb3RgIG9iamVjdCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgICAqIG5vZGVzIHZpYSB0aGUgYHJlZ2lzdGVyKClgIG1ldGhvZC4gVGhlIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYCBpbnN0YW5jZVxuICAgICAqIGlzIGNyZWF0ZWQgZm9yIGVhY2ggc3VjaCBub2RlLCB2aWEgdGhlIGBfbWFuYWdlZE5vZGVzYCBtYXAuXG4gICAgICovXG5cblxuICAgIHZhciBJbmVydE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydE1hbmFnZXIoZG9jdW1lbnQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudDsgSW5lcnRNYW5hZ2VyIG5lZWRzIHRvIHdyYXAgYSBkb2N1bWVudC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAdHlwZSB7IURvY3VtZW50fSAqL1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBub2RlcyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Tm9kZT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Um9vdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnNlcnZlciBmb3IgbXV0YXRpb25zIG9uIGBkb2N1bWVudC5ib2R5YC5cbiAgICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl93YXRjaEZvckluZXJ0LmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgICAgYWRkSW5lcnRTdHlsZShkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcblxuICAgICAgICAvLyBXYWl0IGZvciBkb2N1bWVudCB0byBiZSBsb2FkZWQuXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25Eb2N1bWVudExvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBzaG91bGQgYmUgYW4gaW5lcnQgcm9vdCBvciBub3QuXG4gICAgICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluZXJ0XG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAgICBrZXk6ICdzZXRJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbmVydChyb290LCBpbmVydCkge1xuICAgICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBpbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmVydFJvb3QgPSBuZXcgSW5lcnRSb290KHJvb3QsIHRoaXMpO1xuICAgICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290cy5zZXQocm9vdCwgaW5lcnRSb290KTtcbiAgICAgICAgICAgIC8vIElmIG5vdCBjb250YWluZWQgaW4gdGhlIGRvY3VtZW50LCBpdCBtdXN0IGJlIGluIGEgc2hhZG93Um9vdC5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHJvb3QpKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgYWRkSW5lcnRTdHlsZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgICAgX2luZXJ0Um9vdC5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShyb290KTtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIEluZXJ0Um9vdCBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBlbGVtZW50LCBpZiBhbnkuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmVydFJvb3QoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbmVydFJvb3RzLmdldChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBub2RlLlxuICAgICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgICAqIGJlIGFkZGVkIHRvIGl0cyBzZXQgb2YgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Tm9kZX0gaW5lcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbm9kZSB3YXMgYWxyZWFkeSBpbiBhbiBpbmVydCBzdWJ0cmVlXG4gICAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZXJ0Tm9kZSA9IG5ldyBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuc2V0KG5vZGUsIGluZXJ0Tm9kZSk7XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlLXJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIGluZXJ0IG5vZGUuXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICAgKiBub2RlIGZyb20gdGhlIEluZXJ0TWFuYWdlcidzIHNldCBvZiBtYW5hZ2VkIG5vZGVzIGlmIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICogSWYgdGhlIG5vZGUgaXMgbm90IGN1cnJlbnRseSBtYW5hZ2VkLCB0aGlzIGlzIGVzc2VudGlhbGx5IGEgbm8tb3AuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7P0luZXJ0Tm9kZX0gVGhlIHBvdGVudGlhbGx5IGRlc3Ryb3llZCBJbmVydE5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgaWYgYW55LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXJlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKCFpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0Tm9kZS5yZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9jdW1lbnRMb2FkZWQoKSB7XG4gICAgICAgICAgLy8gRmluZCBhbGwgaW5lcnQgcm9vdHMgaW4gZG9jdW1lbnQgYW5kIG1ha2UgdGhlbSBhY3R1YWxseSBpbmVydC5cbiAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gQ29tbWVudCB0aGlzIG91dCB0byB1c2UgcHJvZ3JhbW1hdGljIEFQSSBvbmx5LlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZG9jdW1lbnQuYm9keSB8fCB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgc3VidHJlZTogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3dhdGNoRm9ySW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhdGNoRm9ySW5lcnQocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgICAgICB2YXIgaW5lcnQgPSB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb24gKCFFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAgICogICAgIGJlZm9yZSBkZXNjZW5kaW5nIGludG8gY2hpbGQgbm9kZXMuXG4gICAgICogQHBhcmFtIHs/U2hhZG93Um9vdD19IHNoYWRvd1Jvb3RBbmNlc3RvciBUaGUgbmVhcmVzdCBTaGFkb3dSb290IGFuY2VzdG9yLCBpZiBhbnkuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNvbXBvc2VkVHJlZVdhbGsobm9kZSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcikge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL25vZGU7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVzY2VuZCBpbnRvIG5vZGU6XG4gICAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgICAvLyB1cCBieSB0aGUgPGNvbnRlbnQ+IG9yIDxzaGFkb3c+IGVsZW1lbnRzLiBEZXNjZW5kIHN0cmFpZ2h0IGludG8gdGhlXG4gICAgICAgIC8vIFNoYWRvd1Jvb3QuXG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc2hhZG93Um9vdCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBkaXN0cmlidXRlZCBlbGVtZW50cyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnY29udGVudCcpIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmaWVzIGlmIFNoYWRvd0RvbSB2MCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIGRpc3RyaWJ1dGVkTm9kZXMgPSBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMgPyBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhkaXN0cmlidXRlZE5vZGVzW2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8c2xvdD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGFzc2lnbmVkIG5vZGVzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdzbG90Jykge1xuICAgICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZ5IGlmIFNoYWRvd0RvbSB2MSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIF9kaXN0cmlidXRlZE5vZGVzID0gc2xvdC5hc3NpZ25lZE5vZGVzID8gc2xvdC5hc3NpZ25lZE5vZGVzKHsgZmxhdHRlbjogdHJ1ZSB9KSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoX2Rpc3RyaWJ1dGVkTm9kZXNbX2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgICAvLyBlbGVtZW50LCBub3IgYSA8c2hhZG93PiBlbGVtZW50IHJlY3Vyc2Ugbm9ybWFsbHkuXG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGNoaWxkLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgICBpZiAobm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZSNpbmVydC1zdHlsZSwgbGluayNpbmVydC1zdHlsZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2luZXJ0LXN0eWxlJyk7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG5cbiAgICBpZiAoIUVsZW1lbnQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdpbmVydCcpKSB7XG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbGVtZW50LnByb3RvdHlwZSwgJ2luZXJ0Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAvKiogQHRoaXMgeyFFbGVtZW50fSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAdGhpcyB7IUVsZW1lbnR9ICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGluZXJ0KSB7XG4gICAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KSgpO1xuXG59KSkpO1xuIiwiaW1wb3J0IFwiYmxvY2tpbmctZWxlbWVudHNcIjtcclxuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgXCJ3aWNnLWluZXJ0XCI7XHJcbmNvbnN0IGJsb2NraW5nRWxlbWVudHMgPSBkb2N1bWVudC4kYmxvY2tpbmdFbGVtZW50cztcclxuLyoqXHJcbiAqIEFsbG93cyBhbiBlbGVtZW50IHRvIHRyYXAgZm9jdXMgYnkgYXBwbHlpbmcgdGhlIFwiaW5lcnRcIiBhdHRyaWJ1dGUgdG8gYWxsIHNpYmxpbmcsIGF1bnQsIGFuZCB1bmNsZSBub2Rlcy5cclxuICpcclxuICogQXV0b21hdGljYWxseSBoYW5kbGVzIGNvbnNlY3V0aXZlIGNhbGxzIHdpdGggYSBsb29zZWx5IGFwcGxpZWQgc3RhY2sgb3BlcmF0aW9uXHJcbiAqIChzcGVjaWZpY2FsbHkgdmlhIGBibG9ja2luZ0VsZW1lbnRzYCwgd2l0aCBhIHNtYWxsIHBvbHlmaWxsIGJlY2F1c2UgSSdtIG5vdCBzdXJlIGhvdyBsb25nXHJcbiAqIGl0J2xsIHRha2UgdG8gZmluZCBpdHMgd2F5IGludG8gdGhlIHNwZWMsIGlmIGV2ZXIpXHJcbiAqIEBwYXJhbSB0YXJnZXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCbG9ja2luZ0VsZW1lbnQodGFyZ2V0KSB7XHJcbiAgICAvKipcclxuICAgICAqIFB1c2gvcG9wIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nRWxlbWVudHMgc3RhY2suXHJcbiAgICAgKi9cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICBibG9ja2luZ0VsZW1lbnRzLnB1c2godGFyZ2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGJsb2NraW5nRWxlbWVudHMucmVtb3ZlKHRhcmdldCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3RhcmdldF0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BFbGVtZW50KCkge1xyXG4gICAgcmV0dXJuIGJsb2NraW5nRWxlbWVudHMudG9wO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1ibG9ja2luZy1lbGVtZW50LmpzLm1hcCIsImltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgaXNGb2N1c2FibGUgfSBmcm9tIFwidGFiYmFibGVcIjtcclxuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCB9IGZyb20gXCIuL3VzZS1hY3RpdmUtZWxlbWVudFwiO1xyXG5pbXBvcnQgeyBnZXRUb3BFbGVtZW50LCB1c2VCbG9ja2luZ0VsZW1lbnQgfSBmcm9tIFwiLi91c2UtYmxvY2tpbmctZWxlbWVudFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5jb25zdCBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8gPSBuZXcgTWFwKCk7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VGb2N1c1RyYXAoeyB0cmFwQWN0aXZlIH0pIHtcclxuICAgIGNvbnN0IHsgZWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICBjb25zdCB7IGdldExhc3RBY3RpdmVFbGVtZW50IH0gPSB1c2VBY3RpdmVFbGVtZW50KCk7XHJcbiAgICAvLyBXaGVuIHRoZSB0cmFwIGJlY29tZXMgYWN0aXZlLCBiZWZvcmUgd2UgbGV0IHRoZSBibG9ja2luZ0VsZW1lbnRzIGhvb2sgcnVuLFxyXG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGF0ZXZlcidzIGN1cnJlbnRseSBmb2N1c2VkIGFuZCBzYXZlIGl0LlxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAodHJhcEFjdGl2ZSAmJiBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcclxuICAgICAgICAgICAgLy8gdG8gd2hhdGV2ZXIncyBjdXJyZW50bHkgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcclxuICAgICAgICAgICAgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvLnNldChnZXRUb3BFbGVtZW50KCksIGdldExhc3RBY3RpdmVFbGVtZW50KCkgPz8gZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3RyYXBBY3RpdmUsIGVsZW1lbnRdKTtcclxuICAgIHVzZUJsb2NraW5nRWxlbWVudCh0cmFwQWN0aXZlID8gZWxlbWVudCA6IG51bGwpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbnkgdGltZSB3ZSBhY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHRoZSB0cmFwLFxyXG4gICAgICogY2hhbmdlIGZvY3VzIHRvIHNvbWV0aGluZyBlbHNlIChzb21ldGhpbmcgaW5cclxuICAgICAqIHRoZSB0cmFwIGlmIGl0J3MgYWN0aXZlLCBvciB3aGF0ZXZlciB3ZSd2ZVxyXG4gICAgICogdHJhY2tlZCBpbiBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8gaWYgbm90KVxyXG4gICAgICovXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICh0cmFwQWN0aXZlICYmIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgbGV0IHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGV4dHJhIHF1ZXVlTWljcm90YXNrIGlzIG5lZWRlZCBmb3JcclxuICAgICAgICAgICAgICAgIC8vIC4uLnJlYXNvbnM/XHJcbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluZEZpcnN0Rm9jdXNhYmxlKGVsZW1lbnQpPy5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZkhhbmRsZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgZm9jdXMgdG8gdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgLy8gdGhhdCBoYXMgcmV0dXJuZWQgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcclxuICAgICAgICAgICAgbGV0IHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvLmdldChnZXRUb3BFbGVtZW50KCkpPy5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZkhhbmRsZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3RyYXBBY3RpdmUsIGVsZW1lbnRdKTtcclxuICAgIGNvbnN0IHVzZUZvY3VzVHJhcFByb3BzID0gKChwcm9wcykgPT4ge1xyXG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHsgXCJhcmlhLW1vZGFsXCI6IHRyYXBBY3RpdmUgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9LCB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VGb2N1c1RyYXBQcm9wcyxcclxuICAgICAgICBlbGVtZW50LFxyXG4gICAgICAgIGdldEVsZW1lbnRcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IGNvbnRhaW5lZCB3aXRoaW4gdGhlIGdpdmVuIG5vZGUsIG9yIG51bGwgaWYgbm9uZSBhcmUgZm91bmQuXHJcbiAqIEBwYXJhbSBlbGVtZW50XHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0Rm9jdXNhYmxlKGVsZW1lbnQpIHtcclxuICAgIGNvbnN0IHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsZW1lbnQsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7IGFjY2VwdE5vZGU6IChub2RlKSA9PiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgaXNGb2N1c2FibGUobm9kZSkgPyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQKSB9KTtcclxuICAgIGNvbnN0IGZpcnN0Rm9jdXNhYmxlID0gdHJlZVdhbGtlci5maXJzdENoaWxkKCk7XHJcbiAgICByZXR1cm4gZmlyc3RGb2N1c2FibGU7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWZvY3VzLXRyYXAuanMubWFwIiwiaW1wb3J0IHsgdXNlSGFzRm9jdXMsIHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgdXNlU3RhdGUsIHVzZVRpbWVvdXQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYVRvb2x0aXAoeyBtb3VzZW92ZXJEZWxheSB9KSB7XHJcbiAgICBtb3VzZW92ZXJEZWxheSA/Pz0gNDAwO1xyXG4gICAgY29uc3QgW29wZW4sIHNldE9wZW4sIGdldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2hhc0FueU1vdXNlb3Zlciwgc2V0SGFzQW55TW91c2VvdmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIC8vY29uc3QgW21vdXNlb3ZlcklzVmFsaWQsIHNldE1vdXNlb3ZlcklzVmFsaWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VUb29sdGlwSWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVRvb2x0aXBJZFJlZmVyZW5jaW5nUHJvcHMgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtdG9vbHRpcC1cIiB9KTtcclxuICAgIGNvbnN0IHsgZm9jdXNlZElubmVyOiB0cmlnZ2VyRm9jdXNlZCwgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXMoKTtcclxuICAgIGNvbnN0IFt0cmlnZ2VySGFzTW91c2VvdmVyLCBzZXRUcmlnZ2VySGFzTW91c2VvdmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFt0b29sdGlwSGFzTW91c2VvdmVyLCBzZXRUb29sdGlwSGFzTW91c2VvdmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIHVzZVRpbWVvdXQoe1xyXG4gICAgICAgIHRpbWVvdXQ6IG1vdXNlb3ZlckRlbGF5LFxyXG4gICAgICAgIHRyaWdnZXJJbmRleDogKCt0cmlnZ2VySGFzTW91c2VvdmVyICsgK3Rvb2x0aXBIYXNNb3VzZW92ZXIpLFxyXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0cmlnZ2VySGFzTW91c2VvdmVyIHx8IHRvb2x0aXBIYXNNb3VzZW92ZXIpXHJcbiAgICAgICAgICAgICAgICBzZXRIYXNBbnlNb3VzZW92ZXIodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB1c2VUaW1lb3V0KHtcclxuICAgICAgICB0aW1lb3V0OiA1MCxcclxuICAgICAgICB0cmlnZ2VySW5kZXg6ICgrdHJpZ2dlckhhc01vdXNlb3ZlciArICt0b29sdGlwSGFzTW91c2VvdmVyKSxcclxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRyaWdnZXJIYXNNb3VzZW92ZXIgJiYgIXRvb2x0aXBIYXNNb3VzZW92ZXIpXHJcbiAgICAgICAgICAgICAgICBzZXRIYXNBbnlNb3VzZW92ZXIoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRPcGVuKGhhc0FueU1vdXNlb3ZlciB8fCB0cmlnZ2VyRm9jdXNlZCk7XHJcbiAgICB9LCBbaGFzQW55TW91c2VvdmVyLCB0cmlnZ2VyRm9jdXNlZF0pO1xyXG4gICAgY29uc3QgdXNlVG9vbHRpcFRyaWdnZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VUb29sdGlwVHJpZ2dlcigpIHtcclxuICAgICAgICBmdW5jdGlvbiBvblBvaW50ZXJFbnRlcihlKSB7XHJcbiAgICAgICAgICAgIHNldFRyaWdnZXJIYXNNb3VzZW92ZXIodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIG9uUG9pbnRlckxlYXZlKGUpIHtcclxuICAgICAgICAgICAgc2V0VHJpZ2dlckhhc01vdXNlb3ZlcihmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMoeyAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgIC8vIE5vdGU6IFRob3VnaCBpdCdzIGltcG9ydGFudCB0byBtYWtlIHN1cmUgdGhhdCBmb2N1c2luZyBhY3RpdmF0ZXMgYSB0b29sdGlwLFxyXG4gICAgICAgICAgICAvLyBpdCdzIHBlcmZlY3RseSByZWFzb25hYmxlIHRoYXQgYSBjaGlsZCBlbGVtZW50IHdpbGwgYmUgdGhlIG9uZSB0aGF0J3MgZm9jdXNlZCxcclxuICAgICAgICAgICAgLy8gbm90IHRoaXMgb25lLCBzbyB3ZSBkb24ndCBzZXQgdGFiSW5kZXg9MFxyXG4gICAgICAgICAgICByZXR1cm4gdXNlVG9vbHRpcElkUmVmZXJlbmNpbmdQcm9wcyhcImFyaWEtZGVzY3JpYmVkYnlcIikodXNlTWVyZ2VkUHJvcHMoKSh7IG9uUG9pbnRlckVudGVyLCBvblBvaW50ZXJMZWF2ZSB9LCB1c2VIYXNGb2N1c1Byb3BzKHByb3BzKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1c2VUb29sdGlwVHJpZ2dlclByb3BzIH07XHJcbiAgICB9LCBbdXNlVG9vbHRpcElkUmVmZXJlbmNpbmdQcm9wc10pO1xyXG4gICAgY29uc3QgdXNlVG9vbHRpcCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVRvb2x0aXAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gb25Qb2ludGVyRW50ZXIoZSkge1xyXG4gICAgICAgICAgICBzZXRUb29sdGlwSGFzTW91c2VvdmVyKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvblBvaW50ZXJMZWF2ZShlKSB7XHJcbiAgICAgICAgICAgIHNldFRvb2x0aXBIYXNNb3VzZW92ZXIoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiB1c2VUb29sdGlwUHJvcHMoeyAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcInRvb2x0aXBcIjtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZVRvb2x0aXBJZFByb3BzKHVzZU1lcmdlZFByb3BzKCkoeyBvblBvaW50ZXJFbnRlciwgb25Qb2ludGVyTGVhdmUgfSwgcHJvcHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlVG9vbHRpcFByb3BzIH07XHJcbiAgICB9LCBbdXNlVG9vbHRpcElkUHJvcHNdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlVG9vbHRpcCxcclxuICAgICAgICB1c2VUb29sdGlwVHJpZ2dlcixcclxuICAgICAgICBpc09wZW46IG9wZW4sXHJcbiAgICAgICAgZ2V0SXNPcGVuOiBnZXRPcGVuXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS10b29sdGlwLmpzLm1hcCIsImltcG9ydHt1c2VTdGF0ZSBhcyBuLHVzZVJlZHVjZXIgYXMgdCx1c2VFZmZlY3QgYXMgZSx1c2VMYXlvdXRFZmZlY3QgYXMgcix1c2VSZWYgYXMgdSx1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIG8sdXNlTWVtbyBhcyBpLHVzZUNhbGxiYWNrIGFzIGwsdXNlQ29udGV4dCBhcyBmLHVzZURlYnVnVmFsdWUgYXMgY31mcm9tXCJwcmVhY3QvaG9va3NcIjtleHBvcnQqZnJvbVwicHJlYWN0L2hvb2tzXCI7aW1wb3J0e0NvbXBvbmVudCBhcyBhLGNyZWF0ZUVsZW1lbnQgYXMgcyxvcHRpb25zIGFzIGgsdG9DaGlsZEFycmF5IGFzIHYsRnJhZ21lbnQgYXMgZCxyZW5kZXIgYXMgcCxoeWRyYXRlIGFzIG0sY2xvbmVFbGVtZW50IGFzIHksY3JlYXRlUmVmIGFzIGIsY3JlYXRlQ29udGV4dCBhcyBffWZyb21cInByZWFjdFwiO2V4cG9ydHtjcmVhdGVFbGVtZW50LGNyZWF0ZUNvbnRleHQsY3JlYXRlUmVmLEZyYWdtZW50LENvbXBvbmVudH1mcm9tXCJwcmVhY3RcIjtmdW5jdGlvbiBTKG4sdCl7Zm9yKHZhciBlIGluIHQpbltlXT10W2VdO3JldHVybiBufWZ1bmN0aW9uIEMobix0KXtmb3IodmFyIGUgaW4gbilpZihcIl9fc291cmNlXCIhPT1lJiYhKGUgaW4gdCkpcmV0dXJuITA7Zm9yKHZhciByIGluIHQpaWYoXCJfX3NvdXJjZVwiIT09ciYmbltyXSE9PXRbcl0pcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gRShuKXt0aGlzLnByb3BzPW59ZnVuY3Rpb24gZyhuLHQpe2Z1bmN0aW9uIGUobil7dmFyIGU9dGhpcy5wcm9wcy5yZWYscj1lPT1uLnJlZjtyZXR1cm4hciYmZSYmKGUuY2FsbD9lKG51bGwpOmUuY3VycmVudD1udWxsKSx0PyF0KHRoaXMucHJvcHMsbil8fCFyOkModGhpcy5wcm9wcyxuKX1mdW5jdGlvbiByKHQpe3JldHVybiB0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZT1lLHMobix0KX1yZXR1cm4gci5kaXNwbGF5TmFtZT1cIk1lbW8oXCIrKG4uZGlzcGxheU5hbWV8fG4ubmFtZSkrXCIpXCIsci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD0hMCxyLl9fZj0hMCxyfShFLnByb3RvdHlwZT1uZXcgYSkuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITAsRS5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIEModGhpcy5wcm9wcyxuKXx8Qyh0aGlzLnN0YXRlLHQpfTt2YXIgdz1oLl9fYjtoLl9fYj1mdW5jdGlvbihuKXtuLnR5cGUmJm4udHlwZS5fX2YmJm4ucmVmJiYobi5wcm9wcy5yZWY9bi5yZWYsbi5yZWY9bnVsbCksdyYmdyhuKX07dmFyIFI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvciYmU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpfHwzOTExO2Z1bmN0aW9uIHgobil7ZnVuY3Rpb24gdCh0LGUpe3ZhciByPVMoe30sdCk7cmV0dXJuIGRlbGV0ZSByLnJlZixuKHIsKGU9dC5yZWZ8fGUpJiYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fFwiY3VycmVudFwiaW4gZSk/ZTpudWxsKX1yZXR1cm4gdC4kJHR5cGVvZj1SLHQucmVuZGVyPXQsdC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD10Ll9fZj0hMCx0LmRpc3BsYXlOYW1lPVwiRm9yd2FyZFJlZihcIisobi5kaXNwbGF5TmFtZXx8bi5uYW1lKStcIilcIix0fXZhciBOPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG51bGw9PW4/bnVsbDp2KHYobikubWFwKHQpKX0saz17bWFwOk4sZm9yRWFjaDpOLGNvdW50OmZ1bmN0aW9uKG4pe3JldHVybiBuP3YobikubGVuZ3RoOjB9LG9ubHk6ZnVuY3Rpb24obil7dmFyIHQ9dihuKTtpZigxIT09dC5sZW5ndGgpdGhyb3dcIkNoaWxkcmVuLm9ubHlcIjtyZXR1cm4gdFswXX0sdG9BcnJheTp2fSxBPWguX19lO2guX19lPWZ1bmN0aW9uKG4sdCxlKXtpZihuLnRoZW4pZm9yKHZhciByLHU9dDt1PXUuX187KWlmKChyPXUuX19jKSYmci5fX2MpcmV0dXJuIG51bGw9PXQuX19lJiYodC5fX2U9ZS5fX2UsdC5fX2s9ZS5fX2spLHIuX19jKG4sdCk7QShuLHQsZSl9O3ZhciBPPWgudW5tb3VudDtmdW5jdGlvbiBMKCl7dGhpcy5fX3U9MCx0aGlzLnQ9bnVsbCx0aGlzLl9fYj1udWxsfWZ1bmN0aW9uIFUobil7dmFyIHQ9bi5fXy5fX2M7cmV0dXJuIHQmJnQuX19lJiZ0Ll9fZShuKX1mdW5jdGlvbiBGKG4pe3ZhciB0LGUscjtmdW5jdGlvbiB1KHUpe2lmKHR8fCh0PW4oKSkudGhlbihmdW5jdGlvbihuKXtlPW4uZGVmYXVsdHx8bn0sZnVuY3Rpb24obil7cj1ufSkscil0aHJvdyByO2lmKCFlKXRocm93IHQ7cmV0dXJuIHMoZSx1KX1yZXR1cm4gdS5kaXNwbGF5TmFtZT1cIkxhenlcIix1Ll9fZj0hMCx1fWZ1bmN0aW9uIE0oKXt0aGlzLnU9bnVsbCx0aGlzLm89bnVsbH1oLnVubW91bnQ9ZnVuY3Rpb24obil7dmFyIHQ9bi5fX2M7dCYmdC5fX1ImJnQuX19SKCksdCYmITA9PT1uLl9faCYmKG4udHlwZT1udWxsKSxPJiZPKG4pfSwoTC5wcm90b3R5cGU9bmV3IGEpLl9fYz1mdW5jdGlvbihuLHQpe3ZhciBlPXQuX19jLHI9dGhpcztudWxsPT1yLnQmJihyLnQ9W10pLHIudC5wdXNoKGUpO3ZhciB1PVUoci5fX3YpLG89ITEsaT1mdW5jdGlvbigpe298fChvPSEwLGUuX19SPW51bGwsdT91KGwpOmwoKSl9O2UuX19SPWk7dmFyIGw9ZnVuY3Rpb24oKXtpZighLS1yLl9fdSl7aWYoci5zdGF0ZS5fX2Upe3ZhciBuPXIuc3RhdGUuX19lO3IuX192Ll9fa1swXT1mdW5jdGlvbiBuKHQsZSxyKXtyZXR1cm4gdCYmKHQuX192PW51bGwsdC5fX2s9dC5fX2smJnQuX19rLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbih0LGUscil9KSx0Ll9fYyYmdC5fX2MuX19QPT09ZSYmKHQuX19lJiZyLmluc2VydEJlZm9yZSh0Ll9fZSx0Ll9fZCksdC5fX2MuX19lPSEwLHQuX19jLl9fUD1yKSksdH0obixuLl9fYy5fX1Asbi5fX2MuX19PKX12YXIgdDtmb3Ioci5zZXRTdGF0ZSh7X19lOnIuX19iPW51bGx9KTt0PXIudC5wb3AoKTspdC5mb3JjZVVwZGF0ZSgpfX0sZj0hMD09PXQuX19oO3IuX191Kyt8fGZ8fHIuc2V0U3RhdGUoe19fZTpyLl9fYj1yLl9fdi5fX2tbMF19KSxuLnRoZW4oaSxpKX0sTC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXt0aGlzLnQ9W119LEwucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihuLHQpe2lmKHRoaXMuX19iKXtpZih0aGlzLl9fdi5fX2spe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikscj10aGlzLl9fdi5fX2tbMF0uX19jO3RoaXMuX192Ll9fa1swXT1mdW5jdGlvbiBuKHQsZSxyKXtyZXR1cm4gdCYmKHQuX19jJiZ0Ll9fYy5fX0gmJih0Ll9fYy5fX0guX18uZm9yRWFjaChmdW5jdGlvbihuKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLl9fYyYmbi5fX2MoKX0pLHQuX19jLl9fSD1udWxsKSxudWxsIT0odD1TKHt9LHQpKS5fX2MmJih0Ll9fYy5fX1A9PT1yJiYodC5fX2MuX19QPWUpLHQuX19jPW51bGwpLHQuX19rPXQuX19rJiZ0Ll9fay5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG4odCxlLHIpfSkpLHR9KHRoaXMuX19iLGUsci5fX089ci5fX1ApfXRoaXMuX19iPW51bGx9dmFyIHU9dC5fX2UmJnMoZCxudWxsLG4uZmFsbGJhY2spO3JldHVybiB1JiYodS5fX2g9bnVsbCksW3MoZCxudWxsLHQuX19lP251bGw6bi5jaGlsZHJlbiksdV19O3ZhciBUPWZ1bmN0aW9uKG4sdCxlKXtpZigrK2VbMV09PT1lWzBdJiZuLm8uZGVsZXRlKHQpLG4ucHJvcHMucmV2ZWFsT3JkZXImJihcInRcIiE9PW4ucHJvcHMucmV2ZWFsT3JkZXJbMF18fCFuLm8uc2l6ZSkpZm9yKGU9bi51O2U7KXtmb3IoO2UubGVuZ3RoPjM7KWUucG9wKCkoKTtpZihlWzFdPGVbMF0pYnJlYWs7bi51PWU9ZVsyXX19O2Z1bmN0aW9uIEQobil7cmV0dXJuIHRoaXMuZ2V0Q2hpbGRDb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIG4uY29udGV4dH0sbi5jaGlsZHJlbn1mdW5jdGlvbiBJKG4pe3ZhciB0PXRoaXMsZT1uLmk7dC5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3AobnVsbCx0LmwpLHQubD1udWxsLHQuaT1udWxsfSx0LmkmJnQuaSE9PWUmJnQuY29tcG9uZW50V2lsbFVubW91bnQoKSxuLl9fdj8odC5sfHwodC5pPWUsdC5sPXtub2RlVHlwZToxLHBhcmVudE5vZGU6ZSxjaGlsZE5vZGVzOltdLGFwcGVuZENoaWxkOmZ1bmN0aW9uKG4pe3RoaXMuY2hpbGROb2Rlcy5wdXNoKG4pLHQuaS5hcHBlbmRDaGlsZChuKX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKG4sZSl7dGhpcy5jaGlsZE5vZGVzLnB1c2gobiksdC5pLmFwcGVuZENoaWxkKG4pfSxyZW1vdmVDaGlsZDpmdW5jdGlvbihuKXt0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKG4pPj4+MSwxKSx0LmkucmVtb3ZlQ2hpbGQobil9fSkscChzKEQse2NvbnRleHQ6dC5jb250ZXh0fSxuLl9fdiksdC5sKSk6dC5sJiZ0LmNvbXBvbmVudFdpbGxVbm1vdW50KCl9ZnVuY3Rpb24gVyhuLHQpe3JldHVybiBzKEkse19fdjpuLGk6dH0pfShNLnByb3RvdHlwZT1uZXcgYSkuX19lPWZ1bmN0aW9uKG4pe3ZhciB0PXRoaXMsZT1VKHQuX192KSxyPXQuby5nZXQobik7cmV0dXJuIHJbMF0rKyxmdW5jdGlvbih1KXt2YXIgbz1mdW5jdGlvbigpe3QucHJvcHMucmV2ZWFsT3JkZXI/KHIucHVzaCh1KSxUKHQsbixyKSk6dSgpfTtlP2Uobyk6bygpfX0sTS5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKG4pe3RoaXMudT1udWxsLHRoaXMubz1uZXcgTWFwO3ZhciB0PXYobi5jaGlsZHJlbik7bi5yZXZlYWxPcmRlciYmXCJiXCI9PT1uLnJldmVhbE9yZGVyWzBdJiZ0LnJldmVyc2UoKTtmb3IodmFyIGU9dC5sZW5ndGg7ZS0tOyl0aGlzLm8uc2V0KHRbZV0sdGhpcy51PVsxLDAsdGhpcy51XSk7cmV0dXJuIG4uY2hpbGRyZW59LE0ucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZT1NLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudD1mdW5jdGlvbigpe3ZhciBuPXRoaXM7dGhpcy5vLmZvckVhY2goZnVuY3Rpb24odCxlKXtUKG4sZSx0KX0pfTt2YXIgaj1cInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yJiZTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKXx8NjAxMDMsUD0vXig/OmFjY2VudHxhbGlnbm1lbnR8YXJhYmljfGJhc2VsaW5lfGNhcHxjbGlwKD8hUGF0aFUpfGNvbG9yfGZpbGx8Zmxvb2R8Zm9udHxnbHlwaCg/IVIpfGhvcml6fG1hcmtlcig/IUh8V3xVKXxvdmVybGluZXxwYWludHxzdG9wfHN0cmlrZXRocm91Z2h8c3Ryb2tlfHRleHQoPyFMKXx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KD8hQykpW0EtWl0vLFY9ZnVuY3Rpb24obil7cmV0dXJuKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2woKT8vZmlsfGNoZXxyYWQvaTovZmlsfGNoZXxyYS9pKS50ZXN0KG4pfTtmdW5jdGlvbiB6KG4sdCxlKXtyZXR1cm4gbnVsbD09dC5fX2smJih0LnRleHRDb250ZW50PVwiXCIpLHAobix0KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlKCksbj9uLl9fYzpudWxsfWZ1bmN0aW9uIEIobix0LGUpe3JldHVybiBtKG4sdCksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZSgpLG4/bi5fX2M6bnVsbH1hLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9LFtcImNvbXBvbmVudFdpbGxNb3VudFwiLFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiLFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLnByb3RvdHlwZSxuLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbXCJVTlNBRkVfXCIrbl19LHNldDpmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxuLHtjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pfX0pfSk7dmFyIEg9aC5ldmVudDtmdW5jdGlvbiBaKCl7fWZ1bmN0aW9uIFkoKXtyZXR1cm4gdGhpcy5jYW5jZWxCdWJibGV9ZnVuY3Rpb24gJCgpe3JldHVybiB0aGlzLmRlZmF1bHRQcmV2ZW50ZWR9aC5ldmVudD1mdW5jdGlvbihuKXtyZXR1cm4gSCYmKG49SChuKSksbi5wZXJzaXN0PVosbi5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1ZLG4uaXNEZWZhdWx0UHJldmVudGVkPSQsbi5uYXRpdmVFdmVudD1ufTt2YXIgcSxHPXtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xhc3N9fSxKPWgudm5vZGU7aC52bm9kZT1mdW5jdGlvbihuKXt2YXIgdD1uLnR5cGUsZT1uLnByb3BzLHI9ZTtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7Zm9yKHZhciB1IGluIHI9e30sZSl7dmFyIG89ZVt1XTtcInZhbHVlXCI9PT11JiZcImRlZmF1bHRWYWx1ZVwiaW4gZSYmbnVsbD09b3x8KFwiZGVmYXVsdFZhbHVlXCI9PT11JiZcInZhbHVlXCJpbiBlJiZudWxsPT1lLnZhbHVlP3U9XCJ2YWx1ZVwiOlwiZG93bmxvYWRcIj09PXUmJiEwPT09bz9vPVwiXCI6L29uZG91YmxlY2xpY2svaS50ZXN0KHUpP3U9XCJvbmRibGNsaWNrXCI6L15vbmNoYW5nZSh0ZXh0YXJlYXxpbnB1dCkvaS50ZXN0KHUrdCkmJiFWKGUudHlwZSk/dT1cIm9uaW5wdXRcIjovXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucCkvLnRlc3QodSk/dT11LnRvTG93ZXJDYXNlKCk6UC50ZXN0KHUpP3U9dS5yZXBsYWNlKC9bQS1aMC05XS8sXCItJCZcIikudG9Mb3dlckNhc2UoKTpudWxsPT09byYmKG89dm9pZCAwKSxyW3VdPW8pfVwic2VsZWN0XCI9PXQmJnIubXVsdGlwbGUmJkFycmF5LmlzQXJyYXkoci52YWx1ZSkmJihyLnZhbHVlPXYoZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbihuKXtuLnByb3BzLnNlbGVjdGVkPS0xIT1yLnZhbHVlLmluZGV4T2Yobi5wcm9wcy52YWx1ZSl9KSksXCJzZWxlY3RcIj09dCYmbnVsbCE9ci5kZWZhdWx0VmFsdWUmJihyLnZhbHVlPXYoZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbihuKXtuLnByb3BzLnNlbGVjdGVkPXIubXVsdGlwbGU/LTEhPXIuZGVmYXVsdFZhbHVlLmluZGV4T2Yobi5wcm9wcy52YWx1ZSk6ci5kZWZhdWx0VmFsdWU9PW4ucHJvcHMudmFsdWV9KSksbi5wcm9wcz1yfXQmJmUuY2xhc3MhPWUuY2xhc3NOYW1lJiYoRy5lbnVtZXJhYmxlPVwiY2xhc3NOYW1lXCJpbiBlLG51bGwhPWUuY2xhc3NOYW1lJiYoci5jbGFzcz1lLmNsYXNzTmFtZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJjbGFzc05hbWVcIixHKSksbi4kJHR5cGVvZj1qLEomJkoobil9O3ZhciBLPWguX19yO2guX19yPWZ1bmN0aW9uKG4pe0smJksobikscT1uLl9fY307dmFyIFE9e1JlYWN0Q3VycmVudERpc3BhdGNoZXI6e2N1cnJlbnQ6e3JlYWRDb250ZXh0OmZ1bmN0aW9uKG4pe3JldHVybiBxLl9fbltuLl9fY10ucHJvcHMudmFsdWV9fX19LFg9XCIxNy4wLjJcIjtmdW5jdGlvbiBubihuKXtyZXR1cm4gcy5iaW5kKG51bGwsbil9ZnVuY3Rpb24gdG4obil7cmV0dXJuISFuJiZuLiQkdHlwZW9mPT09an1mdW5jdGlvbiBlbihuKXtyZXR1cm4gdG4obik/eS5hcHBseShudWxsLGFyZ3VtZW50cyk6bn1mdW5jdGlvbiBybihuKXtyZXR1cm4hIW4uX19rJiYocChudWxsLG4pLCEwKX1mdW5jdGlvbiB1bihuKXtyZXR1cm4gbiYmKG4uYmFzZXx8MT09PW4ubm9kZVR5cGUmJm4pfHxudWxsfXZhciBvbj1mdW5jdGlvbihuLHQpe3JldHVybiBuKHQpfSxsbj1mdW5jdGlvbihuLHQpe3JldHVybiBuKHQpfSxmbj1kO2V4cG9ydCBkZWZhdWx0e3VzZVN0YXRlOm4sdXNlUmVkdWNlcjp0LHVzZUVmZmVjdDplLHVzZUxheW91dEVmZmVjdDpyLHVzZVJlZjp1LHVzZUltcGVyYXRpdmVIYW5kbGU6byx1c2VNZW1vOmksdXNlQ2FsbGJhY2s6bCx1c2VDb250ZXh0OmYsdXNlRGVidWdWYWx1ZTpjLHZlcnNpb246XCIxNy4wLjJcIixDaGlsZHJlbjprLHJlbmRlcjp6LGh5ZHJhdGU6Qix1bm1vdW50Q29tcG9uZW50QXROb2RlOnJuLGNyZWF0ZVBvcnRhbDpXLGNyZWF0ZUVsZW1lbnQ6cyxjcmVhdGVDb250ZXh0Ol8sY3JlYXRlRmFjdG9yeTpubixjbG9uZUVsZW1lbnQ6ZW4sY3JlYXRlUmVmOmIsRnJhZ21lbnQ6ZCxpc1ZhbGlkRWxlbWVudDp0bixmaW5kRE9NTm9kZTp1bixDb21wb25lbnQ6YSxQdXJlQ29tcG9uZW50OkUsbWVtbzpnLGZvcndhcmRSZWY6eCxmbHVzaFN5bmM6bG4sdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6b24sU3RyaWN0TW9kZTpkLFN1c3BlbnNlOkwsU3VzcGVuc2VMaXN0Ok0sbGF6eTpGLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOlF9O2V4cG9ydHtYIGFzIHZlcnNpb24sayBhcyBDaGlsZHJlbix6IGFzIHJlbmRlcixCIGFzIGh5ZHJhdGUscm4gYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSxXIGFzIGNyZWF0ZVBvcnRhbCxubiBhcyBjcmVhdGVGYWN0b3J5LGVuIGFzIGNsb25lRWxlbWVudCx0biBhcyBpc1ZhbGlkRWxlbWVudCx1biBhcyBmaW5kRE9NTm9kZSxFIGFzIFB1cmVDb21wb25lbnQsZyBhcyBtZW1vLHggYXMgZm9yd2FyZFJlZixsbiBhcyBmbHVzaFN5bmMsb24gYXMgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsZm4gYXMgU3RyaWN0TW9kZSxMIGFzIFN1c3BlbnNlLE0gYXMgU3VzcGVuc2VMaXN0LEYgYXMgbGF6eSxRIGFzIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhdC5tb2R1bGUuanMubWFwXG4iLCJpbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuLyoqXHJcbiAqIFNob3J0Y3V0IGZvciBwcmVhY3QvY29tcGF0J3MgYGZvcndhcmRSZWZgIHRoYXQgYXV0by1hc3N1bWVzIHNvbWUgdGhpbmdzIHRoYXQgYXJlIHVzZWZ1bCBmb3IgZm9yd2FyZGluZyByZWZzIHRvIGBIVE1MRWxlbWVudHNgIHNwZWNpZmljYWxseS5cclxuICogTmFtZWx5IGl0IGludm9sdmVzIGRlLWd1bmtpbmcgdGhlIHR5cGUgc3lzdGVtIGJ5IGxldHRpbmcgdXMgcmV0dXJuICpnZW5lcmljKiBmdW5jdGlvbiBhbmQgcGxheWluZyBuaWNlIHdpdGggUmVhY3QuIEluIGFsbCBvdGhlciByZXNwZWN0cywgaXQgYWN0cyBsaWtlIGBmb3J3YXJkUmVmYC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkRWxlbWVudFJlZihDb21wb25lbnQpIHtcclxuICAgIGNvbnN0IEZvcndhcmRlZENvbXBvbmVudCA9IGZvcndhcmRSZWYoQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBGb3J3YXJkZWRDb21wb25lbnQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9yd2FyZC1lbGVtZW50LXJlZi5qcy5tYXAiLCJpbXBvcnQgeyBkZWZhdWx0IGFzIGNsc3ggfSBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBjbG9uZUVsZW1lbnQgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUxvZ2ljYWxEaXJlY3Rpb24gfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbG9naWNhbC1kaXJlY3Rpb25cIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbi8vaW1wb3J0IHsgbWVyZ2VTdHlsZXMgfSBmcm9tIFwiLi9tZXJnZS1zdHlsZVwiO1xyXG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXJlZi1lbGVtZW50XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vZm9yd2FyZC1lbGVtZW50LXJlZlwiO1xyXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUoY2xhc3NCYXNlLCBvcGVuLCBwaGFzZSkge1xyXG4gICAgaWYgKHBoYXNlKVxyXG4gICAgICAgIHJldHVybiBgJHtjbGFzc0Jhc2UgfHwgXCJ0cmFuc2l0aW9uXCJ9LSR7b3Blbn0tJHtwaGFzZX1gO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBgJHtjbGFzc0Jhc2UgfHwgXCJ0cmFuc2l0aW9uXCJ9LSR7b3Blbn1gO1xyXG59XHJcbmxldCBkdW1teTtcclxuZnVuY3Rpb24gZm9yY2VSZWZsb3coZSkge1xyXG4gICAgLy8gVHJ5IHJlYWxseSBoYXJkIHRvIG1ha2Ugc3VyZSB0aGlzIGlzbid0IG9wdGltaXplZCBvdXQgYnkgYW55dGhpbmcuXHJcbiAgICAvLyBXZSBuZWVkIGl0IGZvciBpdHMgZG9jdW1lbnQgcmVmbG93IHNpZGUgZWZmZWN0LlxyXG4gICAgZHVtbXkgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgcmV0dXJuIGU7XHJcbn1cclxuLyoqXHJcbiAqIEEgaG9vayB0aGF0IGFkZHMgJiByZW1vdmVzIGNsYXNzIG5hbWVzIGluIGEgd2F5IHRoYXQgZmFjaWxpdGF0ZXMgcHJvcGVyIHRyYW5zaXRpb25zLlxyXG4gKlxyXG4gKiBUaGUgZmlyc3QgYXJndW1lbnQgY29udGFpbnMgdGhlIHByb3BzIHJlbGF0ZWQgZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24uXHJcbiAqXHJcbiAqIFRoZSBzZWNvbmQgYXJndW1lbnQgY29udGFpbnMgYW55IG90aGVyIHByb3BzIHlvdSBtaWdodCB3YW50IG1lcmdlZCBpbnRvIHRoZSBmaW5hbCBwcm9kdWN0ICh0aGVzZSBhcmUgbm90IHJlYWQgb3IgbWFuaXB1bGF0ZWQgb3IgYW55dGhpbmcgLS0gaXQncyBwdXJlbHkgc2hvcnRoYW5kIGFuZCBjYW4gYmUgb21pdHRlZCB3aXRoIGB7fWAgYW5kIHRoZW4geW91ciBvd24gYHVzZU1lcmdlZFByb3BzYCkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wcyh7IG1lYXN1cmUsIGFuaW1hdGVPbk1vdW50LCBjbGFzc0Jhc2UsIG9uVHJhbnNpdGlvblVwZGF0ZSwgZXhpdFZpc2liaWxpdHksIGR1cmF0aW9uLCBvcGVuLCByZWYgfSwgb3RoZXJQcm9wcykge1xyXG4gICAgY2xhc3NCYXNlID8/PSBcInRyYW5zaXRpb25cIjtcclxuICAgIGNvbnN0IHsgZWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICBjb25zdCBbcGhhc2UsIHNldFBoYXNlXSA9IHVzZVN0YXRlKGFuaW1hdGVPbk1vdW50ID8gXCJpbml0XCIgOiBudWxsKTtcclxuICAgIGNvbnN0IFtkaXJlY3Rpb24sIHNldERpcmVjdGlvbl0gPSB1c2VTdGF0ZShvcGVuID09IG51bGwgPyBudWxsIDogb3BlbiA/IFwiZW50ZXJcIiA6IFwiZXhpdFwiKTtcclxuICAgIGNvbnN0IFtzdXJmYWNlV2lkdGgsIHNldFN1cmZhY2VXaWR0aF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtzdXJmYWNlSGVpZ2h0LCBzZXRTdXJmYWNlSGVpZ2h0XSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgW3N1cmZhY2VYLCBzZXRTdXJmYWNlWF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtzdXJmYWNlWSwgc2V0U3VyZmFjZVldID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBbdHJhbnNpdGlvbmluZ1dpZHRoLCBzZXRUcmFuc2l0aW9uaW5nV2lkdGhdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBbdHJhbnNpdGlvbmluZ0hlaWdodCwgc2V0VHJhbnNpdGlvbmluZ0hlaWdodF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFt0cmFuc2l0aW9uaW5nWCwgc2V0VHJhbnNpdGlvbmluZ1hdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBbdHJhbnNpdGlvbmluZ1ksIHNldFRyYW5zaXRpb25pbmdZXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgeyBnZXRMb2dpY2FsRGlyZWN0aW9uIH0gPSB1c2VMb2dpY2FsRGlyZWN0aW9uKGVsZW1lbnQpO1xyXG4gICAgY29uc3QgbG9naWNhbERpcmVjdGlvbiA9IGdldExvZ2ljYWxEaXJlY3Rpb24oKTtcclxuICAgIGNvbnN0IG9uVHJhbnNpdGlvblVwZGF0ZVJlZiA9IHVzZVJlZihvblRyYW5zaXRpb25VcGRhdGUpO1xyXG4gICAgY29uc3QgcGhhc2VSZWYgPSB1c2VSZWYocGhhc2UpO1xyXG4gICAgY29uc3QgZGlyZWN0aW9uUmVmID0gdXNlUmVmKGRpcmVjdGlvbik7XHJcbiAgICBjb25zdCBkdXJhdGlvblJlZiA9IHVzZVJlZihkdXJhdGlvbik7XHJcbiAgICBjb25zdCB0b29FYXJseVRpbWVvdXRSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCB0b29FYXJseVZhbHVlUmVmID0gdXNlUmVmKHRydWUpO1xyXG4gICAgY29uc3QgdG9vTGF0ZVRpbWVvdXRSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCBvblRyYW5zaXRpb25FbmQgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xyXG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gZWxlbWVudCAmJiB0b29FYXJseVZhbHVlUmVmLmN1cnJlbnQgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgc2V0UGhhc2UoXCJmaW5hbGl6ZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbZWxlbWVudF0pO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgb25UcmFuc2l0aW9uVXBkYXRlUmVmLmN1cnJlbnQgPSBvblRyYW5zaXRpb25VcGRhdGU7IH0sIFtvblRyYW5zaXRpb25VcGRhdGVdKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHBoYXNlUmVmLmN1cnJlbnQgPSBwaGFzZTsgfSwgW3BoYXNlXSk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBkaXJlY3Rpb25SZWYuY3VycmVudCA9IGRpcmVjdGlvbjsgfSwgW2RpcmVjdGlvbl0pO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgZHVyYXRpb25SZWYuY3VycmVudCA9IGR1cmF0aW9uOyB9LCBbZHVyYXRpb25dKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmJiBwaGFzZSlcclxuICAgICAgICAgICAgb25UcmFuc2l0aW9uVXBkYXRlUmVmLmN1cnJlbnQ/LihkaXJlY3Rpb24sIHBoYXNlKTtcclxuICAgIH0sIFtkaXJlY3Rpb24sIHBoYXNlXSk7XHJcbiAgICAvLyBFdmVyeSB0aW1lIHRoZSBwaGFzZSBjaGFuZ2VzIHRvIFwidHJhbnNpdGlvblwiLCBhZGQgb3VyIHRyYW5zaXRpb24gdGltZW91dCB0aW1lb3V0c1xyXG4gICAgLy8gdG8gY2F0Y2ggYW55IHRpbWUgb25UcmFuc2l0aW9uRW5kIGZhaWxzIHRvIHJlcG9ydCBmb3Igd2hhdGV2ZXIgcmVhc29uIHRvIGJlIHNhZmVcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHBoYXNlID09IFwidHJhbnNpdGlvblwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXREdXJhdGlvbiA9IGR1cmF0aW9uUmVmLmN1cnJlbnQgPz8gMTAwMDtcclxuICAgICAgICAgICAgdG9vRWFybHlUaW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0b29FYXJseVZhbHVlUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRvb0Vhcmx5VGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfSwgNTApO1xyXG4gICAgICAgICAgICB0b29MYXRlVGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdG9vRWFybHlWYWx1ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRvb0xhdGVUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgc2V0UGhhc2UoXCJmaW5hbGl6ZVwiKTtcclxuICAgICAgICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRvb0Vhcmx5VGltZW91dFJlZi5jdXJyZW50KVxyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRvb0Vhcmx5VGltZW91dFJlZi5jdXJyZW50KTtcclxuICAgICAgICAgICAgaWYgKHRvb0xhdGVUaW1lb3V0UmVmLmN1cnJlbnQpXHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodG9vTGF0ZVRpbWVvdXRSZWYuY3VycmVudCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtwaGFzZV0pO1xyXG4gICAgLy8gQW55IHRpbWUgXCJvcGVuXCIgY2hhbmdlcywgdXBkYXRlIG91ciBkaXJlY3Rpb24gYW5kIHBoYXNlLlxyXG4gICAgLy8gSW4gYWRkaXRpb24sIG1lYXN1cmUgdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgaWYgcmVxdWVzdGVkLlxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudCAmJiBvcGVuICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNQaGFzZSA9IHBoYXNlUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIC8vIFN3YXAgb3VyIGRpcmVjdGlvblxyXG4gICAgICAgICAgICBpZiAob3BlbilcclxuICAgICAgICAgICAgICAgIHNldERpcmVjdGlvbihcImVudGVyXCIpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBzZXREaXJlY3Rpb24oXCJleGl0XCIpO1xyXG4gICAgICAgICAgICBzZXRQaGFzZShwcmV2aW91c1BoYXNlID09PSBudWxsID8gXCJmaW5hbGl6ZVwiIDogXCJpbml0XCIpO1xyXG4gICAgICAgICAgICBpZiAobWVhc3VyZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTaXplV2l0aFRyYW5zaXRpb24gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gY3VycmVudFNpemVXaXRoVHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uaW5nWCh4ICsgXCJweFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uaW5nWSh5ICsgXCJweFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uaW5nV2lkdGgod2lkdGggKyBcInB4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25pbmdIZWlnaHQoaGVpZ2h0ICsgXCJweFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1BoYXNlID09PSBcImZpbmFsaXplXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBiZSBtZXNzaW5nIHdpdGggdGhlIGFjdHVhbCBlbGVtZW50J3MgY2xhc3MsIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlJ2xsIHdhbnQgYW4gZWFzeSB3YXkgdG8gcmVzdG9yZSBpdCBsYXRlci5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWNrdXAgPSBlbGVtZW50LmNsYXNzTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoYCR7Y2xhc3NCYXNlfS1tZWFzdXJlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGAke2NsYXNzQmFzZX0tZW50ZXJgLCBgJHtjbGFzc0Jhc2V9LWVudGVyLWluaXRgLCBgJHtjbGFzc0Jhc2V9LWVudGVyLXRyYW5zaXRpb25gLCBgJHtjbGFzc0Jhc2V9LWVudGVyLWZpbmFsaXplYCwgYCR7Y2xhc3NCYXNlfS1leGl0YCwgYCR7Y2xhc3NCYXNlfS1leGl0LWluaXRgLCBgJHtjbGFzc0Jhc2V9LWV4aXQtdHJhbnNpdGlvbmAsIGAke2NsYXNzQmFzZX0tZXhpdC1maW5hbGl6ZWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlUmVmbG93KGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemVXaXRob3V0VHJhbnNpdGlvbiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSBzaXplV2l0aG91dFRyYW5zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3VyZmFjZVgoeCArIFwicHhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3VyZmFjZVkoeSArIFwicHhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3VyZmFjZVdpZHRoKHdpZHRoICsgXCJweFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRTdXJmYWNlSGVpZ2h0KGhlaWdodCArIFwicHhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBiYWNrdXA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VSZWZsb3coZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbb3BlbiwgZWxlbWVudCwgbWVhc3VyZSwgY2xhc3NCYXNlXSk7XHJcbiAgICAvLyBBbnkgdGltZSB0aGUgcGhhc2UgY2hhbmdlcyB0byBpbml0LCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIHNjcmVlbiBpcyBwYWludGVkLFxyXG4gICAgLy8gY2hhbmdlIHRoZSBwaGFzZSB0byBcInRyYW5zaXRpb25cIiBhbmQgcmUtcmVuZGVyICgpLlxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudCAmJiBkaXJlY3Rpb25SZWYuY3VycmVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNsYXNzQmFzZSA/Pz0gXCJ0cmFuc2l0aW9uXCI7XHJcbiAgICAgICAgICAgIGlmIChwaGFzZSA9PT0gXCJpbml0XCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFByZWFjdCBqdXN0IGZpbmlzaGVkIHJlbmRlcmluZyBpbml0XHJcbiAgICAgICAgICAgICAgICAvLyBOb3cgc2V0IG91ciB0cmFuc2l0aW9uIHN0eWxlLlxyXG4gICAgICAgICAgICAgICAgc2V0UGhhc2UoXCJ0cmFuc2l0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lYXN1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JjZVJlZmxvdyhlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtwaGFzZSwgbWVhc3VyZSwgZWxlbWVudF0pO1xyXG4gICAgY29uc3QgaW5saW5lRGlyZWN0aW9uID0gbG9naWNhbERpcmVjdGlvbj8uaW5saW5lRGlyZWN0aW9uO1xyXG4gICAgY29uc3QgYmxvY2tEaXJlY3Rpb24gPSBsb2dpY2FsRGlyZWN0aW9uPy5ibG9ja0RpcmVjdGlvbjtcclxuICAgIGNvbnN0IHdyaXRpbmdNb2RlSXNIb3Jpem9udGFsID0gKGlubGluZURpcmVjdGlvbiA9PSBcInJ0bFwiIHx8IGlubGluZURpcmVjdGlvbiA9PSBcImx0clwiKTtcclxuICAgIGNvbnN0IHN1cmZhY2VJbmxpbmVJbnNldCA9IHdyaXRpbmdNb2RlSXNIb3Jpem9udGFsID8gc3VyZmFjZVggOiBzdXJmYWNlWTtcclxuICAgIGNvbnN0IHN1cmZhY2VCbG9ja0luc2V0ID0gd3JpdGluZ01vZGVJc0hvcml6b250YWwgPyBzdXJmYWNlWSA6IHN1cmZhY2VYO1xyXG4gICAgY29uc3Qgc3VyZmFjZUlubGluZVNpemUgPSB3cml0aW5nTW9kZUlzSG9yaXpvbnRhbCA/IHN1cmZhY2VXaWR0aCA6IHN1cmZhY2VIZWlnaHQ7XHJcbiAgICBjb25zdCBzdXJmYWNlQmxvY2tTaXplID0gd3JpdGluZ01vZGVJc0hvcml6b250YWwgPyBzdXJmYWNlSGVpZ2h0IDogc3VyZmFjZVdpZHRoO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvbmluZ0lubGluZUluc2V0ID0gd3JpdGluZ01vZGVJc0hvcml6b250YWwgPyB0cmFuc2l0aW9uaW5nWCA6IHRyYW5zaXRpb25pbmdZO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvbmluZ0Jsb2NrSW5zZXQgPSB3cml0aW5nTW9kZUlzSG9yaXpvbnRhbCA/IHRyYW5zaXRpb25pbmdZIDogdHJhbnNpdGlvbmluZ1g7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uaW5nSW5saW5lU2l6ZSA9IHdyaXRpbmdNb2RlSXNIb3Jpem9udGFsID8gdHJhbnNpdGlvbmluZ1dpZHRoIDogdHJhbnNpdGlvbmluZ0hlaWdodDtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25pbmdCbG9ja1NpemUgPSB3cml0aW5nTW9kZUlzSG9yaXpvbnRhbCA/IHRyYW5zaXRpb25pbmdIZWlnaHQgOiB0cmFuc2l0aW9uaW5nV2lkdGg7XHJcbiAgICBsZXQgYWxtb3N0RG9uZSA9IHVzZVJlZkVsZW1lbnRQcm9wcyh7XHJcbiAgICAgICAgcmVmLFxyXG4gICAgICAgIHN0eWxlOiByZW1vdmVFbXB0eSh7XHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tZHVyYXRpb25gXTogZHVyYXRpb24sXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tc3VyZmFjZS14YF06IHN1cmZhY2VYLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXN1cmZhY2UteWBdOiBzdXJmYWNlWSxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1zdXJmYWNlLXdpZHRoYF06IHN1cmZhY2VXaWR0aCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1zdXJmYWNlLWhlaWdodGBdOiBzdXJmYWNlSGVpZ2h0LFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXN1cmZhY2UtaW5saW5lLWluc2V0YF06IHN1cmZhY2VJbmxpbmVJbnNldCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1zdXJmYWNlLWJsb2NrLWluc2V0YF06IHN1cmZhY2VCbG9ja0luc2V0LFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXN1cmZhY2UtaW5saW5lLXNpemVgXTogc3VyZmFjZUlubGluZVNpemUsXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tc3VyZmFjZS1ibG9jay1zaXplYF06IHN1cmZhY2VCbG9ja1NpemUsXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tdHJhbnNpdGlvbmluZy14YF06IHRyYW5zaXRpb25pbmdYLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXRyYW5zaXRpb25pbmcteWBdOiB0cmFuc2l0aW9uaW5nWSxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS10cmFuc2l0aW9uaW5nLXdpZHRoYF06IHRyYW5zaXRpb25pbmdXaWR0aCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS10cmFuc2l0aW9uaW5nLWhlaWdodGBdOiB0cmFuc2l0aW9uaW5nSGVpZ2h0LFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXRyYW5zaXRpb25pbmctaW5saW5lLWluc2V0YF06IHRyYW5zaXRpb25pbmdJbmxpbmVJbnNldCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS10cmFuc2l0aW9uaW5nLWJsb2NrLWluc2V0YF06IHRyYW5zaXRpb25pbmdCbG9ja0luc2V0LFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXRyYW5zaXRpb25pbmctaW5saW5lLXNpemVgXTogdHJhbnNpdGlvbmluZ0lubGluZVNpemUsXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tdHJhbnNpdGlvbmluZy1ibG9jay1zaXplYF06IHRyYW5zaXRpb25pbmdCbG9ja1NpemVcclxuICAgICAgICB9KSxcclxuICAgICAgICBvblRyYW5zaXRpb25FbmQsXHJcbiAgICAgICAgLi4uKHsgXCJhcmlhLWhpZGRlblwiOiBvcGVuID8gdW5kZWZpbmVkIDogXCJ0cnVlXCIgfSksXHJcbiAgICAgICAgY2xhc3NOYW1lOiBjbHN4KGRpcmVjdGlvbiAmJiBnZXRDbGFzc05hbWUoY2xhc3NCYXNlLCBkaXJlY3Rpb24pLCBkaXJlY3Rpb24gJiYgcGhhc2UgJiYgZ2V0Q2xhc3NOYW1lKGNsYXNzQmFzZSwgZGlyZWN0aW9uLCBwaGFzZSksIGV4aXRWaXNpYmlsaXR5ID09IFwicmVtb3ZlZFwiICYmIGAke2NsYXNzQmFzZX0tcmVtb3ZlZC1vbi1leGl0YCwgZXhpdFZpc2liaWxpdHkgPT0gXCJ2aXNpYmxlXCIgJiYgYCR7Y2xhc3NCYXNlfS12aXNpYmxlLW9uLWV4aXRgLCBgJHtjbGFzc0Jhc2V9LWlubGluZS1kaXJlY3Rpb24tJHtpbmxpbmVEaXJlY3Rpb24gPz8gXCJsdHJcIn1gLCBgJHtjbGFzc0Jhc2V9LWJsb2NrLWRpcmVjdGlvbi0ke2Jsb2NrRGlyZWN0aW9uID8/IFwidHRiXCJ9YCksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKGFsbW9zdERvbmUsIG90aGVyUHJvcHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUVtcHR5KG9iaikge1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvYmopLmZpbHRlcigoW18sIHZdKSA9PiB2ICE9IG51bGwpKTtcclxufVxyXG4vKipcclxuICogQSBjb21wb25lbnQgdGhhdCAqd3JhcHMgYW4gSFRNTEVsZW1lbnQgb3Igb3RoZXIgcmVmLWZvcndhcmRpbmcgY29tcG9uZW50KiBhbmQgYWxsb3dzIGl0IHRvIHVzZSBDU1MgdG8gdHJhbnNpdGlvbiBpbi9vdXQuXHJcbiAqIENvbWJpbmVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gaXQsIHRoZSBwcm9wcyBpdHMgY2hpbGQgaGFzLCBhbmQgdGhlIHByb3BzIG5lZWRlZCBmb3IgdGhlIENTUyB0cmFuc2l0aW9uLCBhbmQgcGFzc2VzIHRoZW1cclxuICogYWxsIHRvIHRoZSBjaGlsZCBlbGVtZW50IHlvdSBwcm92aWRlLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSBtb3N0IGdlbmVyYWwgY29tcG9uZW50IHRoYXQgb3RoZXJzIHVzZSBhcyBhIGJhc2UuIEJ5IGRlZmF1bHQsIHRoaXMgY29tcG9uZW50IGJ5IGl0c2VsZiBkb2Vzbid0IGFjdHVhbGx5IGFkZCBhbnkgQ1NTIGNsYXNzZXMgdGhhdCBhbmltYXRlIGFueXRoaW5nIChsaWtlIG9wYWNpdHksIGZvciBleGFtcGxlKS5cclxuICogSXQgYWRkcyBjbGFzc2VzIGxpa2UgYHRyYW5zaXRpb24tZW50ZXItZmluYWxpemVgLCBidXQgeW91IG5lZWQgdG8gcHJvdmlkZSB0aGUgYWRkaXRpb25hbCBlLmcuIGBmYWRlYCBjbGFzcyB0aGF0IHJlYWN0cyB0byBpdC5cclxuICpcclxuICogVXNlIHRoaXMgaWYgdGhlIG90aGVyLCBtb3JlIHNwZWNpYWxpemVkIFRyYW5zaXRpb24gY29tcG9uZW50cyBkb24ndCBmaXQgeW91ciBuZWVkcy5cclxuICpcclxuICogQGV4YW1wbGUgYDxUcmFuc2l0aW9uYWJsZSBvcGVuPXtvcGVufSB7Li4udXNlQ3JlYXRlRmFkZVByb3BzKC4uLil9PjxkaXY+e2NoaWxkcmVufTwvZGl2PjwvVHJhbnNpdGlvbmFibGU+YFxyXG4gKiBAZXhhbXBsZSBgPFRyYW5zaXRpb25hYmxlIG9wZW49e29wZW59PjxkaXYgey4uLnVzZUNyZWF0ZUZhZGVQcm9wcyguLi4pfT57Y2hpbGRyZW59PC9kaXY+PC9UcmFuc2l0aW9uYWJsZT5gXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVHJhbnNpdGlvbmFibGUgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBUcmFuc2l0aW9uKHsgY2hpbGRyZW46IGNoaWxkLCBkdXJhdGlvbiwgY2xhc3NCYXNlLCBtZWFzdXJlLCBleGl0VmlzaWJpbGl0eSwgb3Blbiwgb25UcmFuc2l0aW9uVXBkYXRlLCBhbmltYXRlT25Nb3VudCwgLi4ucHJvcHMgfSwgcikge1xyXG4gICAgaWYgKCFjaGlsZElzVk5vZGUoY2hpbGQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBUcmFuc2l0aW9uYWJsZSBjb21wb25lbnQgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZCAoZS5nLiBhIDxkaXY+LCBidXQgbm90IFxcXCJhIHN0cmluZ1xcXCIpLlwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRyYW5zaXRpb25Qcm9wcyA9IHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHMoeyBjbGFzc0Jhc2UsIGR1cmF0aW9uLCBtZWFzdXJlLCBvcGVuLCBhbmltYXRlT25Nb3VudCwgb25UcmFuc2l0aW9uVXBkYXRlLCByZWY6IHIsIGV4aXRWaXNpYmlsaXR5IH0sIHByb3BzKTtcclxuICAgIGNvbnN0IG1lcmdlZFdpdGhDaGlsZHJlbiA9IHVzZU1lcmdlZFByb3BzKCkodHJhbnNpdGlvblByb3BzLCB7IC4uLmNoaWxkLnByb3BzLCByZWY6IGNoaWxkLnJlZiB9KTtcclxuICAgIHJldHVybiBjbG9uZUVsZW1lbnQoY2hpbGQsIG1lcmdlZFdpdGhDaGlsZHJlbik7XHJcbn0pO1xyXG5mdW5jdGlvbiBjaGlsZElzVk5vZGUoY2hpbGQpIHtcclxuICAgIGlmICghY2hpbGQpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjaGlsZCAhPSBcIm9iamVjdFwiKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiAoXCJwcm9wc1wiIGluIGNoaWxkKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2l0aW9uYWJsZS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IFRyYW5zaXRpb25hYmxlIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGVcIjtcclxuaW1wb3J0IHsgZGVmYXVsdCBhcyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBDbGlwIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cclxuICogQmUgc3VyZSB0byBtZXJnZSB0aGVzZSByZXR1cm5lZCBwcm9wcyB3aXRoIHdoYXRldmVyIHRoZSB1c2VyIHBhc3NlZCBpbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDcmVhdGVDbGlwUHJvcHMoeyBjbGFzc0Jhc2UsIGNsaXBPcmlnaW4sIGNsaXBPcmlnaW5JbmxpbmUsIGNsaXBPcmlnaW5CbG9jaywgY2xpcE1pbiwgY2xpcE1pbklubGluZSwgY2xpcE1pbkJsb2NrIH0sIG90aGVyUHJvcHMpIHtcclxuICAgIGNsYXNzQmFzZSA/Pz0gXCJ0cmFuc2l0aW9uXCI7XHJcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBjbHN4KGAke2NsYXNzQmFzZX0tY2xpcGApLFxyXG4gICAgICAgIGNsYXNzQmFzZSxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWNsaXAtb3JpZ2luLWlubGluZWBdOiAoY2xpcE9yaWdpbklubGluZSA/PyBjbGlwT3JpZ2luID8/IDAuNSksXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tY2xpcC1vcmlnaW4tYmxvY2tgXTogKGNsaXBPcmlnaW5CbG9jayA/PyBjbGlwT3JpZ2luID8/IDApLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWNsaXAtbWluLWlubGluZWBdOiAoY2xpcE1pbklubGluZSA/PyBjbGlwTWluID8/IDEpLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWNsaXAtbWluLWJsb2NrYF06IChjbGlwTWluQmxvY2sgPz8gY2xpcE1pbiA/PyAwKSxcclxuICAgICAgICB9LFxyXG4gICAgfSwgb3RoZXJQcm9wcyk7XHJcbn1cclxuO1xyXG5leHBvcnQgY29uc3QgQ2xpcCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENsaXAoeyBjbGFzc0Jhc2UsIGNsaXBPcmlnaW4sIGNsaXBPcmlnaW5JbmxpbmUsIGNsaXBPcmlnaW5CbG9jaywgY2xpcE1pbiwgY2xpcE1pbklubGluZSwgY2xpcE1pbkJsb2NrLCBvcGVuLCAuLi5yZXN0IH0sIHJlZikge1xyXG4gICAgcmV0dXJuIGgoVHJhbnNpdGlvbmFibGUsIHsgb3Blbjogb3BlbiwgLi4udXNlQ3JlYXRlQ2xpcFByb3BzKHsgY2xhc3NCYXNlLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luSW5saW5lLCBjbGlwT3JpZ2luQmxvY2ssIGNsaXBNaW4sIGNsaXBNaW5JbmxpbmUsIGNsaXBNaW5CbG9jayB9LCB7IC4uLnJlc3QsIHJlZiB9KSB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaXAuanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBUcmFuc2l0aW9uYWJsZSB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlXCI7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgRmFkZSB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXHJcbiAqIEJlIHN1cmUgdG8gbWVyZ2UgdGhlc2UgcmV0dXJuZWQgcHJvcHMgd2l0aCB3aGF0ZXZlciB0aGUgdXNlciBwYXNzZWQgaW4uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlRmFkZVByb3BzKHsgY2xhc3NCYXNlLCBmYWRlTWluLCBmYWRlTWF4IH0sIG90aGVyUHJvcHMpIHtcclxuICAgIGNsYXNzQmFzZSA/Pz0gXCJ0cmFuc2l0aW9uXCI7XHJcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtjbGFzc0Jhc2V9LWZhZGVgLFxyXG4gICAgICAgIGNsYXNzQmFzZSxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWZhZGUtbWluYF06IChmYWRlTWluID8/IDApLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWZhZGUtbWF4YF06IChmYWRlTWF4ID8/IDEpLFxyXG4gICAgICAgIH1cclxuICAgIH0sIG90aGVyUHJvcHMpO1xyXG59XHJcbjtcclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYSBGYWRlIGVmZmVjdC5cclxuICpcclxuICogTm90ZSB0aGF0IHdoaWxlIGl0IGlzIGFic29sdXRlbHkgcG9zc2libGUgdG8gd3JhcCBhbm90aGVyIHRyYW5zaXRpb24gd2l0aCBgPEZhZGU+YCxcclxuICogdGhlcmUgd2lsbCBiZSBzb21lIGR1cGxpY2F0ZSBjb2RlIHJ1biBhcyB0d28gYDxUcmFuc2l0aW9uYWJsZT5gIGNvbXBvbmVudHMgZW5kIHVwIG9wZXJhdGluZyBvbiB0aGUgc2FtZSBlbGVtZW50LlxyXG4gKiBJdCdzIGdlbmVyYWxseSByZWNvbW1lbmRlZCB0byBlaXRoZXIgdXNlIHRoZSBjb21wb25lbnRzIHRoYXQgaW5jbHVkZSBhIGNvbWJpbmVkIGZhZGUgZWZmZWN0LFxyXG4gKiBvciBqdXN0IGRpcmVjdGx5IGEgYDxUcmFuc2l0aW9uYWJsZT5gIG9uIHlvdXIgb3duLlxyXG4gKlxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBGYWRlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gRmFkZSh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCwgb3BlbiwgLi4ucmVzdCB9LCByZWYpIHtcclxuICAgIHJldHVybiBoKFRyYW5zaXRpb25hYmxlLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZUZhZGVQcm9wcyh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCB9LCB7IC4uLnJlc3QsIHJlZiB9KSB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhZGUuanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgQ2xpcCB9IGZyb20gXCIuL2NsaXBcIjtcclxuaW1wb3J0IHsgdXNlQ3JlYXRlRmFkZVByb3BzIH0gZnJvbSBcIi4vZmFkZVwiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcclxuO1xyXG5leHBvcnQgY29uc3QgQ2xpcEZhZGUgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDbGlwRmFkZSh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCwgb3BlbiwgLi4ucmVzdCB9LCByZWYpIHtcclxuICAgIHJldHVybiBoKENsaXAsIHsgb3Blbjogb3BlbiwgLi4udXNlQ3JlYXRlRmFkZVByb3BzKHsgY2xhc3NCYXNlLCBmYWRlTWluLCBmYWRlTWF4IH0sIHsgLi4ucmVzdCwgcmVmIH0pIH0pO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpcC1mYWRlLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vZm9yd2FyZC1lbGVtZW50LXJlZlwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbmFibGUgfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZVwiO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIFpvb20gdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxyXG4gKiBCZSBzdXJlIHRvIG1lcmdlIHRoZXNlIHJldHVybmVkIHByb3BzIHdpdGggd2hhdGV2ZXIgdGhlIHVzZXIgcGFzc2VkIGluLlxyXG4gKlxyXG4gKiBJTVBPUlRBTlQ6IElmIHVzZWQgb3V0c2lkZSBvZiBhIGA8Q29sbGFwc2UgLz5gLCB5b3UgbXVzdCBpbmNsdWRlIHRoZSBgbWVhc3VyZWAgcHJvcCBvbiB0aGUgYDxUcmFuc2l0aW9uYWJsZT5gIHRoYXQgeW91IHVzZS5cclxuICpcclxuICogQGV4YW1wbGUgPFRyYW5zaXRpb25hYmxlIG1lYXN1cmUgey4uLnVzZUNyZWF0ZUNvbGxhcHNlUHJvcHMoLi4uKX0gLz5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDcmVhdGVDb2xsYXBzZVByb3BzKHsgY2xhc3NCYXNlLCBtaW5CbG9ja1NpemUgfSwgb3RoZXJQcm9wcykge1xyXG4gICAgY2xhc3NCYXNlID8/PSBcInRyYW5zaXRpb25cIjtcclxuICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHtcclxuICAgICAgICBjbGFzc0Jhc2UsXHJcbiAgICAgICAgbWVhc3VyZTogdHJ1ZSxcclxuICAgICAgICBjbGFzc05hbWU6IGAke2NsYXNzQmFzZX0tY29sbGFwc2VgLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tY29sbGFwc2UtbWluLWJsb2NrYF06IG1pbkJsb2NrU2l6ZSA/PyAwXHJcbiAgICAgICAgfVxyXG4gICAgfSwgb3RoZXJQcm9wcyk7XHJcbn1cclxuO1xyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIENvbGxhcHNlIGVmZmVjdC5cclxuICpcclxuICogKkltcG9ydGFudCo6IFRoaXMgY29tcG9uZW50IGlzICpub3QqIGVmZmljaWVudCBmb3IgdGhlIGJyb3dzZXIgdG8gYW5pbWF0ZSFcclxuICogTWFrZSBzdXJlIHlvdSBkbyB0ZXN0aW5nIG9uIGxvd2VyIHBvd2VyIGRldmljZXMsIG9yIHByZWZlciBhIGxpZ2h0ZXJcclxuICogYWx0ZXJuYXRpdmUsIGxpa2UgYDxDbGlwPmAuXHJcbiAqXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENvbGxhcHNlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ29sbGFwc2UoeyBjbGFzc0Jhc2UsIG9wZW4sIG1pbkJsb2NrU2l6ZSwgLi4ucmVzdCB9LCByZWYpIHtcclxuICAgIHJldHVybiBoKFRyYW5zaXRpb25hYmxlLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZUNvbGxhcHNlUHJvcHMoeyBjbGFzc0Jhc2UsIG1pbkJsb2NrU2l6ZSB9LCB7IC4uLnJlc3QsIHJlZiB9KSB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbGxhcHNlLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IENvbGxhcHNlIH0gZnJvbSBcIi4vY29sbGFwc2VcIjtcclxuaW1wb3J0IHsgdXNlQ3JlYXRlRmFkZVByb3BzIH0gZnJvbSBcIi4vZmFkZVwiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcclxuO1xyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBib3RoIENvbGxhcHNlIGFuZCBGYWRlIGVmZmVjdHMuXHJcbiAqXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYCBgQ29sbGFwc2VgIGBGYWRlYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENvbGxhcHNlRmFkZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENvbGxhcHNlRmFkZSh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCwgb3BlbiwgLi4ucmVzdCB9LCByZWYpIHtcclxuICAgIHJldHVybiBoKENvbGxhcHNlLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZUZhZGVQcm9wcyh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCB9LCB7IC4uLnJlc3QsIHJlZiB9KSB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbGxhcHNlLWZhZGUuanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbmFibGUgfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZVwiO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIFNsaWRlIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDcmVhdGVTbGlkZVByb3BzKHsgY2xhc3NCYXNlLCBzbGlkZVRhcmdldElubGluZSwgc2xpZGVUYXJnZXRCbG9jayB9LCBvdGhlclByb3BzKSB7XHJcbiAgICBjbGFzc0Jhc2UgPz89IFwidHJhbnNpdGlvblwiO1xyXG4gICAgY29uc3QgbGFzdFZhbGlkVGFyZ2V0SW5saW5lID0gdXNlUmVmKHNsaWRlVGFyZ2V0SW5saW5lID8/IDEpO1xyXG4gICAgY29uc3QgbGFzdFZhbGlkVGFyZ2V0QmxvY2sgPSB1c2VSZWYoc2xpZGVUYXJnZXRCbG9jayA/PyAwKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7IGlmIChzbGlkZVRhcmdldElubGluZSlcclxuICAgICAgICBsYXN0VmFsaWRUYXJnZXRJbmxpbmUuY3VycmVudCA9IHNsaWRlVGFyZ2V0SW5saW5lOyB9LCBbc2xpZGVUYXJnZXRJbmxpbmVdKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7IGlmIChzbGlkZVRhcmdldEJsb2NrKVxyXG4gICAgICAgIGxhc3RWYWxpZFRhcmdldEJsb2NrLmN1cnJlbnQgPSBzbGlkZVRhcmdldEJsb2NrOyB9LCBbc2xpZGVUYXJnZXRCbG9ja10pO1xyXG4gICAgaWYgKHNsaWRlVGFyZ2V0SW5saW5lID09IDApXHJcbiAgICAgICAgc2xpZGVUYXJnZXRJbmxpbmUgPSBsYXN0VmFsaWRUYXJnZXRJbmxpbmUuY3VycmVudDtcclxuICAgIGlmIChzbGlkZVRhcmdldEJsb2NrID09IDApXHJcbiAgICAgICAgc2xpZGVUYXJnZXRCbG9jayA9IGxhc3RWYWxpZFRhcmdldEJsb2NrLmN1cnJlbnQ7XHJcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtjbGFzc0Jhc2V9LXNsaWRlYCxcclxuICAgICAgICBjbGFzc0Jhc2UsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1zbGlkZS10YXJnZXQtaW5saW5lYF06IGAkeyhzbGlkZVRhcmdldElubGluZSA/PyAwKX1gLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXNsaWRlLXRhcmdldC1ibG9ja2BdOiBgJHsoc2xpZGVUYXJnZXRCbG9jayA/PyAwKX1gXHJcbiAgICAgICAgfVxyXG4gICAgfSwgb3RoZXJQcm9wcyk7XHJcbn1cclxuO1xyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIFNsaWRlIGVmZmVjdC5cclxuICpcclxuICogUHJvdmlkZSB0aGUgZGlyZWN0aW9uIHRoZSBlbGVtZW50IHdpbGwgdHJhdmVsIGluIHdpdGggYHNsaWRlSW5saW5lYCBhbmQgYHNsaWRlQmxvY2tgLFxyXG4gKiB3aXRoIGAxYCBiZWluZyBgMTAwJWAgb2YgdGhlIGVsZW1lbnQncyB3aWR0aCBvciBoZWlnaHQuXHJcbiAqXHJcbiAqIEEgdmFsdWUgb2YgYDBgIGlzIGhhbmRsZWQgc3BlY2lhbGx5LCBlZmZlY3RpdmVseSBtZWFuaW5nIFwidXNlIHRoZSBsYXN0IG5vbi16ZXJvIHZhbHVlXCIsXHJcbiAqIHdoaWNoIGFsbG93cyBmb3IgY29udmVuaWVudCBzZXR1cHMgaW5zaWRlIG9mIGEgYFN3YXBDb250YWluZXJgXHJcbiAqIChgc2xpZGVJbmxpbmU9e2luZGV4IC0gc2VsZWN0ZWRJbmRleH1gIG9yIHNpbWlsYXIuKVxyXG4gKlxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBTbGlkZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFNsaWRlKHsgY2xhc3NCYXNlLCBzbGlkZVRhcmdldElubGluZSwgc2xpZGVUYXJnZXRCbG9jaywgb3BlbiwgLi4ucmVzdCB9LCByZWYpIHtcclxuICAgIHJldHVybiBoKFRyYW5zaXRpb25hYmxlLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZVNsaWRlUHJvcHMoeyBjbGFzc0Jhc2UsIHNsaWRlVGFyZ2V0SW5saW5lLCBzbGlkZVRhcmdldEJsb2NrIH0sIHsgLi4ucmVzdCwgcmVmIH0pIH0pO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2xpZGUuanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ3JlYXRlRmFkZVByb3BzIH0gZnJvbSBcIi4vZmFkZVwiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcclxuaW1wb3J0IHsgU2xpZGUgfSBmcm9tIFwiLi9zbGlkZVwiO1xyXG47XHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGJvdGggU2xpZGUgYW5kIEZhZGUgZWZmZWN0cy5cclxuICpcclxuICogYHNsaWRlSW5saW5lPXsoaW5kZXggLSBzZWxlY3RlZEluZGV4KSAvIDEwfWAgd291bGQgbWFrZSB0aGUgZWxlbWVudCBsb29rIGxpa2UgaXQgZmFkZXMgb3V0IGJlZm9yZSBpdCB0cmF2ZWxzIHRvIGl0cyB0YXJnZXQgZGVzdGluYXRpb24uXHJcbiAqXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYCBgWm9vbWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBTbGlkZUZhZGUgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBTbGlkZUZhZGUoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXgsIG9wZW4sIC4uLnJlc3QgfSwgcmVmKSB7XHJcbiAgICByZXR1cm4gaChTbGlkZSwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVGYWRlUHJvcHMoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXggfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGlkZS1mYWRlLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbmFibGUgfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZVwiO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIFpvb20gdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNyZWF0ZVpvb21Qcm9wcyh7IGNsYXNzQmFzZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbklubGluZSwgem9vbU9yaWdpbkJsb2NrLCB6b29tTWluLCB6b29tTWluSW5saW5lLCB6b29tTWluQmxvY2sgfSwgb3RoZXJQcm9wcykge1xyXG4gICAgY2xhc3NCYXNlID8/PSBcInRyYW5zaXRpb25cIjtcclxuICAgIHJldHVybiAodXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtjbGFzc0Jhc2V9LXpvb21gLFxyXG4gICAgICAgIGNsYXNzQmFzZSxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXpvb20tb3JpZ2luLWlubGluZWBdOiBgJHsoem9vbU9yaWdpbklubGluZSA/PyB6b29tT3JpZ2luID8/IDAuNSl9YCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS16b29tLW9yaWdpbi1ibG9ja2BdOiBgJHsoem9vbU9yaWdpbkJsb2NrID8/IHpvb21PcmlnaW4gPz8gMC41KX1gLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXpvb20tbWluLWlubGluZWBdOiBgJHsoem9vbU1pbklubGluZSA/PyB6b29tTWluID8/IDApfWAsXHJcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tem9vbS1taW4tYmxvY2tgXTogYCR7KHpvb21NaW5CbG9jayA/PyB6b29tTWluID8/IDApfWAsXHJcbiAgICAgICAgfSxcclxuICAgIH0sIG90aGVyUHJvcHMpKTtcclxufVxyXG47XHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgWm9vbSBlZmZlY3QuXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYCBgWm9vbUZhZGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgWm9vbSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFpvb20oeyBjbGFzc0Jhc2UsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5JbmxpbmUsIHpvb21PcmlnaW5CbG9jaywgem9vbU1pbiwgem9vbU1pbklubGluZSwgem9vbU1pbkJsb2NrLCBvcGVuLCAuLi5yZXN0IH0sIHJlZikge1xyXG4gICAgcmV0dXJuIGgoVHJhbnNpdGlvbmFibGUsIHsgb3Blbjogb3BlbiwgLi4udXNlQ3JlYXRlWm9vbVByb3BzKHsgY2xhc3NCYXNlLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luSW5saW5lLCB6b29tT3JpZ2luQmxvY2ssIHpvb21NaW4sIHpvb21NaW5JbmxpbmUsIHpvb21NaW5CbG9jayB9LCB7IC4uLnJlc3QsIHJlZiB9KSB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXpvb20uanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ3JlYXRlRmFkZVByb3BzIH0gZnJvbSBcIi4vZmFkZVwiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcclxuaW1wb3J0IHsgWm9vbSB9IGZyb20gXCIuL3pvb21cIjtcclxuO1xyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBib3RoIFpvb20gYW5kIEZhZGUgZWZmZWN0cy5cclxuICpcclxuICogVGhpcyBpcyBhbiBpZGVhbCB0aW1lIHRvIHVzZSB0aGUgbWluaW11bSBzaXplIFpvb20gcHJvcGVydGllcy5cclxuICpcclxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgIGBab29tYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFpvb21GYWRlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gWm9vbUZhZGUoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXgsIG9wZW4sIC4uLnJlc3QgfSwgcmVmKSB7XHJcbiAgICByZXR1cm4gaChab29tLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZUZhZGVQcm9wcyh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCB9LCB7IC4uLnJlc3QsIHJlZiB9KSB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXpvb20tZmFkZS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcclxuaW1wb3J0IHsgU2xpZGUgfSBmcm9tIFwiLi9zbGlkZVwiO1xyXG5pbXBvcnQgeyB1c2VDcmVhdGVab29tUHJvcHMgfSBmcm9tIFwiLi96b29tXCI7XHJcbjtcclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYm90aCBTbGlkZSBhbmQgWm9vbSBlZmZlY3RzLlxyXG4gKlxyXG4gKiBQcm9iYWJseSBiZXN0IGNvbWJpbmVkIHdpdGggYHVzZUNyZWF0ZUZhZGVQcm9wc2AgKG9yIGp1c3QgdXNpbmcgYSBgU2xpZGVab29tRmFkZWA/KS5cclxuICpcclxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgIGBTbGlkZUZhZGVab29tYCBgWm9vbWAgYEZhZGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgU2xpZGVab29tID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGVab29tKHsgY2xhc3NCYXNlLCB6b29tTWluLCB6b29tTWluSW5saW5lLCB6b29tTWluQmxvY2ssIHpvb21PcmlnaW4sIHpvb21PcmlnaW5JbmxpbmUsIHpvb21PcmlnaW5CbG9jaywgb3BlbiwgLi4ucmVzdCB9LCByZWYpIHtcclxuICAgIHJldHVybiBoKFNsaWRlLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZVpvb21Qcm9wcyh7IGNsYXNzQmFzZSwgem9vbU1pbiwgem9vbU1pbklubGluZSwgem9vbU1pbkJsb2NrLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luSW5saW5lLCB6b29tT3JpZ2luQmxvY2sgfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGlkZS16b29tLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNyZWF0ZUZhZGVQcm9wcyB9IGZyb20gXCIuL2ZhZGVcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XHJcbmltcG9ydCB7IFNsaWRlWm9vbSB9IGZyb20gXCIuL3NsaWRlLXpvb21cIjtcclxuO1xyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBab29tLCBTbGlkZSwgYW5kIEZhZGUgZWZmZWN0cy5cclxuICpcclxuICogTm90ZSB0aGF0IHRoaXMgaXMgYmFzaWNhbGx5IGp1c3Qgc2hvcnRoYW5kIGZvciBzb21lIHByb3AgY3JlYXRpb24gYW5kIHByb3AgbWVyZ2luZyBmdW5jdGlvbnMuXHJcbiAqXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYCBgU2xpZGVgIGBab29tYCBgRmFkZWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBTbGlkZVpvb21GYWRlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGVab29tRmFkZSh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCwgb3BlbiwgLi4ucmVzdCB9LCByZWYpIHtcclxuICAgIHJldHVybiBoKFNsaWRlWm9vbSwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVGYWRlUHJvcHMoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXggfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGlkZS16b29tLWZhZGUuanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vZm9yd2FyZC1lbGVtZW50LXJlZlwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgVHJhbnNpdGlvbmFibGUgfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZVwiO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIEZsaXAgdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNyZWF0ZUZsaXBQcm9wcyh7IGNsYXNzQmFzZSwgZmxpcEFuZ2xlSW5saW5lLCBmbGlwQW5nbGVCbG9jaywgcGVyc3BlY3RpdmUgfSwgb3RoZXJQcm9wcykge1xyXG4gICAgY2xhc3NCYXNlID8/PSBcInRyYW5zaXRpb25cIjtcclxuICAgIGNvbnN0IGxhc3RWYWxpZFRhcmdldElubGluZSA9IHVzZVJlZihmbGlwQW5nbGVJbmxpbmUgPz8gMTgwKTtcclxuICAgIGNvbnN0IGxhc3RWYWxpZFRhcmdldEJsb2NrID0gdXNlUmVmKGZsaXBBbmdsZUJsb2NrID8/IDApO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHsgaWYgKGZsaXBBbmdsZUlubGluZSlcclxuICAgICAgICBsYXN0VmFsaWRUYXJnZXRJbmxpbmUuY3VycmVudCA9IGZsaXBBbmdsZUlubGluZTsgfSwgW2ZsaXBBbmdsZUlubGluZV0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHsgaWYgKGZsaXBBbmdsZUJsb2NrKVxyXG4gICAgICAgIGxhc3RWYWxpZFRhcmdldEJsb2NrLmN1cnJlbnQgPSBmbGlwQW5nbGVCbG9jazsgfSwgW2ZsaXBBbmdsZUJsb2NrXSk7XHJcbiAgICBpZiAoZmxpcEFuZ2xlSW5saW5lID09IDApXHJcbiAgICAgICAgZmxpcEFuZ2xlSW5saW5lID0gbGFzdFZhbGlkVGFyZ2V0SW5saW5lLmN1cnJlbnQ7XHJcbiAgICBpZiAoZmxpcEFuZ2xlQmxvY2sgPT0gMClcclxuICAgICAgICBmbGlwQW5nbGVCbG9jayA9IGxhc3RWYWxpZFRhcmdldEJsb2NrLmN1cnJlbnQ7XHJcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtjbGFzc0Jhc2V9LWZsaXBgLFxyXG4gICAgICAgIGNsYXNzQmFzZSxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWZsaXAtYW5nbGUtaW5saW5lYF06IGAkeyhmbGlwQW5nbGVJbmxpbmUgPz8gMCl9ZGVnYCxcclxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1mbGlwLWFuZ2xlLWJsb2NrYF06IGAkeyhmbGlwQW5nbGVCbG9jayA/PyAwKX1kZWdgLFxyXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXBlcnNwZWN0aXZlYF06IGAkeyhwZXJzcGVjdGl2ZSA/PyA4MDApfXB4YFxyXG4gICAgICAgIH1cclxuICAgIH0sIG90aGVyUHJvcHMpO1xyXG59XHJcbjtcclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYSBGbGlwIGVmZmVjdC5cclxuICpcclxuICogUHJvdmlkZSB0aGUgZGlyZWN0aW9uIHRoZSBlbGVtZW50IHdpbGwgdHJhdmVsIGluIHdpdGggYGZsaXBJbmxpbmVgIGFuZCBgZmxpcEJsb2NrYCxcclxuICogd2l0aCBgMWAgYmVpbmcgYDEwMCVgIG9mIHRoZSBlbGVtZW50J3Mgd2lkdGggb3IgaGVpZ2h0LlxyXG4gKlxyXG4gKiBBIHZhbHVlIG9mIGAwYCBpcyBoYW5kbGVkIHNwZWNpYWxseSwgZWZmZWN0aXZlbHkgbWVhbmluZyBcInVzZSB0aGUgbGFzdCBub24temVybyB2YWx1ZVwiLFxyXG4gKiB3aGljaCBhbGxvd3MgZm9yIGNvbnZlbmllbnQgc2V0dXBzIGluc2lkZSBvZiBhIGBTd2FwQ29udGFpbmVyYFxyXG4gKiAoYGZsaXBJbmxpbmU9e2luZGV4IC0gc2VsZWN0ZWRJbmRleH1gIG9yIHNpbWlsYXIuKVxyXG4gKlxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBGbGlwID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gRmxpcCh7IGNsYXNzQmFzZSwgZmxpcEFuZ2xlSW5saW5lLCBmbGlwQW5nbGVCbG9jaywgcGVyc3BlY3RpdmUsIG9wZW4sIC4uLnJlc3QgfSwgcmVmKSB7XHJcbiAgICByZXR1cm4gaChUcmFuc2l0aW9uYWJsZSwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVGbGlwUHJvcHMoeyBjbGFzc0Jhc2UsIGZsaXBBbmdsZUlubGluZSwgZmxpcEFuZ2xlQmxvY2ssIHBlcnNwZWN0aXZlIH0sIHsgLi4ucmVzdCwgcmVmIH0pIH0pO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmxpcC5qcy5tYXAiLCJpbXBvcnQgeyBkZWZhdWx0IGFzIGNsc3ggfSBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBjbG9uZUVsZW1lbnQgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBzd2FwIGNvbnRhaW5lci5cclxuICogQmUgc3VyZSB0byBtZXJnZSB0aGVzZSByZXR1cm5lZCBwcm9wcyB3aXRoIHdoYXRldmVyIHRoZSB1c2VyIHBhc3NlZCBpbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDcmVhdGVTd2FwcGFibGVQcm9wcyh7IGlubGluZSwgY2xhc3NCYXNlIH0sIG90aGVyUHJvcHMpIHtcclxuICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHtcclxuICAgICAgICBjbGFzc05hbWU6IGNsc3goYCR7Y2xhc3NCYXNlID8/IFwidHJhbnNpdGlvblwifS1zd2FwLWNvbnRhaW5lcmAsIGlubGluZSAmJiBgJHtjbGFzc0Jhc2UgPz8gXCJ0cmFuc2l0aW9uXCJ9LXN3YXAtY29udGFpbmVyLWlubGluZWApXHJcbiAgICB9LCBvdGhlclByb3BzKTtcclxufVxyXG4vKipcclxuICogQWxsb3dzIGEgc2V0IG9mIGNoaWxkIDxUcmFuc2l0aW9uYWJsZT4gY29tcG9uZW50cyB0byBhbmltYXRlIGluICYgb3V0IGluLXBsYWNlLiBWZXJ5IHVzZWZ1bCBmb3IsIGUuZy4sIHRhYiBwYW5lbHMuXHJcbiAqXHJcbiAqIFlvdSBtdXN0IG1hbmFnZSBlYWNoIGNoaWxkIGA8VHJhbnNpdGlvbmFibGU+YCBjb21wb25lbnQncyBgb3BlbmAgcHJvcCAtLSB0aGlzIGNvbXBvbmVudCAqZG9lcyBub3QqIG1hbmFnZSBhbnkgc29ydCBvZiBzdGF0ZSBpbiB0aGF0IHJlZ2FyZC5cclxuICpcclxuICogTGlrZSBgPFRyYW5zaXRpb25hYmxlPmAsICp0aGlzIHdyYXBzIGFuIEhUTUxFbGVtZW50IChvciBvdGhlciByZWYtZm9yd2FyZGluZyBjb21wb25lbnQpKi4gVGhpcyB3aWxsIGJlIHlvdXIgY29udGFpbmVyIHRoYXQgaG9sZHMgZWFjaCBgPFRyYW5zaXRpb25hYmxlPmAgKG9yIGNvbXBvbmVudCB0aGF0IHVzZXMgaXQpLiBTdHJpY3RseSBzcGVha2luZyBpdCBjb3VsZCBiZSBhbnl0aGluZywgbm90IGEgYDxUcmFuc2l0aW9uYWJsZT5gLCBidXQgaWYgaXQgZG9lc250J3QgdHJhbnNpdGlvbiBvdXQgdGhlbiBpdCdzIGp1c3QgZ29pbmcgdG8gYmUgaGFuZ2luZyBhcm91bmQgMTAwJSBvZiB0aGUgdGltZS5cclxuICpcclxuICogTG9uZyB3YXkgb2Ygc2F5aW5nLCBpZiB5b3UgZ2V0IGEgY3J5cHRpYyBlcnJvciB3aXRoIHRoaXMgY29tcG9uZW50LCBtYWtlIHN1cmUgaXQgaGFzIGEgc2luZ2xlIGA8ZGl2PmAgY2hpbGQgb3Igc29tZXRoaW5nLlxyXG4gKiBAcGFyYW0gcGFyYW0wXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgU3dhcHBhYmxlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU3dhcHBhYmxlKHsgY2hpbGRyZW4sIGNsYXNzQmFzZSwgaW5saW5lLCAuLi5wIH0sIHJlZikge1xyXG4gICAgaW5saW5lID8/PSB0eXBlb2YgY2hpbGRyZW4udHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBpbmxpbmVFbGVtZW50cy5oYXMoY2hpbGRyZW4udHlwZSk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uUHJvcHMgPSB1c2VDcmVhdGVTd2FwcGFibGVQcm9wcyh7IGNsYXNzQmFzZSwgaW5saW5lIH0sIHsgLi4ucCwgcmVmIH0pO1xyXG4gICAgY29uc3QgbWVyZ2VkV2l0aENoaWxkcmVuID0gdXNlTWVyZ2VkUHJvcHMoKSh0cmFuc2l0aW9uUHJvcHMsIGNoaWxkcmVuLnByb3BzKTtcclxuICAgIHJldHVybiBjbG9uZUVsZW1lbnQoY2hpbGRyZW4sIG1lcmdlZFdpdGhDaGlsZHJlbik7XHJcbn0pO1xyXG4vLyBJZiBcImlubGluZVwiIGlzbid0IGV4cGxpY2l0bHkgcHJvdmlkZWQsIHdlIHRyeSB0byBpbXBsaWNpdGx5IGRvIGl0IGJhc2VkIG9uIHRoZSBjaGlsZCdzIHRhZy5cclxuLy8gTm90IHBlcmZlY3QsIGJ1dCBpdCdzIG5vdCBzdXBwb3NlZCB0byBiZS4gYGlubGluZWAgaXMgZm9yIHBlcmZlY3QuXHJcbmNvbnN0IGlubGluZUVsZW1lbnRzID0gbmV3IFNldChbXHJcbiAgICBcImFcIixcclxuICAgIFwiYWJiclwiLFxyXG4gICAgXCJhY3JvbnltXCIsXHJcbiAgICBcImF1ZGlvXCIsXHJcbiAgICBcImJcIixcclxuICAgIFwiYmRpXCIsXHJcbiAgICBcImJkb1wiLFxyXG4gICAgXCJiaWdcIixcclxuICAgIFwiYnJcIixcclxuICAgIFwiYnV0dG9uXCIsXHJcbiAgICBcImNhbnZhc1wiLFxyXG4gICAgXCJjaXRlXCIsXHJcbiAgICBcImNvZGVcIixcclxuICAgIFwiZGF0YVwiLFxyXG4gICAgXCJkYXRhbGlzdFwiLFxyXG4gICAgXCJkZWxcIixcclxuICAgIFwiZGZuXCIsXHJcbiAgICBcImVtXCIsXHJcbiAgICBcImVtYmVkXCIsXHJcbiAgICBcImlcIixcclxuICAgIFwiaWZyYW1lXCIsXHJcbiAgICBcImltZ1wiLFxyXG4gICAgXCJpbnB1dFwiLFxyXG4gICAgXCJpbnNcIixcclxuICAgIFwia2JkXCIsXHJcbiAgICBcImxhYmVsXCIsXHJcbiAgICBcIm1hcFwiLFxyXG4gICAgXCJtYXJrXCIsXHJcbiAgICBcIm1ldGVyXCIsXHJcbiAgICBcIm5vc2NyaXB0XCIsXHJcbiAgICBcIm9iamVjdFwiLFxyXG4gICAgXCJvdXRwdXRcIixcclxuICAgIFwicGljdHVyZVwiLFxyXG4gICAgXCJwcm9ncmVzc1wiLFxyXG4gICAgXCJxXCIsXHJcbiAgICBcInJ1YnlcIixcclxuICAgIFwic1wiLFxyXG4gICAgXCJzYW1wXCIsXHJcbiAgICBcInNjcmlwdFwiLFxyXG4gICAgXCJzZWxlY3RcIixcclxuICAgIFwic2xvdFwiLFxyXG4gICAgXCJzbWFsbFwiLFxyXG4gICAgXCJzcGFuXCIsXHJcbiAgICBcInN0cm9uZ1wiLFxyXG4gICAgXCJzdWJcIixcclxuICAgIFwic3VwXCIsXHJcbiAgICBcInN2Z1wiLFxyXG4gICAgXCJ0ZW1wbGF0ZVwiLFxyXG4gICAgXCJ0ZXh0YXJlYVwiLFxyXG4gICAgXCJ0aW1lXCIsXHJcbiAgICBcInVcIixcclxuICAgIFwidHRcIixcclxuICAgIFwidmFyXCIsXHJcbiAgICBcInZpZGVvXCIsXHJcbiAgICBcIndiclwiXHJcbl0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2FwcGFibGUuanMubWFwIiwiZXhwb3J0IGNvbnN0IEV2ZW50RGV0YWlsID0gU3ltYm9sKFwiZXZlbnQtZGV0YWlsXCIpO1xyXG5leHBvcnQgZnVuY3Rpb24gZW5oYW5jZUV2ZW50KGUsIGRldGFpbCkge1xyXG4gICAgbGV0IGV2ZW50ID0gZTtcclxuICAgIGV2ZW50W0V2ZW50RGV0YWlsXSA9IGRldGFpbDtcclxuICAgIHJldHVybiBldmVudDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wcy5qcy5tYXAiLCJpbXBvcnQgeyB1c2VNZXJnZWRQcm9wcywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxubGV0IHB1bHNlID0gKFwidmlicmF0ZVwiIGluIG5hdmlnYXRvcikgPyAoKCkgPT4gbmF2aWdhdG9yLnZpYnJhdGUoMTApKSA6ICgoKSA9PiB7IH0pO1xyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBlbmFibGUvZGlzYWJsZSBidXR0b24gdmlicmF0aW9uIHB1bHNlcyBvbiBhbiBhcHAtd2lkZSBzY2FsZS5cclxuICpcclxuICpcclxuICogQHBhcmFtIGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGEgYnV0dG9uIGlzIHRhcHBlZC5cclxuICogKERlZmF1bHQgaXMgYCgpID0+IG5hdmlnYXRvci52aWJyYXRlKDEwKWAgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LCBhIG5vb3Agb3RoZXJ3aXNlKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldEJ1dHRvblZpYnJhdGUoZnVuYykge1xyXG4gICAgcHVsc2UgPSBmdW5jO1xyXG59XHJcbmZ1bmN0aW9uIGV4Y2x1ZGVzKHRhZywgdGFyZ2V0LCBleGNsdWRlKSB7XHJcbiAgICBpZiAoZXhjbHVkZT8uW3RhcmdldF0pXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAodGFyZ2V0ID09PSBcInNwYWNlXCIgfHwgdGFyZ2V0ID09PSBcImVudGVyXCIpXHJcbiAgICAgICAgcmV0dXJuIHRhZyA9PSBcImJ1dHRvblwiO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBFYXN5IHdheSB0byBcInBvbHlmaWxsXCIgYnV0dG9uLWxpa2UgaW50ZXJhY3Rpb25zIG9udG8sIGUuZy4sIGEgZGl2LlxyXG4gKlxyXG4gKiBBZGRzIGNsaWNrLCBzcGFjZSBvbiBrZXlEb3duLCBhbmQgZW50ZXIgb24ga2V5VXAsIGFzIHdlbGwgYXMgaGFwdGljXHJcbiAqIGZlZWRiYWNrIHZpYSBhIG1vbWVudGFyeSB2aWJyYXRpb24gcHVsc2Ugd2hlbiB0aGVyZSdzIGFuIG9uQ2xpY2sgaGFuZGxlciBwcm92aWRlZFxyXG4gKiAodGhpcyBjYW4gYmUgZGlzYWJsZWQgYXBwLXdpZGUgd2l0aCBgc2V0QnV0dG9uVmlicmF0ZWApLlxyXG4gKlxyXG4gKiBJbiBhZGRpdGlvbiwgd2hlbiB0aGUgQ1NTIGA6YWN0aXZlYCBwc2V1ZG8tY2xhc3Mgd291bGQgYXBwbHkgdG8gYSBub3JtYWwgYnV0dG9uXHJcbiAqIChpLmUuIHdoZW4gaG9sZGluZyB0aGUgc3BhY2ViYXIgb3IgZHVyaW5nIG1vdXNlZG93biksIGB7IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IFwidHJ1ZVwiIH1gXHJcbiAqIGlzIGFkZGVkIHRvIHRoZSBwcm9wcy4gIFlvdSBjYW4gZWl0aGVyIGxldCBpdCBwYXNzIHRocm91Z2ggYW5kIHN0eWxlIGl0IHRocm91Z2ggbmV3IENTUyxcclxuICogb3IgaW5zcGVjdCB0aGUgcmV0dXJuZWQgcHJvcHMgZm9yIGl0IGFuZCBhZGQgZS5nLiBhbiBgLmFjdGl2ZWAgY2xhc3MgZm9yIGV4aXN0aW5nIENTU1xyXG4gKlxyXG4gKiBAcGFyYW0gb25DbGlja1xyXG4gKiBAcGFyYW0gZXhjbHVkZSBXaGV0aGVyIHRoZSBwb2x5ZmlsbCBzaG91bGQgYXBwbHkgKGNhbiBzcGVjaWZ5IGZvciBzcGVjaWZpYyBpbnRlcmFjdGlvbnMpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnModGFnLCBvbkNsaWNrU3luYywgZXhjbHVkZSkge1xyXG4gICAgLy90eXBlIEUgPSBFdiBleHRlbmRzIGguSlNYLlRhcmdldGVkRXZlbnQ8aW5mZXIgRSwgYW55Pj8gRSA6IEV2ZW50VGFyZ2V0O1xyXG4gICAgY29uc3QgW2FjdGl2ZSwgc2V0QWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IG9uS2V5VXAgPSBleGNsdWRlcyh0YWcsIFwic3BhY2VcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZSkgPT4ge1xyXG4gICAgICAgIGlmIChlLmtleSA9PSBcIiBcIiAmJiBvbkNsaWNrU3luYykge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIG9uQ2xpY2tTeW5jKGUpO1xyXG4gICAgICAgICAgICBzZXRBY3RpdmUoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBvbk1vdXNlRG93biA9IGV4Y2x1ZGVzKHRhZywgXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKVxyXG4gICAgICAgICAgICBzZXRBY3RpdmUodHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgb25CbHVyID0gKGUpID0+IHtcclxuICAgICAgICBzZXRBY3RpdmUoZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG9uTW91c2VVcCA9IGV4Y2x1ZGVzKHRhZywgXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IG9uQmx1cjtcclxuICAgIGNvbnN0IG9uTW91c2VPdXQgPSBleGNsdWRlcyh0YWcsIFwiY2xpY2tcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiBvbkJsdXI7XHJcbiAgICBjb25zdCBvbktleURvd24gPSBleGNsdWRlcyh0YWcsIFwic3BhY2VcIiwgZXhjbHVkZSkgJiYgZXhjbHVkZXModGFnLCBcImVudGVyXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGUpID0+IHtcclxuICAgICAgICBpZiAoZS5rZXkgPT0gXCIgXCIgJiYgb25DbGlja1N5bmMgJiYgIWV4Y2x1ZGVzKHRhZywgXCJzcGFjZVwiLCBleGNsdWRlKSkge1xyXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBhY3RpdmF0ZSBpdCBvbiBhIHNwYWNlIGtleWRvd25cclxuICAgICAgICAgICAgLy8gYnV0IHdlIGRvIHByZXZlbnREZWZhdWx0IHRvIHN0b3AgdGhlIHBhZ2UgZnJvbSBzY3JvbGxpbmcuXHJcbiAgICAgICAgICAgIHNldEFjdGl2ZSh0cnVlKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZS5rZXkgPT0gXCJFbnRlclwiICYmIG9uQ2xpY2tTeW5jICYmICFleGNsdWRlcyh0YWcsIFwiZW50ZXJcIiwgZXhjbHVkZSkpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBvbkNsaWNrU3luYyhlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgb25DbGljazIgPSBleGNsdWRlcyh0YWcsIFwiY2xpY2tcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoKGUpID0+IHtcclxuICAgICAgICBpZiAob25DbGlja1N5bmMgJiYgIWV4Y2x1ZGVzKHRhZywgXCJjbGlja1wiLCBleGNsdWRlKSkge1xyXG4gICAgICAgICAgICBwdWxzZSgpO1xyXG4gICAgICAgICAgICBvbkNsaWNrU3luYyhlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAocHJvcHMpID0+IHVzZU1lcmdlZFByb3BzKCkoeyBvbktleURvd24sIG9uS2V5VXAsIG9uQ2xpY2s6IG9uQ2xpY2syLCBvbkJsdXIsIG9uTW91c2VEb3duLCBvbk1vdXNlVXAsIG9uTW91c2VPdXQsIC4uLnsgXCJkYXRhLXBzZXVkby1hY3RpdmVcIjogYWN0aXZlID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSB9LCBwcm9wcyk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFCdXR0b24oeyB0YWcsIHByZXNzZWQsIG9uQ2xpY2sgfSkge1xyXG4gICAgZnVuY3Rpb24gdXNlQXJpYUJ1dHRvblByb3BzKHsgXCJhcmlhLXByZXNzZWRcIjogYXJpYVByZXNzZWQsIHRhYkluZGV4LCByb2xlLCAuLi5wIH0pIHtcclxuICAgICAgICBjb25zdCBwcm9wcyA9IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzKHRhZywgKGUpID0+IG9uQ2xpY2s/LihlbmhhbmNlRXZlbnQoZSwgeyBwcmVzc2VkOiBwcmVzc2VkID09IG51bGwgPyBudWxsIDogIXByZXNzZWQgfSkpLCB1bmRlZmluZWQpKHApO1xyXG4gICAgICAgIGNvbnN0IGJ1dHRvblByb3BzID0geyByb2xlLCB0YWJJbmRleCwgXCJhcmlhLXByZXNzZWRcIjogYXJpYVByZXNzZWQgPz8gKHByZXNzZWQgPT09IHRydWUgPyBcInRydWVcIiA6IHByZXNzZWQgPT09IGZhbHNlID8gXCJmYWxzZVwiIDogdW5kZWZpbmVkKSB9O1xyXG4gICAgICAgIGNvbnN0IGRpdlByb3BzID0geyAuLi5idXR0b25Qcm9wcywgdGFiSW5kZXg6IHRhYkluZGV4ID8/IDAsIHJvbGU6IHJvbGUgPz8gXCJidXR0b25cIiB9O1xyXG4gICAgICAgIGNvbnN0IGFuY2hvclByb3BzID0geyAuLi5kaXZQcm9wcyB9O1xyXG4gICAgICAgIHN3aXRjaCAodGFnKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJidXR0b25cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKGJ1dHRvblByb3BzLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKShhbmNob3JQcm9wcywgcHJvcHMpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoZGl2UHJvcHMsIHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUFyaWFCdXR0b25Qcm9wc1xyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtYnV0dG9uLmpzLm1hcCIsImltcG9ydCB7IHVzZUNoaWxkRmxhZywgdXNlQ2hpbGRNYW5hZ2VyLCB1c2VMYXlvdXRFZmZlY3QsIHVzZUxpbmVhck5hdmlnYXRpb24sIHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzIH0gZnJvbSBcIi4vdXNlLWJ1dHRvblwiO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvbih7IGV4cGFuZGVkSW5kZXgsIHNldEV4cGFuZGVkSW5kZXggfSkge1xyXG4gICAgY29uc3QgW2xhc3RGb2N1c2VkSW5kZXgsIHNldExhc3RGb2N1c2VkSW5kZXgsIGdldExhc3RGb2N1c2VkSW5kZXhdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBzdGFibGVTZXRFeHBhbmRlZEluZGV4ID0gdXNlU3RhYmxlQ2FsbGJhY2soc2V0RXhwYW5kZWRJbmRleCA/PyAoKCkgPT4geyB9KSk7XHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZEFjY29yZGlvblNlY3Rpb25zLCB1c2VNYW5hZ2VkQ2hpbGQ6IHVzZU1hbmFnZWRDaGlsZFNlY3Rpb24gfSA9IHVzZUNoaWxkTWFuYWdlcigpO1xyXG4gICAgY29uc3QgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGQgfSA9IHVzZUxpbmVhck5hdmlnYXRpb24oeyBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRBY2NvcmRpb25TZWN0aW9ucywgbmF2aWdhdGlvbkRpcmVjdGlvbjogXCJibG9ja1wiLCBnZXRJbmRleDogZ2V0TGFzdEZvY3VzZWRJbmRleCwgc2V0SW5kZXg6IHNldExhc3RGb2N1c2VkSW5kZXggfSk7XHJcbiAgICAvLyBBbnkgdGltZSBsaXN0IG1hbmFnZW1lbnQgY2hhbmdlcyB0aGUgZm9jdXNlZCBpbmRleCwgbWFudWFsbHkgZm9jdXMgdGhlIGNoaWxkXHJcbiAgICAvLyBUT0RPOiBDYW4gdGhpcyBiZSBjdXQ/XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChsYXN0Rm9jdXNlZEluZGV4ICE9IG51bGwgJiYgbGFzdEZvY3VzZWRJbmRleCA+PSAwKVxyXG4gICAgICAgICAgICBtYW5hZ2VkQWNjb3JkaW9uU2VjdGlvbnNbbGFzdEZvY3VzZWRJbmRleF0/LmZvY3VzKCk7XHJcbiAgICB9LCBbbGFzdEZvY3VzZWRJbmRleF0pO1xyXG4gICAgdXNlQ2hpbGRGbGFnKGV4cGFuZGVkSW5kZXgsIG1hbmFnZWRBY2NvcmRpb25TZWN0aW9ucy5sZW5ndGgsIChpLCBvcGVuKSA9PiBtYW5hZ2VkQWNjb3JkaW9uU2VjdGlvbnNbaV0/LnNldE9wZW5Gcm9tUGFyZW50KG9wZW4pKTtcclxuICAgIGNvbnN0IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uID0gdXNlQ2FsbGJhY2soKGFyZ3MpID0+IHtcclxuICAgICAgICBjb25zdCBbb3BlbkZyb21QYXJlbnQsIHNldE9wZW5Gcm9tUGFyZW50LCBnZXRPcGVuRnJvbVBhcmVudF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgICAgICBjb25zdCB7IHJhbmRvbUlkOiBib2R5UmFuZG9tSWQsIHVzZVJhbmRvbUlkUHJvcHM6IHVzZUJvZHlSYW5kb21JZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlUmVmZXJlbmNlZEJvZHlJZFByb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLWFjY29yZGlvbi1zZWN0aW9uLWJvZHktXCIgfSk7XHJcbiAgICAgICAgY29uc3QgeyByYW5kb21JZDogaGVhZFJhbmRvbUlkLCB1c2VSYW5kb21JZFByb3BzOiB1c2VIZWFkUmFuZG9tSWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRIZWFkSWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1hY2NvcmRpb24tc2VjdGlvbi1oZWFkZXItXCIgfSk7XHJcbiAgICAgICAgbGV0IG9wZW4gPSAoKGFyZ3Mub3BlbiA/PyBvcGVuRnJvbVBhcmVudCkgPz8gbnVsbCk7XHJcbiAgICAgICAgLy8gVE9ETzogQ29udmVydCB0byB1c2UgdXNlTWFuYWdlZENoaWxkIHNvIHRoYXQgdGhpcyBob29rIFxyXG4gICAgICAgIC8vIGlzIHN0YWJsZSB3aXRob3V0IChkaXJlY3RseSkgZGVwZW5kaW5nIG9uIHRoZSBvcGVuIHN0YXRlLlxyXG4gICAgICAgIGNvbnN0IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXIoeyB0YWcgfSkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcywgZWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHsgZWxlbWVudD8uZm9jdXMoKTsgfSwgW2VsZW1lbnRdKTtcclxuICAgICAgICAgICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGRQcm9wcyB9ID0gdXNlTWFuYWdlZENoaWxkU2VjdGlvbih7IGluZGV4OiBhcmdzLmluZGV4LCBvcGVuOiBvcGVuLCBzZXRPcGVuRnJvbVBhcmVudCwgZm9jdXMgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkUHJvcHMgfSA9IHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZCgpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzKHsgW1wiYXJpYS1leHBhbmRlZFwiXTogYXJpYUV4cGFuZGVkLCBbXCJhcmlhLWRpc2FibGVkXCJdOiBhcmlhRGlzYWJsZWQsIC4uLnByb3BzIH0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9uRm9jdXMgPSAoKSA9PiB7IHNldExhc3RGb2N1c2VkSW5kZXgoYXJncy5pbmRleCk7IH07XHJcbiAgICAgICAgICAgICAgICBsZXQgb25DbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0T3BlbkZyb21QYXJlbnQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhYmxlU2V0RXhwYW5kZWRJbmRleChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWJsZVNldEV4cGFuZGVkSW5kZXgoYXJncy5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHJldEIgPSB1c2VNZXJnZWRQcm9wcygpKHsgdGFiSW5kZXg6IDAgfSwgdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnModGFnLCBvbkNsaWNrLCB1bmRlZmluZWQpKHByb3BzKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmV0MyA9IHVzZU1lcmdlZFByb3BzKCkodXNlSGVhZFJhbmRvbUlkUHJvcHModXNlUmVmZXJlbmNlZEJvZHlJZFByb3BzKFwiYXJpYS1jb250cm9sc1wiKSh7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IChhcmlhRXhwYW5kZWQgPz8gKCEhb3BlbikudG9TdHJpbmcoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IChhcmlhRGlzYWJsZWQgPz8gKG9wZW4gPyBcInRydWVcIiA6IHVuZGVmaW5lZCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLnVzZVJlZkVsZW1lbnRQcm9wcyh1c2VNYW5hZ2VkQ2hpbGRQcm9wcyhyZXRCKSlcclxuICAgICAgICAgICAgICAgIH0pKSwgeyBvbkZvY3VzIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZFByb3BzKHJldDMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcyB9O1xyXG4gICAgICAgIH0sIFtvcGVuXSk7XHJcbiAgICAgICAgY29uc3QgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5KCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyh7IHJvbGUsIC4uLnByb3BzIH0pIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXQxID0gdXNlUmVmZXJlbmNlZEhlYWRJZFByb3BzKFwiYXJpYS1sYWJlbGxlZGJ5XCIpKHsgcm9sZTogcm9sZSA/PyBcInJlZ2lvblwiLCAuLi5wcm9wcyB9KTtcclxuICAgICAgICAgICAgICAgIGxldCByZXQyID0gdXNlQm9keVJhbmRvbUlkUHJvcHMocmV0MSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0MjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sIFtdKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBleHBhbmRlZDogb3BlbixcclxuICAgICAgICAgICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXIsXHJcbiAgICAgICAgICAgIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keSxcclxuICAgICAgICB9O1xyXG4gICAgfSwgW3VzZUxpbmVhck5hdmlnYXRpb25DaGlsZF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvblxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtYWNjb3JkaW9uLmpzLm1hcCIsImltcG9ydCB7IHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VCdXR0b25MaWtlRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcclxuLyoqXHJcbiAqIEFkZHMgYW4gSUQgYW5kIFwiYXJpYS1sYWJlbGxlZGJ5XCIgZm9yIHR3byBlbGVtZW50cywgYW4gXCJpbnB1dFwiIGVsZW1lbnQgYW5kIGEgXCJsYWJlbFwiIGVsZW1lbnQuXHJcbiAqXHJcbiAqIFJldHVybnMgdGhlIGB1c2VSZWZlcmVuY2VkSWRQcm9wc2AgaG9va3MgaWYgeW91IG5lZWQgdG8gYWxzbyBhZGQgb3RoZXIgSUQtcmVmZXJlbmNpbmcgYXR0cmlidXRlcywgbGlrZSBgZm9yYFxyXG4gKlxyXG4gKiBAc2VlIHVzZUlucHV0TGFiZWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VHZW5lcmljTGFiZWwoeyBsYWJlbFByZWZpeCwgaW5wdXRQcmVmaXgsIGJhY2t1cFRleHQgfSA9IHsgbGFiZWxQcmVmaXg6IFwibGFiZWwtXCIsIGlucHV0UHJlZml4OiBcImlucHV0LVwiIH0pIHtcclxuICAgIGNvbnN0IHsgZWxlbWVudDogbGFiZWxFbGVtZW50LCBnZXRFbGVtZW50OiBnZXRMYWJlbEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlTGFiZWxSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgIGNvbnN0IHsgZWxlbWVudDogaW5wdXRFbGVtZW50LCBnZXRFbGVtZW50OiBnZXRJbnB1dEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlSW5wdXRSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlTGFiZWxSYW5kb21JZFByb3BzLCBpZDogbGFiZWxJZCwgcmFuZG9tSWQ6IGxhYmVsUmFuZG9tSWQsIHVzZVJlZmVyZW5jZWRJZFByb3BzOiB1c2VSZWZlcmVuY2VkTGFiZWxJZFByb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogbGFiZWxQcmVmaXggfSk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUHJvcHM6IHVzZUlucHV0UmFuZG9tSWRQcm9wcywgaWQ6IGlucHV0SWQsIHJhbmRvbUlkOiBpbnB1dFJhbmRvbUlkLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlUmVmZXJlbmNlZElucHV0SWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IGlucHV0UHJlZml4IH0pO1xyXG4gICAgY29uc3QgbGFiZWxIYXNNb3VudGVkID0gISEobGFiZWxFbGVtZW50KTtcclxuICAgIGNvbnN0IGlucHV0SGFzTW91bnRlZCA9ICEhKGlucHV0RWxlbWVudCk7XHJcbiAgICBjb25zdCB1c2VHZW5lcmljTGFiZWxMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUdlbmVyaWNMYWJlbExhYmVsKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHM6IChwcm9wcykgPT4geyByZXR1cm4gdXNlTGFiZWxSYW5kb21JZFByb3BzKHVzZUxhYmVsUmVmRWxlbWVudFByb3BzKHByb3BzKSk7IH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3QgdXNlR2VuZXJpY0xhYmVsSW5wdXQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VHZW5lcmljTGFiZWxJbnB1dCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VHZW5lcmljTGFiZWxJbnB1dFByb3BzOiAoeyBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRieSwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCwgLi4ucHJvcHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh1c2VJbnB1dFJhbmRvbUlkUHJvcHModXNlUmVmZXJlbmNlZExhYmVsSWRQcm9wcyhcImFyaWEtbGFiZWxsZWRieVwiKSh1c2VJbnB1dFJlZkVsZW1lbnRQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHsgXCJhcmlhLWxhYmVsXCI6ICghbGFiZWxIYXNNb3VudGVkID8gYmFja3VwVGV4dCA6IGFyaWFMYWJlbCkgPz8gYXJpYUxhYmVsIH0sIHByb3BzKSkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW2xhYmVsSGFzTW91bnRlZF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VHZW5lcmljTGFiZWxJbnB1dCxcclxuICAgICAgICB1c2VHZW5lcmljTGFiZWxMYWJlbCxcclxuICAgICAgICB1c2VSZWZlcmVuY2VkTGFiZWxJZFByb3BzLFxyXG4gICAgICAgIHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMsXHJcbiAgICAgICAgbGFiZWxJZCxcclxuICAgICAgICBpbnB1dElkLFxyXG4gICAgICAgIGxhYmVsRWxlbWVudCxcclxuICAgICAgICBpbnB1dEVsZW1lbnQsXHJcbiAgICAgICAgZ2V0TGFiZWxFbGVtZW50LFxyXG4gICAgICAgIGdldElucHV0RWxlbWVudCxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEhhbmRsZXMgdGhlIGF0dHJpYnV0ZXMgYGlkYCwgYGZvcmAsIGFuZCBgYXJpYS1sYWJlbGxlZGJ5YCBmb3IgdG8gcmVsYXRlZCBlbGVtZW50cy5cclxuICpcclxuICogSXQncyBhc3N1bWVkIHRoYXQgdGhlIGxhYmVsIGlzIGFuIGBIVE1MTGFiZWxFbGVtZW50YCwgYW5kIHRoZSBpbnB1dCBpcyBzb21ldGhpbmcgZm9yIHdoaWNoXHJcbiAqIHRoZSBgZm9yYCBhdHRyaWJ1dGUgY2FuIHJlZmVyZW5jZS5cclxuICpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnB1dExhYmVsKHsgbGFiZWxQcmVmaXgsIGlucHV0UHJlZml4IH0gPSB7IGxhYmVsUHJlZml4OiBcImxhYmVsLVwiLCBpbnB1dFByZWZpeDogXCJpbnB1dC1cIiB9KSB7XHJcbiAgICBjb25zdCB7IHVzZUdlbmVyaWNMYWJlbElucHV0LCB1c2VHZW5lcmljTGFiZWxMYWJlbCwgdXNlUmVmZXJlbmNlZElucHV0SWRQcm9wcywgdXNlUmVmZXJlbmNlZExhYmVsSWRQcm9wcywgaW5wdXRJZCwgbGFiZWxJZCwgaW5wdXRFbGVtZW50LCBnZXRJbnB1dEVsZW1lbnQsIGxhYmVsRWxlbWVudCwgZ2V0TGFiZWxFbGVtZW50IH0gPSB1c2VHZW5lcmljTGFiZWwoeyBsYWJlbFByZWZpeCwgaW5wdXRQcmVmaXggfSk7XHJcbiAgICBjb25zdCB1c2VJbnB1dExhYmVsTGFiZWwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VJbnB1dExhYmVsTGFiZWwoeyB0YWcgfSkge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlR2VuZXJpY0xhYmVsTGFiZWxQcm9wcyB9ID0gdXNlR2VuZXJpY0xhYmVsTGFiZWwoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VJbnB1dExhYmVsTGFiZWxQcm9wcyhwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aEZvciA9IHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMoXCJmb3JcIikocHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aG91dEZvciA9IHByb3BzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHModGFnID09IFwibGFiZWxcIiA/IHdpdGhGb3IgOiB3aXRob3V0Rm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbdXNlR2VuZXJpY0xhYmVsSW5wdXRdKTtcclxuICAgIGNvbnN0IHVzZUlucHV0TGFiZWxJbnB1dCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUlucHV0TGFiZWxJbnB1dCgpIHtcclxuICAgICAgICBjb25zdCB7IHVzZUdlbmVyaWNMYWJlbElucHV0UHJvcHMgfSA9IHVzZUdlbmVyaWNMYWJlbElucHV0KCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlSW5wdXRMYWJlbElucHV0UHJvcHMocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VHZW5lcmljTGFiZWxJbnB1dFByb3BzKHByb3BzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbdXNlR2VuZXJpY0xhYmVsTGFiZWxdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlSW5wdXRMYWJlbExhYmVsLFxyXG4gICAgICAgIHVzZUlucHV0TGFiZWxJbnB1dCxcclxuICAgICAgICBsYWJlbElkLFxyXG4gICAgICAgIGlucHV0SWQsXHJcbiAgICAgICAgaW5wdXRFbGVtZW50LFxyXG4gICAgICAgIGxhYmVsRWxlbWVudCxcclxuICAgICAgICBnZXRJbnB1dEVsZW1lbnQsXHJcbiAgICAgICAgZ2V0TGFiZWxFbGVtZW50XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IGhhbmRsZXNJbnB1dCA9ICh0YWcsIGxhYmVsUG9zaXRpb24sIHdoaWNoKSA9PiB7XHJcbiAgICBpZiAobGFiZWxQb3NpdGlvbiA9PT0gXCJzZXBhcmF0ZVwiKSB7XHJcbiAgICAgICAgaWYgKHdoaWNoID09PSBcImlucHV0LWVsZW1lbnRcIilcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZWxzZSBpZiAod2hpY2ggPT09IFwibGFiZWwtZWxlbWVudFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gdGFnICE9IFwiaW5wdXRcIjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT09IFwid3JhcHBpbmdcIikge1xyXG4gICAgICAgIGlmICh3aGljaCA9PT0gXCJpbnB1dC1lbGVtZW50XCIpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAod2hpY2ggPT0gXCJsYWJlbC1lbGVtZW50XCIpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogSGFuZGxlcyBsYWJlbCB0eXBlICh3cmFwcGluZyBvciBzZXBhcmF0ZSkgZm9yIGNoZWNrYm94ZXMsIHJhZGlvcywgc3dpdGNoZXMsIGV0Yy5cclxuICogQHBhcmFtIHBhcmFtMFxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoZWNrYm94TGlrZSh7IGNoZWNrZWQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCBvbklucHV0LCByb2xlIH0pIHtcclxuICAgIGNvbnN0IHN0YWJsZU9uSW5wdXQgPSB1c2VTdGFibGVDYWxsYmFjaygoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCk7IG9uSW5wdXQ/LihlKTsgfSk7XHJcbiAgICBjb25zdCB7IGlucHV0SWQsIGxhYmVsSWQsIHVzZUlucHV0TGFiZWxJbnB1dDogdXNlSUxJbnB1dCwgdXNlSW5wdXRMYWJlbExhYmVsOiB1c2VJTExhYmVsLCBnZXRMYWJlbEVsZW1lbnQsIGdldElucHV0RWxlbWVudCB9ID0gdXNlSW5wdXRMYWJlbCh7IGxhYmVsUHJlZml4OiBcImFyaWEtY2hlY2tib3gtbGFiZWwtXCIsIGlucHV0UHJlZml4OiBcImFyaWEtY2hlY2tib3gtaW5wdXQtXCIgfSk7XHJcbiAgICBjb25zdCB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VDaGVja2JveElucHV0RWxlbWVudCh7IHRhZyB9KSB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VJbnB1dExhYmVsSW5wdXRQcm9wczogdXNlSUxJbnB1dFByb3BzIH0gPSB1c2VJTElucHV0KCk7XHJcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgICAgICAvLyBvbkNsaWNrIGFuZCBvbkNoYW5nZSBhcmUgYSBiaXQgbWVzc3ksIHNvIHdlIG5lZWQgdG9cclxuICAgICAgICAvLyAqYWx3YXlzKiBtYWtlIHN1cmUgdGhhdCB0aGUgdmlzaWJsZSBzdGF0ZSBpcyBjb3JyZWN0XHJcbiAgICAgICAgLy8gYWZ0ZXIgYWxsIHRoZSBldmVudCBkdXN0IHNldHRsZXMuXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzI3NDUsXHJcbiAgICAgICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzE4OTkjaXNzdWVjb21tZW50LTUyNTY5MDE5NFxyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHRhZyA9PSBcImlucHV0XCIpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IGNoZWNrZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbdGFnLCBlbGVtZW50LCBjaGVja2VkXSk7XHJcbiAgICAgICAgcmV0dXJuIHsgaW5wdXRFbGVtZW50OiBlbGVtZW50LCB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyB9O1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzKHsgLi4ucDAgfSkge1xyXG4gICAgICAgICAgICAvLyBGb3Igc29tZSByZWFzb24sIENocm9tZSB3b24ndCBmaXJlIG9uSW5wdXQgZXZlbnRzIGZvciByYWRpbyBidXR0b25zIHRoYXQgYXJlIHRhYkluZGV4PS0xPz9cclxuICAgICAgICAgICAgLy8gTmVlZHMgaW52ZXN0aWdhdGluZywgYnV0IG9uSW5wdXQgd29ya3MgZmluZSBpbiBGaXJlZm94XHJcbiAgICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICAgICAgbGV0IHByb3BzID0gdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnModGFnLCBkaXNhYmxlZCB8fCAhaGFuZGxlc0lucHV0KHRhZywgbGFiZWxQb3NpdGlvbiwgXCJpbnB1dC1lbGVtZW50XCIpID8gdW5kZWZpbmVkIDogc3RhYmxlT25JbnB1dCwgdW5kZWZpbmVkKSh7fSk7XHJcbiAgICAgICAgICAgIGlmICh0YWcgPT0gXCJpbnB1dFwiKVxyXG4gICAgICAgICAgICAgICAgcHJvcHMub25JbnB1dCA9IChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHByb3BzID0gdXNlUmVmRWxlbWVudFByb3BzKHVzZUlMSW5wdXRQcm9wcyhwcm9wcykpO1xyXG4gICAgICAgICAgICBpZiAobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlIHdyYXBwZWQgbGFiZWwgaGFuZGxlcyBhbGwgaW50ZXJhY3Rpb25zLFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhpcyBlbGVtZW50IGNhbid0IGJlIGludGVyYWN0ZWQgd2l0aFxyXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpZiBpdCdzIGFuIGlucHV0IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICBwcm9wcy5pbmVydCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy50YWJJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgcHJvcHMub25Gb2N1cyA9IGUgPT4gZ2V0TGFiZWxFbGVtZW50KCkuZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YWcgPT09IFwiaW5wdXRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNoZWNrZWQgPSBjaGVja2VkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMucm9sZSA9IHJvbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1jaGVja2VkXCJdID0gY2hlY2tlZCA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWRpc2FibGVkXCJdID0gZGlzYWJsZWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBsYWJlbCBjbGlja3MgY2FuJ3QgYWZmZWN0IHRoZSBjaGVja2JveCB3aGlsZSBpdCdzIGRpc2FibGVkXHJcbiAgICAgICAgICAgIHByb3BzLm9uQ2xpY2sgPSBkaXNhYmxlZCA/ICgoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCk7IH0pIDogcHJvcHMub25DbGljaztcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkocDAsIHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbdXNlSUxJbnB1dCwgcm9sZSwgbGFiZWxQb3NpdGlvbiwgZGlzYWJsZWQsIGNoZWNrZWRdKTtcclxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KHsgdGFnIH0pIHtcclxuICAgICAgICBjb25zdCB7IHVzZUlucHV0TGFiZWxMYWJlbFByb3BzOiB1c2VJTExhYmVsUHJvcHMgfSA9IHVzZUlMTGFiZWwoeyB0YWcgfSk7XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMoeyAuLi5wMCB9KSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzKFwiZGl2XCIsIGRpc2FibGVkIHx8ICFoYW5kbGVzSW5wdXQodGFnLCBsYWJlbFBvc2l0aW9uLCBcImxhYmVsLWVsZW1lbnRcIikgPyB1bmRlZmluZWQgOiBzdGFibGVPbklucHV0LCB1bmRlZmluZWQpKHt9KTtcclxuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdQcm9wcy50YWJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBuZXdQcm9wcy5yb2xlID0gcm9sZTtcclxuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IGRpc2FibGVkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1tcImFyaWEtY2hlY2tlZFwiXSA9IGNoZWNrZWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBvbmUgY2FzZSB3aGVyZSB0aGVyZSdzIGFsbW9zdCBub3RoaW5nIHRvIGRvXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBub3JtYWwgY2FzZSB3aGVyZSBldmVyeXRoaW5nIGFjdHMgYWNjb3JkaW5nIG5vcm1hbCBIVE1MIG1lY2hhbmljcy5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBKdXN0IG1ha2Ugc3VyZSB0aGF0IGxhYmVsIGNsaWNrcyBjYW4ndCBhZmZlY3QgdGhlIGNoZWNrYm94IHdoaWxlIGl0J3MgZGlzYWJsZWRcclxuICAgICAgICAgICAgbmV3UHJvcHMub25DbGljayA9IGRpc2FibGVkID8gKChlKSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgfSkgOiBuZXdQcm9wcy5vbkNsaWNrO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKShuZXdQcm9wcywgdXNlSUxMYWJlbFByb3BzKHAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzIH07XHJcbiAgICB9LCBbdXNlSUxMYWJlbCwgZGlzYWJsZWQsIGNoZWNrZWQsIHJvbGUsIGxhYmVsUG9zaXRpb25dKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LFxyXG4gICAgICAgIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCxcclxuICAgICAgICBnZXRMYWJlbEVsZW1lbnQsXHJcbiAgICAgICAgZ2V0SW5wdXRFbGVtZW50XHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1sYWJlbC5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQ2hlY2tib3hMaWtlIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhQ2hlY2tib3goeyBsYWJlbFBvc2l0aW9uLCBjaGVja2VkLCBvbklucHV0LCBkaXNhYmxlZCB9KSB7XHJcbiAgICBjb25zdCBvbklucHV0RW5oYW5jZWQgPSAoZSkgPT4gb25JbnB1dD8uKGVuaGFuY2VFdmVudChlLCB7IGNoZWNrZWQ6ICFjaGVja2VkIH0pKTtcclxuICAgIGNvbnN0IHsgZ2V0SW5wdXRFbGVtZW50LCBnZXRMYWJlbEVsZW1lbnQsIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50IH0gPSB1c2VDaGVja2JveExpa2UoeyBjaGVja2VkOiAhIWNoZWNrZWQsIGxhYmVsUG9zaXRpb24sIHJvbGU6IFwiY2hlY2tib3hcIiwgZGlzYWJsZWQsIG9uSW5wdXQ6IG9uSW5wdXRFbmhhbmNlZCB9KTtcclxuICAgIGNvbnN0IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoeyB0YWcgfSkge1xyXG4gICAgICAgIGNvbnN0IHsgaW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50KHsgdGFnIH0pO1xyXG4gICAgICAgIGNvbnN0IGlzTWl4ZWQgPSAoY2hlY2tlZCA9PSBcIm1peGVkXCIpO1xyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dEVsZW1lbnQgJiYgdGFnID09PSBcImlucHV0XCIpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0RWxlbWVudC5pbmRldGVybWluYXRlID0gaXNNaXhlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtpbnB1dEVsZW1lbnQsIGlzTWl4ZWQsIHRhZ10pO1xyXG4gICAgICAgIHJldHVybiB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMgfTtcclxuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKHsgLi4ucDAgfSkge1xyXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyhwMCk7XHJcbiAgICAgICAgICAgIHByb3BzLmNoZWNrZWQgPz89ICEhY2hlY2tlZDtcclxuICAgICAgICAgICAgaWYgKHRhZyA9PSBcImlucHV0XCIpXHJcbiAgICAgICAgICAgICAgICBwcm9wcy50eXBlID0gXCJjaGVja2JveFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2NoZWNrZWQsIGxhYmVsUG9zaXRpb24sIGRpc2FibGVkXSk7XHJcbiAgICBjb25zdCB1c2VDaGVja2JveExhYmVsRWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KHsgdGFnIH0pIHtcclxuICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQoeyB0YWcgfSk7XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyh7IC4uLnByb3BzIH0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzKHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgICAgIHJldHVybiB7IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMgfTtcclxuICAgIH0sIFt1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50LFxyXG4gICAgICAgIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50XHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1jaGVja2JveC5qcy5tYXAiLCJpbXBvcnQgeyB1c2VGb2N1c1RyYXAsIHVzZUdsb2JhbEhhbmRsZXIsIHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuLyoqXHJcbiAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIGEgbW9kYWwtbGlrZSBzb2Z0LWRpc21pc3MgaW50ZXJhY3Rpb24uXHJcbiAqXHJcbiAqIFRoYXQgaXMsIGFueSBjbGlja3Mgb3IgdGFwcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBjb21wb25lbnQsXHJcbiAqIG9yIGFueSB0aW1lIHRoZSBFc2NhcGUga2V5IGlzIHByZXNzZWQgd2l0aGluIHRoZSBjb21wb25lbnQsXHJcbiAqICh3aXRoIHZhcmlvdXMgYnJvd3NlciBvZGRpdGllcyByZWdhcmRpbmcgY2xpY2tzIG9uIGJsYW5rIG9yIGluZXJ0IGFyZWFzIGhhbmRsZWQpXHJcbiAqIHRoZSBjb21wb25lbnQgd2lsbCByZXF1ZXN0IHRvIGNsb3NlIGl0c2VsZi5cclxuICpcclxuICogT2YgY291cnNlLCBpZiB5b3UgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhlIGBvbkNsb3NlYCBmdW5jdGlvbixcclxuICogaXQgd29uJ3QgYmUgYSBzb2Z0IGRpc21pc3MgYW55bW9yZS5cclxuICpcclxuICogQHBhcmFtIHBhcmFtMFxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNvZnREaXNtaXNzKHsgb25DbG9zZSB9KSB7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgZnVuY3Rpb24gb25CYWNrZHJvcENsaWNrKGUpIHtcclxuICAgICAgICAvLyBCYXNpY2FsbHksIFwid2FzIHRoaXMgZXZlbnQgZmlyZWQgb24gdGhlIHJvb3QtbW9zdCBlbGVtZW50LCBvciBhdCBsZWFzdCBhbiBlbGVtZW50IG5vdCBjb250YWluZWQgYnkgdGhlIG1vZGFsP1wiXHJcbiAgICAgICAgLy8gRWl0aGVyIGNvdWxkIGJlIGhvdyB0aGUgYnJvd3NlciBoYW5kbGVzIHRoZXNlIHNvcnRzIG9mIFwiaW50ZXJhY3Rpbmcgd2l0aCBub3RoaW5nXCIgZXZlbnRzLlxyXG4gICAgICAgIGlmIChlLnRhcmdldCA9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgIShlbGVtZW50ICYmIGUudGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCAmJiBlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCAmJiBlbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0KSkpIHtcclxuICAgICAgICAgICAgb25DbG9zZShcImJhY2tkcm9wXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFNpbmNlIGV2ZXJ5dGhpbmcgZWxzZSBpcyBpbmVydCwgd2UgbGlzdGVuIGZvciBjYXB0dXJlZCBjbGlja3Mgb24gdGhlIHdpbmRvd1xyXG4gICAgLy8gKHdlIGRvbid0IHVzZSBvbkNsaWNrIHNpbmNlIHRoYXQgZG9lc24ndCBmaXJlIHdoZW4gY2xpY2tlZCBvbiBlbXB0eS9pbmVydCBhcmVhcylcclxuICAgIC8vIE5vdGU6IFdlIG5lZWQgYSAqc2VwYXJhdGUqIHRvdWNoIGV2ZW50IG9uIG1vYmlsZSBTYWZhcmksIGJlY2F1c2VcclxuICAgIC8vIGl0IGRvZXNuJ3QgbGV0IGNsaWNrIGV2ZW50cyBidWJibGUgb3IgYmUgY2FwdHVyZWQgZnJvbSB0cmFkaXRpb25hbGx5IG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cyxcclxuICAgIC8vIGJ1dCB0b3VjaCBldmVudHMgd29yayBhcyBleHBlY3RlZC5cclxuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcIm1vdXNlZG93blwiLCAhb3BlbiA/IG51bGwgOiBvbkJhY2tkcm9wQ2xpY2ssIHsgY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcInRvdWNoc3RhcnRcIiwgIW9wZW4gPyBudWxsIDogb25CYWNrZHJvcENsaWNrLCB7IGNhcHR1cmU6IHRydWUgfSk7XHJcbiAgICBjb25zdCBvbktleURvd24gPSAoZSkgPT4ge1xyXG4gICAgICAgIGlmIChlLmtleSA9PT0gXCJFc2NhcGVcIikge1xyXG4gICAgICAgICAgICBvbkNsb3NlKFwiZXNjYXBlXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4geyB1c2VTb2Z0RGlzbWlzc1Byb3BzOiAocHJvcHMpID0+IHVzZU1lcmdlZFByb3BzKCkodXNlUmVmRWxlbWVudFByb3BzKHsgb25LZXlEb3duIH0pLCBwcm9wcykgfTtcclxufVxyXG4vKipcclxuICogQSBnZW5lcmljIG1vZGFsIGhvb2ssIHVzZWQgYnkgbW9kYWwgZGlhbG9ncywgYnV0IGNhbiBhbHNvXHJcbiAqIGJlIHVzZWQgYnkgYW55dGhpbmcgdGhhdCdzIG1vZGFsIHdpdGggYSBiYWNrZHJvcC5cclxuICogQHBhcmFtIHBhcmFtMFxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFNb2RhbCh7IG9wZW4sIG9uQ2xvc2UgfSkge1xyXG4gICAgY29uc3Qgc3RhYmxlT25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UpO1xyXG4gICAgY29uc3QgW21vZGFsRGVzY3JpYmVkQnlCb2R5LCBzZXRNb2RhbERlc2NyaWJlZEJ5Qm9keV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICB1c2VIaWRlU2Nyb2xsKG9wZW4pO1xyXG4gICAgY29uc3QgeyBpZDogbW9kYWxJZCwgdXNlUmFuZG9tSWRQcm9wczogdXNlTW9kYWxJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlTW9kYWxSZWZlcmVuY2luZ0lkUHJvcHMgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtbW9kYWwtXCIgfSk7XHJcbiAgICBjb25zdCB7IGlkOiBib2R5SWQsIHVzZVJhbmRvbUlkUHJvcHM6IHVzZUJvZHlJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlQm9keVJlZmVyZW5jaW5nSWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1tb2RhbC1ib2R5LVwiIH0pO1xyXG4gICAgY29uc3QgeyBpZDogdGl0bGVJZCwgdXNlUmFuZG9tSWRQcm9wczogdXNlVGl0bGVJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlVGl0bGVSZWZlcmVuY2luZ0lkUHJvcHMgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtbW9kYWwtdGl0bGUtXCIgfSk7XHJcbiAgICBjb25zdCB7IHVzZVNvZnREaXNtaXNzUHJvcHMgfSA9IHVzZVNvZnREaXNtaXNzKHsgb25DbG9zZTogc3RhYmxlT25DbG9zZSB9KTtcclxuICAgIGNvbnN0IHVzZU1vZGFsQmFja2Ryb3AgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VNb2RhbEJhY2tkcm9wKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZU1vZGFsQmFja2Ryb3BQcm9wcyhwcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IG9uUG9pbnRlclVwOiAoKSA9PiBzdGFibGVPbkNsb3NlKFwiYmFja2Ryb3BcIikgfSwgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1c2VNb2RhbEJhY2tkcm9wUHJvcHMgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHVzZU1vZGFsUHJvcHMgPSBmdW5jdGlvbiAoeyBcImFyaWEtbW9kYWxcIjogYXJpYU1vZGFsLCByb2xlLCAuLi5wMCB9KSB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VGb2N1c1RyYXBQcm9wcyB9ID0gdXNlRm9jdXNUcmFwKHsgdHJhcEFjdGl2ZTogb3BlbiB9KTtcclxuICAgICAgICBjb25zdCBwMSA9IHVzZVRpdGxlUmVmZXJlbmNpbmdJZFByb3BzKFwiYXJpYS1sYWJlbGxlZGJ5XCIpKHAwKTtcclxuICAgICAgICBjb25zdCBwMiA9IHVzZU1vZGFsSWRQcm9wcyhwMSk7XHJcbiAgICAgICAgY29uc3QgcEZpbmFsID0gdXNlQm9keVJlZmVyZW5jaW5nSWRQcm9wcyhcImFyaWEtZGVzY3JpYmVkYnlcIikocDIpO1xyXG4gICAgICAgIHJldHVybiB1c2VGb2N1c1RyYXBQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHVzZVNvZnREaXNtaXNzUHJvcHMoeyByb2xlOiBcImRpYWxvZ1wiIH0pLCBtb2RhbERlc2NyaWJlZEJ5Qm9keSA/IHBGaW5hbCA6IHAyKSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXNlTW9kYWxUaXRsZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZU1vZGFsVGl0bGUoKSB7XHJcbiAgICAgICAgY29uc3QgdXNlTW9kYWxUaXRsZVByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VUaXRsZUlkUHJvcHMocHJvcHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTW9kYWxUaXRsZVByb3BzIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCB1c2VNb2RhbEJvZHkgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VNb2RhbEJvZHkoeyBkZXNjcmlwdGl2ZSB9KSB7XHJcbiAgICAgICAgc2V0TW9kYWxEZXNjcmliZWRCeUJvZHkoZGVzY3JpcHRpdmUpO1xyXG4gICAgICAgIGNvbnN0IHVzZU1vZGFsQm9keVByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VCb2R5SWRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4geyB1c2VNb2RhbEJvZHlQcm9wcyB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VNb2RhbFByb3BzLFxyXG4gICAgICAgIHVzZU1vZGFsVGl0bGUsXHJcbiAgICAgICAgdXNlTW9kYWxCb2R5LFxyXG4gICAgICAgIHVzZU1vZGFsQmFja2Ryb3BcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEFsbG93cyBmb3IgaGlkaW5nIHRoZSBzY3JvbGwgYmFyIG9mIHRoZSByb290IEhUTUwgZWxlbWVudFxyXG4gKiB3aXRob3V0IHNoaWZ0aW5nIHRoZSBsYXlvdXQgb2YgdGhlIHBhZ2UgbW9yZSB0aGFuIGFkZGluZyBhIGZvdyBwaXhlbHNcclxuICogb2YgcGFkZGluZyB0byB0aGUgcm9vdCBlbGVtZW50IGlmIG5lY2Vzc2FyeS5cclxuICogQHBhcmFtIGhpZGVTY3JvbGxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VIaWRlU2Nyb2xsKGhpZGVTY3JvbGwpIHtcclxuICAgIGNvbnN0IFtzY3JvbGxiYXJXaWR0aCwgc2V0U2Nyb2xsYmFyV2lkdGgsIGdldFNjcm9sbGJhcldpZHRoXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoaGlkZVNjcm9sbCkge1xyXG4gICAgICAgICAgICBsZXQgd2lkdGhXaXRoU2Nyb2xsQmFyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImRvY3VtZW50LXNjcm9sbC1oaWRkZW5cIik7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdID0gKCsoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gfHwgXCIwXCIpICsgMSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgbGV0IHdpZHRoV2l0aG91dFNjcm9sbEJhciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcclxuICAgICAgICAgICAgbGV0IHNjcm9sbGJhcldpZHRoID0gKHdpZHRoV2l0aG91dFNjcm9sbEJhciAtIHdpZHRoV2l0aFNjcm9sbEJhcik7XHJcbiAgICAgICAgICAgIC8vIEZhaWxzYWZlIC0tIGlmIHRoaXMgbWVhc3VyaW5nIHRyaWNrIGRvZXMgc29tZXRoaW5nIHVuZXhwZWN0ZWQsIGp1c3QgaWdub3JlIGl0XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxiYXJXaWR0aCA+IDgwKVxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFyV2lkdGggPSAwO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXNjcm9sbGJhci13aWR0aFwiLCBgJHtzY3JvbGxiYXJXaWR0aH1weGApO1xyXG4gICAgICAgICAgICBzZXRTY3JvbGxiYXJXaWR0aChzY3JvbGxiYXJXaWR0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSA9ICgrKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdIHx8IFwiMFwiKSAtIDEpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gPT0gXCIwXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zY3JvbGwtaGlkZXJzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZG9jdW1lbnQtc2Nyb2xsLWhpZGRlblwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbaGlkZVNjcm9sbF0pO1xyXG4gICAgcmV0dXJuIHsgc2Nyb2xsYmFyV2lkdGgsIGdldFNjcm9sbGJhcldpZHRoIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW1vZGFsLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VBcmlhTW9kYWwgfSBmcm9tIFwiLi91c2UtbW9kYWxcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFEaWFsb2coeyBvcGVuLCBvbkNsb3NlIH0pIHtcclxuICAgIC8vIFRPRE86IERpZmZlcmVuY2VzIGJldHdlZW4gZGlhbG9nIGFuZCBtb2RhbCBnbyBoZXJlLCBwcmVzdW1hYmx5LlxyXG4gICAgLy8gTm9uLW1vZGFsIGRpYWxvZ3MgbmVlZCB0byBiZSBhYmxlIHRvIGJlIHJlcG9zaXRpb25lZCwgZXRjLlxyXG4gICAgY29uc3QgeyB1c2VNb2RhbEJhY2tkcm9wLCB1c2VNb2RhbEJvZHksIHVzZU1vZGFsUHJvcHMsIHVzZU1vZGFsVGl0bGUgfSA9IHVzZUFyaWFNb2RhbCh7IG9wZW4sIG9uQ2xvc2UgfSk7XHJcbiAgICBjb25zdCB1c2VEaWFsb2dCYWNrZHJvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9ID0gdXNlTW9kYWxCYWNrZHJvcCgpO1xyXG4gICAgICAgIHJldHVybiB7IHVzZURpYWxvZ0JhY2tkcm9wUHJvcHM6IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9O1xyXG4gICAgfSwgW3VzZU1vZGFsQmFja2Ryb3BdKTtcclxuICAgIGNvbnN0IHVzZURpYWxvZ0JvZHkgPSB1c2VDYWxsYmFjaygoeyBkZXNjcmlwdGl2ZSB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VNb2RhbEJvZHlQcm9wcyB9ID0gdXNlTW9kYWxCb2R5KHsgZGVzY3JpcHRpdmUgfSk7XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlRGlhbG9nQm9keVByb3BzOiB1c2VNb2RhbEJvZHlQcm9wcyB9O1xyXG4gICAgfSwgW3VzZU1vZGFsQmFja2Ryb3BdKTtcclxuICAgIGNvbnN0IHVzZURpYWxvZ1Byb3BzID0gdXNlTW9kYWxQcm9wcztcclxuICAgIGNvbnN0IHVzZURpYWxvZ1RpdGxlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxUaXRsZVByb3BzIH0gPSB1c2VNb2RhbFRpdGxlKCk7XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlRGlhbG9nVGl0bGVQcm9wczogdXNlTW9kYWxUaXRsZVByb3BzIH07XHJcbiAgICB9LCBbdXNlTW9kYWxUaXRsZV0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VEaWFsb2dQcm9wcyxcclxuICAgICAgICB1c2VEaWFsb2dUaXRsZSxcclxuICAgICAgICB1c2VEaWFsb2dCb2R5LFxyXG4gICAgICAgIHVzZURpYWxvZ0JhY2tkcm9wXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1kaWFsb2cuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZUFyaWFNb2RhbCB9IGZyb20gXCIuL3VzZS1tb2RhbFwiO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlRHJhd2VyKHsgb3Blbiwgb25DbG9zZSB9KSB7XHJcbiAgICAvLyBUT0RPOiBEcmF3ZXJzIGFyZSBub3QgYWx3YXlzIG1vZGFsLlxyXG4gICAgY29uc3QgeyB1c2VNb2RhbEJhY2tkcm9wLCB1c2VNb2RhbEJvZHksIHVzZU1vZGFsUHJvcHMsIHVzZU1vZGFsVGl0bGUgfSA9IHVzZUFyaWFNb2RhbCh7IG9wZW4sIG9uQ2xvc2UgfSk7XHJcbiAgICBjb25zdCB1c2VEcmF3ZXJCYWNrZHJvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9ID0gdXNlTW9kYWxCYWNrZHJvcCgpO1xyXG4gICAgICAgIHJldHVybiB7IHVzZURyYXdlckJhY2tkcm9wUHJvcHM6IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9O1xyXG4gICAgfSwgW3VzZU1vZGFsQmFja2Ryb3BdKTtcclxuICAgIGNvbnN0IHVzZURyYXdlckJvZHkgPSB1c2VDYWxsYmFjaygoeyBkZXNjcmlwdGl2ZSB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VNb2RhbEJvZHlQcm9wcyB9ID0gdXNlTW9kYWxCb2R5KHsgZGVzY3JpcHRpdmUgfSk7XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlRHJhd2VyQm9keVByb3BzOiB1c2VNb2RhbEJvZHlQcm9wcyB9O1xyXG4gICAgfSwgW3VzZU1vZGFsQmFja2Ryb3BdKTtcclxuICAgIGNvbnN0IHVzZURyYXdlclByb3BzID0gdXNlTW9kYWxQcm9wcztcclxuICAgIGNvbnN0IHVzZURyYXdlclRpdGxlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxUaXRsZVByb3BzIH0gPSB1c2VNb2RhbFRpdGxlKCk7XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlRHJhd2VyVGl0bGVQcm9wczogdXNlTW9kYWxUaXRsZVByb3BzIH07XHJcbiAgICB9LCBbdXNlTW9kYWxUaXRsZV0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VEcmF3ZXJQcm9wcyxcclxuICAgICAgICB1c2VEcmF3ZXJUaXRsZSxcclxuICAgICAgICB1c2VEcmF3ZXJCb2R5LFxyXG4gICAgICAgIHVzZURyYXdlckJhY2tkcm9wXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1kcmF3ZXIuanMubWFwIiwiaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCwgdXNlQ2hpbGRGbGFnLCB1c2VIYXNGb2N1cywgdXNlTGF5b3V0RWZmZWN0LCB1c2VMaXN0TmF2aWdhdGlvbiwgdXNlTWVyZ2VkUHJvcHMsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcbmltcG9ydCB7IHVzZUdlbmVyaWNMYWJlbCB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYUxpc3Rib3hTaW5nbGUoeyBzZWxlY3RlZEluZGV4LCBvblNlbGVjdCwgc2VsZWN0aW9uTW9kZSwgLi4uYXJncyB9KSB7XHJcbiAgICBjb25zdCB7IGxhc3RGb2N1c2VkSW5uZXIsIHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzKCk7XHJcbiAgICBjb25zdCB7IHVzZUdlbmVyaWNMYWJlbElucHV0LCB1c2VHZW5lcmljTGFiZWxMYWJlbCwgdXNlUmVmZXJlbmNlZElucHV0SWRQcm9wcywgdXNlUmVmZXJlbmNlZExhYmVsSWRQcm9wcywgaW5wdXRFbGVtZW50IH0gPSB1c2VHZW5lcmljTGFiZWwoeyBsYWJlbFByZWZpeDogXCJhcmlhLWxpc3Rib3gtbGFiZWwtXCIsIGlucHV0UHJlZml4OiBcImFyaWEtbGlzdGJveC1cIiB9KTtcclxuICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCwgbmF2aWdhdGVUb0luZGV4LCBtYW5hZ2VkQ2hpbGRyZW4sIHNldFRhYmJhYmxlSW5kZXgsIHRhYmJhYmxlSW5kZXgsIGZvY3VzQ3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9ID0gdXNlTGlzdE5hdmlnYXRpb24oeyAuLi5hcmdzLCBmb2N1c09uQ2hhbmdlOiBsYXN0Rm9jdXNlZElubmVyIH0pO1xyXG4gICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VHZW5lcmljTGFiZWxJbnB1dCgpO1xyXG4gICAgY29uc3Qgc3RhYmxlT25TZWxlY3QgPSB1c2VTdGFibGVDYWxsYmFjayhvblNlbGVjdCA/PyAoKCkgPT4geyB9KSk7XHJcbiAgICB1c2VDaGlsZEZsYWcoc2VsZWN0ZWRJbmRleCwgbWFuYWdlZENoaWxkcmVuLmxlbmd0aCwgKGksIHNlbGVjdGVkKSA9PiBtYW5hZ2VkQ2hpbGRyZW5baV0/LnNldFNlbGVjdGVkKHNlbGVjdGVkKSk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKFtdKSA9PiB7XHJcbiAgICAgICAgbmF2aWdhdGVUb0luZGV4KHNlbGVjdGVkSW5kZXgpO1xyXG4gICAgfSwgW3NlbGVjdGVkSW5kZXgsIG1hbmFnZWRDaGlsZHJlbi5sZW5ndGhdKTtcclxuICAgIGNvbnN0IGNoaWxkQ291bnQgPSBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgY29uc3QgeyBsYXN0QWN0aXZlRWxlbWVudCB9ID0gdXNlQWN0aXZlRWxlbWVudCgpO1xyXG4gICAgbGV0IGFueVJhZGlvc0ZvY3VzZWQgPSAoISFpbnB1dEVsZW1lbnQ/LmNvbnRhaW5zKGxhc3RBY3RpdmVFbGVtZW50KSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICghYW55UmFkaW9zRm9jdXNlZClcclxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChzZWxlY3RlZEluZGV4KTtcclxuICAgIH0sIFthbnlSYWRpb3NGb2N1c2VkLCBzZWxlY3RlZEluZGV4LCBzZXRUYWJiYWJsZUluZGV4XSk7XHJcbiAgICBjb25zdCB1c2VMaXN0Ym94U2luZ2xlSXRlbSA9IHVzZUNhbGxiYWNrKChpbmZvKSA9PiB7XHJcbiAgICAgICAgY29uc3QgW3NlbGVjdGVkLCBzZXRTZWxlY3RlZCwgZ2V0U2VsZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uU2libGluZ1Byb3BzLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoeyBzZXRTZWxlY3RlZCwgLi4uaW5mbyB9KTtcclxuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5mby5pbmRleDtcclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiB0YWJiYWJsZSAmJiBzZWxlY3Rpb25Nb2RlID09IFwiZm9jdXNcIikge1xyXG4gICAgICAgICAgICAgICAgc3RhYmxlT25TZWxlY3Q/Lih7IHRhcmdldDogZWxlbWVudCwgY3VycmVudFRhcmdldDogZWxlbWVudCwgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBpbmRleCB9IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW2VsZW1lbnQsIHRhYmJhYmxlLCBzZWxlY3Rpb25Nb2RlLCBpbmRleF0pO1xyXG4gICAgICAgIHJldHVybiB7IHVzZUxpc3Rib3hTaW5nbGVJdGVtUHJvcHMsIHRhYmJhYmxlLCBzZWxlY3RlZCwgZ2V0U2VsZWN0ZWQgfTtcclxuICAgICAgICBmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzKHByb3BzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0gdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnMoaW5mby50YWcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoaW5mby5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICBzdGFibGVPblNlbGVjdD8uKHsgdGFyZ2V0OiBlbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBlbGVtZW50LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IGluZGV4IH0gfSk7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCkoe30pO1xyXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJvcHRpb25cIjtcclxuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXNldHNpemVcIl0gPSAoY2hpbGRDb3VudCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXBvc2luc2V0XCJdID0gKGluZm8uaW5kZXggKyAxKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBwcm9wc1tcImFyaWEtc2VsZWN0ZWRcIl0gPSBzZWxlY3RlZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHVzZU1lcmdlZFByb3BzKCkobmV3UHJvcHMsIHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wcykpKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbdXNlTGlzdE5hdmlnYXRpb25DaGlsZCwgc2VsZWN0aW9uTW9kZSwgY2hpbGRDb3VudF0pO1xyXG4gICAgY29uc3QgdXNlTGlzdGJveFNpbmdsZUxhYmVsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZUxhYmVsKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzKHByb3BzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlR2VuZXJpY0xhYmVsTGFiZWxQcm9wcyB9ID0gdXNlR2VuZXJpY0xhYmVsTGFiZWwoKTtcclxuICAgICAgICAgICAgdXNlR2VuZXJpY0xhYmVsTGFiZWxQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzIH07XHJcbiAgICB9LCBbdXNlR2VuZXJpY0xhYmVsTGFiZWxdKTtcclxuICAgIHJldHVybiB7IHVzZUxpc3Rib3hTaW5nbGVJdGVtLCB1c2VMaXN0Ym94U2luZ2xlUHJvcHMsIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCwgdGFiYmFibGVJbmRleCwgZm9jdXM6IGZvY3VzQ3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9O1xyXG4gICAgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZVByb3BzKHByb3BzKSB7XHJcbiAgICAgICAgcHJvcHMucm9sZSA9IFwibGlzdGJveFwiO1xyXG4gICAgICAgIHJldHVybiB1c2VIYXNGb2N1c1Byb3BzKHVzZUdlbmVyaWNMYWJlbElucHV0UHJvcHMocHJvcHMpKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbGlzdGJveC1zaW5nbGUuanMubWFwIiwiaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCwgdXNlSGFzRm9jdXMsIHVzZUxheW91dEVmZmVjdCwgdXNlTGlzdE5hdmlnYXRpb24sIHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVRpbWVvdXQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZVNvZnREaXNtaXNzIH0gZnJvbSBcIi4vdXNlLW1vZGFsXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhTWVudSh7IGNvbGxhdG9yLCBrZXlOYXZpZ2F0aW9uLCBub1R5cGVhaGVhZCwgbm9XcmFwLCB0eXBlYWhlYWRUaW1lb3V0LCAuLi5hcmdzIH0pIHtcclxuICAgIGNvbnN0IFtmb2N1c1RyYXBBY3RpdmUsIHNldEZvY3VzVHJhcEFjdGl2ZV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGxldCBvbkNsb3NlID0gYXJncy5vbkNsb3NlO1xyXG4gICAgbGV0IG9uT3BlbiA9IGFyZ3Mub25PcGVuO1xyXG4gICAgbGV0IG1lbnViYXIgPSBhcmdzLm1lbnViYXI7XHJcbiAgICBsZXQgb3BlbiA9IChtZW51YmFyID8gdHJ1ZSA6IGFyZ3Mub3Blbik7XHJcbiAgICBjb25zdCBzdGFibGVPbkNsb3NlID0gdXNlU3RhYmxlQ2FsbGJhY2sob25DbG9zZSA/PyAoKCkgPT4geyB9KSk7XHJcbiAgICAvLyBUT0RPOiBJdCdzIGF3a3dhcmQgdGhhdCB0aGUgYnV0dG9uIGZvY3VzIHByb3BzIGFyZSBvdXQgaGVyZSB3aGVyZSB3ZSBkb24ndCBoYXZlIGl0cyB0eXBlLFxyXG4gICAgLy8gYnV0IGZvY3VzIG1hbmFnZW1lbnQgaXMgc3VwZXIgc2Vuc2l0aXZlLCBhbmQgZXZlbiB3YWl0aW5nIGZvciBhIHVzZUxheW91dEVmZmVjdCB0byBzeW5jIHN0YXRlIGhlcmVcclxuICAgIC8vIHdvdWxkIGJlIHRvbyBsYXRlLCBzbyBpdCB3b3VsZCBsb29rIGxpa2UgdGhlcmUncyBhIG1vbWVudCBiZXR3ZWVuIG1lbnUgZm9jdXMgbG9zdCBhbmQgYnV0dG9uIGZvY3VzIGdhaW5lZFxyXG4gICAgLy8gd2hlcmUgbm90aGluZyBpcyBmb2N1c2VkLiBcclxuICAgIGNvbnN0IHsgZm9jdXNlZElubmVyOiBtZW51SGFzRm9jdXMsIHVzZUhhc0ZvY3VzUHJvcHM6IHVzZU1lbnVIYXNGb2N1c1Byb3BzLCB9ID0gdXNlSGFzRm9jdXMoKTtcclxuICAgIGNvbnN0IHsgZm9jdXNlZElubmVyOiBidXR0b25IYXNGb2N1cywgdXNlSGFzRm9jdXNQcm9wczogdXNlQnV0dG9uSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXMoKTtcclxuICAgIGNvbnN0IHsgYWN0aXZlRWxlbWVudCwgbGFzdEFjdGl2ZUVsZW1lbnQsIHdpbmRvd0ZvY3VzZWQgfSA9IHVzZUFjdGl2ZUVsZW1lbnQoKTtcclxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCB0YWJiYWJsZUluZGV4LCBmb2N1c0N1cnJlbnQ6IGZvY3VzTWVudSB9ID0gdXNlTGlzdE5hdmlnYXRpb24oeyBjb2xsYXRvciwga2V5TmF2aWdhdGlvbiwgbm9UeXBlYWhlYWQsIG5vV3JhcCwgdHlwZWFoZWFkVGltZW91dCwgZm9jdXNPbkNoYW5nZTogKG1lbnVIYXNGb2N1cyB8fCBidXR0b25IYXNGb2N1cykgfSk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUHJvcHM6IHVzZU1lbnVJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlTWVudUlkUmVmZXJlbmNpbmdQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1tZW51LVwiIH0pO1xyXG4gICAgY29uc3QgW29wZW5lckVsZW1lbnQsIHNldE9wZW5lckVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCB7IHVzZVNvZnREaXNtaXNzUHJvcHMgfSA9IHVzZVNvZnREaXNtaXNzKHsgb25DbG9zZTogc3RhYmxlT25DbG9zZSB9KTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0Rm9jdXNUcmFwQWN0aXZlKG9wZW4pO1xyXG4gICAgfSwgW29wZW5dKTtcclxuICAgIGNvbnN0IGZvY3VzTWVudVN0YWJsZSA9IHVzZVN0YWJsZUNhbGxiYWNrKGZvY3VzTWVudSA/PyAoKCkgPT4geyB9KSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChmb2N1c1RyYXBBY3RpdmUpIHtcclxuICAgICAgICAgICAgZm9jdXNNZW51U3RhYmxlPy4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZm9jdXNUcmFwQWN0aXZlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBvcGVuZXJFbGVtZW50Py5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbnVsbCwgc28gd2UndmUgb25seSBqdXN0IG1vdW50ZWQgYW5kIHNob3VsZG4ndCBmb2N1cyBvdXJzZWx2ZXMuXHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2ZvY3VzVHJhcEFjdGl2ZV0pO1xyXG4gICAgLy8gRm9jdXMgbWFuYWdlbWVudCBpcyByZWFsbHkgZmluaWNreSwgYW5kIHRoZXJlJ3MgYWx3YXlzIGdvaW5nIHRvIGJlIFxyXG4gICAgLy8gYW4gZWRnZSBjYXNlIHdoZXJlIG5vdGhpbmcncyBmb2N1c2VkIGZvciB0d28gY29uc2VjdXRpdmUgZnJhbWVzIFxyXG4gICAgLy8gb24gaU9TIG9yIHdoYXRldmVyLCB3aGljaCB3b3VsZCBpbW1lZGlhdGVseSBjbG9zZSB0aGUgbWVudSBcclxuICAgIC8vIGFueSB0aW1lIGl0J3MgYmVlbiBvcGVuZWQuIFNvIGFueSB0aW1lIGl0ICpsb29rcyogbGlrZSB3ZSBzaG91bGQgY2xvc2UsXHJcbiAgICAvLyB0cnkgd2FpdGluZyAxMDBtcy4gSWYgaXQncyBzdGlsbCB0cnVlIHRoZW4sIHRoZW4geWVhaCwgd2Ugc2hvdWxkIGNsb3NlLlxyXG4gICAgbGV0IHNob3VsZENsb3NlID0gKGZvY3VzVHJhcEFjdGl2ZSAmJiB3aW5kb3dGb2N1c2VkICYmICFtZW51SGFzRm9jdXMgJiYgIWJ1dHRvbkhhc0ZvY3VzKTtcclxuICAgIHVzZVRpbWVvdXQoe1xyXG4gICAgICAgIHRpbWVvdXQ6IDEwMCxcclxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2xvc2UpIHtcclxuICAgICAgICAgICAgICAgIG9uQ2xvc2U/LigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmlnZ2VySW5kZXg6IGAke3Nob3VsZENsb3NlfWBcclxuICAgIH0pO1xyXG4gICAgLy8gQSBtZW51IHNlbnRpbmFsIGlzIGEgaGlkZGVuIGJ1dCBmb2N1c2FibGUgZWxlbWVudCB0aGF0IGNvbWVzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGVsZW1lbnRcclxuICAgIC8vIHRoYXQsIHdoZW4gYWN0aXZhdGVkIG9yIGZvY3VzZWQgb3ZlciwgY2xvc2VzIHRoZSBtZW51LlxyXG4gICAgLy8gKGlmIGZvY3VzZWQgd2l0aGluIDEwMG1zIG9mIHRoZSBvcGVuIHByb3AgY2hhbmdpbmcsIGluc3RlYWQgb2ZcclxuICAgIC8vIGNsb3NpbmcgdGhlIG1lbnUsIGZvY3VzaW5nIHRoZSBzZW50aW5lbCBpbW1lZGlhdGVseSBhc2tzIHRoZSBtZW51IHRvIGZvY3VzIGl0c2VsZikuXHJcbiAgICAvLyBUaGlzIGV4aXN0cyBiZWNhdXNlIHdoaWxlIG1vdXNlIHVzZXJzIGNhbiBjbGljayBvdXQgb2YgYSBtZW51XHJcbiAgICAvLyBhbmQga2V5Ym9hcmQgdXNlcnMgY2FuIGVzY2FwZSB0byBjbG9zZSB0aGUgbWVudSxcclxuICAgIC8vIHNjcmVlbiByZWFkZXJzIGFuZCBvdGhlciBpbnB1dCBtZXRob2RzIHRoYXQgZG9uJ3QgdXNlIHRob3NlIHR3byBiZWNvbWUgc3R1Y2suXHJcbiAgICBjb25zdCB1c2VNZW51U2VudGluZWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgW2ZpcnN0U2VudGluZWxJc0FjdGl2ZSwgc2V0Rmlyc3RTZW50aW5lbElzQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgICAgICB1c2VUaW1lb3V0KHsgY2FsbGJhY2s6ICgpID0+IHsgc2V0Rmlyc3RTZW50aW5lbElzQWN0aXZlKG9wZW4pOyB9LCB0aW1lb3V0OiAxMDAsIHRyaWdnZXJJbmRleDogYCR7Zmlyc3RTZW50aW5lbElzQWN0aXZlfWAgfSk7XHJcbiAgICAgICAgY29uc3Qgb25Gb2N1cyA9IGZpcnN0U2VudGluZWxJc0FjdGl2ZSA/ICgoKSA9PiBzdGFibGVPbkNsb3NlKCkpIDogKCgpID0+IGZvY3VzTWVudT8uKCkpO1xyXG4gICAgICAgIGNvbnN0IG9uQ2xpY2sgPSAoKSA9PiBzdGFibGVPbkNsb3NlKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlTWVudVNlbnRpbmVsUHJvcHM6IGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IG9uRm9jdXMsIG9uQ2xpY2sgfSwgcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW2ZvY3VzTWVudSwgb3Blbl0pO1xyXG4gICAgY29uc3QgdXNlTWVudUJ1dHRvbiA9IHVzZUNhbGxiYWNrKCh7IHRhZyB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBzZXRPcGVuZXJFbGVtZW50KGVsZW1lbnQpOyB9LCBbZWxlbWVudF0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZU1lbnVCdXR0b25Qcm9wczogZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgICAgIGxldCBwcm9wcyA9IHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHsgb25DbGljazogKCkgPT4geyByZXR1cm4gb3BlbiA/IG9uQ2xvc2U/LigpIDogb25PcGVuPy4oKTsgfSB9LCB1c2VNZW51SWRSZWZlcmVuY2luZ1Byb3BzKFwiYXJpYS1jb250cm9sc1wiKSh1c2VCdXR0b25IYXNGb2N1c1Byb3BzKHApKSkpO1xyXG4gICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWhhc3BvcHVwXCJdID0gXCJtZW51XCI7XHJcbiAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtZXhwYW5kZWRcIl0gPSBvcGVuID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW29wZW4sIG9uQ2xvc2UsIG9uT3BlbiwgdXNlTWVudUlkUmVmZXJlbmNpbmdQcm9wc10pO1xyXG4gICAgY29uc3QgdXNlTWVudVN1Ym1lbnVJdGVtID0gdXNlQ2FsbGJhY2soKGFyZ3MpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZU1lbnVQcm9wcywgdXNlTWVudUJ1dHRvbiB9ID0gdXNlQXJpYU1lbnUoYXJncyk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VNZW51QnV0dG9uUHJvcHMgfSA9IHVzZU1lbnVCdXR0b24oeyB0YWc6IFwibGlcIiB9KTtcclxuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIGdldEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHNldE9wZW5lckVsZW1lbnQoZWxlbWVudCk7IH0sIFtlbGVtZW50XSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZWxlbWVudCxcclxuICAgICAgICAgICAgZ2V0RWxlbWVudCxcclxuICAgICAgICAgICAgdXNlTWVudVByb3BzLFxyXG4gICAgICAgICAgICB1c2VNZW51U3VibWVudUl0ZW1Qcm9wczogZnVuY3Rpb24gKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwibWVudWl0ZW1cIjtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHModXNlTWVudUJ1dHRvblByb3BzKHVzZU1lbnVJZFJlZmVyZW5jaW5nUHJvcHMoXCJhcmlhLWNvbnRyb2xzXCIpKHByb3BzKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHVzZU1lbnVJdGVtID0gdXNlQ2FsbGJhY2soKGFyZ3MpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZChhcmdzKTtcclxuICAgICAgICAvLyBjb25zdCB7IGdldFN5bmNIYW5kbGVyLCAuLi5hc3luY0luZm8gfSA9IHVzZUFzeW5jSGFuZGxlcjxFPigpKHsgY2FwdHVyZTogXyA9PiB2b2lkICgwKSB9KTtcclxuICAgICAgICAvLyBjb25zdCBvbkNsaWNrID0gZ2V0U3luY0hhbmRsZXIoYXN5bmNJbmZvLnBlbmRpbmcgPyBudWxsIDogKGFyZ3Mub25DbGljayA/PyBudWxsKSk7XHJcbiAgICAgICAgY29uc3Qgb25DbGljayA9IGFyZ3Mub25DbGljaztcclxuICAgICAgICBmdW5jdGlvbiB1c2VNZW51SXRlbVByb3BzKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJtZW51aXRlbVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IG9uQ2xpY2sgfSwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHByb3BzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZU1lbnVJdGVtUHJvcHMgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHVzZU1lbnVJdGVtQ2hlY2tib3ggPSB1c2VDYWxsYmFjaygoYXJncykgPT4ge1xyXG4gICAgICAgIC8vY29uc3QgeyBnZXRTeW5jSGFuZGxlciwgLi4uYXN5bmNJbmZvIH0gPSB1c2VBc3luY0hhbmRsZXI8RT4oKSh7IGNhcHR1cmU6IF8gPT4gIWFyZ3MuY2hlY2tlZCB9KTtcclxuICAgICAgICAvL2NvbnN0IG9uQ2xpY2sgPSBnZXRTeW5jSGFuZGxlcihhc3luY0luZm8ucGVuZGluZyA/IG51bGwgOiBhcmdzLm9uQ2hhbmdlKTtcclxuICAgICAgICBjb25zdCBvbkNsaWNrID0gKGUpID0+IGFyZ3Mub25DaGFuZ2UoZW5oYW5jZUV2ZW50KGUsIHsgY2hlY2tlZDogIWFyZ3MuY2hlY2tlZCB9KSk7XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlTWVudUl0ZW1Qcm9wcyh7IC4uLnByb3BzIH0pIHtcclxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwibWVudWl0ZW1jaGVja2JveFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IG9uQ2xpY2sgfSwgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1c2VNZW51SXRlbVByb3BzIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICBmdW5jdGlvbiB1c2VNZW51UHJvcHMoeyAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgcHJvcHMucm9sZSA9IFwibWVudVwiO1xyXG4gICAgICAgIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmtleSA9PSBcIkVzY2FwZVwiICYmIG9uQ2xvc2UpIHtcclxuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXNlTWVudUlkUHJvcHModXNlTWVudUhhc0ZvY3VzUHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IG9uS2V5RG93biB9LCB1c2VTb2Z0RGlzbWlzc1Byb3BzKHByb3BzKSkpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTWVudVByb3BzLFxyXG4gICAgICAgIHVzZU1lbnVCdXR0b24sXHJcbiAgICAgICAgdXNlTWVudUl0ZW0sXHJcbiAgICAgICAgdXNlTWVudVNlbnRpbmVsLFxyXG4gICAgICAgIHVzZU1lbnVJdGVtQ2hlY2tib3gsXHJcbiAgICAgICAgdXNlTWVudVN1Ym1lbnVJdGVtLFxyXG4gICAgICAgIGZvY3VzTWVudVxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbWVudS5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDaGlsZEZsYWcsIHVzZUNoaWxkTWFuYWdlciwgdXNlSGFzRm9jdXMsIHVzZUxheW91dEVmZmVjdCwgdXNlTGlzdE5hdmlnYXRpb24sIHVzZUxvZ2ljYWxEaXJlY3Rpb24sIHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhVGFicyh7IHNlbGVjdGlvbk1vZGUsIHNlbGVjdGVkSW5kZXgsIG9uU2VsZWN0LCBvcmllbnRhdGlvbjogbG9naWNhbE9yaWVudGF0aW9uLCAuLi5hcmdzIH0pIHtcclxuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wczogdXNlVGFiTGlzdEhhc0ZvY3VzUHJvcHMsIGZvY3VzZWRJbm5lcjogdGFiTGlzdEZvY3VzZWQgfSA9IHVzZUhhc0ZvY3VzKCk7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGxpc3RFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgIGNvbnN0IHsgZ2V0TG9naWNhbERpcmVjdGlvbiwgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbiB9ID0gdXNlTG9naWNhbERpcmVjdGlvbihsaXN0RWxlbWVudCk7XHJcbiAgICBjb25zdCBwaHlzaWNhbE9yaWVudGF0aW9uID0gY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbihsb2dpY2FsT3JpZW50YXRpb24pO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VUYWJMaXN0SWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRUYWJMaXN0SWQgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtdGFiLWxpc3QtXCIgfSk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUHJvcHM6IHVzZVRhYkxhYmVsSWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRUYWJMYWJlbElkIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLXRhYi1sYWJlbC1cIiB9KTtcclxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkVGFicywgbmF2aWdhdGVUb0luZGV4LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCB0YWJiYWJsZUluZGV4LCBpbnZhbGlkVHlwZWFoZWFkLCBjdXJyZW50VHlwZWFoZWFkLCBmb2N1c0N1cnJlbnQgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uKHsgLi4uYXJncywgZm9jdXNPbkNoYW5nZTogdGFiTGlzdEZvY3VzZWQsIGtleU5hdmlnYXRpb246IGxvZ2ljYWxPcmllbnRhdGlvbiB9KTtcclxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkUGFuZWxzLCB1c2VNYW5hZ2VkQ2hpbGQ6IHVzZU1hbmFnZWRUYWJQYW5lbCB9ID0gdXNlQ2hpbGRNYW5hZ2VyKCk7XHJcbiAgICBjb25zdCBzdGFibGVPblNlbGVjdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uU2VsZWN0KTtcclxuICAgIGNvbnN0IGNoaWxkQ291bnQgPSBtYW5hZ2VkVGFicy5sZW5ndGg7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG1hbmFnZWRUYWJzKVxyXG4gICAgICAgICAgICBjaGlsZC5zZXRTZWxlY3Rpb25Nb2RlKHNlbGVjdGlvbk1vZGUpO1xyXG4gICAgfSwgW3NlbGVjdGlvbk1vZGVdKTtcclxuICAgIHVzZUNoaWxkRmxhZyhzZWxlY3RlZEluZGV4LCBtYW5hZ2VkVGFicy5sZW5ndGgsIChpLCBzZWxlY3RlZCkgPT4gbWFuYWdlZFRhYnNbaV0/LnNldFNlbGVjdGVkKHNlbGVjdGVkKSk7XHJcbiAgICB1c2VDaGlsZEZsYWcoc2VsZWN0ZWRJbmRleCwgbWFuYWdlZFBhbmVscy5sZW5ndGgsIChpLCB2aXNpYmxlKSA9PiBtYW5hZ2VkUGFuZWxzW2ldPy5zZXRWaXNpYmxlKHZpc2libGUpKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoW3ByZXZDaGlsZENvdW50LCBwcmV2U2VsZWN0ZWRJbmRleF0pID0+IHtcclxuICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAhPSBudWxsICYmIHNlbGVjdGlvbk1vZGUgPT0gXCJhY3RpdmF0ZVwiKSB7XHJcbiAgICAgICAgICAgIG1hbmFnZWRQYW5lbHNbc2VsZWN0ZWRJbmRleF0/LmZvY3VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2NoaWxkQ291bnQsIHNlbGVjdGVkSW5kZXgsIHNlbGVjdGlvbk1vZGVdKTtcclxuICAgIGNvbnN0IGdldFRhYkxpc3RJc0ZvY3VzZWQgPSB1c2VTdGFibGVHZXR0ZXIodGFiTGlzdEZvY3VzZWQpO1xyXG4gICAgY29uc3QgdXNlVGFiID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVGFiKGluZm8pIHtcclxuICAgICAgICAvL2NvbnN0IFtzZWxlY3RlZFRhYklkLCBzZXRTZWxlY3RlZFRhYklkLCBnZXRTZWxlY3RlZFRhYklkXSA9IHVzZVN0YXRlPHN0cmluZyB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcclxuICAgICAgICBjb25zdCBbc2VsZWN0aW9uTW9kZUwsIHNldFNlbGVjdGlvbk1vZGVMXSA9IHVzZVN0YXRlKHNlbGVjdGlvbk1vZGUpO1xyXG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICAgICAgY29uc3QgW3RhYlBhbmVsSWQsIHNldFRhYlBhbmVsSWRdID0gdXNlU3RhdGUodW5kZWZpbmVkKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUHJvcHM6IHVzZVRhYklkUHJvcHMsIGlkOiB0YWJJZCwgZ2V0SWQ6IGdldFRhYklkIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLXRhYi1cIiB9KTtcclxuICAgICAgICBjb25zdCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkLCBnZXRTZWxlY3RlZF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgICAgICBjb25zdCB7IHRhYmJhYmxlLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsIHVzZUxpc3ROYXZpZ2F0aW9uU2libGluZ1Byb3BzIH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHsgLi4uaW5mbywgc2V0U2VsZWN0ZWQsIHRhYklkLCBzZXRUYWJQYW5lbElkLCBzZXRTZWxlY3Rpb25Nb2RlOiBzZXRTZWxlY3Rpb25Nb2RlTCB9KTtcclxuICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUdldHRlcihpbmZvLmluZGV4KTtcclxuICAgICAgICAvLyBjb25zdCB7IGdldFN5bmNIYW5kbGVyLCAuLi5hc3luY0luZm8gfSA9IHVzZUFzeW5jSGFuZGxlcjxFbGVtZW50PigpKHsgY2FwdHVyZTogKGU6IHVua25vd24pID0+IGluZm8uaW5kZXggfSk7XHJcbiAgICAgICAgLy8gY29uc3Qgb25TZWxlY3QgPSBnZXRTeW5jSGFuZGxlcihhc3luY0luZm8ucGVuZGluZz8gbnVsbCA6IChzdGFibGVBc3luY09uU2VsZWN0ID8/IG51bGwpKTtcclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGFiYmFibGUgJiYgc2VsZWN0aW9uTW9kZUwgPT0gXCJmb2N1c1wiKSB7XHJcbiAgICAgICAgICAgICAgICBvblNlbGVjdCh7IHRhcmdldDogZWxlbWVudCwgY3VycmVudFRhcmdldDogZWxlbWVudCwgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBnZXRJbmRleCgpIH0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbdGFiYmFibGUsIHNlbGVjdGlvbk1vZGVMLCBlbGVtZW50XSk7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHsgbWFuYWdlZFBhbmVsc1tpbmZvLmluZGV4XT8uc2V0VGFiSWQodGFiSWQpOyB9LCBbdGFiSWQsIGluZm8uaW5kZXhdKTtcclxuICAgICAgICAvKnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZClcclxuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkVGFiSWQodGFiSWQpO1xyXG4gICAgICAgIH0sIFtzZWxlY3RlZCwgdGFiSWRdKSovXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlVGFiUHJvcHMoeyAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0gdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnMoaW5mby50YWcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoaW5mby5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBvblNlbGVjdD8uKGVuaGFuY2VFdmVudChlLCB7IHNlbGVjdGVkSW5kZXg6IGdldEluZGV4KCkgfSkpO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQpKHByb3BzKTtcclxuICAgICAgICAgICAgbmV3UHJvcHMucm9sZSA9IFwidGFiXCI7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1zZWxlY3RlZFwiXSA9IChzZWxlY3RlZCA/PyBmYWxzZSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgbmV3UHJvcHNbXCJhcmlhLWNvbnRyb2xzXCJdID0gdGFiUGFuZWxJZDtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoe30sIHVzZVRhYklkUHJvcHModXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHVzZVJlZkVsZW1lbnRQcm9wcyhuZXdQcm9wcykpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZVRhYlByb3BzLCBzZWxlY3RlZCB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3QgdXNlVGFiUGFuZWwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VQYW5lbChpbmZvKSB7XHJcbiAgICAgICAgLy9jb25zdCBbc2VsZWN0ZWRUYWJQYW5lbElkLCBzZXRTZWxlY3RlZFRhYlBhbmVsSWQsIGdldFNlbGVjdGVkVGFiUGFuZWxJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgY29uc3QgW3Nob3VsZEZvY3VzLCBzZXRTaG91bGRGb2N1c10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgW3RhYklkLCBzZXRUYWJJZF0gPSB1c2VTdGF0ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIGNvbnN0IFtzZWxlY3RlZCwgc2V0U2VsZWN0ZWQsIGdldFNlbGVjdGVkXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlUGFuZWxJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlUmVmZXJlbmNlZFBhbmVsSWQsIGlkOiB0YWJQYW5lbElkIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLXRhYi1wYW5lbC1cIiB9KTtcclxuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIHVzZU1hbmFnZWRDaGlsZFByb3BzIH0gPSB1c2VNYW5hZ2VkVGFiUGFuZWwoeyAuLi5pbmZvLCB0YWJQYW5lbElkLCBzZXRUYWJJZCwgZm9jdXMsIHNldFZpc2libGU6IHNldFNlbGVjdGVkIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIGZvY3VzKCkge1xyXG4gICAgICAgICAgICBpZiAoZ2V0VGFiTGlzdElzRm9jdXNlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTaG91bGRGb2N1cyh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkRm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ/LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICBzZXRTaG91bGRGb2N1cyhmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbZWxlbWVudCwgc2hvdWxkRm9jdXNdKTtcclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4geyBtYW5hZ2VkVGFic1tpbmZvLmluZGV4XT8uc2V0VGFiUGFuZWxJZCh0YWJQYW5lbElkKTsgfSwgW3RhYlBhbmVsSWQsIGluZm8uaW5kZXhdKTtcclxuICAgICAgICBmdW5jdGlvbiB1c2VUYWJQYW5lbFByb3BzKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICBwcm9wc1tcImFyaWEtbGFiZWxsZWRieVwiXSA9IG1hbmFnZWRUYWJzW2luZm8uaW5kZXhdPy50YWJJZDtcclxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwidGFicGFuZWxcIjtcclxuICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPz89IC0xOyAvLyBNYWtlIHN1cmUgdGhlIHRhYiBwYW5lbCBpcyB0YWJiYWJsZS5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoe30sIHVzZVBhbmVsSWRQcm9wcyh1c2VNYW5hZ2VkQ2hpbGRQcm9wcyhwcm9wcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlVGFiUGFuZWxQcm9wcywgc2VsZWN0ZWQgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHVzZVRhYnNMaXN0ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVGFiTGlzdCgpIHtcclxuICAgICAgICBmdW5jdGlvbiB1c2VUYWJMaXN0UHJvcHMoeyAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcInRhYmxpc3RcIjtcclxuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLW9yaWVudGF0aW9uXCJdID0gcGh5c2ljYWxPcmllbnRhdGlvbjtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZVJlZmVyZW5jZWRUYWJMYWJlbElkKFwiYXJpYS1sYWJlbGxlZGJ5XCIpKHVzZVRhYkxpc3RIYXNGb2N1c1Byb3BzKHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlVGFiTGlzdFByb3BzIH07XHJcbiAgICB9LCBbcGh5c2ljYWxPcmllbnRhdGlvbl0pO1xyXG4gICAgY29uc3QgdXNlVGFic0xhYmVsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVGFic0xhYmVsKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVRhYnNMYWJlbFByb3BzKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlVGFiTGFiZWxJZFByb3BzKHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlVGFic0xhYmVsUHJvcHMgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIHJldHVybiB7IHVzZVRhYiwgdXNlVGFiUGFuZWwsIHVzZVRhYnNMaXN0LCB1c2VUYWJzTGFiZWwsIHRhYmJhYmxlSW5kZXgsIGZvY3VzVGFiTGlzdDogZm9jdXNDdXJyZW50LCBjdXJyZW50VHlwZWFoZWFkLCBpbnZhbGlkVHlwZWFoZWFkIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXRhYnMuanMubWFwIiwiaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCwgdXNlQ2hpbGRGbGFnLCB1c2VIYXNGb2N1cywgdXNlTGlzdE5hdmlnYXRpb24sIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZUNoZWNrYm94TGlrZSB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYVJhZGlvR3JvdXAoeyBuYW1lLCBzZWxlY3RlZFZhbHVlLCBvbklucHV0IH0pIHtcclxuICAgIGNvbnN0IHsgZWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleCwgZ2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IGJ5TmFtZSA9IHVzZVJlZihuZXcgTWFwKCkpO1xyXG4gICAgY29uc3Qgc3RhYmxlT25JbnB1dCA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uSW5wdXQpO1xyXG4gICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzLCBsYXN0Rm9jdXNlZElubmVyIH0gPSB1c2VIYXNGb2N1cygpO1xyXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW4sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsIHNldFRhYmJhYmxlSW5kZXgsIHRhYmJhYmxlSW5kZXgsIGZvY3VzQ3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9ID0gdXNlTGlzdE5hdmlnYXRpb24oeyBmb2N1c09uQ2hhbmdlOiBsYXN0Rm9jdXNlZElubmVyIH0pO1xyXG4gICAgY29uc3QgdXNlUmFkaW9Hcm91cFByb3BzID0gdXNlQ2FsbGJhY2soKHsgLi4ucHJvcHMgfSkgPT4ge1xyXG4gICAgICAgIHByb3BzLnJvbGUgPSBcInJhZGlvZ3JvdXBcIjtcclxuICAgICAgICByZXR1cm4gdXNlUmVmRWxlbWVudFByb3BzKHVzZUhhc0ZvY3VzUHJvcHMocHJvcHMpKTtcclxuICAgIH0sIFt1c2VIYXNGb2N1c1Byb3BzLCB1c2VSZWZFbGVtZW50UHJvcHNdKTtcclxuICAgIHVzZUNoaWxkRmxhZyhzZWxlY3RlZEluZGV4LCBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoLCAoaSwgY2hlY2tlZCkgPT4gbWFuYWdlZENoaWxkcmVuW2ldPy5zZXRDaGVja2VkKGNoZWNrZWQpKTtcclxuICAgIGNvbnN0IHsgbGFzdEFjdGl2ZUVsZW1lbnQgfSA9IHVzZUFjdGl2ZUVsZW1lbnQoKTtcclxuICAgIGxldCBhbnlSYWRpb3NGb2N1c2VkID0gKCEhZWxlbWVudD8uY29udGFpbnMobGFzdEFjdGl2ZUVsZW1lbnQpKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFhbnlSYWRpb3NGb2N1c2VkICYmIHNlbGVjdGVkSW5kZXggIT0gbnVsbClcclxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChzZWxlY3RlZEluZGV4KTtcclxuICAgIH0sIFthbnlSYWRpb3NGb2N1c2VkLCBzZWxlY3RlZEluZGV4LCBzZXRUYWJiYWJsZUluZGV4XSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGxldCBvbGRJbmRleCA9IGdldFNlbGVjdGVkSW5kZXgoKTtcclxuICAgICAgICBsZXQgbmV3SW5kZXggPSBieU5hbWUuY3VycmVudC5nZXQoc2VsZWN0ZWRWYWx1ZSk7XHJcbiAgICAgICAgc2V0U2VsZWN0ZWRJbmRleChuZXdJbmRleCk7XHJcbiAgICB9LCBbc2VsZWN0ZWRWYWx1ZV0pO1xyXG4gICAgY29uc3QgdXNlUmFkaW8gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VBcmlhUmFkaW8oeyB2YWx1ZSwgaW5kZXgsIHRleHQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCAuLi5yZXN0IH0pIHtcclxuICAgICAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICAgICAgY29uc3Qgb25JbnB1dCA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XHJcbiAgICAgICAgICAgIHN0YWJsZU9uSW5wdXQoZW5oYW5jZUV2ZW50KGUsIHsgc2VsZWN0ZWRWYWx1ZTogdmFsdWUgfSkpO1xyXG4gICAgICAgIH0sIFtzdGFibGVPbklucHV0LCB2YWx1ZSwgaW5kZXhdKTtcclxuICAgICAgICBjb25zdCB7IGdldElucHV0RWxlbWVudCwgZ2V0TGFiZWxFbGVtZW50LCB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCB9ID0gdXNlQ2hlY2tib3hMaWtlKHsgY2hlY2tlZCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24sIG9uSW5wdXQsIHJvbGU6IFwicmFkaW9cIiB9KTtcclxuICAgICAgICAvL2NvbnN0IHt9ID0gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50KHsgIH0pXHJcbiAgICAgICAgY29uc3QgYnlOYW1lMiA9IGJ5TmFtZS5jdXJyZW50O1xyXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCFieU5hbWUyLmhhcyh2YWx1ZSkpO1xyXG4gICAgICAgICAgICBieU5hbWUyLnNldCh2YWx1ZSwgaW5kZXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4geyBieU5hbWUyLmRlbGV0ZSh2YWx1ZSk7IH07XHJcbiAgICAgICAgfSwgW3ZhbHVlLCBpbmRleF0pO1xyXG4gICAgICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcywgdXNlTGlzdE5hdmlnYXRpb25TaWJsaW5nUHJvcHMgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoeyBpbmRleCwgc2V0Q2hlY2tlZCwgdGV4dCwgLi4ucmVzdCB9KTtcclxuICAgICAgICBjb25zdCB1c2VSYWRpb0lucHV0ID0gKHsgdGFnIH0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdXNlUmFkaW9JbnB1dFByb3BzID0gKHByb3BzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnID09IFwiaW5wdXRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNoZWNrZWQgPSBjaGVja2VkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWNoZWNrZWRcIl0gPSBjaGVja2VkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQoeyB0YWcgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHVzZU1lcmdlZFByb3BzKCkodXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKCh1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyh7fSkpKSwgcHJvcHMpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVzZVJhZGlvSW5wdXRQcm9wc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgdXNlUmFkaW9MYWJlbCA9IHVzZUNhbGxiYWNrKCh7IHRhZyB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZVJhZGlvTGFiZWxQcm9wcyA9IChwcm9wcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50KHsgdGFnIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzKCkoe30sIHByb3BzKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1c2VSYWRpb0xhYmVsUHJvcHNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LCBbdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50XSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlUmFkaW9JbnB1dCxcclxuICAgICAgICAgICAgdXNlUmFkaW9MYWJlbCxcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2J5TmFtZSwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VSYWRpbyxcclxuICAgICAgICB1c2VSYWRpb0dyb3VwUHJvcHMsXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIGdldEluZGV4OiB1c2VDYWxsYmFjaygodmFsdWUpID0+IHsgcmV0dXJuIGJ5TmFtZS5jdXJyZW50LmdldCh2YWx1ZSk7IH0sIFtieU5hbWVdKSxcclxuICAgICAgICB0YWJiYWJsZUluZGV4LFxyXG4gICAgICAgIGZvY3VzUmFkaW86IGZvY3VzQ3VycmVudCxcclxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxyXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWRcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXJhZGlvLWdyb3VwLmpzLm1hcCIsImltcG9ydCB7IGZpbmRGaXJzdEZvY3VzYWJsZSwgdXNlQ2hpbGRGbGFnLCB1c2VDaGlsZE1hbmFnZXIsIHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhdGUsIHVzZVRpbWVvdXQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VUb2FzdHMoe30pIHtcclxuICAgIC8vIFwiUG9pbnRlclwiIHRvIHdoYXRldmVyIGluZGV4IHRvYXN0IGlzIGN1cnJlbnRseSBiZWluZyBzaG93bi5cclxuICAgIC8vIEUuZy4gaXQncyAwIHdoZW4gdGhlIGZpcnN0IHRvYXN0IGlzIHNob3duLCB0aGVuIHdoZW4gZGlzbWlzc2VkLCBpdCBiZWNvbWVzIDEuXHJcbiAgICAvLyBXaGVuIHRoZSBzZWNvbmQgdG9hc3QgaXMgc2hvd24sIGl0IHN0YXlzIGF0IDEgdW50aWwgZGlzbWlzc2VkLCB3aGVuIGl0IHRoZW4gYmVjb21lcyAyLCBldGMuXHJcbiAgICAvLyBCZWNhdXNlIHRvYXN0cyBjYW4gcG90ZW50aWFsbHkgYmUgZGlzbWlzc2VkIG91dCBvZiBvcmRlciwgdGhpcyByZXByZXNlbnRzIHRoZSBcIm9sZGVzdFwiIHRvYXN0IHRoYXQgc3RpbGwgaGFzbid0IGJlZW4gZGlzbWlzc2VkLFxyXG4gICAgLy8gZXZlbiBpZiBcInlvdW5nZXJcIiBvbmVzIGhhdmUuXHJcbiAgICBjb25zdCBbYWN0aXZlVG9hc3RJbmRleCwgc2V0QWN0aXZlVG9hc3RJbmRleCwgZ2V0QWN0aXZlVG9hc3RJbmRleF0gPSB1c2VTdGF0ZSgtMSk7XHJcbiAgICBjb25zdCBbcG9saXRlbmVzcywgc2V0UG9saXRlbmVzc10gPSB1c2VTdGF0ZShcInBvbGl0ZVwiKTtcclxuICAgIGNvbnN0IHsgZWxlbWVudCwgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICBjb25zdCB7IGluZGljZXNCeUVsZW1lbnQsIG1hbmFnZWRDaGlsZHJlbiwgbW91bnRlZENoaWxkcmVuOiB0b2FzdFF1ZXVlLCB1c2VNYW5hZ2VkQ2hpbGQsIGdldE1vdW50SW5kZXggfSA9IHVzZUNoaWxkTWFuYWdlcigpO1xyXG4gICAgLy8gQW55IHRpbWUgYSBuZXcgdG9hc3QgbW91bnRzLCB1cGRhdGUgb3VyIGJvdHRvbW1vc3RUb2FzdEluZGV4IHRvIHBvaW50IHRvIGl0IGlmIG5lY2Vzc2FyeVxyXG4gICAgLy8gKFwibmVjZXNzYXJ5XCIganVzdCBtZWFuaW5nIGlmIGl0J3MgdGhlIGZpcnN0IHRvYXN0IGV2ZXIgb3IgYWxsIHByaW9yIHRvYXN0cyBoYXZlIGJlZW4gZGlzbWlzc2VkKVxyXG4gICAgY29uc3Qgb25BbnlUb2FzdE1vdW50ZWQgPSB1c2VDYWxsYmFjaygoaW5kZXgpID0+IHtcclxuICAgICAgICBsZXQgYm90dG9tID0gZ2V0QWN0aXZlVG9hc3RJbmRleCgpO1xyXG4gICAgICAgIHdoaWxlIChib3R0b20gPCB0b2FzdFF1ZXVlLmxlbmd0aCAmJiAoYm90dG9tIDwgMCB8fCB0b2FzdFF1ZXVlW2JvdHRvbV0/LmRpc21pc3NlZCkpIHtcclxuICAgICAgICAgICAgKytib3R0b207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldEFjdGl2ZVRvYXN0SW5kZXgoYm90dG9tKTtcclxuICAgIH0sIFtzZXRBY3RpdmVUb2FzdEluZGV4XSk7XHJcbiAgICAvLyBBbnkgdGltZSBhIHRvYXN0IGlzIGRpc21pc3NlZCwgdXBkYXRlIG91ciBib3R0b21tb3N0VG9hc3RJbmRleCB0byBwb2ludCB0byB0aGUgbmV4dCB0b2FzdCBpbiB0aGUgcXVldWUsIGlmIG9uZSBleGlzdHMuXHJcbiAgICBjb25zdCBvbkFueVRvYXN0RGlzbWlzc2VkID0gdXNlQ2FsbGJhY2soKGluZGV4KSA9PiB7XHJcbiAgICAgICAgbGV0IGJvdHRvbSA9IGdldEFjdGl2ZVRvYXN0SW5kZXgoKTtcclxuICAgICAgICB3aGlsZSAoYm90dG9tIDwgdG9hc3RRdWV1ZS5sZW5ndGggJiYgKGJvdHRvbSA8IDAgfHwgYm90dG9tID09PSBpbmRleCB8fCB0b2FzdFF1ZXVlW2JvdHRvbV0/LmRpc21pc3NlZCkpIHtcclxuICAgICAgICAgICAgKytib3R0b207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldEFjdGl2ZVRvYXN0SW5kZXgoYm90dG9tKTtcclxuICAgICAgICBpZiAoZ2V0RWxlbWVudCgpPy5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSlcclxuICAgICAgICAgICAgdG9hc3RRdWV1ZVtib3R0b21dPy5mb2N1cygpO1xyXG4gICAgfSwgW3NldEFjdGl2ZVRvYXN0SW5kZXhdKTtcclxuICAgIC8vIEFueSB0aW1lIHRoZSBpbmRleCBwb2ludGluZyB0byB0aGUgY3VycmVudGx5LXNob3dpbmcgdG9hc3QgY2hhbmdlcyxcclxuICAgIC8vIHVwZGF0ZSB0aGUgcmVsZXZhbnQgY2hpbGRyZW4gYW5kIGxldCB0aGVtIGtub3cgdGhhdCB0aGV5J3JlIG5vdyBlaXRoZXIgYWN0aXZlIG9yIGRpc21pc3NlZC5cclxuICAgIHVzZUNoaWxkRmxhZyhhY3RpdmVUb2FzdEluZGV4LCB0b2FzdFF1ZXVlLmxlbmd0aCwgKChpLCBzZXQpID0+IHtcclxuICAgICAgICBpZiAoc2V0KVxyXG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChpIDw9IGdldEFjdGl2ZVRvYXN0SW5kZXgoKSk7XHJcbiAgICAgICAgdG9hc3RRdWV1ZVtpXT8uc2V0U3RhdHVzKHNldCA/IFwiYWN0aXZlXCIgOiAoaSA8IGdldEFjdGl2ZVRvYXN0SW5kZXgoKSA/IFwiZGlzbWlzc2VkXCIgOiBcInBlbmRpbmdcIikpO1xyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgdXNlVG9hc3QgPSB1c2VDYWxsYmFjaygoeyBwb2xpdGVuZXNzLCB0aW1lb3V0IH0pID0+IHtcclxuICAgICAgICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXMsIGdldFN0YXR1c10gPSB1c2VTdGF0ZShcInBlbmRpbmdcIik7XHJcbiAgICAgICAgY29uc3QgZGlzbWlzc2VkID0gKHN0YXR1cyA9PT0gXCJkaXNtaXNzZWRcIik7XHJcbiAgICAgICAgY29uc3QgZGlzbWlzcyA9IHVzZUNhbGxiYWNrKCgpID0+IHsgc2V0U3RhdHVzKFwiZGlzbWlzc2VkXCIpOyB9LCBbXSk7XHJcbiAgICAgICAgY29uc3QgeyByYW5kb21JZDogdG9hc3RJZCB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwidG9hc3QtXCIgfSk7XHJcbiAgICAgICAgLy9jb25zdCBbdG9hc3RJZCwgc2V0VG9hc3RJZF0gPSB1c2VTdGF0ZSgoKSA9PiBnZW5lcmF0ZVJhbmRvbUlkKFwidG9hc3QtXCIpKTtcclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBzZXRQb2xpdGVuZXNzKHBvbGl0ZW5lc3MgPz8gXCJwb2xpdGVcIik7IH0sIFtwb2xpdGVuZXNzXSk7XHJcbiAgICAgICAgY29uc3QgZm9jdXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEZvY3VzYWJsZSA9IGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGZpcnN0Rm9jdXNhYmxlPy5mb2N1cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW10pO1xyXG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgdXNlTWFuYWdlZENoaWxkUHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZU1hbmFnZWRDaGlsZCh7IGRpc21pc3NlZCwgaW5kZXg6IHRvYXN0SWQsIHNldFN0YXR1cywgZm9jdXMgfSk7XHJcbiAgICAgICAgY29uc3QgaXNBY3RpdmUgPSAoc3RhdHVzID09PSBcImFjdGl2ZVwiKTtcclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBvbkFueVRvYXN0TW91bnRlZChnZXRNb3VudEluZGV4KHRvYXN0SWQpKTtcclxuICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGRpc21pc3NlZClcclxuICAgICAgICAgICAgICAgIG9uQW55VG9hc3REaXNtaXNzZWQoZ2V0TW91bnRJbmRleCh0b2FzdElkKSk7XHJcbiAgICAgICAgfSwgW2Rpc21pc3NlZF0pO1xyXG4gICAgICAgIHVzZVRpbWVvdXQoe1xyXG4gICAgICAgICAgICB0aW1lb3V0LFxyXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhcImRpc21pc3NlZFwiKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdHJpZ2dlckluZGV4OiBpc0FjdGl2ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXR1cyxcclxuICAgICAgICAgICAgZ2V0U3RhdHVzLFxyXG4gICAgICAgICAgICBkaXNtaXNzLFxyXG4gICAgICAgICAgICB1c2VUb2FzdFByb3BzOiBmdW5jdGlvbiAoeyAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh1c2VNYW5hZ2VkQ2hpbGRQcm9wcyh7fSksIHByb3BzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICBmdW5jdGlvbiB1c2VUb2FzdENvbnRhaW5lclByb3BzKHsgcm9sZSwgXCJhcmlhLWxpdmVcIjogYXJpYUxpdmUsIFwiYXJpYS1yZWxldmFudFwiOiBhcmlhUmVsZXZhbnQsIC4uLnByb3BzIH0pIHtcclxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh1c2VSZWZFbGVtZW50UHJvcHMoeyBjbGFzczogXCJ0b2FzdHMtY29udGFpbmVyXCIsIHJvbGU6IFwic3RhdHVzXCIsIFwiYXJpYS1saXZlXCI6IHBvbGl0ZW5lc3MgPz8gYXJpYUxpdmUgPz8gXCJwb2xpdGVcIiwgXCJhcmlhLXJlbGV2YW50XCI6IGFyaWFSZWxldmFudCA/PyBcImFkZGl0aW9uc1wiIH0pLCBwcm9wcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB1c2VUb2FzdCwgdXNlVG9hc3RDb250YWluZXJQcm9wcyB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS10b2FzdHMuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlQ29udGV4dCwgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRFbGVtZW50UmVmKGNvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGZvcndhcmRSZWYoY29tcG9uZW50KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdXNlUHNldWRvQWN0aXZlKHsgXCJkYXRhLXBzZXVkby1hY3RpdmVcIjogYWN0aXZlLCAuLi5wcm9wcyB9KSB7XHJcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzTmFtZTogY2xzeCgoYWN0aXZlID09IHRydWUgfHwgYWN0aXZlID09IFwidHJ1ZVwiKSAmJiBcImFjdGl2ZVwiKSB9LCBwcm9wcyk7XHJcbn1cclxuY29uc3QgU3Bpbm5lckRlbGF5Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoMTAwMCk7XHJcbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlU3Bpbm5lckRlbGF5KHsgY2hpbGRyZW4sIHRpbWVvdXQgfSkge1xyXG4gICAgcmV0dXJuIGgoU3Bpbm5lckRlbGF5Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGltZW91dCB9LCBjaGlsZHJlbik7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNwaW5uZXJEZWxheShwZW5kaW5nLCB0aW1lb3V0KSB7XHJcbiAgICBjb25zdCBbc2hvd1NwaW5uZXIsIHNldFNob3dTcGlubmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHNldFNob3dTcGlubmVyKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbcGVuZGluZ10pO1xyXG4gICAgY29uc3QgZGVmYXVsdERlbGF5ID0gdXNlQ29udGV4dChTcGlubmVyRGVsYXlDb250ZXh0KTtcclxuICAgIHVzZVRpbWVvdXQoe1xyXG4gICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQgPz8gZGVmYXVsdERlbGF5ID8/IDEwMDAsXHJcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgc2V0U2hvd1NwaW5uZXIocGVuZGluZyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmlnZ2VySW5kZXg6IHBlbmRpbmdcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNob3dTcGlubmVyO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BzLmpzLm1hcCIsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUFyaWFBY2NvcmRpb24gfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0c1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgQ29sbGFwc2UgfSBmcm9tIFwicHJlYWN0LXRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi4vcHJvcHNcIjtcclxuY29uc3QgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuZXhwb3J0IGNvbnN0IEFjY29yZGlvbiA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEFjY29yZGlvbih7IGV4cGFuZGVkSW5kZXgsIHNldEV4cGFuZGVkSW5kZXgsIGNoaWxkcmVuLCAuLi5wcm9wcyB9LCByZWYpIHtcclxuICAgIGNvbnN0IHsgdXNlQXJpYUFjY29yZGlvblNlY3Rpb24gfSA9IHVzZUFyaWFBY2NvcmRpb24oeyBleHBhbmRlZEluZGV4LCBzZXRFeHBhbmRlZEluZGV4IH0pO1xyXG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKSh7IHJlZiwgY2xhc3NOYW1lOiBcImFjY29yZGlhblwiIH0sIHByb3BzKSB9LFxyXG4gICAgICAgIGgoVXNlQXJpYUFjY29yZGlvblNlY3Rpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbiB9LCBjaGlsZHJlbikpKTtcclxufSk7XHJcbmV4cG9ydCBjb25zdCBBY2NvcmRpb25TZWN0aW9uID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQWNjb3JkaW9uU2VjdGlvbih7IGluZGV4LCBvcGVuLCBoZWFkZXIsIGhlYWRlckxldmVsLCBjaGlsZHJlbiwgVHJhbnNpdGlvbiwgLi4ucHJvcHMgfSwgcmVmKSB7XHJcbiAgICBjb25zdCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbiA9IHVzZUNvbnRleHQoVXNlQXJpYUFjY29yZGlvblNlY3Rpb25Db250ZXh0KTtcclxuICAgIGNvbnN0IHsgZXhwYW5kZWQsIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyLCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHkgfSA9IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uKHsgaW5kZXgsIG9wZW4gfSk7XHJcbiAgICBjb25zdCB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHMgfSA9IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyKHsgdGFnOiBcImJ1dHRvblwiIH0pO1xyXG4gICAgY29uc3QgeyB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyB9ID0gdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5KCk7XHJcbiAgICBUcmFuc2l0aW9uID8/PSBDb2xsYXBzZTtcclxuICAgIGhlYWRlckxldmVsID8/PSAyO1xyXG4gICAgY29uc29sZS5sb2coYCR7aW5kZXh9OiAke2V4cGFuZGVkPy50b1N0cmluZygpfWApO1xyXG4gICAgY29uc3QgaGVhZGVyQnV0dG9uUHJvcHMgPSB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzKHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3M6IGNsc3goXCJhY2NvcmRpb24tYnV0dG9uXCIsICFleHBhbmRlZCA/IFwiIGNvbGxhcHNlZFwiIDogXCJcIikgfSk7XHJcbiAgICBjb25zdCBoZWFkZXJQcm9wcyA9ICh7IGNsYXNzOiBcImFjY29yZGlvbi1oZWFkZXJcIiwgY2hpbGRyZW46IGgoXCJidXR0b25cIiwgeyAuLi5oZWFkZXJCdXR0b25Qcm9wcyB9LCBoZWFkZXIpIH0pO1xyXG4gICAgY29uc3QgaGVhZGVySnN4ID0gaGVhZGVyTGV2ZWwgPj0gMSAmJiBoZWFkZXJMZXZlbCA8PSA2ID8gaChgaCR7aGVhZGVyTGV2ZWx9YCwgaGVhZGVyUHJvcHMpIDogaChcImRpdlwiLCB1c2VNZXJnZWRQcm9wcygpKGhlYWRlclByb3BzLCB7IHJvbGU6IFwiaGVhZGluZ1wiLCBcImFyaWEtbGV2ZWxcIjogYCR7aGVhZGVyTGV2ZWx9YCB9KSk7XHJcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyAuLi57IHJlZiwgY2xhc3M6IFwiYWNjb3JkaW9uLWl0ZW1cIiB9IH0sXHJcbiAgICAgICAgaGVhZGVySnN4LFxyXG4gICAgICAgIGgoVHJhbnNpdGlvbiwgeyBvcGVuOiBleHBhbmRlZCwgLi4udXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHModXNlTWVyZ2VkUHJvcHMoKShwcm9wcywgeyBjbGFzczogXCJcIiB9KSkgfSxcclxuICAgICAgICAgICAgaChcImRpdlwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzOiBcImFjY29yZGlvbi1ib2R5XCIgfSwgY2hpbGRyZW4pKSkpKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY29yZGlvbi5qcy5tYXAiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMsIHVzZVJhbmRvbUlkLCB1c2VTdGF0ZSwgdXNlVGltZW91dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IGdldEZyb21Mb2NhbFN0b3JhZ2UsIHN0b3JlVG9Mb2NhbFN0b3JhZ2UgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtcGVyc2lzdGVudC1zdGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmLCB1c2VTcGlubmVyRGVsYXkgfSBmcm9tIFwiLi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgRmFkZSB9IGZyb20gXCJwcmVhY3QtdHJhbnNpdGlvbi9mYWRlXCI7XHJcbmltcG9ydCB7IFN3YXBwYWJsZSB9IGZyb20gXCJwcmVhY3QtdHJhbnNpdGlvblwiO1xyXG4vLyBJdCdzIHBvc3NpYmxlIHRvIGRvIHRoaXMgYXMgdXNlRWZmZWN0LCBidXQgZG9pbmcgc28gc2NyZXdzIHVwIHRoZSBhbmltYXRpb24gaW4gQ2hyb21lIHNvbWV0aW1lc1xyXG4vLyByZXN1bWFibHkgYmVjYXVzZSB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNoYW5nZXMuIFxyXG4vLyAoYW5kIGluIHJlYWxseSB3ZWlyZCB3YXlzIC0tIGNoYW5naW5nIHRoZSBhbmltYXRpb24gc3BlZWQgaW4gdGhlIGNvbnNvbGUgZml4ZXMgaXQgdW50aWwgeW91IHB1dCBpdCBiYWNrIGF0IDEwMCUgc3BlZWQ/Pz8pLlxyXG4vLyBBc3N1bWluZyB0aGF0J3MgdGhlIGNhc2UsIGl0J3MgZWFzaWVyIHRvIGp1c3QgdGFrZSBjYXJlIG9mIHRoZSBlbGVtZW50IGNvdW50IG9uIHBhZ2UgbG9hZC5cclxubGV0IGdpbW1pY2tDb3VudCA9IDg7XHJcbigoKSA9PiB7XHJcbiAgICBsZXQgbGFzdFNldCA9IChnZXRGcm9tTG9jYWxTdG9yYWdlKCkoXCJjaXJjdWxhci1wcm9ncmVzcy1naW1taWNrLWxhc3Qtc2V0XCIsIHN0ciA9PiBuZXcgRGF0ZShzdHIpKSA/PyBuZXcgRGF0ZSgxOTcwLCAwLCAxKSk7XHJcbiAgICBjb25zdCBkYXlzU2luY2VMYXN0R2ltbWlja1NldCA9IE1hdGguZmxvb3IoKCsobmV3IERhdGUoKSkgLSArbGFzdFNldCkgLyAxMDAwIC8gNjAgLyA2MCAvIDI0KTtcclxuICAgIGlmIChkYXlzU2luY2VMYXN0R2ltbWlja1NldCA+IDApIHtcclxuICAgICAgICBsZXQgbmV3Q291bnQgPSA0ICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMiArIE1hdGgucmFuZG9tKCkgKiAyKTtcclxuICAgICAgICBnaW1taWNrQ291bnQgPSBuZXdDb3VudDtcclxuICAgICAgICBzdG9yZVRvTG9jYWxTdG9yYWdlKCkoXCJjaXJjdWxhci1wcm9ncmVzcy1naW1taWNrLWxhc3Qtc2V0XCIsIG5ldyBEYXRlKCksIGQgPT4gZC50b0lTT1N0cmluZygpKTtcclxuICAgICAgICBzdG9yZVRvTG9jYWxTdG9yYWdlKCkoXCJjaXJjdWxhci1wcm9ncmVzcy1naW1taWNrLWNvdW50XCIsIGdpbW1pY2tDb3VudCwgSlNPTi5zdHJpbmdpZnkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2ltbWlja0NvdW50ID0gKGdldEZyb21Mb2NhbFN0b3JhZ2UoKShcImNpcmN1bGFyLXByb2dyZXNzLWdpbW1pY2stY291bnRcIiwgSlNPTi5wYXJzZSkgPz8gOCk7XHJcbiAgICB9XHJcbn0pKCk7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhUHJvZ3Jlc3NCYXIoeyB0YWcsIG1heCwgdmFsdWUsIHZhbHVlVGV4dCB9KSB7XHJcbiAgICAvL2NvbnN0IHsgaW5wdXRJZCwgbGFiZWxJZCwgdXNlR2VuZXJpY0xhYmVsSW5wdXQsIHVzZUdlbmVyaWNMYWJlbExhYmVsLCB1c2VSZWZlcmVuY2VkSW5wdXRJZFByb3BzLCB1c2VSZWZlcmVuY2VkTGFiZWxJZFByb3BzIH0gPSB1c2VHZW5lcmljTGFiZWwoeyBpbnB1dFByZWZpeDogXCJwcm9ncmVzc2Jhci1cIiwgbGFiZWxQcmVmaXg6IFwicHJvZ3Jlc3NiYXItcmVmZXJlbmNlLVwiIH0pO1xyXG4gICAgY29uc3QgeyBpZDogcHJvZ3Jlc3NCYXJJZCwgZ2V0SWQsIHVzZVJhbmRvbUlkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJwcm9ncmVzc2Jhci1cIiB9KTtcclxuICAgIGZ1bmN0aW9uIHVzZVByb2dyZXNzUHJvcHMoeyBcImFyaWEtdmFsdWVtYXhcIjogYXJpYVZhbHVlTWF4LCBcImFyaWEtdmFsdWVub3dcIjogYXJpYVZhbHVlTm93LCBcImFyaWEtdmFsdWV0ZXh0XCI6IGFyaWFWYWx1ZVRleHQsIHJvbGUsIC4uLnAgfSkge1xyXG4gICAgICAgIGNvbnN0IGV4dHJhUHJvcHMgPSB0YWcgPT09IFwicHJvZ3Jlc3NcIiA/XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1heCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiAodmFsdWUgPz8gdW5kZWZpbmVkKSxcclxuICAgICAgICAgICAgICAgIFwiYXJpYS12YWx1ZW5vd1wiOiB2YWx1ZSA9PSBudWxsID8gdW5kZWZpbmVkIDogYCR7dmFsdWV9YCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJhcmlhLXZhbHVlbWF4XCI6IG1heCA9PSBudWxsID8gdW5kZWZpbmVkIDogYCR7bWF4fWAsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhcmlhLXZhbHVldGV4dFwiOiB2YWx1ZVRleHQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGAke3ZhbHVlVGV4dH1gLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYXJpYS12YWx1ZW5vd1wiOiB2YWx1ZSA9PSBudWxsID8gdW5kZWZpbmVkIDogYCR7dmFsdWV9YCxcclxuICAgICAgICAgICAgICAgICAgICByb2xlOiBcInByb2dyZXNzYmFyXCJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHVzZVJhbmRvbUlkUHJvcHModXNlTWVyZ2VkUHJvcHMoKShleHRyYVByb3BzLCBwKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB1c2VSZWZlcmVuY2VkRWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVJlZmVyZW5jZWRFbGVtZW50KCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVJlZmVyZW5jZWRQcm9wcyhwcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlUmVmZXJlbmNlZElkUHJvcHMoXCJhcmlhLWNvbnRyb2xzXCIpKHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlUmVmZXJlbmNlZFByb3BzIH07XHJcbiAgICB9LCBbdXNlUmVmZXJlbmNlZElkUHJvcHNdKTtcclxuICAgIHJldHVybiB7IHVzZVByb2dyZXNzUHJvcHMsIHVzZVJlZmVyZW5jZWRFbGVtZW50IH07XHJcbn1cclxuZXhwb3J0IGNvbnN0IFByb2dyZXNzQXNDaGlsZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XHJcbmNvbnN0IFByb2dyZXNzTWF4Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcclxuY29uc3QgUHJvZ3Jlc3NWYWx1ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XHJcbmNvbnN0IFByb2dyZXNzVmFsdWVUZXh0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcclxuLyoqXHJcbiAqIEEgcHJvZ3Jlc3MgYmFyIGNhbiBlaXRoZXIgdGFrZSBpdHMgdmFsdWUgJiBtYXggYXJndW1lbnRzIGRpcmVjdGx5LFxyXG4gKiBvciBoYXZlIHRoZW0gcHJvdmlkZWQgYnkgYSBwYXJlbnQgdmlhIHZhcmlvbnMgQ29udGV4dCBvYmplY3RzLlxyXG4gKlxyXG4gKiBQcm9wcyB3aWxsIGJlIHByaW9yaXRpemVkIG92ZXIgY29udGV4dCBpZiBib3RoIGFyZSBnaXZlbi5cclxuICogQHBhcmFtIHBhcmFtMFxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFByb2dyZXNzTGluZWFyKHsgY29sb3IsIG1heDogbWF4UHJvcCwgdmFsdWU6IHZhbHVlUHJvcCwgdmFsdWVUZXh0OiB2YWx1ZVRleHRQcm9wLCBzdHJpcGVkLCB2YXJpYW50LCAuLi5yZXN0IH0pIHtcclxuICAgIGxldCB2YWx1ZSA9ICh1c2VDb250ZXh0KFByb2dyZXNzVmFsdWVDb250ZXh0KSk7XHJcbiAgICBsZXQgbWF4ID0gdXNlQ29udGV4dChQcm9ncmVzc01heENvbnRleHQpO1xyXG4gICAgbGV0IHZhbHVlVGV4dCA9IHVzZUNvbnRleHQoUHJvZ3Jlc3NWYWx1ZVRleHRDb250ZXh0KTtcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHZhbHVlID0gdmFsdWVQcm9wO1xyXG4gICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIG1heCA9IG1heFByb3A7XHJcbiAgICBpZiAodmFsdWVUZXh0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdmFsdWVUZXh0ID0gdmFsdWVUZXh0UHJvcDtcclxuICAgIGNvbnN0IHByb3ZpZGVQYXJlbnRXaXRoSG9vayA9IHVzZUNvbnRleHQoUHJvZ3Jlc3NBc0NoaWxkQ29udGV4dCk7XHJcbiAgICBjb25zdCB7IHVzZVByb2dyZXNzUHJvcHMsIHVzZVJlZmVyZW5jZWRFbGVtZW50IH0gPSB1c2VBcmlhUHJvZ3Jlc3NCYXIoeyB2YWx1ZSwgdmFsdWVUZXh0LCBtYXgsIHRhZzogXCJwcm9ncmVzc1wiIH0pO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgcHJvdmlkZVBhcmVudFdpdGhIb29rPy4odXNlUmVmZXJlbmNlZEVsZW1lbnQpOyB9LCBbdXNlUmVmZXJlbmNlZEVsZW1lbnQsIHByb3ZpZGVQYXJlbnRXaXRoSG9va10pO1xyXG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzTmFtZTogY2xzeChcInByb2dyZXNzXCIsIGBiZy0ke2NvbG9yID8/IFwicHJpbWFyeVwifWApIH0sIHJlc3QpIH0sXHJcbiAgICAgICAgaChcInByb2dyZXNzXCIsIHsgLi4udXNlUHJvZ3Jlc3NQcm9wcyh7IGNsYXNzTmFtZTogXCJwcm9ncmVzcy1iYXJcIiB9KSB9KSkpO1xyXG59XHJcbi8vIDopXHJcbmNvbnN0IFIgPSAoKG5ldyBEYXRlKCkpLmdldERhdGUoKSAlIDIpO1xyXG5mdW5jdGlvbiBDaGVjaygpIHtcclxuICAgIHJldHVybiAoaChcImlcIiwgeyBjbGFzczogXCJiaSBiaS1jaGVja1wiIH0pKTtcclxufVxyXG5mdW5jdGlvbiBDcm9zcygpIHtcclxuICAgIHJldHVybiAoaChcImlcIiwgeyBjbGFzczogXCJiaSBiaS14XCIgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHNhZmVQYXJzZUludChzdHIpIHtcclxuICAgIGxldCByZXQgPSBwYXJzZUludChzdHIpO1xyXG4gICAgaWYgKCFpc0Zpbml0ZShyZXQpIHx8IGlzTmFOKHJldCkpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmV4cG9ydCBjb25zdCBQcm9ncmVzc0NpcmN1bGFyID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gKHsgbG9hZGluZ0xhYmVsLCBzcGlubmVyVGltZW91dCwgbW9kZSwgY29sb3JGaWxsLCBjaGlsZHJlblBvc2l0aW9uLCBjaGlsZHJlbiwgY29sb3IsIC4uLnAgfSwgcmVmKSB7XHJcbiAgICBjb25zdCB7IHVzZVByb2dyZXNzUHJvcHMsIHVzZVJlZmVyZW5jZWRFbGVtZW50IH0gPSB1c2VBcmlhUHJvZ3Jlc3NCYXIoeyB2YWx1ZTogbnVsbCwgdmFsdWVUZXh0OiB1bmRlZmluZWQsIG1heDogdW5kZWZpbmVkLCB0YWc6IFwiZGl2XCIgfSk7XHJcbiAgICAvL3VzZUxheW91dEVmZmVjdCgoKSA9PiB7IHByb3ZpZGVQYXJlbnRXaXRoSG9vaz8uKHVzZVJlZmVyZW5jZWRFbGVtZW50KSB9LCBbdXNlUmVmZXJlbmNlZEVsZW1lbnQsIHByb3ZpZGVQYXJlbnRXaXRoSG9va10pXHJcbiAgICBjb25zdCB7IHVzZVJlZmVyZW5jZWRQcm9wcyB9ID0gdXNlUmVmZXJlbmNlZEVsZW1lbnQoKTtcclxuICAgIGNvbnN0IHNob3dTcGlubmVyID0gdXNlU3Bpbm5lckRlbGF5KG1vZGUgPT09IFwicGVuZGluZ1wiLCBzcGlubmVyVGltZW91dCk7XHJcbiAgICAvL2NvbnN0IFtzcGlubmVyU2hvd0NvdW50LCBzZXRTcGlubmVyU2hvd0NvdW50XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgLy91c2VFZmZlY3QoKCkgPT4geyBzZXRTcGlubmVyU2hvd0NvdW50KHMgPT4gKytzKSB9LCBbc2hvd1NwaW5uZXJdKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7IHNldFNob3duU3RhdHVzTG9uZ0Vub3VnaChmYWxzZSk7IH0sIFttb2RlXSk7XHJcbiAgICBjb25zdCBbc2hvd25TdGF0dXNMb25nRW5vdWdoLCBzZXRTaG93blN0YXR1c0xvbmdFbm91Z2hdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgdXNlVGltZW91dCh7XHJcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHsgaWYgKG1vZGUgPT0gXCJmYWlsZWRcIiB8fCAobW9kZSA9PSBcInN1Y2NlZWRlZFwiKSlcclxuICAgICAgICAgICAgc2V0U2hvd25TdGF0dXNMb25nRW5vdWdoKHRydWUpOyB9LFxyXG4gICAgICAgIHRpbWVvdXQ6IDEwMDAsXHJcbiAgICAgICAgdHJpZ2dlckluZGV4OiBtb2RlXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHByb2dyZXNzUHJvcHMgPSB1c2VQcm9ncmVzc1Byb3BzKHsgXCJhcmlhLWhpZGRlblwiOiBgJHttb2RlICE9IFwicGVuZGluZ1wifWAsIFwiYXJpYS12YWx1ZXRleHRcIjogXCJPcGVyYXRpb24gcGVuZGluZ1wiIH0pO1xyXG4gICAgY29uc3QgcHJvZ3Jlc3NFbGVtZW50ID0gKGgoXCJkaXZcIiwgeyAuLi51c2VNZXJnZWRQcm9wcygpKHsgcmVmLCBjbGFzc05hbWU6IGNsc3goXCJjaXJjdWxhci1wcm9ncmVzcy1jb250YWluZXJcIikgfSwgdXNlTWVyZ2VkUHJvcHMoKShwcm9ncmVzc1Byb3BzLCBwKSkgfSxcclxuICAgICAgICBtb2RlID09PSBcInBlbmRpbmdcIiAmJiAhIWxvYWRpbmdMYWJlbCAmJiBoKFwiZGl2XCIsIHsgcm9sZTogXCJhbGVydFwiLCBcImFyaWEtbGl2ZVwiOiBcImFzc2VydGl2ZVwiLCBjbGFzczogXCJ2aXN1YWxseS1oaWRkZW5cIiB9LCBsb2FkaW5nTGFiZWwpLFxyXG4gICAgICAgIGgoU3dhcHBhYmxlLCBudWxsLFxyXG4gICAgICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNpcmN1bGFyLXByb2dyZXNzLXN3YXBwYWJsZVwiIH0sXHJcbiAgICAgICAgICAgICAgICBoKEZhZGUsIHsgb3BlbjogbW9kZSA9PT0gXCJwZW5kaW5nXCIgJiYgc2hvd1NwaW5uZXIgfSxcclxuICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgc3R5bGU6IHsgXCItLWNvdW50XCI6IGdpbW1pY2tDb3VudCB9LCBjbGFzc05hbWU6IGNsc3goXCJjaXJjdWxhci1wcm9ncmVzc1wiLCBjb2xvciA/IGBjaXJjdWxhci1wcm9ncmVzcy0ke2NvbG9yfWAgOiB1bmRlZmluZWQsIGNvbG9yRmlsbCA9PSBcImZvcmVncm91bmRcIiAmJiBcImludmVyc2UtZmlsbFwiLCBjb2xvckZpbGwgPT09IFwiZm9yZWdyb3VuZC1vbmx5XCIgJiYgXCJuby1maWxsXCIpIH0sIEFycmF5LmZyb20oZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnaW1taWNrQ291bnQ7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGgoXCJkaXZcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KCkpKSksXHJcbiAgICAgICAgICAgICAgICBoKEZhZGUsIHsgb3BlbjogIXNob3duU3RhdHVzTG9uZ0Vub3VnaCAmJiBtb2RlID09PSBcInN1Y2NlZWRlZFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzOiBcImNpcmN1bGFyLXByb2dyZXNzLXN1Y2NlZWRlZFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoQ2hlY2ssIG51bGwpKSksXHJcbiAgICAgICAgICAgICAgICBoKEZhZGUsIHsgb3BlbjogIXNob3duU3RhdHVzTG9uZ0Vub3VnaCAmJiBtb2RlID09PSBcImZhaWxlZFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzOiBcImNpcmN1bGFyLXByb2dyZXNzLWZhaWxlZFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoQ3Jvc3MsIG51bGwpKSkpKSkpO1xyXG4gICAgY2hpbGRyZW5Qb3NpdGlvbiA/Pz0gXCJhZnRlclwiO1xyXG4gICAgcmV0dXJuIChoKEZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIGNoaWxkcmVuUG9zaXRpb24gPT0gXCJiZWZvcmVcIiAmJiBwcm9ncmVzc0VsZW1lbnQsXHJcbiAgICAgICAgY2hpbGRyZW4gJiYgY3JlYXRlRWxlbWVudChjaGlsZHJlbi50eXBlLCB1c2VNZXJnZWRQcm9wcygpKHsgY2hpbGRyZW46IGNoaWxkcmVuUG9zaXRpb24gPT09IFwiY2hpbGRcIiA/IHByb2dyZXNzRWxlbWVudCA6IHVuZGVmaW5lZCwgcmVmOiBjaGlsZHJlbi5yZWYgfSwgdXNlUmVmZXJlbmNlZFByb3BzKGNoaWxkcmVuLnByb3BzKSkpLFxyXG4gICAgICAgIGNoaWxkcmVuUG9zaXRpb24gPT0gXCJhZnRlclwiICYmIHByb2dyZXNzRWxlbWVudCkpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluZWFyLmpzLm1hcCIsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuZXhwb3J0IGNvbnN0IFVzZUJ1dHRvbkdyb3VwQ2hpbGQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG5jb25zdCBEZWZhdWx0RmlsbFN0eWxlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoXCJmaWxsXCIpO1xyXG5jb25zdCBEZWZhdWx0Q29sb3JTdHlsZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KFwicHJpbWFyeVwiKTtcclxuY29uc3QgRGVmYXVsdFNpemVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcIm1kXCIpO1xyXG5jb25zdCBEZWZhdWx0RGlzYWJsZWRDb250ZXh0ID0gY3JlYXRlQ29udGV4dChmYWxzZSk7XHJcbmV4cG9ydCBjb25zdCBQcm92aWRlRGVmYXVsdEJ1dHRvbkZpbGwgPSBtZW1vKGZ1bmN0aW9uIFByb3ZpZGVEZWZhdWx0QnV0dG9uRmlsbCh7IHZhbHVlLCBjaGlsZHJlbiB9KSB7IHJldHVybiBoKERlZmF1bHRGaWxsU3R5bGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSB9LCBjaGlsZHJlbik7IH0pO1xyXG5leHBvcnQgY29uc3QgUHJvdmlkZURlZmF1bHRCdXR0b25Db2xvciA9IG1lbW8oZnVuY3Rpb24gUHJvdmlkZURlZmF1bHRCdXR0b25Db2xvcih7IHZhbHVlLCBjaGlsZHJlbiB9KSB7IHJldHVybiBoKERlZmF1bHRDb2xvclN0eWxlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdmFsdWUgfSwgY2hpbGRyZW4pOyB9KTtcclxuZXhwb3J0IGNvbnN0IFByb3ZpZGVEZWZhdWx0QnV0dG9uU2l6ZSA9IG1lbW8oZnVuY3Rpb24gUHJvdmlkZURlZmF1bHRCdXR0b25TaXplKHsgdmFsdWUsIGNoaWxkcmVuIH0pIHsgcmV0dXJuIGgoRGVmYXVsdFNpemVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSB9LCBjaGlsZHJlbik7IH0pO1xyXG5leHBvcnQgY29uc3QgUHJvdmlkZURlZmF1bHRCdXR0b25EaXNhYmxlZCA9IG1lbW8oZnVuY3Rpb24gUHJvdmlkZURlZmF1bHRCdXR0b25EaXNhYmxlZCh7IHZhbHVlLCBjaGlsZHJlbiB9KSB7IHJldHVybiBoKERlZmF1bHREaXNhYmxlZENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHZhbHVlIH0sIGNoaWxkcmVuKTsgfSk7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCdXR0b25GaWxsVmFyaWFudChwcm92aWRlZFZhbHVlKSB7XHJcbiAgICBjb25zdCBkZWZhdWx0RmlsbCA9IHVzZUNvbnRleHQoRGVmYXVsdEZpbGxTdHlsZUNvbnRleHQpO1xyXG4gICAgcmV0dXJuIHByb3ZpZGVkVmFsdWUgPz8gZGVmYXVsdEZpbGw7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJ1dHRvbkNvbG9yVmFyaWFudChwcm92aWRlZFZhbHVlKSB7XHJcbiAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSB1c2VDb250ZXh0KERlZmF1bHRDb2xvclN0eWxlQ29udGV4dCk7XHJcbiAgICByZXR1cm4gcHJvdmlkZWRWYWx1ZSA/PyBkZWZhdWx0Q29sb3I7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJ1dHRvblNpemUocHJvdmlkZWRWYWx1ZSkge1xyXG4gICAgY29uc3QgZGVmYXVsdFNpemUgPSB1c2VDb250ZXh0KERlZmF1bHRTaXplQ29udGV4dCk7XHJcbiAgICByZXR1cm4gcHJvdmlkZWRWYWx1ZSA/PyBkZWZhdWx0U2l6ZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQnV0dG9uRGlzYWJsZWQocHJvdmlkZWRWYWx1ZSkge1xyXG4gICAgY29uc3QgZGVmYXVsdERpc2FibGVkID0gdXNlQ29udGV4dChEZWZhdWx0RGlzYWJsZWRDb250ZXh0KTtcclxuICAgIHJldHVybiBwcm92aWRlZFZhbHVlID8/IGRlZmF1bHREaXNhYmxlZDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQnV0dG9uU3R5bGVzKHApIHtcclxuICAgIGxldCB7IGNvbG9yVmFyaWFudCwgc2l6ZSwgZmlsbFZhcmlhbnQsIGRpc2FibGVkIH0gPSBwO1xyXG4gICAgY29sb3JWYXJpYW50ID0gdXNlQnV0dG9uQ29sb3JWYXJpYW50KGNvbG9yVmFyaWFudCk7XHJcbiAgICBzaXplID0gdXNlQnV0dG9uU2l6ZShzaXplKTtcclxuICAgIGZpbGxWYXJpYW50ID0gdXNlQnV0dG9uRmlsbFZhcmlhbnQoZmlsbFZhcmlhbnQpO1xyXG4gICAgZGlzYWJsZWQgPSB1c2VCdXR0b25EaXNhYmxlZChkaXNhYmxlZCk7XHJcbiAgICBjb25zdCB1c2VCdXR0b25TdHlsZXNQcm9wcyA9IChwcm9wcykgPT4gdXNlTWVyZ2VkUHJvcHMoKSh7IFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkLCBjbGFzc05hbWU6IGNsc3goZGlzYWJsZWQgJiYgXCJkaXNhYmxlZFwiLCBcImJ0blwiLCBgYnRuLSR7ZmlsbFZhcmlhbnQgPT0gXCJvdXRsaW5lXCIgPyBgb3V0bGluZS1gIDogYGB9JHtjb2xvclZhcmlhbnR9YCwgYGJ0bi0ke3NpemV9YCwgZGlzYWJsZWQgJiYgXCJkaXNhYmxlZFwiKSB9LCBwcm9wcyk7XHJcbiAgICByZXR1cm4geyBjb2xvclZhcmlhbnQsIHNpemUsIGZpbGxWYXJpYW50LCBkaXNhYmxlZCwgdXNlQnV0dG9uU3R5bGVzUHJvcHMgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0cy5qcy5tYXAiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VBcmlhQnV0dG9uIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWJ1dHRvblwiO1xyXG5pbXBvcnQgeyB1c2VBc3luY0hhbmRsZXIsIHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgUHJvZ3Jlc3NDaXJjdWxhciB9IGZyb20gXCIuLi9wcm9ncmVzc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyBVc2VCdXR0b25Hcm91cENoaWxkLCB1c2VCdXR0b25TdHlsZXMgfSBmcm9tIFwiLi9kZWZhdWx0c1wiO1xyXG5mdW5jdGlvbiBCdXR0b25SKHAsIHJlZikge1xyXG4gICAgaWYgKHAudGFnPy50b0xvd2VyQ2FzZSgpID09PSBcImFcIiB8fCAhIXAuaHJlZilcclxuICAgICAgICByZXR1cm4gaChBbmNob3JCdXR0b24sIHsgcmVmOiByZWYsIC4uLnAgfSk7XHJcbiAgICBlbHNlIGlmIChwLnByZXNzZWQgIT0gbnVsbClcclxuICAgICAgICByZXR1cm4gaChUb2dnbGVCdXR0b24sIHsgcmVmOiByZWYsIC4uLnAgfSk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGgoQnV0dG9uQnV0dG9uLCB7IHJlZjogcmVmLCAuLi5wIH0pO1xyXG59XHJcbmNvbnN0IEFuY2hvckJ1dHRvbiA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEFuY2hvckJ1dHRvbihwLCByZWYpIHtcclxuICAgIGxldCB7IGNvbG9yVmFyaWFudCwgc2l6ZSwgZmlsbFZhcmlhbnQsIGRpc2FibGVkLCAuLi5wcm9wcyB9ID0gcDtcclxuICAgIGNvbnN0IGJ1dHRvblN0eWxlSW5mbyA9IHVzZUJ1dHRvblN0eWxlcyh7IGNvbG9yVmFyaWFudCwgc2l6ZSwgZmlsbFZhcmlhbnQsIGRpc2FibGVkIH0pO1xyXG4gICAgZGlzYWJsZWQgPSBidXR0b25TdHlsZUluZm8uZGlzYWJsZWQ7XHJcbiAgICBjb2xvclZhcmlhbnQgPSBidXR0b25TdHlsZUluZm8uY29sb3JWYXJpYW50O1xyXG4gICAgc2l6ZSA9IGJ1dHRvblN0eWxlSW5mby5zaXplO1xyXG4gICAgZmlsbFZhcmlhbnQgPSBidXR0b25TdHlsZUluZm8uZmlsbFZhcmlhbnQ7XHJcbiAgICBjb25zdCB1c2VCdXR0b25TdHlsZXNQcm9wcyA9IGJ1dHRvblN0eWxlSW5mby51c2VCdXR0b25TdHlsZXNQcm9wcztcclxuICAgIHJldHVybiBoKFwiYVwiLCB7IC4uLih1c2VCdXR0b25TdHlsZXNQcm9wcyh7IC4uLnByb3BzLCByZWYgfSkpIH0pO1xyXG59KTtcclxuY29uc3QgQnV0dG9uQnV0dG9uID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQnV0dG9uQnV0dG9uKHAsIHJlZikge1xyXG4gICAgbGV0IHsgY29sb3JWYXJpYW50LCBzaXplLCBmaWxsVmFyaWFudCwgZGlzYWJsZWQsIGRlYm91bmNlLCBzaG93QXN5bmNTdWNjZXNzLCBvbkNsaWNrOiBvbkNsaWNrQXN5bmMsIC4uLnByb3BzIH0gPSBwO1xyXG4gICAgY29uc3QgeyBnZXRTeW5jSGFuZGxlciwgcGVuZGluZywgc2V0dGxlQ291bnQsIGhhc0Vycm9yIH0gPSB1c2VBc3luY0hhbmRsZXIoKSh7IGRlYm91bmNlLCBjYXB0dXJlOiB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiB1bmRlZmluZWQ7IH0sIFtdKSB9KTtcclxuICAgIGRpc2FibGVkIHx8PSBwZW5kaW5nO1xyXG4gICAgY29uc3QgeyB1c2VBcmlhQnV0dG9uUHJvcHMgfSA9IHVzZUFyaWFCdXR0b24oeyB0YWc6IFwiYnV0dG9uXCIgfSk7XHJcbiAgICBjb25zdCBidXR0b25TdHlsZUluZm8gPSB1c2VCdXR0b25TdHlsZXMoeyBjb2xvclZhcmlhbnQsIHNpemUsIGZpbGxWYXJpYW50LCBkaXNhYmxlZCB9KTtcclxuICAgIGRpc2FibGVkID0gYnV0dG9uU3R5bGVJbmZvLmRpc2FibGVkO1xyXG4gICAgY29sb3JWYXJpYW50ID0gYnV0dG9uU3R5bGVJbmZvLmNvbG9yVmFyaWFudDtcclxuICAgIHNpemUgPSBidXR0b25TdHlsZUluZm8uc2l6ZTtcclxuICAgIGZpbGxWYXJpYW50ID0gYnV0dG9uU3R5bGVJbmZvLmZpbGxWYXJpYW50O1xyXG4gICAgY29uc3QgdXNlQnV0dG9uU3R5bGVzUHJvcHMgPSBidXR0b25TdHlsZUluZm8udXNlQnV0dG9uU3R5bGVzUHJvcHM7XHJcbiAgICBjb25zdCBvbkNsaWNrID0gZ2V0U3luY0hhbmRsZXIocGVuZGluZyA/IG51bGwgOiBvbkNsaWNrQXN5bmMpO1xyXG4gICAgcmV0dXJuIChoKFByb2dyZXNzQ2lyY3VsYXIsIHsgbW9kZTogaGFzRXJyb3IgPyBcImZhaWxlZFwiIDogcGVuZGluZyA/IFwicGVuZGluZ1wiIDogKHNldHRsZUNvdW50ICYmIHNob3dBc3luY1N1Y2Nlc3MpID8gXCJzdWNjZWVkZWRcIiA6IG51bGwsIGNoaWxkcmVuUG9zaXRpb246IFwiY2hpbGRcIiwgY29sb3JGaWxsOiBmaWxsVmFyaWFudCA9PSBcImZpbGxcIiA/IFwiZm9yZWdyb3VuZFwiIDogXCJiYWNrZ3JvdW5kXCIgfSxcclxuICAgICAgICBoKFwiYnV0dG9uXCIsIHsgLi4udXNlQXJpYUJ1dHRvblByb3BzKHVzZUJ1dHRvblN0eWxlc1Byb3BzKHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzc05hbWU6IGNsc3gocGVuZGluZyAmJiBcInBlbmRpbmcgYWN0aXZlXCIsIGRpc2FibGVkICYmIFwiZGlzYWJsZWRcIikgfSwgeyAuLi5wcm9wcywgb25DbGljaywgcmVmIH0pKSkgfSkpKTtcclxufSk7XHJcbmV4cG9ydCBjb25zdCBUb2dnbGVCdXR0b24gPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBUb2dnbGVCdXR0b24ocCwgcmVmKSB7XHJcbiAgICBsZXQgeyBjb2xvclZhcmlhbnQsIHNpemUsIGRpc2FibGVkLCBwcmVzc2VkLCBkZWJvdW5jZSwgb25JbnB1dDogb25QcmVzc0FzeW5jLCBzaG93QXN5bmNTdWNjZXNzLCAuLi5wcm9wcyB9ID0gcDtcclxuICAgIGNvbnN0IGZpbGxWYXJpYW50ID0gcHJlc3NlZCA/IFwiZmlsbFwiIDogXCJvdXRsaW5lXCI7XHJcbiAgICBjb25zdCBpbkJ1dHRvbkdyb3VwID0gISF1c2VDb250ZXh0KFVzZUJ1dHRvbkdyb3VwQ2hpbGQpO1xyXG4gICAgY29uc3QgZ2V0UHJlc3NlZCA9IHVzZVN0YWJsZUdldHRlcihwcmVzc2VkKTtcclxuICAgIGNvbnN0IHsgZ2V0U3luY0hhbmRsZXIsIHBlbmRpbmcsIGhhc0Vycm9yLCBzZXR0bGVDb3VudCwgaGFzQ2FwdHVyZSwgY3VycmVudENhcHR1cmUgfSA9IHVzZUFzeW5jSGFuZGxlcigpKHsgZGVib3VuY2UsIGNhcHR1cmU6IHVzZUNhbGxiYWNrKCgpID0+IHsgcmV0dXJuICFnZXRQcmVzc2VkKCk7IH0sIFtdKSB9KTtcclxuICAgIGRpc2FibGVkIHx8PSBwZW5kaW5nO1xyXG4gICAgaWYgKGhhc0NhcHR1cmUgJiYgcGVuZGluZylcclxuICAgICAgICBwcmVzc2VkID0gY3VycmVudENhcHR1cmU7XHJcbiAgICBjb25zdCB7IHVzZUFyaWFCdXR0b25Qcm9wcyB9ID0gdXNlQXJpYUJ1dHRvbih7IHRhZzogXCJidXR0b25cIiwgcHJlc3NlZCB9KTtcclxuICAgIGNvbnN0IGJ1dHRvblN0eWxlSW5mbyA9IHVzZUJ1dHRvblN0eWxlcyh7IGNvbG9yVmFyaWFudCwgc2l6ZSwgZmlsbFZhcmlhbnQsIGRpc2FibGVkIH0pO1xyXG4gICAgZGlzYWJsZWQgPSBidXR0b25TdHlsZUluZm8uZGlzYWJsZWQ7XHJcbiAgICBjb2xvclZhcmlhbnQgPSBidXR0b25TdHlsZUluZm8uY29sb3JWYXJpYW50O1xyXG4gICAgc2l6ZSA9IGJ1dHRvblN0eWxlSW5mby5zaXplO1xyXG4gICAgY29uc3QgdXNlQnV0dG9uU3R5bGVzUHJvcHMgPSBidXR0b25TdHlsZUluZm8udXNlQnV0dG9uU3R5bGVzUHJvcHM7XHJcbiAgICBjb25zdCBvbkNsaWNrID0gZ2V0U3luY0hhbmRsZXIocGVuZGluZyA/IG51bGwgOiBvblByZXNzQXN5bmMpO1xyXG4gICAgcmV0dXJuIChoKFByb2dyZXNzQ2lyY3VsYXIsIHsgbW9kZTogaGFzRXJyb3IgPyBcImZhaWxlZFwiIDogcGVuZGluZyA/IFwicGVuZGluZ1wiIDogKHNldHRsZUNvdW50ICYmIHNob3dBc3luY1N1Y2Nlc3MpID8gXCJzdWNjZWVkZWRcIiA6IG51bGwsIGNoaWxkcmVuUG9zaXRpb246IFwiY2hpbGRcIiwgY29sb3JGaWxsOiBmaWxsVmFyaWFudCA9PSBcImZpbGxcIiA/IFwiZm9yZWdyb3VuZFwiIDogXCJiYWNrZ3JvdW5kXCIgfSxcclxuICAgICAgICBoKFwiYnV0dG9uXCIsIHsgLi4udXNlQXJpYUJ1dHRvblByb3BzKHVzZUJ1dHRvblN0eWxlc1Byb3BzKHsgLi4udXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzTmFtZTogY2xzeChcInRvZ2dsZS1idXR0b25cIiwgKHBlbmRpbmcgfHwgKGluQnV0dG9uR3JvdXAgJiYgcHJlc3NlZCkpICYmIFwiYWN0aXZlXCIpLCBvbkNsaWNrLCByZWYgfSwgcHJvcHMpIH0pKSB9KSkpO1xyXG59KTtcclxuZXhwb3J0IGNvbnN0IEJ1dHRvbiA9IGZvcndhcmRFbGVtZW50UmVmKEJ1dHRvblIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24uanMubWFwIiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlSGFzRm9jdXMsIHVzZUxpc3ROYXZpZ2F0aW9uLCB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4uL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZUJ1dHRvbkNvbG9yVmFyaWFudCwgdXNlQnV0dG9uRGlzYWJsZWQsIHVzZUJ1dHRvbkZpbGxWYXJpYW50LCBVc2VCdXR0b25Hcm91cENoaWxkLCB1c2VCdXR0b25TaXplIH0gZnJvbSBcIi4vZGVmYXVsdHNcIjtcclxuaW1wb3J0IHsgUHJvdmlkZURlZmF1bHRCdXR0b25Db2xvciwgUHJvdmlkZURlZmF1bHRCdXR0b25TaXplLCBQcm92aWRlRGVmYXVsdEJ1dHRvbkRpc2FibGVkLCBQcm92aWRlRGVmYXVsdEJ1dHRvbkZpbGwgfSBmcm9tIFwiLi9kZWZhdWx0c1wiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gXCIuL2J1dHRvblwiO1xyXG5leHBvcnQgY29uc3QgQnV0dG9uR3JvdXAgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBCdXR0b25Hcm91cChwLCByZWYpIHtcclxuICAgIGNvbnN0IHsgbGFzdEZvY3VzZWRJbm5lciwgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXMoKTtcclxuICAgIGNvbnN0IHsgaW5kaWNlc0J5RWxlbWVudCwgbWFuYWdlZENoaWxkcmVuLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCBuYXZpZ2F0ZVRvSW5kZXgsIGNoaWxkQ291bnQgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uKHsgZm9jdXNPbkNoYW5nZTogbGFzdEZvY3VzZWRJbm5lciB9KTtcclxuICAgIC8vIFN0eWxpbmcgcHJvcHNcclxuICAgIGxldCB7IGNvbG9yVmFyaWFudCwgZmlsbFZhcmlhbnQsIHNpemUsIGRpc2FibGVkLCBzZWxlY3RlZEluZGV4LCB3cmFwLCAuLi5wMyB9ID0gcDtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbClcclxuICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KHNlbGVjdGVkSW5kZXgpO1xyXG4gICAgfSwgW3NlbGVjdGVkSW5kZXhdKTtcclxuICAgIC8vIEJ1aWxkIG5ldyBET00gcHJvcHMgdG8gbWVyZ2UgYmFzZWQgb2ZmIHRoZSBzdHlsaW5nIHByb3BzXHJcbiAgICBjb2xvclZhcmlhbnQgPSB1c2VCdXR0b25Db2xvclZhcmlhbnQoY29sb3JWYXJpYW50KTtcclxuICAgIHNpemUgPSB1c2VCdXR0b25TaXplKHNpemUpO1xyXG4gICAgZmlsbFZhcmlhbnQgPSB1c2VCdXR0b25GaWxsVmFyaWFudChmaWxsVmFyaWFudCk7XHJcbiAgICBkaXNhYmxlZCA9IHVzZUJ1dHRvbkRpc2FibGVkKGRpc2FibGVkKTtcclxuICAgIGNvbnN0IG5ld0RvbVByb3BzID0geyByZWYsIHJvbGU6IFwiZ3JvdXBcIiwgZGlzYWJsZWQsIGNsYXNzTmFtZTogY2xzeChcImJ0bi1ncm91cFwiLCB3cmFwICYmIFwid3JhcFwiKSB9O1xyXG4gICAgLy8gUmVtYWluaW5nIHByb3BzLCBmb3J3YXJkZWQgb250byB0aGUgRE9NXHJcbiAgICBjb25zdCBkb21Qcm9wcyA9IHVzZUhhc0ZvY3VzUHJvcHModXNlTWVyZ2VkUHJvcHMoKShuZXdEb21Qcm9wcywgcDMpKTtcclxuICAgIGRvbVByb3BzW1wiZGF0YS1jaGlsZC1jb3VudFwiXSA9IGAke2NoaWxkQ291bnR9YDtcclxuICAgIHJldHVybiAoaChVc2VCdXR0b25Hcm91cENoaWxkLlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkIH0sXHJcbiAgICAgICAgaChQcm92aWRlRGVmYXVsdEJ1dHRvbkNvbG9yLCB7IHZhbHVlOiBjb2xvclZhcmlhbnQgfSxcclxuICAgICAgICAgICAgaChQcm92aWRlRGVmYXVsdEJ1dHRvbkZpbGwsIHsgdmFsdWU6IGZpbGxWYXJpYW50IH0sXHJcbiAgICAgICAgICAgICAgICBoKFByb3ZpZGVEZWZhdWx0QnV0dG9uU2l6ZSwgeyB2YWx1ZTogc2l6ZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGgoUHJvdmlkZURlZmF1bHRCdXR0b25EaXNhYmxlZCwgeyB2YWx1ZTogZGlzYWJsZWQgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IC4uLmRvbVByb3BzIH0pKSkpKSkpO1xyXG59KTtcclxuZXhwb3J0IGNvbnN0IEJ1dHRvbkdyb3VwQ2hpbGQgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBCdXR0b25Hcm91cENoaWxkMSh7IGluZGV4LCAuLi5idXR0b25Qcm9wcyB9LCByZWYpIHtcclxuICAgIC8vIFRoaXMgaXMgbW9yZS1vci1sZXNzIGZvcmNlZCB0byBiZSBhIHNlcGFyYXRlIGNvbXBvbmVudCBiZWNhdXNlIG9mIHRoZSBpbmRleCBwcm9wLlxyXG4gICAgLy8gSXQgd291bGQgYmUgcmVhbGx5IG5pY2UgdG8gZmluZCBhIHdheSB0byBtYWtlIHRoYXQgaW1wbGljaXQgYmFzZWQgb24gRE9NIGxvY2F0aW9uLFxyXG4gICAgLy8gc3BlY2lmaWNhbGx5IGZvciBzbWFsbCB0aGluZ3MgbGlrZSBidXR0b24gZ3JvdXBzLi4uXHJcbiAgICBjb25zdCB1c2VCdXR0b25Hcm91cENoaWxkID0gdXNlQ29udGV4dChVc2VCdXR0b25Hcm91cENoaWxkKTtcclxuICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcywgdXNlTGlzdE5hdmlnYXRpb25TaWJsaW5nUHJvcHMgfSA9IHVzZUJ1dHRvbkdyb3VwQ2hpbGQoeyBpbmRleCwgdGV4dDogbnVsbCB9KTtcclxuICAgIC8vIFRPRE86IEl0J3Mga2luZGEgZnJhZ2lsZSBoZXJlIGhvdyB0aGUgc3luYyBvbkNsaWNrIG9mIGxpc3ROYXZpZ2F0aW9uIFxyXG4gICAgLy8gYW5kIHRoZSBhc3luYyBvbkNsaWNrIG9mIGJ1dHRvbiBhcmUgbWl4aW5nLlxyXG4gICAgY29uc3QgcCA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh7IHJlZiwgLi4uYnV0dG9uUHJvcHMgfSk7XHJcbiAgICByZXR1cm4gaChCdXR0b24sIHsgLi4ucCB9KTtcclxufSk7XHJcbigpID0+IHtcclxuICAgIGgoQnV0dG9uR3JvdXBDaGlsZCwgeyBpbmRleDogMCwgcHJlc3NlZDogdHJ1ZSwgb25JbnB1dDogYiA9PiB7IH0gfSk7XHJcbiAgICBoKEJ1dHRvbkdyb3VwQ2hpbGQsIHsgaW5kZXg6IDAsIHRhZzogXCJhXCIsIGhyZWY6IFwiIFwiIH0pO1xyXG4gICAgaChCdXR0b25Hcm91cENoaWxkLCB7IGluZGV4OiAwLCBvbkNsaWNrOiAobiwgZSkgPT4geyB9IH0pO1xyXG4gICAgaChCdXR0b25Hcm91cENoaWxkLCB7IHRhZzogXCJidXR0b25cIiwgaW5kZXg6IDAgfSk7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgaChCdXR0b25Hcm91cENoaWxkLCB7IHRhZzogXCJidXR0b25cIiB9KTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBoKEJ1dHRvbkdyb3VwQ2hpbGQsIHsgdGFnOiBcImJ1dHRvblwiLCBpbmRleDogMCwgcHJlc3NlZDogdHJ1ZSwgb25DbGljazogYiA9PiB7IH0gfSk7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgaChCdXR0b25Hcm91cENoaWxkLCB7IHRhZzogXCJhXCIsIGluZGV4OiAwLCBwcmVzc2VkOiB0cnVlLCBvbkNsaWNrOiBiID0+IHsgfSB9KTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBoKEJ1dHRvbkdyb3VwQ2hpbGQsIHsgdGFnOiBcImFcIiwgaW5kZXg6IDAsIG9uQ2xpY2s6IGIgPT4geyB9IH0pO1xyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24tZ3JvdXAuanMubWFwIiwiaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1yYW5kb20taWRcIjtcclxuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5jb25zdCBiYXNlSWQgPSBnZW5lcmF0ZVJhbmRvbUlkKFwicmVuZGVyLXBvcnRhbC1jb250YWluZXItXCIpO1xyXG5leHBvcnQgZnVuY3Rpb24gQm9keVBvcnRhbCh7IGNoaWxkcmVuIH0pIHtcclxuICAgIGNvbnN0IGlkID0gdXNlUmVmKG51bGwpO1xyXG4gICAgY29uc3QgW3BvcnRhbEVsZW1lbnQsIHNldFBvcnRhbEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChpZC5jdXJyZW50ID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWQuY3VycmVudCA9IGdlbmVyYXRlUmFuZG9tSWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGJhc2VJZCk7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmlkID0gYmFzZUlkO1xyXG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJib2R5LXBvcnRhbC1jb250YWluZXJcIjtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkLmN1cnJlbnQpO1xyXG4gICAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImJvZHktcG9ydGFsXCI7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuaWQgPSBpZC5jdXJyZW50O1xyXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFBvcnRhbEVsZW1lbnQoZWxlbWVudCk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgaWYgKHBvcnRhbEVsZW1lbnQpXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgcG9ydGFsRWxlbWVudCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgQm9keVBvcnRhbCB9IGZyb20gXCIuLi9wb3J0YWxcIjtcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQXJpYURpYWxvZyB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4uL3Byb3BzXCI7XHJcbmltcG9ydCB7IEZhZGUgfSBmcm9tIFwicHJlYWN0LXRyYW5zaXRpb24vZmFkZVwiO1xyXG5pbXBvcnQgXCJ3aWNnLWluZXJ0XCI7XHJcbmV4cG9ydCBjb25zdCBEaWFsb2cgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBEaWFsb2coeyBvbkNsb3NlLCBvcGVuLCBkZXNjcmlwdGl2ZSwgdGl0bGUsIGZvb3RlciwgVHJhbnNpdGlvbiwgY2hpbGRyZW4sIC4uLnJlc3QgfSwgcmVmKSB7XHJcbiAgICBjb25zdCB7IHVzZURpYWxvZ0JhY2tkcm9wLCB1c2VEaWFsb2dCb2R5LCB1c2VEaWFsb2dQcm9wcywgdXNlRGlhbG9nVGl0bGUgfSA9IHVzZUFyaWFEaWFsb2coeyBvcGVuLCBvbkNsb3NlIH0pO1xyXG4gICAgY29uc3QgeyB1c2VEaWFsb2dCYWNrZHJvcFByb3BzIH0gPSB1c2VEaWFsb2dCYWNrZHJvcCgpO1xyXG4gICAgY29uc3QgeyB1c2VEaWFsb2dCb2R5UHJvcHMsIH0gPSB1c2VEaWFsb2dCb2R5KHsgZGVzY3JpcHRpdmUgfSk7XHJcbiAgICBjb25zdCB7IHVzZURpYWxvZ1RpdGxlUHJvcHMgfSA9IHVzZURpYWxvZ1RpdGxlKCk7XHJcbiAgICByZXR1cm4gKGgoQm9keVBvcnRhbCwgbnVsbCxcclxuICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3M6IFwibW9kYWwtcG9ydGFsLWNvbnRhaW5lclwiIH0sXHJcbiAgICAgICAgICAgIGgoRmFkZSwgeyBvcGVuOiBvcGVuIH0sXHJcbiAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlRGlhbG9nQmFja2Ryb3BQcm9wcyh7IGNsYXNzOiBcIm1vZGFsLWJhY2tkcm9wICBiYWNrZHJvcC1maWx0ZXItdHJhbnNpdGlvblwiIH0pIH0pKSxcclxuICAgICAgICAgICAgaChUcmFuc2l0aW9uLCB7IC4uLnsgcmVmLCBvcGVuLCAuLi5yZXN0IH0gfSxcclxuICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VEaWFsb2dQcm9wcyh7IGNsYXNzOiBcIm1vZGFsLWRpYWxvZyBtb2RhbC1kaWFsb2ctc2Nyb2xsYWJsZVwiIH0pIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzOiBcIm1vZGFsLWNvbnRlbnQgXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgIT0gbnVsbCAmJiBoKFwiZGl2XCIsIHsgLi4udXNlRGlhbG9nVGl0bGVQcm9wcyh7IGNsYXNzOiBcIm1vZGFsLWhlYWRlclwiIH0pIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKFwiaDFcIiwgeyBjbGFzczogXCJtb2RhbC10aXRsZVwiIH0sIHRpdGxlKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VEaWFsb2dCb2R5UHJvcHMoeyBjbGFzczogXCJtb2RhbC1ib2R5XCIgfSkgfSwgY2hpbGRyZW4pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb290ZXIgIT0gbnVsbCAmJiBoKFwiZGl2XCIsIHsgY2xhc3M6IFwibW9kYWwtZm9vdGVyXCIgfSwgZm9vdGVyKSkpKSkpKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpYWxvZy5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBCb2R5UG9ydGFsIH0gZnJvbSBcIi4uL3BvcnRhbFwiO1xyXG5pbXBvcnQgeyBGYWRlIH0gZnJvbSBcInByZWFjdC10cmFuc2l0aW9uL2ZhZGVcIjtcclxuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSBcIi4uL2J1dHRvblwiO1xyXG5pbXBvcnQgeyB1c2VEcmF3ZXIgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtZHJhd2VyXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiBEcmF3ZXIoeyBvbkNsb3NlLCBvcGVuLCBkZXNjcmlwdGl2ZSwgdGl0bGUsIGZvb3RlciwgVHJhbnNpdGlvbiwgY2hpbGRyZW4sIC4uLnJlc3QgfSkge1xyXG4gICAgY29uc3QgeyB1c2VEcmF3ZXJCYWNrZHJvcCwgdXNlRHJhd2VyQm9keSwgdXNlRHJhd2VyUHJvcHMsIHVzZURyYXdlclRpdGxlIH0gPSB1c2VEcmF3ZXIoeyBvcGVuLCBvbkNsb3NlIH0pO1xyXG4gICAgY29uc3QgeyB1c2VEcmF3ZXJCYWNrZHJvcFByb3BzIH0gPSB1c2VEcmF3ZXJCYWNrZHJvcCgpO1xyXG4gICAgY29uc3QgeyB1c2VEcmF3ZXJCb2R5UHJvcHMsIH0gPSB1c2VEcmF3ZXJCb2R5KHsgZGVzY3JpcHRpdmUgfSk7XHJcbiAgICBjb25zdCB7IHVzZURyYXdlclRpdGxlUHJvcHMgfSA9IHVzZURyYXdlclRpdGxlKCk7XHJcbiAgICByZXR1cm4gKGgoQm9keVBvcnRhbCwgbnVsbCxcclxuICAgICAgICBoKFwiZGl2XCIsIG51bGwsXHJcbiAgICAgICAgICAgIGgoRmFkZSwgeyBvcGVuOiBvcGVuIH0sXHJcbiAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlRHJhd2VyQmFja2Ryb3BQcm9wcyh7IGNsYXNzOiBcIm9mZmNhbnZhcy1iYWNrZHJvcCBiYWNrZHJvcC1maWx0ZXItdHJhbnNpdGlvblwiIH0pIH0pKSxcclxuICAgICAgICAgICAgaChUcmFuc2l0aW9uLCB7IC4uLnsgb3BlbiwgLi4ucmVzdCB9IH0sXHJcbiAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlRHJhd2VyUHJvcHMoeyBjbGFzczogXCJvZmZjYW52YXMgb2ZmY2FudmFzLXN0YXJ0XCIsIHRhYmluZGV4OiAtMSB9KSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJvZmZjYW52YXMtaGVhZGVyXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaChcImg1XCIsIHsgLi4udXNlRHJhd2VyVGl0bGVQcm9wcyh7IGNsYXNzOiBcIm9mZmNhbnZhcy10aXRsZVwiIH0pIH0sIFwiRHJhd2VyXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoKEJ1dHRvbiwgeyB0YWc6IFwiYnV0dG9uXCIsIGNsYXNzOiBcImJ0bi1jbG9zZSB0ZXh0LXJlc2V0XCIsIFwiYXJpYS1sYWJlbFwiOiBcIkNsb3NlXCIsIG9uQ2xpY2s6ICgpID0+IG9uQ2xvc2UoXCJlc2NhcGVcIikgfSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VEcmF3ZXJCb2R5UHJvcHMoeyBjbGFzczogXCJvZmZjYW52YXMtYm9keVwiIH0pIH0sIGNoaWxkcmVuKSkpKSkpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYXdlci5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuZXhwb3J0IGNvbnN0IEluSW5wdXRHcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0KGZhbHNlKTtcclxuZXhwb3J0IGNvbnN0IEluSW5wdXRHcmlkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoMCk7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnB1dENhcHR1cmVzKHR5cGUpIHtcclxuICAgIGNvbnN0IGNhcHR1cmUgPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0eXBlXSk7XHJcbiAgICBjb25zdCB1bmNhcHR1cmUgPSB1c2VDYWxsYmFjaygodmFsdWUpID0+IHtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3ZhbHVlfWA7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3R5cGVdKTtcclxuICAgIHJldHVybiB7IGNhcHR1cmUsIHVuY2FwdHVyZSB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BzLmpzLm1hcCIsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgSW5JbnB1dEdyaWRDb250ZXh0LCBJbklucHV0R3JvdXBDb250ZXh0IH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuZXhwb3J0IGNvbnN0IElucHV0R3JpZCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIElucHV0R3JpZCh7IHRhZywgY2hpbGRyZW4sIC4uLnByb3BzIH0sIHJlZikge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnID8/IFwiZGl2XCIsIHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzczogXCJpbnB1dC1ncmlkXCIsIHJlZiB9LCBwcm9wcyksIGgoSW5JbnB1dEdyaWRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VDb250ZXh0KEluSW5wdXRHcmlkQ29udGV4dCkgKyAxIH0sIGNoaWxkcmVuKSk7XHJcbn0pO1xyXG4vKipcclxuICogQW4gSW5wdXRHcm91cCwgdGhhdCBwdXRzIGFuIElucHV0IGFuZCBpdHMgTGFiZWwgdG9nZXRoZXIsIHZpc3VhbGx5LCBpbnRvIG9uZSBjb21wb25lbnQuXHJcbiAqXHJcbiAqIEFsbCBJbnB1dC10eXBlIGNvbXBvbmVudHMgYXV0b21hdGljYWxseSBkZXRlY3Qgd2hlbiB0aGV5J3JlIGluIGFuIElucHV0R3JvdXAgYW5kIHJlbmRlciBkaWZmZXJlbnQgYWNjb3JkaW5nbHkuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgSW5wdXRHcm91cCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIElucHV0R3JvdXAoeyBjaGlsZHJlbiwgdGFnLCAuLi5wcm9wcyB9LCByZWYpIHtcclxuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudCh0YWcgPz8gXCJkaXZcIiwgdXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzOiBcImlucHV0LWdyb3VwXCIsIHJlZiB9LCBwcm9wcyksIGgoSW5JbnB1dEdyb3VwQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdHJ1ZSB9LCBjaGlsZHJlbikpKTtcclxufSk7XHJcbi8qKlxyXG4gKiBOb3QgZ2VuZXJhbGx5IG5lZWRlZCwgc2luY2UgbW9zdCBpbnB1dCBjb21wb25lbnRzIGNvbWUgd2l0aCBsYWJlbHMgdGhhdCBkbyB0aGlzIGZvciB5b3UuXHJcbiAqXHJcbiAqIFRoYXQgYmVpbmcgc2FpZCwgaWYgeW91IGp1c3QgbmVlZCBhIHN0YXRpYyBibG9jayBvZiB0ZXh0IG5vdCBob29rZWQgdXAgdG8gYW55IGlucHV0IGVsZW1lbnQsIHRoaXMgaXMgeW91ciBjb21wb25lbnQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgSW5wdXRHcm91cFRleHQgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBJbnB1dEdyb3VwVGV4dCh7IHRhZywgY2hpbGRyZW4sIGRpc2FibGVkLCAuLi5wcm9wcyB9LCByZWYpIHtcclxuICAgIC8qXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgY2xvbmVFbGVtZW50KGNoaWxkcmVuLFxyXG4gICAgICAgICAgICAgICAgdXNlTWVyZ2VkUHJvcHM8YW55PigpKHsgY2xhc3M6IFwiaW5wdXQtZ3JvdXBcIiwgcmVmIH0sIGNoaWxkcmVuLnByb3BzKSxcclxuICAgICAgICAgICAgICAgIDxJbklucHV0R3JvdXBDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt0cnVlfT5cclxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICA8L0luSW5wdXRHcm91cENvbnRleHQuUHJvdmlkZXI+XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApOyovXHJcbiAgICAvKmNvbnN0IGluSW5wdXRHcmlkID0gISF1c2VDb250ZXh0KEluSW5wdXRHcmlkQ29udGV4dCk7XHJcbiAgICBpZiAoaW5JbnB1dEdyaWQpIHtcclxuICAgICAgICBjaGlsZHJlbiA9IDxkaXYgY2xhc3M9XCJmb3JtLWNvbnRyb2wgZmF1eC1mb3JtLWNvbnRyb2xcIj57Y2hpbGRyZW59PC9kaXY+XHJcbiAgICB9Ki9cclxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZyA/PyBcImRpdlwiLCB1c2VNZXJnZWRQcm9wcygpKHsgY2xhc3M6IGNsc3goZGlzYWJsZWQgJiYgXCJkaXNhYmxlZFwiLCBcImlucHV0LWdyb3VwLXRleHRcIiksIHJlZiB9LCBwcm9wcyksIGNoaWxkcmVuKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0LWdyb3VwLmpzLm1hcCIsImltcG9ydCB7IEZyYWdtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VJbnB1dExhYmVsIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWxhYmVsXCI7XHJcbmltcG9ydCB7IHVzZUFzeW5jSGFuZGxlciwgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBQcm9ncmVzc0NpcmN1bGFyIH0gZnJvbSBcIi4uL3Byb2dyZXNzXCI7XHJcbmltcG9ydCB7IEluSW5wdXRHcm91cENvbnRleHQsIHVzZUlucHV0Q2FwdHVyZXMsIEluSW5wdXRHcmlkQ29udGV4dCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IHVzZUhhc0ZvY3VzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuZnVuY3Rpb24gVW5sYWJlbGxlZElucHV0KHsgdHlwZSwgZGlzYWJsZWQsIHZhbHVlLCBvbklucHV0OiBvbklucHV0QXN5bmMsIC4uLnByb3BzIH0pIHtcclxuICAgIGNvbnN0IHsgY2FwdHVyZSwgdW5jYXB0dXJlIH0gPSB1c2VJbnB1dENhcHR1cmVzKHR5cGUpO1xyXG4gICAgY29uc3QgeyBmb2N1c2VkSW5uZXIsIHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzKCk7XHJcbiAgICBjb25zdCB7IGdldFN5bmNIYW5kbGVyLCBjdXJyZW50Q2FwdHVyZSwgcGVuZGluZywgaGFzRXJyb3IsIHNldHRsZUNvdW50LCBmbHVzaERlYm91bmNlZFByb21pc2UsIGN1cnJlbnRUeXBlLCAuLi5hc3luY0luZm8gfSA9IHVzZUFzeW5jSGFuZGxlcigpKHsgY2FwdHVyZSwgZGVib3VuY2U6IDE1MDAgfSk7XHJcbiAgICBjb25zdCBvbklucHV0ID0gZ2V0U3luY0hhbmRsZXIoZGlzYWJsZWQgPyBudWxsIDogb25JbnB1dEFzeW5jKTtcclxuICAgIGNvbnN0IGFzeW5jU3RhdGUgPSAoaGFzRXJyb3IgPyBcImZhaWxlZFwiIDogcGVuZGluZyA/IFwicGVuZGluZ1wiIDogc2V0dGxlQ291bnQgPyBcInN1Y2NlZWRlZFwiIDogbnVsbCk7XHJcbiAgICBjb25zdCBvbkJsdXIgPSBmbHVzaERlYm91bmNlZFByb21pc2U7XHJcbiAgICByZXR1cm4gKGgoUHJvZ3Jlc3NDaXJjdWxhciwgeyBzcGlubmVyVGltZW91dDogMTAsIG1vZGU6IGN1cnJlbnRUeXBlID09PSBcImFzeW5jXCIgPyBhc3luY1N0YXRlIDogbnVsbCwgY2hpbGRyZW5Qb3NpdGlvbjogXCJhZnRlclwiLCBjb2xvcjogXCJpbmZvXCIgfSxcclxuICAgICAgICBoKFwiaW5wdXRcIiwgeyAuLi51c2VIYXNGb2N1c1Byb3BzKHVzZU1lcmdlZFByb3BzKCkocHJvcHMsIHtcclxuICAgICAgICAgICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IGRpc2FibGVkLFxyXG4gICAgICAgICAgICAgICAgb25CbHVyLFxyXG4gICAgICAgICAgICAgICAgY2xhc3M6IGNsc3goYGZvcm0tY29udHJvbGAsIGRpc2FibGVkICYmIFwiZGlzYWJsZWRcIiwgcGVuZGluZyAmJiBcIndpdGgtZW5kLWljb25cIiksXHJcbiAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IChwZW5kaW5nIHx8IGZvY3VzZWRJbm5lcikgPyBjdXJyZW50Q2FwdHVyZSA6IHVuY2FwdHVyZSh2YWx1ZSksIG9uSW5wdXRcclxuICAgICAgICAgICAgfSkpIH0pKSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIElucHV0KHsgY2hpbGRyZW4sIHdpZHRoLCBsYWJlbFBvc2l0aW9uLCAuLi5wcm9wcyB9KSB7XHJcbiAgICBsYWJlbFBvc2l0aW9uID8/PSBcInN0YXJ0XCI7XHJcbiAgICBjb25zdCB7IGlucHV0SWQsIGxhYmVsSWQsIHVzZUlucHV0TGFiZWxJbnB1dCwgdXNlSW5wdXRMYWJlbExhYmVsIH0gPSB1c2VJbnB1dExhYmVsKHsgaW5wdXRQcmVmaXg6IFwiaW5wdXQtXCIsIGxhYmVsUHJlZml4OiBcImlucHV0LWxhYmVsLVwiIH0pO1xyXG4gICAgY29uc3QgeyB1c2VJbnB1dExhYmVsSW5wdXRQcm9wcyB9ID0gdXNlSW5wdXRMYWJlbElucHV0KCk7XHJcbiAgICBjb25zdCB7IHVzZUlucHV0TGFiZWxMYWJlbFByb3BzIH0gPSB1c2VJbnB1dExhYmVsTGFiZWwoeyB0YWc6IFwibGFiZWxcIiB9KTtcclxuICAgIGNvbnN0IGlzSW5JbnB1dEdyb3VwID0gdXNlQ29udGV4dChJbklucHV0R3JvdXBDb250ZXh0KTtcclxuICAgIGNvbnN0IGlzSW5JbnB1dEdyaWQgPSB1c2VDb250ZXh0KEluSW5wdXRHcmlkQ29udGV4dCk7XHJcbiAgICBsZXQgc3RyaW5nTGFiZWwgPSBgJHtjaGlsZHJlbn1gO1xyXG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwgJiYgbGFiZWxQb3NpdGlvbiA9PT0gXCJoaWRkZW5cIikge1xyXG4gICAgICAgIGlmICghW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiXS5pbmNsdWRlcyh0eXBlb2YgY2hpbGRyZW4pKVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBIaWRkZW4gbGFiZWxzIHJlcXVpcmUgYSBzdHJpbmctYmFzZWQgbGFiZWwgZm9yIHRoZSBhcmlhLWxhYmVsIGF0dHJpYnV0ZS5gKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1sYWJlbFwiXSA9IHN0cmluZ0xhYmVsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGFiZWxKc3ggPSBoKFwibGFiZWxcIiwgeyAuLi51c2VJbnB1dExhYmVsTGFiZWxQcm9wcyh7IGNsYXNzOiBjbHN4KHByb3BzLmRpc2FibGVkICYmIFwiZGlzYWJsZWRcIiwgaXNJbklucHV0R3JvdXAgPyBcImlucHV0LWdyb3VwLXRleHRcIiA6IGxhYmVsUG9zaXRpb24gIT0gXCJmbG9hdGluZ1wiID8gXCJmb3JtLWxhYmVsXCIgOiBcIlwiKSB9KSB9LCBjaGlsZHJlbik7XHJcbiAgICBsZXQgaW5wdXRKc3ggPSBoKFVubGFiZWxsZWRJbnB1dCwgeyAuLi51c2VJbnB1dExhYmVsSW5wdXRQcm9wcyhwcm9wcykgfSk7XHJcbiAgICBpZiAoaXNJbklucHV0R3JpZCkge1xyXG4gICAgICAgIGlucHV0SnN4ID0gaChcImRpdlwiLCB7IGNsYXNzOiBcImZvcm0tY29udHJvbCBmYXV4LWZvcm0tY29udHJvbFwiLCBzdHlsZTogd2lkdGg/LmVuZHNXaXRoKFwiY2hcIikgPyB7IFwiLS1mb3JtLWNvbnRyb2wtd2lkdGhcIjogKHdpZHRoID8/IFwiMjBjaFwiKSB9IDogd2lkdGggPyB7IHdpZHRoIH0gOiB1bmRlZmluZWQgfSwgaW5wdXRKc3gpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5wdXRXaXRoTGFiZWwgPSAoaChGcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBsYWJlbFBvc2l0aW9uID09PSBcInN0YXJ0XCIgJiYgbGFiZWxKc3gsXHJcbiAgICAgICAgaW5wdXRKc3gsXHJcbiAgICAgICAgKGxhYmVsUG9zaXRpb24gPT09IFwiZW5kXCIgfHwgbGFiZWxQb3NpdGlvbiA9PSBcImZsb2F0aW5nXCIpICYmIGxhYmVsSnN4KSk7XHJcbiAgICBpZiAobGFiZWxQb3NpdGlvbiAhPT0gXCJmbG9hdGluZ1wiKVxyXG4gICAgICAgIHJldHVybiBpbnB1dFdpdGhMYWJlbDtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gaChcImRpdlwiLCB7IGNsYXNzOiBcImZvcm0tZmxvYXRpbmdcIiB9LCBpbnB1dEpzeCk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5wdXQtdGV4dC5qcy5tYXAiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQXJpYUNoZWNrYm94LCB1c2VDaGVja2JveEdyb3VwIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHNcIjtcclxuaW1wb3J0IHsgRXZlbnREZXRhaWwgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VBc3luY0hhbmRsZXIsIHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IFByb2dyZXNzQ2lyY3VsYXIgfSBmcm9tIFwiLi4vcHJvZ3Jlc3MvbGluZWFyXCI7XHJcbmltcG9ydCB7IElucHV0R3JvdXBUZXh0IH0gZnJvbSBcIi4vaW5wdXQtZ3JvdXBcIjtcclxuaW1wb3J0IHsgSW5JbnB1dEdyaWRDb250ZXh0LCBJbklucHV0R3JvdXBDb250ZXh0IH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuZnVuY3Rpb24gY2FwdHVyZShlKSB7XHJcbiAgICByZXR1cm4gZVtFdmVudERldGFpbF0uY2hlY2tlZDtcclxufVxyXG4vKipcclxuICogVE9ETzogV2hlbiBpbnNpZGUgYW4gSW5wdXRHcm91cCwgQ2hlY2tib3hlcyBkb24ndCBmb3J3YXJkIGFueSBwcm9wZXJ0aWVzIG9yIHJlZnMgYmVjYXVzZSB0aGVyZSdzIG5vIG9uZSBET00gZWxlbWVudCB0byBhdHRhY2ggdG8uXHJcbiAqXHJcbiAqIFByb2JhYmx5IG5lZWQgc2VwYXJhdGUgYGlucHV0UmVmYCAmIGBsYWJlbFJlZmAgcHJvcGVydGllcyBmb3IgdGhhdCxcclxuICogYnV0IGdpdmVuIHRoZXJlJ3MgYWxzbyBubyBlYXN5IHdheSB0byBmb3J3YXJkIHByb3BzIHRvIGp1c3QgdGhlbSBhIHNvbHV0aW9uIGxpa2UgdGhhdCBmZWVscyBpbmNvbXBsZXRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIENoZWNrYm94KHsgY2hlY2tlZCwgZGlzYWJsZWQsIG9uSW5wdXQ6IG9uSW5wdXRBc3luYywgbGFiZWxQb3NpdGlvbiwgY2hpbGRyZW46IGxhYmVsLCAuLi5yZXN0IH0sIHJlZikge1xyXG4gICAgbGFiZWxQb3NpdGlvbiA/Pz0gXCJlbmRcIjtcclxuICAgIGNvbnN0IHsgZ2V0U3luY0hhbmRsZXIsIHBlbmRpbmcsIGhhc0Vycm9yLCBzZXR0bGVDb3VudCwgaGFzQ2FwdHVyZSwgY3VycmVudENhcHR1cmUsIGN1cnJlbnRUeXBlIH0gPSB1c2VBc3luY0hhbmRsZXIoKSh7IGNhcHR1cmUgfSk7XHJcbiAgICBkaXNhYmxlZCB8fD0gcGVuZGluZztcclxuICAgIGNvbnN0IG9uSW5wdXQgPSBnZXRTeW5jSGFuZGxlcihvbklucHV0QXN5bmMpO1xyXG4gICAgY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQgfSA9IHVzZUFyaWFDaGVja2JveCh7IGNoZWNrZWQ6IHBlbmRpbmcgPyBjdXJyZW50Q2FwdHVyZSA6IChjaGVja2VkID09PSBcImluZGV0ZXJtaW5hdGVcIiA/IFwibWl4ZWRcIiA6IGNoZWNrZWQpLCBkaXNhYmxlZDogZGlzYWJsZWQgPz8gZmFsc2UsIG9uSW5wdXQsIGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIiB9KTtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoeyB0YWc6IFwiaW5wdXRcIiB9KTtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoeyB0YWc6IFwibGFiZWxcIiB9KTtcclxuICAgIGNvbnN0IGluSW5wdXRHcm91cCA9IHVzZUNvbnRleHQoSW5JbnB1dEdyb3VwQ29udGV4dCk7XHJcbiAgICBsZXQgc3RyaW5nTGFiZWwgPSBgJHtsYWJlbH1gO1xyXG4gICAgaWYgKGxhYmVsICE9IG51bGwgJiYgbGFiZWxQb3NpdGlvbiA9PT0gXCJoaWRkZW5cIiAmJiAhW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiXS5pbmNsdWRlcyh0eXBlb2YgbGFiZWwpKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgSGlkZGVuIGxhYmVscyByZXF1aXJlIGEgc3RyaW5nLWJhc2VkIGxhYmVsIGZvciB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhc3luY1N0YXRlID0gKGhhc0Vycm9yID8gXCJmYWlsZWRcIiA6IHBlbmRpbmcgPyBcInBlbmRpbmdcIiA6IHNldHRsZUNvdW50ID8gXCJzdWNjZWVkZWRcIiA6IG51bGwpO1xyXG4gICAgY29uc3QgcCA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMoeyB0eXBlOiBcImNoZWNrYm94XCIsIGNsYXNzTmFtZTogY2xzeChcImZvcm0tY2hlY2staW5wdXRcIiwgcGVuZGluZyAmJiBcInBlbmRpbmdcIiwgZGlzYWJsZWQgJiYgXCJkaXNhYmxlZFwiLCBpbklucHV0R3JvdXAgJiYgXCJtdC0wXCIpLCBcImFyaWEtbGFiZWxcIjogbGFiZWxQb3NpdGlvbiA9PT0gXCJoaWRkZW5cIiA/IHN0cmluZ0xhYmVsIDogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uc3QgaW5wdXRFbGVtZW50ID0gaChPcHRpb25hbGx5SW5wdXRHcm91cCwgeyBpc0lucHV0OiB0cnVlLCB0YWc6IGluSW5wdXRHcm91cCA/IFwibGFiZWxcIiA6IG51bGwsIHRhYkluZGV4OiAtMSwgZGlzYWJsZWQ6IGRpc2FibGVkIH0sXHJcbiAgICAgICAgaChQcm9ncmVzc0NpcmN1bGFyLCB7IGNoaWxkcmVuUG9zaXRpb246IFwiYWZ0ZXJcIiwgY29sb3JGaWxsOiBcImZvcmVncm91bmQtb25seVwiLCBtb2RlOiBjdXJyZW50VHlwZSA9PT0gXCJhc3luY1wiID8gYXN5bmNTdGF0ZSA6IG51bGwsIGNvbG9yOiBcImluZm9cIiB9LFxyXG4gICAgICAgICAgICBoKFwiaW5wdXRcIiwgeyAuLi5wIH0pKSk7XHJcbiAgICBjb25zdCBsYWJlbEVsZW1lbnQgPSBoKEZyYWdtZW50LCBudWxsLCBsYWJlbCAhPSBudWxsICYmIGgoT3B0aW9uYWxseUlucHV0R3JvdXAsIHsgaXNJbnB1dDogZmFsc2UsIHRhZzogXCJsYWJlbFwiLCAuLi51c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzKHsgY2xhc3NOYW1lOiBjbHN4KHBlbmRpbmcgJiYgXCJwZW5kaW5nXCIsIGRpc2FibGVkICYmIFwiZGlzYWJsZWRcIiwgXCJmb3JtLWNoZWNrLWxhYmVsXCIpLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0pIH0sIGxhYmVsKSk7XHJcbiAgICBjb25zdCByZXQgPSAoaChGcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBsYWJlbFBvc2l0aW9uID09IFwic3RhcnRcIiAmJiBsYWJlbEVsZW1lbnQsXHJcbiAgICAgICAgaW5wdXRFbGVtZW50LFxyXG4gICAgICAgIGxhYmVsUG9zaXRpb24gPT0gXCJlbmRcIiAmJiBsYWJlbEVsZW1lbnQpKTtcclxuICAgIGlmICghaW5JbnB1dEdyb3VwKVxyXG4gICAgICAgIHJldHVybiBoKFwiZGl2XCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKShyZXN0LCB7IHJlZiwgY2xhc3M6IFwiZm9ybS1jaGVja1wiIH0pIH0sIHJldCk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmNvbnN0IENoZWNrYm94R3JvdXBQYXJlbnRDaGVja2JveFByb3BzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmNvbnN0IENoZWNrYm94R3JvdXBDaGlsZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG5leHBvcnQgZnVuY3Rpb24gQ2hlY2tib3hHcm91cCh7IGNoaWxkcmVuIH0pIHtcclxuICAgIGNvbnN0IHsgcGVyY2VudENoZWNrZWQsIHNlbGZJc0NoZWNrZWQsIG9uQ2hlY2tib3hHcm91cElucHV0LCB1c2VDaGVja2JveEdyb3VwQ2hlY2tib3hQcm9wcywgdXNlQ2hlY2tib3hHcm91cENoaWxkIH0gPSB1c2VDaGVja2JveEdyb3VwKHt9KTtcclxuICAgIHJldHVybiAoaChGcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBoKENoZWNrYm94R3JvdXBQYXJlbnRDaGVja2JveFByb3BzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlQ2hlY2tib3hHcm91cENoZWNrYm94UHJvcHMgfSxcclxuICAgICAgICAgICAgaChDaGVja2JveCwgeyBjbGFzc05hbWU6IFwiY2hlY2tib3gtZ3JvdXAtcGFyZW50XCIsIGNoZWNrZWQ6IHNlbGZJc0NoZWNrZWQsIG9uSW5wdXQ6IHVzZUNhbGxiYWNrKChjaGVja2VkLCBlKSA9PiB7IG9uQ2hlY2tib3hHcm91cElucHV0KGUpOyB9LCBbb25DaGVja2JveEdyb3VwSW5wdXRdKSB9KSksXHJcbiAgICAgICAgaChDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VDaGVja2JveEdyb3VwQ2hpbGQgfSwgY2hpbGRyZW4pKSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIE9wdGlvbmFsbHlJbnB1dEdyb3VwKHsgdGFnLCBjaGlsZHJlbiwgaXNJbnB1dCwgLi4ucHJvcHMgfSkge1xyXG4gICAgY29uc3QgaW5JbnB1dEdyb3VwID0gdXNlQ29udGV4dChJbklucHV0R3JvdXBDb250ZXh0KTtcclxuICAgIGNvbnN0IGluSW5wdXRHcmlkID0gISF1c2VDb250ZXh0KEluSW5wdXRHcmlkQ29udGV4dCk7XHJcbiAgICBpZiAoIWluSW5wdXRHcm91cClcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWcgPz8gRnJhZ21lbnQsIHByb3BzLCBjaGlsZHJlbik7XHJcbiAgICAvLyBJZiB3ZSdyZSBpbiBhbiBJbnB1dEdyaWQncyBJbnB1dEdyb3VwLCB0aGVuIGNyZWF0ZSBhIFxyXG4gICAgLy8gbmV3IGNoaWxkIHRoYXQncywgQ1NTLXdpc2UsIHRoZSBcInRydWVcIiBpbnB1dC5cclxuICAgIC8vIFRoZSBvdGhlciBvbmUgaXMgdXNlZCBmb3IgaXRzIGJvcmRlciBzdHlsZXMgYW5kIHJlbGF0aXZlIHBvc2l0aW9uaW5nLlxyXG4gICAgaWYgKGluSW5wdXRHcmlkICYmIGlzSW5wdXQpXHJcbiAgICAgICAgY2hpbGRyZW4gPSBoKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImlucHV0LWdyb3VwLXRleHRcIiB9LCBjaGlsZHJlbik7XHJcbiAgICByZXR1cm4gaChJbnB1dEdyb3VwVGV4dCwgeyB0YWc6IHRhZyA/PyBcImRpdlwiLCAuLi51c2VNZXJnZWRQcm9wcygpKHsgY2xhc3NOYW1lOiBjbHN4KGlzSW5wdXQgJiYgaW5JbnB1dEdyaWQgJiYgXCJmYXV4LWlucHV0LWdyb3VwLXRleHRcIikgfSwgcHJvcHMpIH0sIGNoaWxkcmVuKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnB1dC1jaGVjay5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQXJpYUNoZWNrYm94IH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHNcIjtcclxuaW1wb3J0IHsgRXZlbnREZXRhaWwgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VBc3luY0hhbmRsZXIsIHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgSW5JbnB1dEdyaWRDb250ZXh0LCBJbklucHV0R3JvdXBDb250ZXh0IH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgUHJvZ3Jlc3NDaXJjdWxhciB9IGZyb20gXCIuLi9wcm9ncmVzcy9saW5lYXJcIjtcclxuaW1wb3J0IHsgSW5wdXRHcm91cFRleHQgfSBmcm9tIFwiLi9pbnB1dC1ncm91cFwiO1xyXG4vKipcclxuICogQHNlZSBDaGVja2JveFxyXG4gKiBAcGFyYW0gcmVmXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU3dpdGNoKHsgY2hlY2tlZCwgZGlzYWJsZWQsIG9uSW5wdXQ6IG9uSW5wdXRBc3luYywgY2hpbGRyZW46IGxhYmVsLCBsYWJlbFBvc2l0aW9uLCAuLi5yZXN0IH0sIHJlZikge1xyXG4gICAgbGFiZWxQb3NpdGlvbiA/Pz0gXCJlbmRcIjtcclxuICAgIGNvbnN0IHsgZ2V0U3luY0hhbmRsZXIsIHBlbmRpbmcsIGN1cnJlbnRUeXBlLCBoYXNFcnJvciwgc2V0dGxlQ291bnQsIGN1cnJlbnRDYXB0dXJlIH0gPSB1c2VBc3luY0hhbmRsZXIoKSh7IGNhcHR1cmU6IChlKSA9PiBlW0V2ZW50RGV0YWlsXS5jaGVja2VkIH0pO1xyXG4gICAgY29uc3QgYXN5bmNTdGF0ZSA9IChoYXNFcnJvciA/IFwiZmFpbGVkXCIgOiBwZW5kaW5nID8gXCJwZW5kaW5nXCIgOiBzZXR0bGVDb3VudCA/IFwic3VjY2VlZGVkXCIgOiBudWxsKTtcclxuICAgIGRpc2FibGVkIHx8PSBwZW5kaW5nO1xyXG4gICAgY29uc3Qgb25JbnB1dCA9IGdldFN5bmNIYW5kbGVyKG9uSW5wdXRBc3luYyk7XHJcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50OiB1c2VTd2l0Y2hJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50OiB1c2VTd2l0Y2hMYWJlbEVsZW1lbnQgfSA9IHVzZUFyaWFDaGVja2JveCh7IGNoZWNrZWQ6IHBlbmRpbmcgPyBjdXJyZW50Q2FwdHVyZSA6IGNoZWNrZWQsIGRpc2FibGVkOiBkaXNhYmxlZCA/PyBmYWxzZSwgb25JbnB1dCwgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiIH0pO1xyXG4gICAgY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzOiB1c2VTd2l0Y2hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlU3dpdGNoSW5wdXRFbGVtZW50KHsgdGFnOiBcImlucHV0XCIgfSk7XHJcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHM6IHVzZVN3aXRjaExhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VTd2l0Y2hMYWJlbEVsZW1lbnQoeyB0YWc6IFwibGFiZWxcIiB9KTtcclxuICAgIGNvbnN0IGluSW5wdXRHcm91cCA9IHVzZUNvbnRleHQoSW5JbnB1dEdyb3VwQ29udGV4dCk7XHJcbiAgICBsZXQgc3RyaW5nTGFiZWwgPSBgJHtsYWJlbH1gO1xyXG4gICAgaWYgKGxhYmVsICE9IG51bGwgJiYgbGFiZWxQb3NpdGlvbiA9PT0gXCJoaWRkZW5cIiAmJiAhW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiXS5pbmNsdWRlcyh0eXBlb2YgbGFiZWwpKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgSGlkZGVuIGxhYmVscyByZXF1aXJlIGEgc3RyaW5nLWJhc2VkIGxhYmVsIGZvciB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSBoKE9wdGlvbmFsbHlJbnB1dEdyb3VwLCB7IHRhZzogaW5JbnB1dEdyb3VwID8gXCJsYWJlbFwiIDogbnVsbCwgZGlzYWJsZWQ6IGRpc2FibGVkLCB0YWJJbmRleDogLTEsIGlzSW5wdXQ6IHRydWUgfSxcclxuICAgICAgICBoKFByb2dyZXNzQ2lyY3VsYXIsIHsgY2hpbGRyZW5Qb3NpdGlvbjogXCJhZnRlclwiLCBjb2xvckZpbGw6IFwiZm9yZWdyb3VuZC1vbmx5XCIsIG1vZGU6IGN1cnJlbnRUeXBlID09PSBcImFzeW5jXCIgPyBhc3luY1N0YXRlIDogbnVsbCwgY29sb3I6IFwiaW5mb1wiIH0sXHJcbiAgICAgICAgICAgIGgoXCJpbnB1dFwiLCB7IC4uLnVzZVN3aXRjaElucHV0RWxlbWVudFByb3BzKHsgdHlwZTogXCJjaGVja2JveFwiLCBjbGFzc05hbWU6IGNsc3gocGVuZGluZyAmJiBcInBlbmRpbmdcIiwgXCJmb3JtLWNoZWNrLWlucHV0XCIsIGRpc2FibGVkICYmIFwiZGlzYWJsZWRcIiksIFwiYXJpYS1sYWJlbFwiOiBsYWJlbFBvc2l0aW9uID09PSBcImhpZGRlblwiID8gc3RyaW5nTGFiZWwgOiB1bmRlZmluZWQgfSkgfSkpKTtcclxuICAgIGNvbnN0IGxhYmVsRWxlbWVudCA9IGgoRnJhZ21lbnQsIG51bGwsIGxhYmVsICE9IG51bGwgJiYgaChPcHRpb25hbGx5SW5wdXRHcm91cCwgeyB0YWc6IFwibGFiZWxcIiwgaXNJbnB1dDogZmFsc2UsIC4uLnVzZVN3aXRjaExhYmVsRWxlbWVudFByb3BzKHsgY2xhc3NOYW1lOiBjbHN4KHBlbmRpbmcgJiYgXCJwZW5kaW5nXCIsIFwiZm9ybS1jaGVjay1sYWJlbFwiLCBkaXNhYmxlZCAmJiBcImRpc2FibGVkXCIpLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0pIH0sIGxhYmVsKSk7XHJcbiAgICBjb25zdCByZXQgPSAoaChGcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBsYWJlbFBvc2l0aW9uID09IFwic3RhcnRcIiAmJiBsYWJlbEVsZW1lbnQsXHJcbiAgICAgICAgaW5wdXRFbGVtZW50LFxyXG4gICAgICAgIGxhYmVsUG9zaXRpb24gPT0gXCJlbmRcIiAmJiBsYWJlbEVsZW1lbnQpKTtcclxuICAgIGlmICghaW5JbnB1dEdyb3VwKVxyXG4gICAgICAgIHJldHVybiBoKFwiZGl2XCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKShyZXN0LCB7IHJlZiwgY2xhc3M6IFwiZm9ybS1jaGVjayBmb3JtLXN3aXRjaFwiIH0pIH0sIHJldCk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbi8vIE5vdGU6IFNsaWdodGx5IGRpZmZlcmVudCBmcm9tIHRoZSBvdGhlcnNcclxuLy8gKF5eXl4gSSdtIHJlYWxseSBnbGFkIEkgbGVmdCB0aGF0IHRoZXJlKVxyXG5mdW5jdGlvbiBPcHRpb25hbGx5SW5wdXRHcm91cCh7IHRhZywgaXNJbnB1dCwgY2hpbGRyZW4sIC4uLnByb3BzIH0pIHtcclxuICAgIGNvbnN0IGluSW5wdXRHcm91cCA9IHVzZUNvbnRleHQoSW5JbnB1dEdyb3VwQ29udGV4dCk7XHJcbiAgICBjb25zdCBpbklucHV0R3JpZCA9IHVzZUNvbnRleHQoSW5JbnB1dEdyaWRDb250ZXh0KTtcclxuICAgIGlmICghaW5JbnB1dEdyb3VwKVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZyA/PyBGcmFnbWVudCwgcHJvcHMsIGNoaWxkcmVuKTtcclxuICAgIGlmIChpbklucHV0R3JpZCAmJiBpc0lucHV0KVxyXG4gICAgICAgIGNoaWxkcmVuID0gaChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeChpc0lucHV0ICYmIGluSW5wdXRHcmlkICYmIFwiZm9ybS1zd2l0Y2hcIiwgXCJpbnB1dC1ncm91cC10ZXh0XCIpIH0sIGNoaWxkcmVuKTtcclxuICAgIHJldHVybiAoaChJbnB1dEdyb3VwVGV4dCwgeyB0YWc6IHRhZyA/PyBcImRpdlwiLCAuLi51c2VNZXJnZWRQcm9wcygpKHsgY2xhc3NOYW1lOiBjbHN4KFwiaW5wdXQtZ3JvdXAtdGV4dFwiLCBpc0lucHV0ICYmICFpbklucHV0R3JpZCAmJiBcImZvcm0tc3dpdGNoXCIsIGlzSW5wdXQgJiYgaW5JbnB1dEdyaWQgJiYgXCJmYXV4LWlucHV0LWdyb3VwLXRleHRcIikgfSwgcHJvcHMpIH0sIGNoaWxkcmVuKSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5wdXQtc3dpdGNoLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIEZyYWdtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBFdmVudERldGFpbCB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZUdlbmVyaWNMYWJlbCB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1sYWJlbFwiO1xyXG5pbXBvcnQgeyB1c2VBcmlhUmFkaW9Hcm91cCB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1yYWRpby1ncm91cFwiO1xyXG5pbXBvcnQgeyB1c2VBc3luY0hhbmRsZXIsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2hpbGRGbGFnIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBQcm9ncmVzc0NpcmN1bGFyIH0gZnJvbSBcIi4uL3Byb2dyZXNzXCI7XHJcbmltcG9ydCB7IEluSW5wdXRHcm91cENvbnRleHQgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBPcHRpb25hbGx5SW5wdXRHcm91cCB9IGZyb20gXCIuL2lucHV0LWNoZWNrXCI7XHJcbmNvbnN0IGtub3duTmFtZXMgPSBuZXcgU2V0KCk7XHJcbmNvbnN0IEN1cnJlbnRIYW5kbGVyVHlwZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KFwic3luY1wiKTtcclxuY29uc3QgUmFkaW9Hcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG5leHBvcnQgZnVuY3Rpb24gUmFkaW9Hcm91cCh7IGNoaWxkcmVuLCBuYW1lLCBzZWxlY3RlZFZhbHVlLCBsYWJlbCwgbGFiZWxQb3NpdGlvbiwgb25JbnB1dDogb25JbnB1dEFzeW5jIH0pIHtcclxuICAgIGNvbnN0IHsgZ2V0U3luY0hhbmRsZXIsIHBlbmRpbmcsIGhhc0Vycm9yLCBzZXR0bGVDb3VudCwgY3VycmVudENhcHR1cmUsIGN1cnJlbnRUeXBlIH0gPSB1c2VBc3luY0hhbmRsZXIoKSh7IGNhcHR1cmU6IChlKSA9PiBlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZFZhbHVlIH0pO1xyXG4gICAgY29uc3Qgb25JbnB1dCA9IGdldFN5bmNIYW5kbGVyKG9uSW5wdXRBc3luYyk7XHJcbiAgICBjb25zdCB7IHVzZVJhZGlvLCB1c2VSYWRpb0dyb3VwUHJvcHMsIG1hbmFnZWRDaGlsZHJlbiwgZ2V0SW5kZXggfSA9IHVzZUFyaWFSYWRpb0dyb3VwKHsgbmFtZSwgc2VsZWN0ZWRWYWx1ZTogcGVuZGluZyA/IGN1cnJlbnRDYXB0dXJlIDogc2VsZWN0ZWRWYWx1ZSwgb25JbnB1dDogb25JbnB1dCB9KTtcclxuICAgIGxldCBzdHJpbmdMYWJlbCA9IHVuZGVmaW5lZDtcclxuICAgIGlmIChsYWJlbFBvc2l0aW9uID09PSBcImhpZGRlblwiKSB7XHJcbiAgICAgICAgaWYgKGxhYmVsICE9IG51bGwgJiYgIVtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0uaW5jbHVkZXModHlwZW9mIGxhYmVsKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBIaWRkZW4gbGFiZWxzIHJlcXVpcmUgYSBzdHJpbmctYmFzZWQgbGFiZWwgZm9yIHRoZSBhcmlhLWxhYmVsIGF0dHJpYnV0ZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0cmluZ0xhYmVsID0gYCR7bGFiZWx9YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBEZWJ1Z2dpbmcgY2hlY2sgLS0gbXVsdGlwbGUgZ3JvdXBzIHdpdGggdGhlIHNhbWUgbmFtZSBjYW4gY2F1c2Ugd2VpcmQgZ2xpdGNoZXMgZnJvbSBuYXRpdmUgcmFkaW8gc2VsZWN0aW9uIGJlaGF2aW9yLlxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoa25vd25OYW1lcy5oYXMobmFtZSkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTXVsdGlwbGUgcmFkaW8gZ3JvdXBzIHdpdGggdGhlIG5hbWUgXCIke25hbWV9XCIgZXhpc3Qgb24gdGhlIHNhbWUgcGFnZSBhdCB0aGUgc2FtZSB0aW1lIWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrbm93bk5hbWVzLmFkZChuYW1lKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ga25vd25OYW1lcy5kZWxldGUobmFtZSk7XHJcbiAgICB9LCBbbmFtZV0pO1xyXG4gICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IGdldEluZGV4KGN1cnJlbnRDYXB0dXJlID8/IHNlbGVjdGVkVmFsdWUpO1xyXG4gICAgLy9jb25zdCBjYXB0dXJlZEluZGV4ID0gZ2V0SW5kZXgoY3VycmVudENhcHR1cmUhKTtcclxuICAgIHVzZUNoaWxkRmxhZyhzZWxlY3RlZEluZGV4LCBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoLCAoaW5kZXgsIGlzU2VsZWN0ZWQpID0+IG1hbmFnZWRDaGlsZHJlbltpbmRleF0uc2V0QXN5bmNTdGF0ZShpc1NlbGVjdGVkID8gKGhhc0Vycm9yID8gXCJmYWlsZWRcIiA6IHBlbmRpbmcgPyBcInBlbmRpbmdcIiA6IFwic3VjY2VlZGVkXCIpIDogbnVsbCkpO1xyXG4gICAgLy8gdXNlQ2hpbGRGbGFnKHBlbmRpbmcgPyBjYXB0dXJlZEluZGV4IDogbnVsbCwgbWFuYWdlZENoaWxkcmVuLmxlbmd0aCwgdXNlQ2FsbGJhY2soKGluZGV4LCBpc0NhcHR1cmVkKSA9PiBtYW5hZ2VkQ2hpbGRyZW5baW5kZXhdLnNldFBlbmRpbmcoaXNDYXB0dXJlZD8gXCJpblwiIDogZmFsc2UpLCBbXSkpO1xyXG4gICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxMYWJlbCwgdXNlR2VuZXJpY0xhYmVsSW5wdXQgfSA9IHVzZUdlbmVyaWNMYWJlbCh7IGlucHV0UHJlZml4OiBcImFyaWEtcmFkaW9ncm91cFwiLCBsYWJlbFByZWZpeDogXCJhcmlhLXJhZGlvZ3JvdXAtbGFiZWxcIiwgYmFja3VwVGV4dDogc3RyaW5nTGFiZWwgfSk7XHJcbiAgICBjb25zdCB7IHVzZUdlbmVyaWNMYWJlbElucHV0UHJvcHMgfSA9IHVzZUdlbmVyaWNMYWJlbElucHV0KCk7XHJcbiAgICBjb25zdCB7IHVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUdlbmVyaWNMYWJlbExhYmVsKCk7XHJcbiAgICBsZXQgbGFiZWxKc3ggPSBoKFwiZGl2XCIsIHsgLi4udXNlR2VuZXJpY0xhYmVsTGFiZWxQcm9wcyh7fSkgfSk7XHJcbiAgICBsZXQgZ3JvdXBKc3ggPSAoaChcImRpdlwiLCB7IC4uLnVzZUdlbmVyaWNMYWJlbElucHV0UHJvcHModXNlUmFkaW9Hcm91cFByb3BzKHsgXCJhcmlhLWxhYmVsXCI6IGxhYmVsUG9zaXRpb24gPT09IFwiaGlkZGVuXCIgPyBzdHJpbmdMYWJlbCA6IHVuZGVmaW5lZCB9KSkgfSwgY2hpbGRyZW4pKTtcclxuICAgIHJldHVybiAoaChDdXJyZW50SGFuZGxlclR5cGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjdXJyZW50VHlwZSA/PyBcInN5bmNcIiB9LFxyXG4gICAgICAgIGgoUmFkaW9Hcm91cENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHVzZVJhZGlvIH0sXHJcbiAgICAgICAgICAgIGxhYmVsUG9zaXRpb24gPT0gXCJzdGFydFwiICYmIGxhYmVsSnN4LFxyXG4gICAgICAgICAgICBncm91cEpzeCxcclxuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiA9PSBcImVuZFwiICYmIGxhYmVsSnN4KSkpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBSYWRpbyh7IGRpc2FibGVkLCBjaGlsZHJlbjogbGFiZWwsIGluZGV4LCB2YWx1ZSwgbGFiZWxQb3NpdGlvbiB9KSB7XHJcbiAgICBjb25zdCB1c2VBcmlhUmFkaW8gPSB1c2VDb250ZXh0KFJhZGlvR3JvdXBDb250ZXh0KTtcclxuICAgIGxhYmVsUG9zaXRpb24gPz89IFwiZW5kXCI7XHJcbiAgICBjb25zdCB0ZXh0ID0gbnVsbDtcclxuICAgIGNvbnN0IGN1cnJlbnRIYW5kbGVyVHlwZSA9IHVzZUNvbnRleHQoQ3VycmVudEhhbmRsZXJUeXBlQ29udGV4dCk7XHJcbiAgICBjb25zdCBbYXN5bmNTdGF0ZSwgc2V0QXN5bmNTdGF0ZV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGRpc2FibGVkIHx8PSAoYXN5bmNTdGF0ZSA9PT0gXCJwZW5kaW5nXCIpO1xyXG4gICAgY29uc3QgeyB1c2VSYWRpb0lucHV0LCB1c2VSYWRpb0xhYmVsIH0gPSB1c2VBcmlhUmFkaW8oeyBkaXNhYmxlZDogZGlzYWJsZWQgPz8gZmFsc2UsIGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIiwgaW5kZXgsIHRleHQsIHZhbHVlLCBzZXRBc3luY1N0YXRlIH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYWRpb0lucHV0UHJvcHMgfSA9IHVzZVJhZGlvSW5wdXQoeyB0YWc6IFwiaW5wdXRcIiB9KTtcclxuICAgIGNvbnN0IHsgdXNlUmFkaW9MYWJlbFByb3BzIH0gPSB1c2VSYWRpb0xhYmVsKHsgdGFnOiBcImxhYmVsXCIgfSk7XHJcbiAgICBjb25zdCBpbklucHV0R3JvdXAgPSB1c2VDb250ZXh0KEluSW5wdXRHcm91cENvbnRleHQpO1xyXG4gICAgbGFiZWwgPz89IHZhbHVlO1xyXG4gICAgbGV0IHN0cmluZ0xhYmVsID0gYCR7bGFiZWx9YDtcclxuICAgIGlmIChsYWJlbCAhPSBudWxsICYmIGxhYmVsUG9zaXRpb24gPT09IFwiaGlkZGVuXCIgJiYgIVtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0uaW5jbHVkZXModHlwZW9mIGxhYmVsKSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEhpZGRlbiBsYWJlbHMgcmVxdWlyZSBhIHN0cmluZy1iYXNlZCBsYWJlbCBmb3IgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5wdXRFbGVtZW50ID0gaChPcHRpb25hbGx5SW5wdXRHcm91cCwgeyBpc0lucHV0OiB0cnVlLCB0YWc6IGluSW5wdXRHcm91cCA/IFwibGFiZWxcIiA6IG51bGwsIGRpc2FibGVkOiBkaXNhYmxlZCwgdGFiSW5kZXg6IC0xIH0sXHJcbiAgICAgICAgaChQcm9ncmVzc0NpcmN1bGFyLCB7IGNoaWxkcmVuUG9zaXRpb246IFwiYWZ0ZXJcIiwgY29sb3JGaWxsOiBcImZvcmVncm91bmQtb25seVwiLCBtb2RlOiBjdXJyZW50SGFuZGxlclR5cGUgPT0gXCJhc3luY1wiID8gYXN5bmNTdGF0ZSA6IG51bGwsIGNvbG9yOiBcImluZm9cIiB9LFxyXG4gICAgICAgICAgICBoKFwiaW5wdXRcIiwgeyAuLi51c2VSYWRpb0lucHV0UHJvcHMoeyB0eXBlOiBcInJhZGlvXCIsIGNsYXNzTmFtZTogY2xzeChhc3luY1N0YXRlID09PSBcInBlbmRpbmdcIiAmJiBcInBlbmRpbmdcIiwgZGlzYWJsZWQgJiYgXCJkaXNhYmxlZFwiLCBcImZvcm0tY2hlY2staW5wdXRcIiksIFwiYXJpYS1sYWJlbFwiOiBsYWJlbFBvc2l0aW9uID09PSBcImhpZGRlblwiID8gc3RyaW5nTGFiZWwgOiB1bmRlZmluZWQgfSkgfSkpKTtcclxuICAgIGNvbnN0IGxhYmVsRWxlbWVudCA9IGgoRnJhZ21lbnQsIG51bGwsIGxhYmVsICE9IG51bGwgJiYgaChPcHRpb25hbGx5SW5wdXRHcm91cCwgeyBpc0lucHV0OiBmYWxzZSwgdGFnOiBcImxhYmVsXCIsIC4uLnVzZVJhZGlvTGFiZWxQcm9wcyh7IGNsYXNzTmFtZTogY2xzeChhc3luY1N0YXRlID09PSBcInBlbmRpbmdcIiAmJiBcInBlbmRpbmdcIiwgZGlzYWJsZWQgJiYgXCJkaXNhYmxlZFwiLCBcImZvcm0tY2hlY2stbGFiZWxcIiksIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSkgfSwgbGFiZWwpKTtcclxuICAgIGNvbnN0IHJldCA9IChoKEZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIGxhYmVsUG9zaXRpb24gPT0gXCJzdGFydFwiICYmIGxhYmVsRWxlbWVudCxcclxuICAgICAgICBpbnB1dEVsZW1lbnQsXHJcbiAgICAgICAgbGFiZWxQb3NpdGlvbiA9PSBcImVuZFwiICYmIGxhYmVsRWxlbWVudCkpO1xyXG4gICAgaWYgKCFpbklucHV0R3JvdXApXHJcbiAgICAgICAgcmV0dXJuIGgoXCJkaXZcIiwgeyBjbGFzczogXCJmb3JtLWNoZWNrXCIgfSwgcmV0KTtcclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5wdXQtcmFkaW8uanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuLi9wcm9wc1wiO1xyXG4vKipcclxuICogVmVyeSBzaW1wbGUsIGVhc3kgcmVzcG9uc2l2ZSBncmlkIHRoYXQgZ3VhcmFudGVlcyBlYWNoIGNvbHVtbiBpcyB0aGUgbWluaW11bSBzaXplLlxyXG4gKlxyXG4gKiBFYXN5IG9uZS1saW5lcnMgYWxsIGFyb3VuZCBoZXJlIVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEdyaWRSZXNwb25zaXZlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gUmVzcG9uc2l2ZUdyaWQoeyB0YWcsIG1pbldpZHRoLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSwgcmVmKSB7XHJcbiAgICByZXR1cm4gKGgodGFnID8/IFwiZGl2XCIsIHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzc05hbWU6IFwicmVzcG9uc2l2ZS1ncmlkXCIsIHN0eWxlOiBtaW5XaWR0aCA/IHsgXCItLWdyaWQtbWluLXdpZHRoXCI6IGAke21pbldpZHRofWAgfSA6IHt9LCByZWYgfSwgcHJvcHMpLCBjaGlsZHJlbikpO1xyXG59KTtcclxuLyoqXHJcbiAqIFZlcnkgc2ltcGxlLCBlYXN5IHN0YXRpYyBncmlkIHRoYXQgZ3VhcmFudGVlcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaXMgZGlzcGxheWVkLFxyXG4gKiBubyBtYXR0ZXIgaG93IGphbmt5IGl0IGxvb2tzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEdyaWRTdGF0aWMgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBSZXNwb25zaXZlR3JpZCh7IHRhZywgY29sdW1ucywgY2hpbGRyZW4sIC4uLnByb3BzIH0sIHJlZikge1xyXG4gICAgcmV0dXJuIChoKHRhZyA/PyBcImRpdlwiLCB1c2VNZXJnZWRQcm9wcygpKHsgY2xhc3NOYW1lOiBcInN0YXRpYy1ncmlkXCIsIHN0eWxlOiB0eXBlb2YgY29sdW1ucyA9PT0gXCJzdHJpbmdcIiA/IHsgXCItLXN0YXRpYy1ncmlkLWNvbHVtbnNcIjogY29sdW1ucyB9IDogeyBcIi0tZ3JpZC1jb2x1bW4tY291bnRcIjogY29sdW1ucyB9LCByZWYgfSwgcHJvcHMpLCBjaGlsZHJlbikpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JpZC5qcy5tYXAiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VBcmlhTGlzdGJveFNpbmdsZSB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzXCI7XHJcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHMvcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQXN5bmNIYW5kbGVyLCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZVBzZXVkb0FjdGl2ZSB9IGZyb20gXCIuLi9wcm9wc1wiO1xyXG5leHBvcnQgY29uc3QgVXNlTGlzdGJveFNpbmdsZUl0ZW1Db250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuZXhwb3J0IGZ1bmN0aW9uIExpc3RTaW5nbGUocHJvcHMsIHJlZikge1xyXG4gICAgY29uc3QgeyBvblNlbGVjdDogb25TZWxlY3RBc3luYywgc2VsZWN0ZWRJbmRleCwgc2VsZWN0aW9uTW9kZSwgY29sbGF0b3IsIGtleU5hdmlnYXRpb24sIG5vVHlwZWFoZWFkLCBub1dyYXAsIHR5cGVhaGVhZFRpbWVvdXQsIHRhZywgc2VsZWN0LCAuLi5kb21Qcm9wcyB9ID0gcHJvcHM7XHJcbiAgICBjb25zdCB7IGdldFN5bmNIYW5kbGVyIH0gPSB1c2VBc3luY0hhbmRsZXIoKSh7IGNhcHR1cmU6IChlKSA9PiBlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZEluZGV4IH0pO1xyXG4gICAgY29uc3Qgb25TZWxlY3QgPSBnZXRTeW5jSGFuZGxlcihvblNlbGVjdEFzeW5jKTtcclxuICAgIGNvbnN0IHsgdXNlTGlzdGJveFNpbmdsZUl0ZW0sIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCwgdXNlTGlzdGJveFNpbmdsZVByb3BzIH0gPSB1c2VBcmlhTGlzdGJveFNpbmdsZSh7IG9uU2VsZWN0LCBzZWxlY3RlZEluZGV4LCBzZWxlY3Rpb25Nb2RlLCB0eXBlYWhlYWRUaW1lb3V0LCBub1dyYXAsIG5vVHlwZWFoZWFkLCBrZXlOYXZpZ2F0aW9uLCBjb2xsYXRvciB9KTtcclxuICAgIHJldHVybiBoKFVzZUxpc3Rib3hTaW5nbGVJdGVtQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlTGlzdGJveFNpbmdsZUl0ZW0gfSwgaCh0YWcsIHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzczogXCJsaXN0LWdyb3VwXCIsIHJlZiB9LCB1c2VMaXN0Ym94U2luZ2xlUHJvcHMoZG9tUHJvcHMpKSkpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBMaXN0SXRlbVNpbmdsZShwcm9wcywgcmVmKSB7XHJcbiAgICBjb25zdCB1c2VMaXN0SXRlbVNpbmdsZSA9IHVzZUNvbnRleHQoVXNlTGlzdGJveFNpbmdsZUl0ZW1Db250ZXh0KTtcclxuICAgIGNvbnN0IHsgaW5kZXgsIC4uLmRvbVByb3BzIH0gPSB7IC4uLnByb3BzLCByZWYgfTtcclxuICAgIGNvbnN0IFt0ZXh0LCBzZXRUZXh0XSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgIHNldFRleHQoZWxlbWVudC5pbm5lclRleHQpO1xyXG4gICAgfSwgW2VsZW1lbnRdKTtcclxuICAgIGNvbnN0IHsgZ2V0U2VsZWN0ZWQsIHRhYmJhYmxlLCBzZWxlY3RlZCwgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyB9ID0gdXNlTGlzdEl0ZW1TaW5nbGUoeyBpbmRleCwgdGV4dCwgdGFnOiBcImxpXCIgfSk7XHJcbiAgICByZXR1cm4gaChcImxpXCIsIHsgLi4udXNlUHNldWRvQWN0aXZlKHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzczogY2xzeChcImxpc3QtZ3JvdXAtaXRlbVwiLCBcImxpc3QtZ3JvdXAtaXRlbS1hY3Rpb25cIiwgc2VsZWN0ZWQgJiYgXCJhY3RpdmVcIikgfSwgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyh1c2VSZWZFbGVtZW50UHJvcHMoZG9tUHJvcHMpKSkpIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3Qtc2luZ2xlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5nbG9iYWxUaGlzLnByb2Nlc3MgPz89IHt9O1xyXG5nbG9iYWxUaGlzLnByb2Nlc3MuZW52ID8/PSB7fTtcclxuZ2xvYmFsVGhpcy5wcm9jZXNzLmVudi5OT0RFX0VOViA/Pz0gXCJkZXZlbG9wbWVudFwiO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXItY29uZmlnLmpzLm1hcCIsImV4cG9ydCB2YXIgdG9wID0gJ3RvcCc7XG5leHBvcnQgdmFyIGJvdHRvbSA9ICdib3R0b20nO1xuZXhwb3J0IHZhciByaWdodCA9ICdyaWdodCc7XG5leHBvcnQgdmFyIGxlZnQgPSAnbGVmdCc7XG5leHBvcnQgdmFyIGF1dG8gPSAnYXV0byc7XG5leHBvcnQgdmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG5leHBvcnQgdmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbmV4cG9ydCB2YXIgZW5kID0gJ2VuZCc7XG5leHBvcnQgdmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuZXhwb3J0IHZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG5leHBvcnQgdmFyIHBvcHBlciA9ICdwb3BwZXInO1xuZXhwb3J0IHZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbmV4cG9ydCB2YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xuZXhwb3J0IHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbmV4cG9ydCB2YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbmV4cG9ydCB2YXIgcmVhZCA9ICdyZWFkJztcbmV4cG9ydCB2YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbmV4cG9ydCB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCB2YXIgbWFpbiA9ICdtYWluJztcbmV4cG9ydCB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxuZXhwb3J0IHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG5leHBvcnQgdmFyIHdyaXRlID0gJ3dyaXRlJztcbmV4cG9ydCB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbmV4cG9ydCB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9OyIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCJpbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59IiwiaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlKSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gMTtcbiAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgJiYgaW5jbHVkZVNjYWxlKSB7XG4gICAgdmFyIG9mZnNldEhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHZhciBvZmZzZXRXaWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7IC8vIERvIG5vdCBhdHRlbXB0IHRvIGRpdmlkZSBieSAwLCBvdGhlcndpc2Ugd2UgZ2V0IGBJbmZpbml0eWAgYXMgc2NhbGVcbiAgICAvLyBGYWxsYmFjayB0byAxIGluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIGAwYFxuXG4gICAgaWYgKG9mZnNldFdpZHRoID4gMCkge1xuICAgICAgc2NhbGVYID0gcmVjdC53aWR0aCAvIG9mZnNldFdpZHRoIHx8IDE7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldEhlaWdodCA+IDApIHtcbiAgICAgIHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gb2Zmc2V0SGVpZ2h0IHx8IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcm91bmQocmVjdC53aWR0aCAvIHNjYWxlWCksXG4gICAgaGVpZ2h0OiByb3VuZChyZWN0LmhlaWdodCAvIHNjYWxlWSksXG4gICAgdG9wOiByb3VuZChyZWN0LnRvcCAvIHNjYWxlWSksXG4gICAgcmlnaHQ6IHJvdW5kKHJlY3QucmlnaHQgLyBzY2FsZVgpLFxuICAgIGJvdHRvbTogcm91bmQocmVjdC5ib3R0b20gLyBzY2FsZVkpLFxuICAgIGxlZnQ6IHJvdW5kKHJlY3QubGVmdCAvIHNjYWxlWCksXG4gICAgeDogcm91bmQocmVjdC5sZWZ0IC8gc2NhbGVYKSxcbiAgICB5OiByb3VuZChyZWN0LnRvcCAvIHNjYWxlWSlcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiOyAvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59IiwiaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufSIsImltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICApO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSBcIi4vaXNUYWJsZUVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTE7XG4gIHZhciBpc0lFID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgIT09IC0xO1xuXG4gIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XG4gICAgdmFyIGVsZW1lbnRDc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn0iLCJleHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcm91bmQgPSBNYXRoLnJvdW5kOyIsImltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuL21hdGguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIG1hdGhNYXgobWluLCBtYXRoTWluKHZhbHVlLCBtYXgpKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59IiwiaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4uL2RvbS11dGlscy9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgd2l0aGluIGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXCI7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xuICBwYWRkaW5nID0gdHlwZW9mIHBhZGRpbmcgPT09ICdmdW5jdGlvbicgPyBwYWRkaW5nKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogcGFkZGluZztcbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyhfcmVmKSB7XG4gIHZhciBfc3RhdGUkbW9kaWZpZXJzRGF0YSQ7XG5cbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLCAnVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcycsICd0aGUgYXJyb3cuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBtb2RpZmllclxcJ3MgYGVsZW1lbnRgIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgcG9wcGVyJywgJ2VsZW1lbnQuJ10uam9pbignICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGFycm93LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufSIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYpIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuICB2YXIgd2luID0gd2luZG93O1xuICB2YXIgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZChyb3VuZCh4ICogZHByKSAvIGRwcikgfHwgMCxcbiAgICB5OiByb3VuZChyb3VuZCh5ICogZHByKSAvIGRwcikgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzO1xuXG4gIHZhciBfcmVmMyA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKG9mZnNldHMpIDogdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyhvZmZzZXRzKSA6IG9mZnNldHMsXG4gICAgICBfcmVmMyR4ID0gX3JlZjMueCxcbiAgICAgIHggPSBfcmVmMyR4ID09PSB2b2lkIDAgPyAwIDogX3JlZjMkeCxcbiAgICAgIF9yZWYzJHkgPSBfcmVmMy55LFxuICAgICAgeSA9IF9yZWYzJHkgPT09IHZvaWQgMCA/IDAgOiBfcmVmMyR5O1xuXG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgdmFyIHNpZGVYID0gbGVmdDtcbiAgdmFyIHNpZGVZID0gdG9wO1xuICB2YXIgd2luID0gd2luZG93O1xuXG4gIGlmIChhZGFwdGl2ZSkge1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcbiAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xuICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJiBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XG4gICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuXG4gICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wIHx8IChwbGFjZW1lbnQgPT09IGxlZnQgfHwgcGxhY2VtZW50ID09PSByaWdodCkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVZID0gYm90dG9tOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICAgICAgeSAtPSBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF0gLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgICAgIHggLT0gb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF0gLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNCkge1xuICB2YXIgc3RhdGUgPSBfcmVmNC5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNC5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9IGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgJyc7XG5cbiAgICBpZiAoYWRhcHRpdmUgJiYgWyd0cmFuc2Zvcm0nLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uc29tZShmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uUHJvcGVydHkuaW5kZXhPZihwcm9wZXJ0eSkgPj0gMDtcbiAgICB9KSkge1xuICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcnLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgJ1xcblxcbicsICdEaXNhYmxlIHRoZSBcImNvbXB1dGVTdHlsZXNcIiBtb2RpZmllclxcJ3MgYGFkYXB0aXZlYCBvcHRpb24gdG8gYWxsb3cnLCAnZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTJywgJ3RyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZycsICdvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuJywgJ1xcblxcbicsICdXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXInLCAnZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvblxuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgZm46IGNvbXB1dGVTdHlsZXMsXG4gIGRhdGE6IHt9XG59OyIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcbiAgICAgIHNjcm9sbCA9IF9vcHRpb25zJHNjcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHNjcm9sbCxcbiAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XG4gIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgaWYgKHNjcm9sbCkge1xuICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIGRhdGE6IHt9XG59OyIsInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsInZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7IC8vIE5COiBUaGlzIGlzbid0IHN1cHBvcnRlZCBvbiBpT1MgPD0gMTIuIElmIHRoZSBrZXlib2FyZCBpcyBvcGVuLCB0aGUgcG9wcGVyXG4gIC8vIGNhbiBiZSBvYnNjdXJlZCB1bmRlcm5lYXRoIGl0LlxuICAvLyBBbHNvLCBgaHRtbC5jbGllbnRIZWlnaHRgIGFkZHMgdGhlIGJvdHRvbSBiYXIgaGVpZ2h0IGluIFNhZmFyaSBpT1MsIGV2ZW5cbiAgLy8gaWYgaXQgaXNuJ3Qgb3Blbiwgc28gaWYgdGhpcyBpc24ndCBhdmFpbGFibGUsIHRoZSBwb3BwZXIgd2lsbCBiZSBkZXRlY3RlZFxuICAvLyB0byBvdmVyZmxvdyB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gdG9vIGVhcmx5LlxuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0OyAvLyBVc2VzIExheW91dCBWaWV3cG9ydCAobGlrZSBDaHJvbWU7IFNhZmFyaSBkb2VzIG5vdCBjdXJyZW50bHkpXG4gICAgLy8gSW4gQ2hyb21lLCBpdCByZXR1cm5zIGEgdmFsdWUgdmVyeSBjbG9zZSB0byAwICgrLy0pIGJ1dCBjb250YWlucyByb3VuZGluZ1xuICAgIC8vIGVycm9ycyBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgbnVtYmVycywgc28gd2UgbmVlZCB0byBjaGVjayBwcmVjaXNpb24uXG4gICAgLy8gU2FmYXJpIHJldHVybnMgYSBudW1iZXIgPD0gMCwgdXN1YWxseSA8IC0xIHdoZW4gcGluY2gtem9vbWVkXG4gICAgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZmFpbHMgaW4gbW9iaWxlIGVtdWxhdGlvbiBtb2RlIGluIENocm9tZS5cbiAgICAvLyBNYXRoLmFicyh3aW4uaW5uZXJXaWR0aCAvIHZpc3VhbFZpZXdwb3J0LnNjYWxlIC0gdmlzdWFsVmlld3BvcnQud2lkdGgpIDxcbiAgICAvLyAwLjAwMVxuICAgIC8vIEZhbGxiYWNrIGhlcmU6IFwiTm90IFNhZmFyaVwiIHVzZXJBZ2VudFxuXG4gICAgaWYgKCEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IHsgbWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59IiwiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufSIsImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSkgOiBpc0hUTUxFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcbiAgdmFyIG9mZnNldHM7XG5cbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSByaWdodDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59IiwiaW1wb3J0IGdldENsaXBwaW5nUmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBjbGlwcGluZ1BhcmVudHMsIHJlZmVyZW5jZSwgcG9wcGVyLCBib3R0b20sIHRvcCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi9leHBhbmRUb0hhc2hNYXAuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gc3RhdGUucGxhY2VtZW50IDogX29wdGlvbnMkcGxhY2VtZW50LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpO1xuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgZWxlbWVudDogcG9wcGVyUmVjdCxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KTtcbiAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcbiAgdmFyIGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0OyAvLyBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyByZWN0XG4gIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcblxuICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxuICAgIGJvdHRvbTogZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tLFxuICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICByaWdodDogZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0XG4gIH07XG4gIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcblxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XG4gICAgdmFyIG9mZnNldCA9IG9mZnNldERhdGFbcGxhY2VtZW50XTtcbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xuICAgICAgdmFyIGF4aXMgPSBbdG9wLCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gJ3knIDogJ3gnO1xuICAgICAgb3ZlcmZsb3dPZmZzZXRzW2tleV0gKz0gb2Zmc2V0W2F4aXNdICogbXVsdGlwbHk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xufSIsImltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyB2YXJpYXRpb25QbGFjZW1lbnRzLCBiYXNlUGxhY2VtZW50cywgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gYWxsUGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICB2YXIgcGxhY2VtZW50cyA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBUaGUgYGFsbG93ZWRBdXRvUGxhY2VtZW50c2Agb3B0aW9uIGRpZCBub3QgYWxsb3cgYW55JywgJ3BsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvbicsICdvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLicsICdGb3IgZXhhbXBsZSwgXCJhdXRvXCIgY2Fubm90IGJlIHVzZWQgdG8gYWxsb3cgXCJib3R0b20tc3RhcnRcIi4nLCAnVXNlIFwiYXV0by1zdGFydFwiIGluc3RlYWQuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gIH0pO1xufSIsImltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyBib3R0b20sIHRvcCwgc3RhcnQsIHJpZ2h0LCBsZWZ0LCBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbmZ1bmN0aW9uIGZsaXAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xuICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuICB2YXIgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG4gIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXG4gICAgfSkgOiBwbGFjZW1lbnQpO1xuICB9LCBbXSk7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gIHZhciBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuXG4gICAgdmFyIF9iYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSk7XG4gICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgdmFyIGFsdFZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgIHJldHVybiBjaGVjaztcbiAgICB9KSkge1xuICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcbiAgfVxuXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyDigJMgcmVzZWFyY2ggbGF0ZXJcbiAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgIHZhciBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICB9XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTsiLCJpbXBvcnQgeyB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcbiAgaWYgKHByZXZlbnRlZE9mZnNldHMgPT09IHZvaWQgMCkge1xuICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGlkZShfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XG4gIHZhciByZWZlcmVuY2VPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gIH0pO1xuICB2YXIgcG9wcGVyQWx0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gIH0pO1xuICB2YXIgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocmVmZXJlbmNlT3ZlcmZsb3csIHJlZmVyZW5jZVJlY3QpO1xuICB2YXIgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHBvcHBlckFsdE92ZXJmbG93LCBwb3BwZXJSZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKTtcbiAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIHZhciBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHBvcHBlckVzY2FwZU9mZnNldHMsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcbiAgfTtcbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnaGlkZScsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG4gIGZuOiBoaWRlXG59OyIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBwbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiLCJpbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn0iLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tIFwiLi4vdXRpbHMvZ2V0QWx0QXhpcy5qc1wiO1xuaW1wb3J0IHdpdGhpbiBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi4vdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxuICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xuICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxuICB9KTtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHRldGhlck9mZnNldDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMgfHwgY2hlY2tBbHRBeGlzKSB7XG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIHRldGhlck9mZnNldFZhbHVlIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSB0ZXRoZXJPZmZzZXRWYWx1ZTtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgdGV0aGVyT2Zmc2V0VmFsdWUgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIHRldGhlck9mZnNldFZhbHVlO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XVttYWluQXhpc10gOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1hdGhNaW4obWluLCB0ZXRoZXJNaW4pIDogbWluLCBvZmZzZXQsIHRldGhlciA/IG1hdGhNYXgobWF4LCB0ZXRoZXJNYXgpIDogbWF4KTtcbiAgICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgICB2YXIgX2FsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtYXRoTWluKF9taW4sIHRldGhlck1pbikgOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoTWF4KF9tYXgsIHRldGhlck1heCkgOiBfbWF4KTtcblxuICAgICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tIFwiLi9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZVNjcm9sbCBmcm9tIFwiLi9nZXROb2RlU2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IHJlY3Qud2lkdGggLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByZWN0LmhlaWdodCAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xufSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XG5cbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdChzdHIpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIFtdLmNvbmNhdChhcmdzKS5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHtcbiAgICByZXR1cm4gcC5yZXBsYWNlKC8lcy8sIGMpO1xuICB9LCBzdHIpO1xufSIsImltcG9ydCBmb3JtYXQgZnJvbSBcIi4vZm9ybWF0LmpzXCI7XG5pbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xudmFyIElOVkFMSURfTU9ESUZJRVJfRVJST1IgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcHJvdmlkZWQgYW4gaW52YWxpZCAlcyBwcm9wZXJ0eSwgZXhwZWN0ZWQgJXMgYnV0IGdvdCAlcyc7XG52YXIgTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHJlcXVpcmVzIFwiJXNcIiwgYnV0IFwiJXNcIiBtb2RpZmllciBpcyBub3QgYXZhaWxhYmxlJztcbnZhciBWQUxJRF9QUk9QRVJUSUVTID0gWyduYW1lJywgJ2VuYWJsZWQnLCAncGhhc2UnLCAnZm4nLCAnZWZmZWN0JywgJ3JlcXVpcmVzJywgJ29wdGlvbnMnXTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBbXS5jb25jYXQoT2JqZWN0LmtleXMobW9kaWZpZXIpLCBWQUxJRF9QUk9QRVJUSUVTKSAvLyBJRTExLWNvbXBhdGlibGUgcmVwbGFjZW1lbnQgZm9yIGBuZXcgU2V0KGl0ZXJhYmxlKWBcbiAgICAuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIHNlbGYpIHtcbiAgICAgIHJldHVybiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIFN0cmluZyhtb2RpZmllci5uYW1lKSwgJ1wibmFtZVwiJywgJ1wic3RyaW5nXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5uYW1lKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZW5hYmxlZCc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5lbmFibGVkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcImVuYWJsZWRcIicsICdcImJvb2xlYW5cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmVuYWJsZWQpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwaGFzZSc6XG4gICAgICAgICAgaWYgKG1vZGlmaWVyUGhhc2VzLmluZGV4T2YobW9kaWZpZXIucGhhc2UpIDwgMCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wicGhhc2VcIicsIFwiZWl0aGVyIFwiICsgbW9kaWZpZXJQaGFzZXMuam9pbignLCAnKSwgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIucGhhc2UpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmbic6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5mbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZm5cIicsICdcImZ1bmN0aW9uXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5mbikgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2VmZmVjdCc6XG4gICAgICAgICAgaWYgKG1vZGlmaWVyLmVmZmVjdCAhPSBudWxsICYmIHR5cGVvZiBtb2RpZmllci5lZmZlY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcImVmZmVjdFwiJywgJ1wiZnVuY3Rpb25cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmZuKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmVxdWlyZXMnOlxuICAgICAgICAgIGlmIChtb2RpZmllci5yZXF1aXJlcyAhPSBudWxsICYmICFBcnJheS5pc0FycmF5KG1vZGlmaWVyLnJlcXVpcmVzKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wicmVxdWlyZXNcIicsICdcImFycmF5XCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5yZXF1aXJlcykgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JlcXVpcmVzSWZFeGlzdHMnOlxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wicmVxdWlyZXNJZkV4aXN0c1wiJywgJ1wiYXJyYXlcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvcHRpb25zJzpcbiAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUG9wcGVySlM6IGFuIGludmFsaWQgcHJvcGVydHkgaGFzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIFxcXCJcIiArIG1vZGlmaWVyLm5hbWUgKyBcIlxcXCIgbW9kaWZpZXIsIHZhbGlkIHByb3BlcnRpZXMgYXJlIFwiICsgVkFMSURfUFJPUEVSVElFUy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcXCJcIiArIHMgKyBcIlxcXCJcIjtcbiAgICAgICAgICB9KS5qb2luKCcsICcpICsgXCI7IGJ1dCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIHByb3ZpZGVkLlwiKTtcbiAgICAgIH1cblxuICAgICAgbW9kaWZpZXIucmVxdWlyZXMgJiYgbW9kaWZpZXIucmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWlyZW1lbnQpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICByZXR1cm4gbW9kLm5hbWUgPT09IHJlcXVpcmVtZW50O1xuICAgICAgICB9KSA9PSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SLCBTdHJpbmcobW9kaWZpZXIubmFtZSksIHJlcXVpcmVtZW50LCByZXF1aXJlbWVudCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdW5pcXVlQnkoYXJyLCBmbikge1xuICB2YXIgaWRlbnRpZmllcnMgPSBuZXcgU2V0KCk7XG4gIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBmbihpdGVtKTtcblxuICAgIGlmICghaWRlbnRpZmllcnMuaGFzKGlkZW50aWZpZXIpKSB7XG4gICAgICBpZGVudGlmaWVycy5hZGQoaWRlbnRpZmllcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSIsImltcG9ydCBnZXRDb21wb3NpdGVSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IG9yZGVyTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcIi4vdXRpbHMvZGVib3VuY2UuanNcIjtcbmltcG9ydCB2YWxpZGF0ZU1vZGlmaWVycyBmcm9tIFwiLi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IHVuaXF1ZUJ5IGZyb20gXCIuL3V0aWxzL3VuaXF1ZUJ5LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi9lbnVtcy5qc1wiO1xudmFyIElOVkFMSURfRUxFTUVOVF9FUlJPUiA9ICdQb3BwZXI6IEludmFsaWQgcmVmZXJlbmNlIG9yIHBvcHBlciBhcmd1bWVudCBwcm92aWRlZC4gVGhleSBtdXN0IGJlIGVpdGhlciBhIERPTSBlbGVtZW50IG9yIHZpcnR1YWwgZWxlbWVudC4nO1xudmFyIElORklOSVRFX0xPT1BfRVJST1IgPSAnUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC4nO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbn07XG5cbmZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pOyAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbW9kaWZpZXJzIHNvIHRoYXQgdGhlIGNvbnN1bWVyIHdpbGwgZ2V0IHdhcm5lZFxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1vZGlmaWVycyBpcyBpbnZhbGlkIGZvciBhbnkgcmVhc29uXG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSB1bmlxdWVCeShbXS5jb25jYXQob3JkZXJlZE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpO1xuXG4gICAgICAgICAgaWYgKGdldEJhc2VQbGFjZW1lbnQoc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICAgICAgICB2YXIgZmxpcE1vZGlmaWVyID0gc3RhdGUub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSAnZmxpcCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFmbGlwTW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsICdwcmVzZW50IGFuZCBlbmFibGVkIHRvIHdvcmsuJ10uam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBvcHBlciksXG4gICAgICAgICAgICAgIG1hcmdpblRvcCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5SaWdodCxcbiAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luTGVmdDsgLy8gV2Ugbm8gbG9uZ2VyIHRha2UgaW50byBhY2NvdW50IGBtYXJnaW5zYCBvbiB0aGUgcG9wcGVyLCBhbmQgaXQgY2FuXG4gICAgICAgICAgLy8gY2F1c2UgYnVncyB3aXRoIHBvc2l0aW9uaW5nLCBzbyB3ZSdsbCB3YXJuIHRoZSBjb25zdW1lclxuXG5cbiAgICAgICAgICBpZiAoW21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdF0uc29tZShmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXJnaW4pO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgJ2JldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50IG9yIGJvdW5kYXJ5LicsICdUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzJywgJ3RoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgJywgJ21vZGlmaWVycy4nXS5qb2luKCcgJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9fZGVidWdfbG9vcHNfXyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgX19kZWJ1Z19sb29wc19fICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChfX2RlYnVnX2xvb3BzX18gPiAxMDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTkZJTklURV9MT09QX0VSUk9SKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgICAgICBfcmVmMyRvcHRpb25zID0gX3JlZjMub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmMyRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuZXhwb3J0IHZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgZGV0ZWN0T3ZlcmZsb3cgfTsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyIsImltcG9ydCBcIi4vcG9wcGVyLWNvbmZpZ1wiO1xyXG5pbXBvcnQgeyBjcmVhdGVQb3BwZXIgfSBmcm9tIFwiQHBvcHBlcmpzL2NvcmVcIjtcclxuaW1wb3J0IHsgdXNlR2xvYmFsSGFuZGxlciwgdXNlTG9naWNhbERpcmVjdGlvbiwgdXNlTWVyZ2VkUHJvcHMsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBvcHBlckFwaSh7IHVwZGF0aW5nLCBwb3NpdGlvbiwgc2tpZGRpbmcsIGRpc3RhbmNlLCBwYWRkaW5nVG9wLCBwYWRkaW5nQm90dG9tLCBwYWRkaW5nTGVmdCwgcGFkZGluZ1JpZ2h0IH0pIHtcclxuICAgIGNvbnN0IFtwb3BwZXJJbnN0YW5jZSwgc2V0UG9wcGVySW5zdGFuY2UsIGdldFBvcHBlckluc3RhbmNlXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgW3VzZWRQbGFjZW1lbnQsIHNldFVzZWRQbGFjZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQ6IHNvdXJjZUVsZW1lbnQsIGdldEVsZW1lbnQ6IGdldFNvdXJjZUVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlU291cmNlRWxlbWVudFJlZlByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQ6IHBvcHBlckVsZW1lbnQsIGdldEVsZW1lbnQ6IGdldFBvcHBlckVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlUG9wcGVyRWxlbWVudFJlZlByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGFycm93RWxlbWVudCwgZ2V0RWxlbWVudDogZ2V0QXJyb3dFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUFycm93RWxlbWVudFJlZlByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XHJcbiAgICBjb25zdCBbc291cmNlU3R5bGUsIHNldFNvdXJjZVN0eWxlXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgW3NvdXJjZUF0dHJpYnV0ZXMsIHNldFNvdXJjZUF0dHJpYnV0ZXNdID0gdXNlU3RhdGUoe30pO1xyXG4gICAgY29uc3QgW3BvcHBlclN0eWxlLCBzZXRQb3BwZXJTdHlsZV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtwb3BwZXJBdHRyaWJ1dGVzLCBzZXRQb3BwZXJBdHRyaWJ1dGVzXSA9IHVzZVN0YXRlKHt9KTtcclxuICAgIGNvbnN0IFthcnJvd1N0eWxlLCBzZXRBcnJvd1N0eWxlXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgW2Fycm93QXR0cmlidXRlcywgc2V0QXJyb3dBdHRyaWJ1dGVzXSA9IHVzZVN0YXRlKHt9KTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIGxldCByYWZIYW5kbGUgPSAwO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiByYWYoKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcCA9ICgoY2xvc2VkID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBnZXRQb3BwZXJJbnN0YW5jZSgpPy51cGRhdGUoKSkgPz8gUHJvbWlzZS5yZXNvbHZlKCkpO1xyXG4gICAgICAgICAgICAgICAgcC50aGVuKF8gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYWZIYW5kbGUgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYWZIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByYWZIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmKTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZkhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUtdGhyZWFkZWQgbGFuZ3VhZ2VzIGFyZSBuaWNlIHNvbWV0aW1lcy5cclxuICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3VwZGF0aW5nXSk7XHJcbiAgICBjb25zdCB1cGRhdGVTdGF0ZU1vZGlmaWVyID0gdXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgbGV0IG1vZGlmaWVyID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBcInVwZGF0ZVN0YXRlXCIsXHJcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIHBoYXNlOiBcIndyaXRlXCIsXHJcbiAgICAgICAgICAgIGZuOiAoeyBzdGF0ZSwgb3B0aW9ucywgbmFtZSwgaW5zdGFuY2UgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHVzZWRQbGFjZW1lbnQgPSBzdGF0ZS5wbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodXNlZFBsYWNlbWVudC5pbmNsdWRlcyhcIi1cIikpXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlZFBsYWNlbWVudCA9IHVzZWRQbGFjZW1lbnQuc3Vic3RyKDAsIHVzZWRQbGFjZW1lbnQuaW5kZXhPZihcIi1cIikpO1xyXG4gICAgICAgICAgICAgICAgc2V0VXNlZFBsYWNlbWVudCh1c2VkUGxhY2VtZW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdHlsZXMucmVmZXJlbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFNvdXJjZVN0eWxlKHN0YXRlLnN0eWxlcy5yZWZlcmVuY2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF0dHJpYnV0ZXMucmVmZXJlbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFNvdXJjZUF0dHJpYnV0ZXMoc3RhdGUuYXR0cmlidXRlcy5yZWZlcmVuY2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnN0eWxlcy5wb3BwZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0UG9wcGVyU3R5bGUoc3RhdGUuc3R5bGVzLnBvcHBlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0UG9wcGVyQXR0cmlidXRlcyhzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3R5bGVzLmFycm93KVxyXG4gICAgICAgICAgICAgICAgICAgIHNldEFycm93U3R5bGUoc3RhdGUuc3R5bGVzLmFycm93KTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hdHRyaWJ1dGVzLmFycm93KVxyXG4gICAgICAgICAgICAgICAgICAgIHNldEFycm93QXR0cmlidXRlcyhzdGF0ZS5hdHRyaWJ1dGVzLmFycm93KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcImNvbXB1dGVTdHlsZXNcIiwgXCJmbGlwXCJdXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbW9kaWZpZXI7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCB7IGNvbnZlcnRFbGVtZW50U2l6ZSwgZ2V0TG9naWNhbERpcmVjdGlvbiB9ID0gdXNlTG9naWNhbERpcmVjdGlvbihzb3VyY2VFbGVtZW50KTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHNvdXJjZUVsZW1lbnQgJiYgcG9wcGVyRWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBvbkZpcnN0VXBkYXRlID0gKCkgPT4geyB9O1xyXG4gICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICAgICAgbGV0IHBsYWNlbWVudCA9IGxvZ2ljYWxUb1BsYWNlbWVudChnZXRMb2dpY2FsRGlyZWN0aW9uKCksIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgc2V0UG9wcGVySW5zdGFuY2UoY3JlYXRlUG9wcGVyKHNvdXJjZUVsZW1lbnQsIHBvcHBlckVsZW1lbnQsIHtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJmbGlwXCIsIG9wdGlvbnM6IHt9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLCBvcHRpb25zOiB7IHBhZGRpbmc6IHsgYm90dG9tOiBwYWRkaW5nQm90dG9tLCB0b3A6IHBhZGRpbmdUb3AsIGxlZnQ6IHBhZGRpbmdMZWZ0LCByaWdodDogcGFkZGluZ1JpZ2h0IH0gfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0YXRlTW9kaWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLCBlbmFibGVkOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJhcHBseVN0eWxlc1wiLCBlbmFibGVkOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICAgICAgXSwgb25GaXJzdFVwZGF0ZSwgcGxhY2VtZW50LCBzdHJhdGVneVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3NvdXJjZUVsZW1lbnQsIHBvcHBlckVsZW1lbnQsIHBvc2l0aW9uLCBza2lkZGluZywgZGlzdGFuY2UsIHBhZGRpbmdUb3AsIHBhZGRpbmdCb3R0b20sIHBhZGRpbmdMZWZ0LCBwYWRkaW5nUmlnaHRdKTtcclxuICAgIGZ1bmN0aW9uIHVzZVBvcHBlclNvdXJjZSgpIHtcclxuICAgICAgICBmdW5jdGlvbiB1c2VQb3BwZXJTb3VyY2VQcm9wcyhwcm9wcykge1xyXG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB7IC4uLnNvdXJjZVN0eWxlIH07XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHNvdXJjZUF0dHJpYnV0ZXMsIHVzZU1lcmdlZFByb3BzKCkoeyBzdHlsZSB9LCB1c2VTb3VyY2VFbGVtZW50UmVmUHJvcHMocHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZVBvcHBlclNvdXJjZVByb3BzIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1c2VQb3BwZXJQb3B1cCh7IG9wZW4gfSkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVBvcHBlclBvcHVwUHJvcHMocHJvcHMpIHtcclxuICAgICAgICAgICAgbGV0IHN0eWxlID0geyAuLi5wb3BwZXJTdHlsZSwgcG9pbnRlckV2ZW50czogb3BlbiA/IHVuZGVmaW5lZCA6IFwibm9uZVwiIH07XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHBvcHBlckF0dHJpYnV0ZXMsIHVzZU1lcmdlZFByb3BzKCkoeyBzdHlsZSB9LCB1c2VQb3BwZXJFbGVtZW50UmVmUHJvcHMocHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZVBvcHBlclBvcHVwUHJvcHMgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVzZVBvcHBlckFycm93KCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVBvcHBlckFycm93UHJvcHMocHJvcHMpIHtcclxuICAgICAgICAgICAgbGV0IHN0eWxlID0geyAuLi5hcnJvd1N0eWxlIH07XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHBvcHBlckF0dHJpYnV0ZXMsIHVzZU1lcmdlZFByb3BzKCkoeyBzdHlsZSB9LCB1c2VBcnJvd0VsZW1lbnRSZWZQcm9wcyhwcm9wcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlUG9wcGVyQXJyb3dQcm9wcyB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgdXNlUG9wcGVyU291cmNlLCB1c2VQb3BwZXJQb3B1cCwgdXNlUG9wcGVyQXJyb3csIHVzZWRQbGFjZW1lbnQsIGdldExvZ2ljYWxEaXJlY3Rpb24gfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcGxhY2VtZW50VG9Mb2dpY2FsKGxvZ2ljYWxEaXJlY3Rpb24sIHBsYWNlbWVudCkge1xyXG4gICAgY29uc3QgeyBibG9ja0RpcmVjdGlvbiwgYmxvY2tPcmllbnRhdGlvbiwgaW5saW5lRGlyZWN0aW9uLCBpbmxpbmVPcmllbnRhdGlvbiB9ID0gbG9naWNhbERpcmVjdGlvbjtcclxuICAgIGxldCBsb2dpY2FsO1xyXG4gICAgc3dpdGNoIChgJHtpbmxpbmVEaXJlY3Rpb259LSR7YmxvY2tEaXJlY3Rpb259LCR7cGxhY2VtZW50fWApIHtcclxuICAgICAgICAvLyBUaGVyZSdzIGEgcGF0dGVybiwgYW5kIGl0IGNvdWxkIGJlIGNvZGVkIGFzIGEgcGF0dGVyblxyXG4gICAgICAgIGNhc2UgXCJsdHItdHRiLHRvcFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1zdGFydFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwibHRyLWJ0dCxib3R0b21cIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stc3RhcnRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInJ0bC10dGIsdG9wXCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLXN0YXJ0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJydGwtYnR0LGJvdHRvbVwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1zdGFydFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwidHRiLWx0cixsZWZ0XCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLXN0YXJ0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJidHQtbHRyLHJpZ2h0XCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLXN0YXJ0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJ0dGItcnRsLGxlZnRcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stc3RhcnRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImJ0dC1ydGwscmlnaHRcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stc3RhcnRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImx0ci10dGIsYm90dG9tXCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwicnRsLXR0Yixib3R0b21cIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stZW5kXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJsdHItYnR0LHRvcFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1lbmRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInJ0bC1idHQsdG9wXCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwidHRiLWx0cixyaWdodFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1lbmRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInR0Yi1ydGwscmlnaHRcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stZW5kXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJidHQtbHRyLGxlZnRcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stZW5kXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJidHQtcnRsLGxlZnRcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stZW5kXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJ0dGItbHRyLHRvcFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtc3RhcnRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInR0Yi1ydGwsdG9wXCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1zdGFydFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiYnR0LWx0cixib3R0b21cIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLXN0YXJ0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJidHQtcnRsLGJvdHRvbVwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtc3RhcnRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImx0ci10dGIsbGVmdFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtc3RhcnRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInJ0bC10dGIsbGVmdFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtc3RhcnRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImx0ci1idHQscmlnaHRcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLXN0YXJ0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJydGwtYnR0LHJpZ2h0XCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1zdGFydFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwidHRiLWx0cixib3R0b21cIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwidHRiLXJ0bCxib3R0b21cIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiYnR0LWx0cix0b3BcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiYnR0LXJ0bCx0b3BcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwibHRyLXR0YixyaWdodFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtZW5kXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJydGwtdHRiLHJpZ2h0XCI6XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1lbmRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImx0ci1idHQsbGVmdFwiOlxyXG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtZW5kXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJydGwtYnR0LGxlZnRcIjpcclxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLWVuZFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBTaG91bGRuJ3QgaGFwcGVuLCBidXQgaGVyZSBmb3IgdHlwZSBjb3JyZWN0bmVzcy5cclxuICAgICAgICBjYXNlIFwidHRiLXR0Yixib3R0b21cIjpcclxuICAgICAgICBjYXNlIFwidHRiLXR0Yix0b3BcIjpcclxuICAgICAgICBjYXNlIFwiYnR0LWJ0dCxib3R0b21cIjpcclxuICAgICAgICBjYXNlIFwiYnR0LWJ0dCx0b3BcIjpcclxuICAgICAgICBjYXNlIFwibHRyLWx0cixib3R0b21cIjpcclxuICAgICAgICBjYXNlIFwibHRyLWx0cix0b3BcIjpcclxuICAgICAgICBjYXNlIFwicnRsLXJ0bCxib3R0b21cIjpcclxuICAgICAgICBjYXNlIFwicnRsLXJ0bCx0b3BcIjpcclxuICAgICAgICBjYXNlIFwidHRiLWJ0dCxib3R0b21cIjpcclxuICAgICAgICBjYXNlIFwiYnR0LXR0Yix0b3BcIjpcclxuICAgICAgICBjYXNlIFwiYnR0LXR0Yixib3R0b21cIjpcclxuICAgICAgICBjYXNlIFwidHRiLWJ0dCx0b3BcIjpcclxuICAgICAgICBjYXNlIFwibHRyLXJ0bCxib3R0b21cIjpcclxuICAgICAgICBjYXNlIFwicnRsLWx0cix0b3BcIjpcclxuICAgICAgICBjYXNlIFwicnRsLWx0cixib3R0b21cIjpcclxuICAgICAgICBjYXNlIFwibHRyLXJ0bCx0b3BcIjpcclxuICAgICAgICBjYXNlIFwidHRiLXR0YixyaWdodFwiOlxyXG4gICAgICAgIGNhc2UgXCJ0dGItdHRiLGxlZnRcIjpcclxuICAgICAgICBjYXNlIFwiYnR0LWJ0dCxyaWdodFwiOlxyXG4gICAgICAgIGNhc2UgXCJidHQtYnR0LGxlZnRcIjpcclxuICAgICAgICBjYXNlIFwibHRyLWx0cixyaWdodFwiOlxyXG4gICAgICAgIGNhc2UgXCJsdHItbHRyLGxlZnRcIjpcclxuICAgICAgICBjYXNlIFwicnRsLXJ0bCxyaWdodFwiOlxyXG4gICAgICAgIGNhc2UgXCJydGwtcnRsLGxlZnRcIjpcclxuICAgICAgICBjYXNlIFwidHRiLWJ0dCxyaWdodFwiOlxyXG4gICAgICAgIGNhc2UgXCJidHQtdHRiLGxlZnRcIjpcclxuICAgICAgICBjYXNlIFwiYnR0LXR0YixyaWdodFwiOlxyXG4gICAgICAgIGNhc2UgXCJ0dGItYnR0LGxlZnRcIjpcclxuICAgICAgICBjYXNlIFwibHRyLXJ0bCxyaWdodFwiOlxyXG4gICAgICAgIGNhc2UgXCJydGwtbHRyLGxlZnRcIjpcclxuICAgICAgICBjYXNlIFwicnRsLWx0cixyaWdodFwiOlxyXG4gICAgICAgIGNhc2UgXCJsdHItcnRsLGxlZnRcIjpcclxuICAgICAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBsb2dpY2FsO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBsb2dpY2FsO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBsb2dpY2FsVG9QbGFjZW1lbnQobG9naWNhbERpcmVjdGlvbiwgcG9zaXRpb24pIHtcclxuICAgIGxldCBwbGFjZW1lbnQ7XHJcbiAgICBjb25zdCB7IGJsb2NrRGlyZWN0aW9uLCBibG9ja09yaWVudGF0aW9uLCBpbmxpbmVEaXJlY3Rpb24sIGlubGluZU9yaWVudGF0aW9uIH0gPSBsb2dpY2FsRGlyZWN0aW9uO1xyXG4gICAgaWYgKHBvc2l0aW9uID09PSBcImJsb2NrLXN0YXJ0XCIgfHwgcG9zaXRpb24gPT0gXCJibG9jay1lbmRcIikge1xyXG4gICAgICAgIHN3aXRjaCAoYCR7cG9zaXRpb259LSR7YmxvY2tEaXJlY3Rpb259YCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stc3RhcnQtdHRiXCI6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcInRvcFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1lbmQtYnR0XCI6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcInRvcFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1zdGFydC1idHRcIjpcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwiYm90dG9tXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImJsb2NrLWVuZC10dGJcIjpcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwiYm90dG9tXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImJsb2NrLXN0YXJ0LWx0clwiOlxyXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImJsb2NrLWVuZC1ydGxcIjpcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1lbmQtbHRyXCI6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImJsb2NrLXN0YXJ0LXJ0bFwiOlxyXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcImJvdHRvbVwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3dpdGNoIChgJHtwb3NpdGlvbn0tJHtpbmxpbmVEaXJlY3Rpb259YCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLXN0YXJ0LWx0clwiOlxyXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImlubGluZS1lbmQtcnRsXCI6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLWVuZC1sdHJcIjpcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLXN0YXJ0LXJ0bFwiOlxyXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtc3RhcnQtdHRiXCI6XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcInRvcFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtZW5kLWJ0dFwiOlxyXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJ0b3BcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLWVuZC10dGJcIjpcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwiYm90dG9tXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImlubGluZS1zdGFydC1idHRcIjpcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwiYm90dG9tXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwbGFjZW1lbnQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNob3VsZFVwZGF0ZVBvcHBlcihvcGVuLCBlbGVtZW50U2l6ZSkge1xyXG4gICAgLy8gU2luY2Ugc2Nyb2xsIGV2ZW50cyBhcmUgYXN5bmNocm9ub3VzLCBlc3BlY2lhbGx5IG9uIGlPUyBkZXZpY2VzLFxyXG4gICAgLy8ganVzdCBtYW51YWxseSBhZGp1c3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIgZm9yIGEgYml0XHJcbiAgICAvLyBhbnkgdGltZSBiYXNpY2FsbHkgYW55IHVzZXIgaW50ZXJhY3Rpb24gaGFwcGVucy5cclxuICAgIGNvbnN0IFt1cGRhdGluZ0ZvckFCaXQsIHNldFVwZGF0aW5nRm9yQUJpdF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIHVzZVRpbWVvdXQoeyBjYWxsYmFjazogKCkgPT4geyBzZXRVcGRhdGluZ0ZvckFCaXQoMCk7IH0sIHRpbWVvdXQ6IDEwMCwgdHJpZ2dlckluZGV4OiB1cGRhdGluZ0ZvckFCaXQgfSk7XHJcbiAgICBsZXQgb25JbnRlcmFjdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHsgc2V0VXBkYXRpbmdGb3JBQml0KHUgPT4gKyt1KTsgfSwgW2Nsb3NlZF0pO1xyXG4gICAgaWYgKCFvcGVuKVxyXG4gICAgICAgIG9uSW50ZXJhY3Rpb24gPSBudWxsO1xyXG4gICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJrZXlkb3duXCIsIG9uSW50ZXJhY3Rpb24sIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcInNjcm9sbFwiLCBvbkludGVyYWN0aW9uLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSk7XHJcbiAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJwb2ludGVybW92ZVwiLCBvbkludGVyYWN0aW9uLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSk7XHJcbiAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJjbGlja1wiLCBvbkludGVyYWN0aW9uLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSk7XHJcbiAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJyZXNpemVcIiwgb25JbnRlcmFjdGlvbiwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHsgb25JbnRlcmFjdGlvbj8uKCk7IH0sIE9iamVjdC52YWx1ZXMoZWxlbWVudFNpemUgPz8ge30pKTtcclxuICAgIHJldHVybiB7IHNob3VsZFVwZGF0ZTogISF1cGRhdGluZ0ZvckFCaXQsIG9uSW50ZXJhY3Rpb24gfTtcclxufVxyXG4vKipcclxuICogSGFuZGxlIHRoZSBlLmcuIHpvb21PcmlnaW5EeW5hbWljIHByb3BzLCB0byB0dXJuIHRoZW0gaW50byB6b29tT3JpZ2luSW5saW5lIG9yIHpvb21PcmlnaW5CbG9jayBhcyBhcHByb3ByaWF0ZS5cclxuICogVE9ETzogUmlnaHQgbm93LCBhbGwgKkR5bmFtaWMgcHJvcHMgYXJlIGp1c3QgaGFuZGxlZCBhcyAxIC0gcHJvcC4gU29tZSBwcm9iYWJseSBuZWVkIHRvIGJlIC0xICogcHJvcCB0aG91Z2guXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZml4UHJvcHMobG9naWNhbERpcmVjdGlvbiwgcmVxdWVzdGVkUGxhY2VtZW50LCB1c2VkUGxhY2VtZW50LCBwcm9wcykge1xyXG4gICAgbGV0IGxvZ2ljYWxTbmFrZSA9IHBsYWNlbWVudFRvTG9naWNhbChsb2dpY2FsRGlyZWN0aW9uLCB1c2VkUGxhY2VtZW50KTtcclxuICAgIGxldCBwcm9wQXhpcztcclxuICAgIGxldCByZXZlcnNlO1xyXG4gICAgc3dpdGNoIChsb2dpY2FsU25ha2UpIHtcclxuICAgICAgICBjYXNlIFwiYmxvY2stc3RhcnRcIjpcclxuICAgICAgICAgICAgcHJvcEF4aXMgPSBcIkJsb2NrXCI7XHJcbiAgICAgICAgICAgIHJldmVyc2UgPSAocmVxdWVzdGVkUGxhY2VtZW50ID09IFwiYmxvY2stZW5kXCIpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiYmxvY2stZW5kXCI6XHJcbiAgICAgICAgICAgIHByb3BBeGlzID0gXCJCbG9ja1wiO1xyXG4gICAgICAgICAgICByZXZlcnNlID0gKHJlcXVlc3RlZFBsYWNlbWVudCA9PSBcImJsb2NrLXN0YXJ0XCIpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiaW5saW5lLXN0YXJ0XCI6XHJcbiAgICAgICAgICAgIHByb3BBeGlzID0gXCJJbmxpbmVcIjtcclxuICAgICAgICAgICAgcmV2ZXJzZSA9IChyZXF1ZXN0ZWRQbGFjZW1lbnQgPT0gXCJpbmxpbmUtZW5kXCIpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiaW5saW5lLWVuZFwiOlxyXG4gICAgICAgICAgICBwcm9wQXhpcyA9IFwiSW5saW5lXCI7XHJcbiAgICAgICAgICAgIHJldmVyc2UgPSAocmVxdWVzdGVkUGxhY2VtZW50ID09IFwiaW5saW5lLXN0YXJ0XCIpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGxldCBuZXdQcm9wcyA9IHsgLi4ucHJvcHMgfTtcclxuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHByb3BzKSB7XHJcbiAgICAgICAgaWYgKHByb3BOYW1lLmVuZHNXaXRoKFwiRHluYW1pY1wiKSAmJiB0eXBlb2YgcHJvcHNbcHJvcE5hbWVdID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdQcm9wTmFtZSA9IGAke3Byb3BOYW1lLnN1YnN0cigwLCBwcm9wTmFtZS5pbmRleE9mKFwiRHluYW1pY1wiKSl9JHtwcm9wQXhpc31gO1xyXG4gICAgICAgICAgICBuZXdQcm9wc1tuZXdQcm9wTmFtZV0gPSAoIXJldmVyc2UgPyBuZXdQcm9wc1twcm9wTmFtZV0gOiAxIC0gbmV3UHJvcHNbcHJvcE5hbWVdKTtcclxuICAgICAgICAgICAgZGVsZXRlIG5ld1Byb3BzW3Byb3BOYW1lXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3UHJvcHM7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLWFwaS5qcy5tYXAiLCJpbXBvcnQgeyBjbG9uZUVsZW1lbnQsIGNyZWF0ZUNvbnRleHQsIEZyYWdtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VBcmlhTWVudSB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzXCI7XHJcbmltcG9ydCB7IHVzZUVsZW1lbnRTaXplLCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgdXNlU3RhdGUsIHVzZVRpbWVvdXQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBCb2R5UG9ydGFsIH0gZnJvbSBcIi4uL3BvcnRhbFwiO1xyXG5pbXBvcnQgeyBmaXhQcm9wcywgdXNlUG9wcGVyQXBpLCB1c2VTaG91bGRVcGRhdGVQb3BwZXIgfSBmcm9tIFwiLi9wb3BwZXItYXBpXCI7XHJcbmZ1bmN0aW9uIGZvbyhwbGFjZW1lbnQsIHByb3BzKSB7XHJcbn1cclxuY29uc3QgT25DbG9zZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XHJcbmNvbnN0IFVzZU1lbnVJdGVtQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmV4cG9ydCBmdW5jdGlvbiBNZW51KHsgYW5jaG9yLCBhbmNob3JUYWcsIGNoaWxkcmVuLCB0YWcsIFRyYW5zaXRpb24sIC4uLnJlc3QgfSkge1xyXG4gICAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3Qgb25DbG9zZSA9IHVzZUNhbGxiYWNrKCgpID0+IHNldE9wZW4oZmFsc2UpLCBbXSk7XHJcbiAgICBjb25zdCBvbk9wZW4gPSAoKSA9PiBzZXRPcGVuKHRydWUpO1xyXG4gICAgY29uc3QgeyB1c2VFbGVtZW50U2l6ZVByb3BzLCBlbGVtZW50U2l6ZSB9ID0gdXNlRWxlbWVudFNpemUoKTtcclxuICAgIGNvbnN0IHsgc2hvdWxkVXBkYXRlOiB1cGRhdGluZ0ZvckFCaXQsIG9uSW50ZXJhY3Rpb24gfSA9IHVzZVNob3VsZFVwZGF0ZVBvcHBlcihvcGVuLCBlbGVtZW50U2l6ZSk7XHJcbiAgICBjb25zdCB7IHVzZVBvcHBlckFycm93LCB1c2VQb3BwZXJQb3B1cCwgdXNlUG9wcGVyU291cmNlLCB1c2VkUGxhY2VtZW50LCBnZXRMb2dpY2FsRGlyZWN0aW9uIH0gPSB1c2VQb3BwZXJBcGkoeyBwb3NpdGlvbjogXCJibG9jay1lbmRcIiwgdXBkYXRpbmc6IHVwZGF0aW5nRm9yQUJpdCB9KTtcclxuICAgIGNvbnN0IHsgdXNlTWVudUJ1dHRvbiwgdXNlTWVudUl0ZW0sIHVzZU1lbnVJdGVtQ2hlY2tib3gsIHVzZU1lbnVQcm9wcywgdXNlTWVudVN1Ym1lbnVJdGVtLCBmb2N1c01lbnUgfSA9IHVzZUFyaWFNZW51KHsgb3Blbiwgb25DbG9zZSwgb25PcGVuIH0pO1xyXG4gICAgY29uc3QgeyB1c2VNZW51QnV0dG9uUHJvcHMgfSA9IHVzZU1lbnVCdXR0b24oeyB0YWc6IGFuY2hvclRhZyA/PyBcImJ1dHRvblwiIH0pO1xyXG4gICAgY29uc3QgeyB1c2VQb3BwZXJTb3VyY2VQcm9wcyB9ID0gdXNlUG9wcGVyU291cmNlKCk7XHJcbiAgICBjb25zdCB7IHVzZVBvcHBlclBvcHVwUHJvcHMgfSA9IHVzZVBvcHBlclBvcHVwKHsgb3BlbiB9KTtcclxuICAgIGNvbnN0IHsgdXNlUG9wcGVyQXJyb3dQcm9wcyB9ID0gdXNlUG9wcGVyQXJyb3coKTtcclxuICAgIC8qY29uc3QgW3NlbnRpbmVsRm9jdXNlZCwgc2V0U2VudGluZWxGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIHVzZVRpbWVvdXQoeyBjYWxsYmFjazogKCkgPT4geyBpZiAoc2VudGluZWxGb2N1c2VkKSBvbkNsb3NlKCk7IHNldFNlbnRpbmVsRm9jdXNlZChmYWxzZSk7IH0sIHRpbWVvdXQ6IDEwMDAsIHRyaWdnZXJJbmRleDogc2VudGluZWxGb2N1c2VkLnRvU3RyaW5nKCkgfSkqL1xyXG4gICAgY29uc3QgW2ZpcnN0U2VudGluZWxJc0FjdGl2ZSwgc2V0Rmlyc3RTZW50aW5lbElzQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIHVzZVRpbWVvdXQoeyBjYWxsYmFjazogKCkgPT4geyBzZXRGaXJzdFNlbnRpbmVsSXNBY3RpdmUob3Blbik7IH0sIHRpbWVvdXQ6IDEwMCwgdHJpZ2dlckluZGV4OiBgJHtmaXJzdFNlbnRpbmVsSXNBY3RpdmV9YCB9KTtcclxuICAgIGNvbnN0IG1lbnVDaGlsZHJlbiA9IChoKEZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VQb3BwZXJBcnJvd1Byb3BzKHt9KSB9KSxcclxuICAgICAgICBoKFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBcInZpc3VhbGx5LWhpZGRlblwiLCBvbkZvY3VzOiAhZmlyc3RTZW50aW5lbElzQWN0aXZlID8gKCkgPT4gZm9jdXNNZW51Py4oKSA6ICgpID0+IG9uQ2xvc2UoKSwgb25DbGljazogb25DbG9zZSB9LCBcIkNsb3NlIG1lbnVcIiksXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgaChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogXCJ2aXN1YWxseS1oaWRkZW5cIiwgb25Gb2N1czogb25DbG9zZSwgb25DbGljazogb25DbG9zZSB9LCBcIkNsb3NlIG1lbnVcIikpKTtcclxuICAgIGNvbnN0IGxvZ2ljYWxEaXJlY3Rpb24gPSBnZXRMb2dpY2FsRGlyZWN0aW9uKCk7XHJcbiAgICBpZiAobG9naWNhbERpcmVjdGlvbiAmJiB1c2VkUGxhY2VtZW50KVxyXG4gICAgICAgIHJlc3QgPSBmaXhQcm9wcyhsb2dpY2FsRGlyZWN0aW9uLCBcImJsb2NrLWVuZFwiLCB1c2VkUGxhY2VtZW50LCByZXN0KTtcclxuICAgIHJldHVybiAoaChGcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBoKE9uQ2xvc2VDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBvbkNsb3NlIH0sXHJcbiAgICAgICAgICAgIGgoVXNlTWVudUl0ZW1Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VNZW51SXRlbSB9LFxyXG4gICAgICAgICAgICAgICAgY2xvbmVFbGVtZW50KGFuY2hvciwgdXNlTWVyZ2VkUHJvcHMoKSh1c2VFbGVtZW50U2l6ZVByb3BzKHsgcmVmOiBhbmNob3IucmVmLCBjbGFzczogYGRyb3Bkb3duLXRvZ2dsZSAke29wZW4gPyBcImFjdGl2ZVwiIDogXCJcIn1gIH0pLCB1c2VQb3BwZXJTb3VyY2VQcm9wcyh1c2VNZW51QnV0dG9uUHJvcHMoYW5jaG9yLnByb3BzKSkpKSxcclxuICAgICAgICAgICAgICAgIGgoQm9keVBvcnRhbCwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlUG9wcGVyUG9wdXBQcm9wcyh7IGNsYXNzOiBcImRyb3Bkb3duLW1lbnUtcG9wcGVyXCIgfSkgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaChUcmFuc2l0aW9uLCB7IC4uLnVzZU1lbnVQcm9wcyhyZXN0KSwgb3Blbjogb3Blbiwgb25UcmFuc2l0aW9uVXBkYXRlOiBvbkludGVyYWN0aW9uLCBleGl0VmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCBudWxsLCBoKHRhZywgeyBjaGlsZHJlbjogbWVudUNoaWxkcmVuLCBjbGFzc05hbWU6IFwiZHJvcGRvd24tbWVudVwiIH0pKSkpKSkpKSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIE1lbnVJdGVtKHsgY2hpbGRyZW4sIGluZGV4LCAuLi5yZXN0IH0pIHtcclxuICAgIGNvbnN0IHVzZU1lbnVJdGVtID0gdXNlQ29udGV4dChVc2VNZW51SXRlbUNvbnRleHQpO1xyXG4gICAgY29uc3QgW3RleHQsIHNldFRleHRdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcywgZWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudCgpO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudClcclxuICAgICAgICAgICAgc2V0VGV4dChlbGVtZW50LmlubmVyVGV4dCk7XHJcbiAgICB9LCBbZWxlbWVudF0pO1xyXG4gICAgY29uc3QgeyB1c2VNZW51SXRlbVByb3BzIH0gPSB1c2VNZW51SXRlbSh7IGluZGV4LCB0ZXh0IH0pO1xyXG4gICAgcmV0dXJuIChoKFwibGlcIiwgbnVsbCxcclxuICAgICAgICBoKFwiYnV0dG9uXCIsIHsgLi4udXNlTWVudUl0ZW1Qcm9wcyh1c2VSZWZFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHMoKShyZXN0LCB7IGNsYXNzOiBcImRyb3Bkb3duLWl0ZW1cIiB9KSkpIH0sIGNoaWxkcmVuKSkpO1xyXG59XHJcbmZ1bmN0aW9uIGZsaXBUcmFuc2l0aW9uQ29tcG9uZW50KGlucHV0LCB7IGlubGluZSwgYmxvY2sgfSkge1xyXG4gICAgbGV0IG91dHB1dCA9IHsgLi4uaW5wdXQgfTtcclxuICAgIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gb3V0cHV0KSB7XHJcbiAgICAgICAgaWYgKG91dHB1dFtgJHtwcm9wTmFtZX1GbGlwc2BdID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGxldCBsID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgY29uc3QgaXNJbmxpbmUgPSBsLmluY2x1ZGVzKFwiaW5saW5lXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBpc0Jsb2NrID0gbC5pbmNsdWRlcyhcImJsb2NrXCIpO1xyXG4gICAgICAgICAgICBpZiAoKGlzSW5saW5lICYmIGlubGluZSkgfHwgKGlzQmxvY2sgJiYgYmxvY2spKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgb3V0cHV0W2Ake3Byb3BOYW1lfUZsaXBzYF07XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRbcHJvcE5hbWVdID0gLWlucHV0W3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVudS5qcy5tYXAiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBoLCBjcmVhdGVDb250ZXh0LCBjbG9uZUVsZW1lbnQgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUFyaWFUYWJzIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHNcIjtcclxuaW1wb3J0IHsgRXZlbnREZXRhaWwgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VBc3luY0hhbmRsZXIgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgU3dhcHBhYmxlIH0gZnJvbSBcInByZWFjdC10cmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmNvbnN0IFVzZVRhYkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG5jb25zdCBVc2VUYWJQYW5lbENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG5leHBvcnQgZnVuY3Rpb24gVGFicyh7IG9uU2VsZWN0OiBvblNlbGVjdEFzeW5jLCBvcmllbnRhdGlvbiwgc2VsZWN0ZWRJbmRleCwgc2VsZWN0aW9uTW9kZSwgdGFnLCBjaGlsZHJlbiwgdmlzdWFsVmFyaWFudCwgLi4ucHJvcHMgfSkge1xyXG4gICAgY29uc3QgY2FwdHVyZSA9IChlKSA9PiB7IHJldHVybiBlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZEluZGV4OyB9O1xyXG4gICAgb3JpZW50YXRpb24gPz89IFwiaW5saW5lXCI7XHJcbiAgICBjb25zdCB7IGdldFN5bmNIYW5kbGVyIH0gPSB1c2VBc3luY0hhbmRsZXIoKSh7IGNhcHR1cmU6IGNhcHR1cmUgfSk7XHJcbiAgICBjb25zdCBvblNlbGVjdCA9IGdldFN5bmNIYW5kbGVyKG9uU2VsZWN0QXN5bmMpO1xyXG4gICAgY29uc3QgeyB1c2VUYWIsIHVzZVRhYlBhbmVsLCB1c2VUYWJzTGFiZWwsIHVzZVRhYnNMaXN0IH0gPSB1c2VBcmlhVGFicyh7IG9uU2VsZWN0LCBzZWxlY3RlZEluZGV4LCBzZWxlY3Rpb25Nb2RlLCBvcmllbnRhdGlvbiB9KTtcclxuICAgIGNvbnN0IHsgdXNlVGFiTGlzdFByb3BzIH0gPSB1c2VUYWJzTGlzdCgpO1xyXG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IGNsc3goXCJ0YWJzLWNvbnRhaW5lclwiLCBgdGFicy1vcmllbnRhdGlvbi0ke29yaWVudGF0aW9ufWApIH0sXHJcbiAgICAgICAgaChVc2VUYWJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VUYWIgfSwgY2xvbmVFbGVtZW50KGNoaWxkcmVuWzBdLCB1c2VUYWJMaXN0UHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzTmFtZTogY2xzeChcIm5hdlwiLCB2aXN1YWxWYXJpYW50ID09IFwicGlsbHNcIiA/IFwibmF2LXBpbGxzXCIgOiBcIm5hdi10YWJzXCIpIH0sIHsgLi4ucHJvcHMgfSkpLCBjaGlsZHJlblswXS5wcm9wcy5jaGlsZHJlbikpLFxyXG4gICAgICAgIGgoVXNlVGFiUGFuZWxDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VUYWJQYW5lbCB9LFxyXG4gICAgICAgICAgICBoKFN3YXBwYWJsZSwgbnVsbCxcclxuICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJ0YWItY29udGVudFwiIH0sIGNoaWxkcmVuLnNsaWNlKDEpKSkpKSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIFRhYih7IGluZGV4LCBjaGlsZHJlbiwgLi4ucHJvcHMgfSkge1xyXG4gICAgY29uc3QgdXNlVGFiQ29udGV4dCA9IHVzZUNvbnRleHQoVXNlVGFiQ29udGV4dCk7XHJcbiAgICBjb25zdCB7IHVzZVRhYlByb3BzLCBzZWxlY3RlZCB9ID0gdXNlVGFiQ29udGV4dCh7IGluZGV4LCB0ZXh0OiBudWxsLCB0YWc6IFwiYnV0dG9uXCIgfSk7XHJcbiAgICByZXR1cm4gaChcImxpXCIsIHsgY2xhc3NOYW1lOiBcIm5hdi1pdGVtXCIsIHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSxcclxuICAgICAgICBoKFwiYnV0dG9uXCIsIHsgLi4udXNlVGFiUHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzOiBjbHN4KGBuYXYtbGlua2AsIHNlbGVjdGVkICYmIGBhY3RpdmVgKSB9LCBwcm9wcykpIH0sIGNoaWxkcmVuKSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIFRhYlBhbmVsKHsgaW5kZXgsIGNoaWxkcmVuLCBUcmFuc2l0aW9uLCAuLi5yZXN0IH0pIHtcclxuICAgIGNvbnN0IHVzZVRhYlBhbmVsID0gdXNlQ29udGV4dChVc2VUYWJQYW5lbENvbnRleHQpO1xyXG4gICAgY29uc3QgeyB1c2VUYWJQYW5lbFByb3BzLCBzZWxlY3RlZCB9ID0gdXNlVGFiUGFuZWwoeyBpbmRleCB9KTtcclxuICAgIHJldHVybiBoKFRyYW5zaXRpb24sIHVzZVRhYlBhbmVsUHJvcHMoeyBjbGFzczogXCJcIiwgb3Blbjogc2VsZWN0ZWQsIGNoaWxkcmVuLCAuLi5yZXN0IH0pKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJzLmpzLm1hcCIsImltcG9ydCB7IEJ1dHRvbiB9IGZyb20gXCIuLi9idXR0b24vYnV0dG9uXCI7XHJcbmltcG9ydCB7IEJvZHlQb3J0YWwgfSBmcm9tIFwiLi4vcG9ydGFsXCI7XHJcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIEZyYWdtZW50LCBoLCBjbG9uZUVsZW1lbnQgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IGdlbmVyYXRlUmFuZG9tSWQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtcmFuZG9tLWlkXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IFNsaWRlRmFkZSB9IGZyb20gXCJwcmVhY3QtdHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VUb2FzdHMgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0c1wiO1xyXG5jb25zdCBQdXNoVG9hc3RDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuY29uc3QgRGVmYXVsdFRvYXN0VGltZW91dCA9IGNyZWF0ZUNvbnRleHQoNTAwMCk7XHJcbmV4cG9ydCBmdW5jdGlvbiBUb2FzdHNQcm92aWRlcih7IGNoaWxkcmVuLCBkZWZhdWx0VGltZW91dCB9KSB7XHJcbiAgICBjb25zdCBbcHVzaFRvYXN0LCBzZXRQdXNoVG9hc3RdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBwdXNoVG9hc3RTdGFibGUgPSB1c2VTdGFibGVDYWxsYmFjaygodG9hc3QpID0+IHtcclxuICAgICAgICBwdXNoVG9hc3Q/Lih0b2FzdCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAoaChGcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBoKERlZmF1bHRUb2FzdFRpbWVvdXQuUHJvdmlkZXIsIHsgdmFsdWU6IGRlZmF1bHRUaW1lb3V0ID8/IDUwMDAgfSxcclxuICAgICAgICAgICAgaChUb2FzdHNQcm92aWRlckhlbHBlciwgeyBzZXRQdXNoVG9hc3Q6IHNldFB1c2hUb2FzdCB9KSxcclxuICAgICAgICAgICAgcHVzaFRvYXN0ICYmIGgoUHVzaFRvYXN0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHVzaFRvYXN0U3RhYmxlIH0sIGNoaWxkcmVuKSkpKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdXNlUHVzaFRvYXN0KCkge1xyXG4gICAgY29uc3QgcHVzaFRvYXN0ID0gdXNlQ29udGV4dChQdXNoVG9hc3RDb250ZXh0KTtcclxuICAgIHJldHVybiBwdXNoVG9hc3Q7XHJcbn1cclxuLy8gRXh0cmFjdGVkIHRvIGEgc2VwYXJhdGUgY29tcG9uZW50IHRvIGF2b2lkIHJlcmVuZGVyaW5nIGFsbCBub24tdG9hc3QgY2hpbGRyZW5cclxuZnVuY3Rpb24gVG9hc3RzUHJvdmlkZXJIZWxwZXIoeyBzZXRQdXNoVG9hc3QgfSkge1xyXG4gICAgY29uc3QgW2NoaWxkcmVuLCBzZXRDaGlsZHJlbl0gPSB1c2VTdGF0ZShbXSk7XHJcbiAgICBjb25zdCBwdXNoVG9hc3QgPSB1c2VDYWxsYmFjaygodG9hc3QpID0+IHsgY29uc3QgcmFuZG9tS2V5ID0gZ2VuZXJhdGVSYW5kb21JZCgpOyBzZXRDaGlsZHJlbihwcmV2ID0+IChbLi4ucHJldiwgY2xvbmVFbGVtZW50KHRvYXN0LCB7IGtleTogcmFuZG9tS2V5IH0pXSkpOyB9LCBbXSk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBzZXRQdXNoVG9hc3QoXyA9PiBwdXNoVG9hc3QpOyB9LCBbcHVzaFRvYXN0XSk7XHJcbiAgICByZXR1cm4gKGgoQm9keVBvcnRhbCwgbnVsbCxcclxuICAgICAgICBoKFRvYXN0c0NvbnRhaW5lckNoaWxkcmVuQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY2hpbGRyZW4gfSxcclxuICAgICAgICAgICAgaChUb2FzdHNDb250YWluZXIsIG51bGwpKSkpO1xyXG59XHJcbmNvbnN0IFRvYXN0c0NvbnRhaW5lckNoaWxkcmVuQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoW10pO1xyXG5jb25zdCBVc2VUb2FzdENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG5mdW5jdGlvbiBUb2FzdHNDb250YWluZXIocHJvcHMpIHtcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gdXNlQ29udGV4dChUb2FzdHNDb250YWluZXJDaGlsZHJlbkNvbnRleHQpO1xyXG4gICAgY29uc3QgeyB1c2VUb2FzdCwgdXNlVG9hc3RDb250YWluZXJQcm9wcyB9ID0gdXNlVG9hc3RzKHByb3BzKTtcclxuICAgIHJldHVybiAoaChVc2VUb2FzdENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHVzZVRvYXN0IH0sXHJcbiAgICAgICAgaChcImRpdlwiLCB7IC4uLnVzZVRvYXN0Q29udGFpbmVyUHJvcHMocHJvcHMpIH0sIGNoaWxkcmVuKSkpO1xyXG59XHJcbmNvbnN0IFRvYXN0RGlzbWlzc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG5leHBvcnQgZnVuY3Rpb24gVG9hc3QoeyB0aW1lb3V0LCBwb2xpdGVuZXNzLCBjaGlsZHJlbiB9KSB7XHJcbiAgICBjb25zdCB1c2VUb2FzdCA9IHVzZUNvbnRleHQoVXNlVG9hc3RDb250ZXh0KTtcclxuICAgIGNvbnN0IGRlZmF1bHRUaW1lb3V0ID0gdXNlQ29udGV4dChEZWZhdWx0VG9hc3RUaW1lb3V0KTtcclxuICAgIGNvbnN0IHsgdXNlVG9hc3RQcm9wcywgZGlzbWlzcywgc3RhdHVzIH0gPSB1c2VUb2FzdCh7IHRpbWVvdXQ6IHRpbWVvdXQgPz8gZGVmYXVsdFRpbWVvdXQsIHBvbGl0ZW5lc3MgfSk7XHJcbiAgICByZXR1cm4gKGgoVG9hc3REaXNtaXNzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGlzbWlzcyB9LFxyXG4gICAgICAgIGgoU2xpZGVGYWRlLCB7IG9wZW46IHN0YXR1cyAhPSBcImRpc21pc3NlZFwiLCBzbGlkZVRhcmdldElubGluZTogMSwgYW5pbWF0ZU9uTW91bnQ6IHRydWUsIGV4aXRWaXNpYmlsaXR5OiBcInJlbW92ZWRcIiB9LFxyXG4gICAgICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlVG9hc3RQcm9wcyh7IGNsYXNzOiBcInRvYXN0IHNob3dcIiB9KSB9LFxyXG4gICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzOiBcImQtZmxleFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzOiBcInRvYXN0LWJvZHlcIiB9LCBjaGlsZHJlbiksXHJcbiAgICAgICAgICAgICAgICAgICAgaChCdXR0b24sIHsgY2xhc3M6IFwiYnRuLWNsb3NlIG1lLTIgbS1hdXRvXCIsIFwiYXJpYS1sYWJlbFwiOiBcIkRpc21pc3MgYWxlcnRcIiwgb25DbGljazogZGlzbWlzcyB9KSkpKSkpO1xyXG59XHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiBUb2FzdEhlYWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInRvYXN0LWhlYWRlclwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWUtYXV0b1wiPlxyXG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPEJ1dHRvbiBjbGFzcz1cImJ0bi1jbG9zZVwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiIC8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApXHJcbn0qL1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2FzdC5qcy5tYXAiLCJpbXBvcnQgeyBCb2R5UG9ydGFsIH0gZnJvbSBcIi4uL3BvcnRhbFwiO1xyXG5pbXBvcnQgeyBjbG9uZUVsZW1lbnQsIGgsIEZyYWdtZW50IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VBcmlhVG9vbHRpcCB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzL3VzZS10b29sdGlwXCI7XHJcbmltcG9ydCB7IHVzZUVsZW1lbnRTaXplIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWVsZW1lbnQtc2l6ZVwiO1xyXG5pbXBvcnQgeyBmaXhQcm9wcywgdXNlUG9wcGVyQXBpLCB1c2VTaG91bGRVcGRhdGVQb3BwZXIgfSBmcm9tIFwiLi4vbWVudS9wb3BwZXItYXBpXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5leHBvcnQgZnVuY3Rpb24gVG9vbHRpcCh7IGNoaWxkcmVuLCBwb3NpdGlvbiwgdG9vbHRpcCwgVHJhbnNpdGlvbiwgbW91c2VvdmVyRGVsYXksIC4uLnJlc3QgfSkge1xyXG4gICAgY29uc3QgeyBnZXRJc09wZW4sIGlzT3BlbiwgdXNlVG9vbHRpcCwgdXNlVG9vbHRpcFRyaWdnZXIgfSA9IHVzZUFyaWFUb29sdGlwKHsgbW91c2VvdmVyRGVsYXkgfSk7XHJcbiAgICBjb25zdCB7IHVzZUVsZW1lbnRTaXplUHJvcHMsIGVsZW1lbnRTaXplIH0gPSB1c2VFbGVtZW50U2l6ZSgpO1xyXG4gICAgbGV0IGNsb25lYWJsZTtcclxuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGNoaWxkcmVuID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBjaGlsZHJlbiA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgY2hpbGRyZW4gPT09IFwiYmlnaW50XCIpIHtcclxuICAgICAgICBjbG9uZWFibGUgPSBoKFwic3BhblwiLCBudWxsLCBjaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICAgIGNsb25lYWJsZSA9IGgoXCJzcGFuXCIsIG51bGwsIGNoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNsb25lYWJsZSA9IGNoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyB1c2VUb29sdGlwUHJvcHMgfSA9IHVzZVRvb2x0aXAoKTtcclxuICAgIGNvbnN0IHsgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyB9ID0gdXNlVG9vbHRpcFRyaWdnZXIoKTtcclxuICAgIGNvbnN0IHsgc2hvdWxkVXBkYXRlLCBvbkludGVyYWN0aW9uIH0gPSB1c2VTaG91bGRVcGRhdGVQb3BwZXIoaXNPcGVuLCBlbGVtZW50U2l6ZSk7XHJcbiAgICBjb25zdCB7IGdldExvZ2ljYWxEaXJlY3Rpb24sIHVzZVBvcHBlckFycm93LCB1c2VQb3BwZXJQb3B1cCwgdXNlUG9wcGVyU291cmNlLCB1c2VkUGxhY2VtZW50IH0gPSB1c2VQb3BwZXJBcGkoeyB1cGRhdGluZzogc2hvdWxkVXBkYXRlLCBwb3NpdGlvbiwgfSk7XHJcbiAgICBjb25zdCB7IHVzZVBvcHBlclBvcHVwUHJvcHMgfSA9IHVzZVBvcHBlclBvcHVwKHsgb3BlbjogaXNPcGVuIH0pO1xyXG4gICAgY29uc3QgeyB1c2VQb3BwZXJBcnJvd1Byb3BzIH0gPSB1c2VQb3BwZXJBcnJvdygpO1xyXG4gICAgY29uc3QgeyB1c2VQb3BwZXJTb3VyY2VQcm9wcyB9ID0gdXNlUG9wcGVyU291cmNlKCk7XHJcbiAgICBjb25zdCBsb2dpY2FsRGlyZWN0aW9uID0gZ2V0TG9naWNhbERpcmVjdGlvbigpO1xyXG4gICAgaWYgKGxvZ2ljYWxEaXJlY3Rpb24gJiYgdXNlZFBsYWNlbWVudClcclxuICAgICAgICByZXN0ID0gZml4UHJvcHMobG9naWNhbERpcmVjdGlvbiwgXCJibG9jay1lbmRcIiwgdXNlZFBsYWNlbWVudCwgcmVzdCk7XHJcbiAgICAvLyBUT0RPOiBJdCdzIHJlcXVpcmVkIGZvciB0aGlzIHRvIGJlIGV4aXRWaXNpYmlsaXR5PVwiaGlkZGVuXCIgZm9yIHRyYW5zZm9ybXMgdG8gd29yaz9cclxuICAgIC8vIFByb2JhYmx5IGFuIGlzc3VlIGluIHRoZSBUcmFuc2l0aW9uIGVsZW1lbnQgaXRzZWxmIGJlY2F1c2UgaXQncyBub3QgYnJvd3Nlci1zcGVjaWZpYyBidXQgaXQncyBhIGxpdHRsZSB3ZWlyZFxyXG4gICAgcmV0dXJuIGgoRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgY2xvbmVFbGVtZW50KGNsb25lYWJsZSwgdXNlTWVyZ2VkUHJvcHMoKSh7IHJlZjogY2xvbmVhYmxlLnJlZiB9LCB1c2VUb29sdGlwVHJpZ2dlclByb3BzKHVzZUVsZW1lbnRTaXplUHJvcHModXNlUG9wcGVyU291cmNlUHJvcHMoY2xvbmVhYmxlLnByb3BzKSkpKSksXHJcbiAgICAgICAgaChCb2R5UG9ydGFsLCBudWxsLFxyXG4gICAgICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlUG9wcGVyUG9wdXBQcm9wcyh7IGNsYXNzOiBcInRvb2x0aXAtd3JhcHBlclwiIH0pIH0sXHJcbiAgICAgICAgICAgICAgICBoKFRyYW5zaXRpb24sIHsgLi4ucmVzdCwgb3BlbjogaXNPcGVuLCBvblRyYW5zaXRpb25VcGRhdGU6IG9uSW50ZXJhY3Rpb24sIGV4aXRWaXNpYmlsaXR5OiBcImhpZGRlblwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IC4uLnVzZVRvb2x0aXBQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHsgY2xhc3M6IFwidG9vbHRpcCBzaG93XCIsIHJvbGU6IFwidG9vbHRpcFwiIH0sIHt9KSkgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IC4uLnVzZVBvcHBlckFycm93UHJvcHMoeyBjbGFzczogXCJ0b29sdGlwLWFycm93XCIgfSkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJ0b29sdGlwLWlubmVyXCIgfSwgdG9vbHRpcCkpKSkpKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b29sdGlwLmpzLm1hcCIsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi4vcHJvcHNcIjtcclxuZXhwb3J0IGNvbnN0IENhcmQgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDYXJkKHAsIHJlZikge1xyXG4gICAgbGV0IHsgY2hpbGRyZW4sIC4uLnByb3BzIH0gPSBwO1xyXG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKSh7IHJlZiwgY2xhc3NOYW1lOiBcImNhcmRcIiB9LCBwcm9wcykgfSwgY2hpbGRyZW4pKTtcclxufSk7XHJcbmZ1bmN0aW9uIENhcmRFbGVtZW50Mih7IGNoaWxkcmVuLCAuLi5wIH0sIHJlZikge1xyXG4gICAgc3dpdGNoIChwLnR5cGUpIHtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNhc2UgXCJwYXJhZ3JhcGhcIjoge1xyXG4gICAgICAgICAgICBjb25zdCB7IHR5cGUsIC4uLnByb3BzIH0gPSBwO1xyXG4gICAgICAgICAgICByZXR1cm4gaChDYXJkQm9keSwgeyAuLi5wcm9wcywgcmVmOiByZWYgfSxcclxuICAgICAgICAgICAgICAgIGgoQ2FyZFRleHQsIG51bGwsIGNoaWxkcmVuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJmb290ZXJcIjoge1xyXG4gICAgICAgICAgICBjb25zdCB7IHR5cGUsIC4uLnByb3BzIH0gPSBwO1xyXG4gICAgICAgICAgICByZXR1cm4gaChDYXJkRm9vdGVyLCB7IC4uLnByb3BzLCByZWY6IHJlZiB9LCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJzdWJ0aXRsZVwiOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgdGFnLCAuLi5wcm9wcyB9ID0gcDtcclxuICAgICAgICAgICAgcmV0dXJuIGgoQ2FyZEJvZHksIHsgLi4ucHJvcHMsIHJlZjogcmVmIH0sXHJcbiAgICAgICAgICAgICAgICBoKENhcmRTdWJ0aXRsZSwgeyB0YWc6IHRhZyB9LCBjaGlsZHJlbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwidGl0bGVcIjoge1xyXG4gICAgICAgICAgICBjb25zdCB7IHR5cGUsIHRhZywgLi4ucHJvcHMgfSA9IHA7XHJcbiAgICAgICAgICAgIHJldHVybiBoKENhcmRCb2R5LCB7IC4uLnByb3BzLCByZWY6IHJlZiB9LFxyXG4gICAgICAgICAgICAgICAgaChDYXJkVGl0bGUsIHsgdGFnOiB0YWcgfSwgY2hpbGRyZW4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcImltYWdlXCI6IHtcclxuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCBzcmMsIC4uLnByb3BzIH0gPSBwO1xyXG4gICAgICAgICAgICByZXR1cm4gaChDYXJkSW1hZ2UsIHsgc3JjOiBzcmMsIHBvc2l0aW9uOiBcImJvdGhcIiwgLi4ucHJvcHMsIHJlZjogcmVmIH0sIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcImZsdXNoXCI6IHtcclxuICAgICAgICAgICAgY29uc3QgeyB0YWcsIC4uLnByb3BzIH0gPSBwO1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWcsIHByb3BzLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjb25zdCBDYXJkRWxlbWVudCA9IGZvcndhcmRFbGVtZW50UmVmKENhcmRFbGVtZW50Mik7XHJcbmNvbnN0IENhcmRJbWFnZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENhcmRJbWFnZShwLCByZWYpIHtcclxuICAgIGNvbnN0IHsgcG9zaXRpb24sIC4uLnByb3BzIH0gPSBwO1xyXG4gICAgcmV0dXJuIChoKFwiaW1nXCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKShwcm9wcywgeyByZWYsIGNsYXNzTmFtZTogYGNhcmQtaW1nJHtwb3NpdGlvbiA9PSBcImJvdGhcIiA/IFwiXCIgOiBgLSR7cG9zaXRpb259YH1gIH0pIH0pKTtcclxufSk7XHJcbmNvbnN0IENhcmRCb2R5ID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2FyZEJvZHkocHJvcHMsIHJlZikge1xyXG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKShwcm9wcywgeyByZWYsIGNsYXNzTmFtZTogXCJjYXJkLWJvZHlcIiB9KSB9KSk7XHJcbn0pO1xyXG5jb25zdCBDYXJkRm9vdGVyID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2FyZEhlYWRlcihwcm9wcywgcmVmKSB7XHJcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyAuLi51c2VNZXJnZWRQcm9wcygpKHByb3BzLCB7IHJlZiwgY2xhc3NOYW1lOiBcImNhcmRcIiB9KSB9KSk7XHJcbn0pO1xyXG5jb25zdCBDYXJkVGl0bGUgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDYXJkVGl0bGUocCwgcmVmKSB7XHJcbiAgICBjb25zdCB7IHRhZywgLi4ucHJvcHMgfSA9IHA7XHJcbiAgICByZXR1cm4gaCh0YWcgPz8gXCJoNVwiLCB1c2VNZXJnZWRQcm9wcygpKHByb3BzLCB7IHJlZiwgY2xhc3NOYW1lOiBcImNhcmQtdGl0bGVcIiB9KSk7XHJcbn0pO1xyXG5jb25zdCBDYXJkU3VidGl0bGUgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDYXJkU3VidGl0bGUocCwgcmVmKSB7XHJcbiAgICBjb25zdCB7IHRhZywgLi4ucHJvcHMgfSA9IHA7XHJcbiAgICByZXR1cm4gaCh0YWcgPz8gXCJoNVwiLCB1c2VNZXJnZWRQcm9wcygpKHByb3BzLCB7IHJlZiwgY2xhc3NOYW1lOiBjbHN4KFwiY2FyZC1zdWJ0aXRsZVwiLCBcIm1iLTJcIiwgXCJ0ZXh0LW11dGVkXCIpIH0pKTtcclxufSk7XHJcbmNvbnN0IENhcmRUZXh0ID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2FyZFRleHQocHJvcHMsIHJlZikge1xyXG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKShwcm9wcywgeyByZWYsIGNsYXNzTmFtZTogXCJjYXJkLXRleHRcIiB9KSB9KSk7XHJcbn0pO1xyXG5jb25zdCBDYXJkSGVhZGVyID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2FyZEhlYWRlcihwcm9wcywgcmVmKSB7XHJcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyAuLi51c2VNZXJnZWRQcm9wcygpKHByb3BzLCB7IHJlZiwgY2xhc3NOYW1lOiBcImNhcmQtaGVhZGVyXCIgfSkgfSkpO1xyXG59KTtcclxuY29uc3QgYTIgPSBoKENhcmRFbGVtZW50LCB7IHR5cGU6IFwidGl0bGVcIiwgdGFnOiBcImgxXCIsIGNoaWxkcmVuOiBcIlwiLCBjbGFzczogXCJcIiB9KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyZC5qcy5tYXAiLG51bGwsbnVsbCxudWxsLG51bGwsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGNsb25lRWxlbWVudCwgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnMgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtYnV0dG9uXCI7XHJcbmltcG9ydCB7IHVzZUdyaWROYXZpZ2F0aW9uLCB1c2VIYXNGb2N1cywgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IEZhZGUsIFN3YXBwYWJsZSB9IGZyb20gXCJwcmVhY3QtdHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4uL3Byb3BzXCI7XHJcbmNvbnN0IEN1cnJlbnRTb3J0ZWRDb2x1bW5Db250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuY29uc3QgU2V0Q3VycmVudFNvcnRlZENvbHVtbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG4vLyBUaGlzIGlzIHRoZSBob29rIHRoYXQgcm93cyB1c2UgZm9yIG5hdmlnYXRpb25cclxuY29uc3QgVXNlR3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuLy8gVGhpcyBpcyB0aGUgaG9vayB0aGF0IGNlbGxzIHVzZSBmb3IgbmF2aWdhdGlvblxyXG5jb25zdCBVc2VHcmlkTmF2aWdhdGlvbkNlbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuLy8gVGhpcyBpcywgaW50ZXJuYWxseSwgd2hhdCB0aGUgaGVhZGVyIGNlbGwgY2FsbHMgd2hlbiB0aGUgdXNlciBjbGlja3MgaXQuXHJcbi8vIFRoZSBib2R5IGNyZWF0ZXMgaXQtLWl0IHNvcnRzIHRoZSBrbm93biByb3dzIGFuZCB1cGRhdGVzIHRoZSBjaGlsZHJlbi5cclxuY29uc3QgSW50ZXJuYWxTb3J0SGFuZGxlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG4vLyBUaGlzIGlzIHVzZWQgYnkgdGhlIGJvZHkuIEl0IGNyZWF0ZXMgdGhlIHNvcnQgaGFuZGxlciwgYnV0IGluIG9yZGVyXHJcbi8vIHRvIGdldCBpdCB0byB0aGUgaGVhZCwgd2hlcmUgdGhlIGNsaWNrYWJsZSBoZWFkZXIgY2VsbHMgYXJlLCB3ZSBuZWVkXHJcbi8vIHRoaXMgQ29udGV4dCwgdXNlZCBieSB0aGUgcGFyZW50IFRhYmxlLCB0byBmYXNjaWxpdGF0ZSBjb21tdW5pY2F0aW9uLlxyXG5jb25zdCBTZXRJbnRlcm5hbFNvcnRIYW5kbGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmV4cG9ydCBjb25zdCBUYWJsZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFRhYmxlKHsgY2hpbGRyZW4sIHNtYWxsLCBzdHJpcGVkLCBob3ZlcmFibGUsIGJvcmRlciwgdmFyaWFudCwgYm9yZGVyQ29sb3IsIC4uLnByb3BzIH0sIHJlZikge1xyXG4gICAgY29uc3QgW3NvcnRlZENvbHVtbiwgc2V0U29ydGVkQ29sdW1uXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgLy8gVGhpcyBpcyB0aGUgb25lIHRoYXQncyB1c2VkIGZvciB0aGUgYnV0dG9uIGluIHRoZSB0YWJsZSBoZWFkXHJcbiAgICBjb25zdCBbaW50ZXJuYWxTb3J0SGFuZGxlciwgc2V0SW50ZXJuYWxTb3J0SGFuZGxlcl0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIHJldHVybiAoaChcInRhYmxlXCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgcm9sZTogXCJncm91cFwiLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsc3goXCJ0YWJsZVwiLCBzbWFsbCAmJiBcInRhYmxlLXNtXCIsIHN0cmlwZWQgJiYgXCJ0YWJsZS1zdHJpcGVkXCIsIGhvdmVyYWJsZSAmJiBcInRhYmxlLWhvdmVyXCIsIGJvcmRlciA9PT0gXCJhbGxcIiAmJiBcInRhYmxlLWJvcmRlcmVkXCIsIGJvcmRlciA9PT0gXCJub25lXCIgJiYgXCJ0YWJsZS1ib3JkZXJsZXNzXCIsIHZhcmlhbnQgJiYgYHRhYmxlLSR7dmFyaWFudH1gLCBib3JkZXJDb2xvciAmJiBgYm9yZGVyLSR7Ym9yZGVyQ29sb3J9YClcclxuICAgICAgICB9LCBwcm9wcykgfSxcclxuICAgICAgICBoKFNldEludGVybmFsU29ydEhhbmRsZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzZXRJbnRlcm5hbFNvcnRIYW5kbGVyIH0sXHJcbiAgICAgICAgICAgIGgoSW50ZXJuYWxTb3J0SGFuZGxlckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGludGVybmFsU29ydEhhbmRsZXIgfSxcclxuICAgICAgICAgICAgICAgIGgoQ3VycmVudFNvcnRlZENvbHVtbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHNvcnRlZENvbHVtbiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGgoU2V0Q3VycmVudFNvcnRlZENvbHVtbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHNldFNvcnRlZENvbHVtbiB9LCBjaGlsZHJlbikpKSkpKTtcclxufSk7XHJcbmNvbnN0IENlbGxJc0luSGVhZGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoZmFsc2UpO1xyXG5mdW5jdGlvbiBub29wKCkgeyB9XHJcbjtcclxuZXhwb3J0IGNvbnN0IFRhYmxlSGVhZCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFRhYmxlSGVhZCh7IGNoaWxkcmVuLCB2YXJpYW50LCAuLi5wcm9wcyB9LCByZWYpIHtcclxuICAgIGNvbnN0IHsgZm9jdXNlZElubmVyLCB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1cyh7fSk7XHJcbiAgICBjb25zdCB7IGNlbGxJbmRleCwgcm93SW5kZXgsIHJvd0NvdW50LCB1c2VHcmlkTmF2aWdhdGlvblJvdyB9ID0gdXNlR3JpZE5hdmlnYXRpb24oeyBmb2N1c09uQ2hhbmdlOiBmb2N1c2VkSW5uZXIgfSk7XHJcbiAgICByZXR1cm4gKGgoVXNlR3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VHcmlkTmF2aWdhdGlvblJvdyB9LFxyXG4gICAgICAgIGgoQ2VsbElzSW5IZWFkZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0cnVlIH0sXHJcbiAgICAgICAgICAgIGgoXCJ0aGVhZFwiLCB7IC4uLnVzZUhhc0ZvY3VzUHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwicm93Z3JvdXBcIixcclxuICAgICAgICAgICAgICAgICAgICBcImRhdGEtY3VycmVudC1yb3dcIjogcm93SW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLWN1cnJlbnQtY29sdW1uXCI6IGNlbGxJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBcImRhdGEtcm93LWNvdW50XCI6IHJvd0NvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzeCh2YXJpYW50ICYmIGB0YWJsZS0ke3ZhcmlhbnR9YClcclxuICAgICAgICAgICAgICAgIH0sIHByb3BzKSkgfSwgY2hpbGRyZW4pKSkpO1xyXG59KTtcclxuZnVuY3Rpb24gY29tcGFyZTMobGhzLCByaHMpIHtcclxuICAgIGlmIChgJHsrbGhzfWAgPT09IGxocylcclxuICAgICAgICBsaHMgPSArbGhzO1xyXG4gICAgaWYgKGAkeytyaHN9YCA9PT0gcmhzKVxyXG4gICAgICAgIHJocyA9ICtyaHM7XHJcbiAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICByaHMgPSBgJHtyaHN9YDtcclxuICAgIGlmICh0eXBlb2YgcmhzID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgIGxocyA9IGAke2xoc31gO1xyXG4gICAgY29uc29sZS5hc3NlcnQodHlwZW9mIGxocyA9PT0gdHlwZW9mIHJocyk7XHJcbiAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICByZXR1cm4gbGhzLmxvY2FsZUNvbXBhcmUocmhzKTtcclxuICAgIGlmICh0eXBlb2YgbGhzID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgIHJldHVybiArbGhzIC0gK3JocztcclxuICAgIHJldHVybiAwO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmUyKGxocywgcmhzKSB7XHJcbiAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJib29sZWFuXCIgfHwgbGhzIGluc3RhbmNlb2YgRGF0ZSlcclxuICAgICAgICBsaHMgPSArbGhzO1xyXG4gICAgaWYgKHR5cGVvZiByaHMgPT09IFwiYm9vbGVhblwiIHx8IHJocyBpbnN0YW5jZW9mIERhdGUpXHJcbiAgICAgICAgcmhzID0gK3JocztcclxuICAgIHJldHVybiBjb21wYXJlMyhsaHMsIHJocyk7XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZTEobGhzLCByaHMpIHtcclxuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFRoZXkncmUgYm90aCBudWxsXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCB8fCByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIE9uZSBvZiB0aGUgdHdvIGlzIG51bGwgLS0gZWFzeSBjYXNlXHJcbiAgICAgICAgcmV0dXJuIGxocyAhPSBudWxsID8gLTEgOiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBhcmUyKGxocywgcmhzKTtcclxufVxyXG5jb25zdCBTb3J0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmV4cG9ydCBjb25zdCBUYWJsZUJvZHkgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBUYWJsZUJvZHkoeyBjaGlsZHJlbiwgdmFyaWFudCwgLi4ucHJvcHMgfSwgcmVmKSB7XHJcbiAgICBjb25zdCB7IGZvY3VzZWRJbm5lciwgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXMoe30pO1xyXG4gICAgY29uc3QgeyBjZWxsSW5kZXgsIHJvd0luZGV4LCByb3dDb3VudCwgdXNlR3JpZE5hdmlnYXRpb25Sb3csIG1hbmFnZWRSb3dzIH0gPSB1c2VHcmlkTmF2aWdhdGlvbih7IGZvY3VzT25DaGFuZ2U6IGZvY3VzZWRJbm5lciB9KTtcclxuICAgIC8vIFRoaXMgaG9va3MgdXAgdG8gaW50ZXJuYWxTb3J0SGFuZGxlciwgdXNlZCBieSB0aGUgdGFibGUgaGVhZC5cclxuICAgIGNvbnN0IHNvcnQgPSB1c2VDYWxsYmFjaygoY29sdW1uLCBkaXJlY3Rpb24pID0+IHtcclxuICAgICAgICBsZXQgc29ydGVkUm93cyA9IG1hbmFnZWRSb3dzLnNsaWNlKCkuc29ydCgobGhzUm93LCByaHNSb3cpID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGNvbXBhcmUxKGxoc1Jvdy5nZXRNYW5hZ2VkQ2VsbHMoKVtjb2x1bW5dLmxpdGVyYWxWYWx1ZSwgcmhzUm93LmdldE1hbmFnZWRDZWxscygpW2NvbHVtbl0ubGl0ZXJhbFZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvblswXSA9PSBcImRcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiAtcmVzdWx0O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAobGV0IGxpdGVyYWxJbmRleCA9IDA7IGxpdGVyYWxJbmRleCA8IHNvcnRlZFJvd3MubGVuZ3RoOyArK2xpdGVyYWxJbmRleCkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXNwbGF5SW5kZXggPSBzb3J0ZWRSb3dzW2xpdGVyYWxJbmRleF0uaW5kZXg7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3BsYXlDZWxscyA9IHNvcnRlZFJvd3NbZGlzcGxheUluZGV4XS5nZXRNYW5hZ2VkQ2VsbHMoKTtcclxuICAgICAgICAgICAgY29uc3QgbGl0ZXJhbENlbGxzID0gc29ydGVkUm93c1tsaXRlcmFsSW5kZXhdLmdldE1hbmFnZWRDZWxscygpO1xyXG4gICAgICAgICAgICBtYW5hZ2VkUm93c1tsaXRlcmFsSW5kZXhdLnNldERpc3BsYXlSb3dJbmRleChkaXNwbGF5SW5kZXgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjZWxsSW5kZXggPSAwOyBjZWxsSW5kZXggPCBkaXNwbGF5Q2VsbHMubGVuZ3RoOyArK2NlbGxJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheUNlbGxzW2NlbGxJbmRleF0ucHJvdmlkZVdpdGhTaWJsaW5nc1NldERpc3BsYXlWYWx1ZSgoKSA9PiBsaXRlcmFsQ2VsbHNbY2VsbEluZGV4XS5zZXREaXNwbGF5VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3Qgc2V0SW50ZXJuYWxTb3J0SGFuZGxlciA9IHVzZUNvbnRleHQoU2V0SW50ZXJuYWxTb3J0SGFuZGxlckNvbnRleHQpO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHsgc2V0SW50ZXJuYWxTb3J0SGFuZGxlcigoKSA9PiBzb3J0KTsgfSwgW3NldEludGVybmFsU29ydEhhbmRsZXIsIHNvcnRdKTtcclxuICAgIHJldHVybiAoaChcInRib2R5XCIsIHsgLi4udXNlSGFzRm9jdXNQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHtcclxuICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICByb2xlOiBcInJvd2dyb3VwXCIsXHJcbiAgICAgICAgICAgIFwiZGF0YS1jdXJyZW50LXJvd1wiOiByb3dJbmRleCxcclxuICAgICAgICAgICAgXCJkYXRhLWN1cnJlbnQtY29sdW1uXCI6IGNlbGxJbmRleCxcclxuICAgICAgICAgICAgXCJkYXRhLXJvdy1jb3VudFwiOiByb3dDb3VudCxcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbHN4KHZhcmlhbnQgJiYgYHRhYmxlLSR7dmFyaWFudH1gKVxyXG4gICAgICAgIH0sIHByb3BzKSkgfSxcclxuICAgICAgICBoKFVzZUdyaWROYXZpZ2F0aW9uUm93Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlR3JpZE5hdmlnYXRpb25Sb3cgfSxcclxuICAgICAgICAgICAgaChTb3J0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogc29ydCB9LCBjaGlsZHJlbikpKSk7XHJcbn0pO1xyXG5leHBvcnQgY29uc3QgVGFibGVGb290ID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gVGFibGVGb290KHsgY2hpbGRyZW4sIHZhcmlhbnQsIC4uLnByb3BzIH0sIHJlZikge1xyXG4gICAgY29uc3QgeyBmb2N1c2VkSW5uZXIsIHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzKHt9KTtcclxuICAgIGNvbnN0IHsgY2VsbEluZGV4LCByb3dJbmRleCwgcm93Q291bnQsIHVzZUdyaWROYXZpZ2F0aW9uUm93IH0gPSB1c2VHcmlkTmF2aWdhdGlvbih7IGZvY3VzT25DaGFuZ2U6IGZvY3VzZWRJbm5lciB9KTtcclxuICAgIHJldHVybiAoaChVc2VHcmlkTmF2aWdhdGlvblJvd0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHVzZUdyaWROYXZpZ2F0aW9uUm93IH0sXHJcbiAgICAgICAgaChcInRmb290XCIsIHsgLi4udXNlSGFzRm9jdXNQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHtcclxuICAgICAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgICAgIFwiZGF0YS1jdXJyZW50LXJvd1wiOiByb3dJbmRleCxcclxuICAgICAgICAgICAgICAgIFwiZGF0YS1jdXJyZW50LWNvbHVtblwiOiBjZWxsSW5kZXgsXHJcbiAgICAgICAgICAgICAgICBcImRhdGEtcm93LWNvdW50XCI6IHJvd0NvdW50LFxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbHN4KHZhcmlhbnQgJiYgYHRhYmxlLSR7dmFyaWFudH1gKVxyXG4gICAgICAgICAgICB9LCBwcm9wcykpIH0sIGNoaWxkcmVuKSkpO1xyXG59KTtcclxuZXhwb3J0IGNvbnN0IFRhYmxlUm93ID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gVGFibGVSb3coeyBjaGlsZHJlbiwgaW5kZXg6IGxpdGVyYWxJbmRleCwgdmFyaWFudCwgLi4ucHJvcHMgfSwgcmVmKSB7XHJcbiAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvblJvdyA9IHVzZUNvbnRleHQoVXNlR3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0KTtcclxuICAgIGNvbnN0IFtkaXNwbGF5SW5kZXgsIHNldERpc3BsYXlJbmRleF0gPSB1c2VTdGF0ZShsaXRlcmFsSW5kZXgpO1xyXG4gICAgY29uc3QgeyBjZWxsQ291bnQsIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHMsIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCwgdGFiYmFibGVDZWxsLCBpc1RhYmJhYmxlUm93LCBtYW5hZ2VkQ2VsbHMgfSA9IHVzZUdyaWROYXZpZ2F0aW9uUm93KHtcclxuICAgICAgICBpbmRleDogbGl0ZXJhbEluZGV4LCBzZXREaXNwbGF5Um93SW5kZXg6IHNldERpc3BsYXlJbmRleCwgZ2V0TWFuYWdlZENlbGxzOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiBtYW5hZ2VkQ2VsbHMpXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGlzSW5USGVhZCA9IHVzZUNvbnRleHQoQ2VsbElzSW5IZWFkZXJDb250ZXh0KTtcclxuICAgIGNvbnN0IHJvd1Byb3BzID0ge1xyXG4gICAgICAgIGNoaWxkcmVuLCAuLi4odXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgcm9sZTogXCJyb3dcIixcclxuICAgICAgICAgICAgXCJkYXRhLWxpdGVyYWwtaW5kZXhcIjogbGl0ZXJhbEluZGV4LFxyXG4gICAgICAgICAgICBcImRhdGEtZGlzcGxheS1pbmRleFwiOiBkaXNwbGF5SW5kZXgsXHJcbiAgICAgICAgICAgIFwiZGF0YS10YWJiYWJsZVwiOiBgJHtpc1RhYmJhYmxlUm93fWAsXHJcbiAgICAgICAgICAgIFwiZGF0YS10YWJiYWJsZS1jZWxsXCI6IGAke3RhYmJhYmxlQ2VsbH1gLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsc3godmFyaWFudCAmJiBgdGFibGUtJHt2YXJpYW50fWApLFxyXG4gICAgICAgICAgICBcImRhdGEtY2VsbC1jb3VudFwiOiBjZWxsQ291bnRcclxuICAgICAgICB9LCBwcm9wcykpXHJcbiAgICB9O1xyXG4gICAgLy8gVGhpcyBpcyB3aGF0IHdlIGRpc3BsYXkgdW5kZXIgdGhlIGRlZmF1bHQgY2lyY3Vtc3RhbmNlICh3ZSdyZSBkaXNwbGF5aW5nIG91ciBvd24gcm93KVxyXG4gICAgY29uc3Qgcm93SnN4ID0gaChcInRyXCIsIHsgLi4udXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyhyb3dQcm9wcykgfSwgY2hpbGRyZW4pO1xyXG4gICAgcmV0dXJuIChoKFVzZUdyaWROYXZpZ2F0aW9uQ2VsbENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCB9LFxyXG4gICAgICAgIGgoRGlzcGxheVJvd0luZGV4Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGlzcGxheUluZGV4IH0sIHJvd0pzeCkpKTtcclxufSk7XHJcbmNvbnN0IERpc3BsYXlSb3dJbmRleENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xyXG5leHBvcnQgY29uc3QgVGFibGVDZWxsID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gVGFibGVDZWxsKHsgdmFsdWU6IGxpdGVyYWxWYWx1ZSwgY2hpbGRyZW4sIGluZGV4LCB2YXJpYW50LCBmb2N1cywgYWN0aXZlLCAuLi5wcm9wcyB9LCByZWYpIHtcclxuICAgIGZvY3VzID8/PSBcImNlbGxcIjtcclxuICAgIGNvbnN0IHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCA9IHVzZUNvbnRleHQoVXNlR3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dCk7XHJcbiAgICBjb25zdCBbZGlzcGxheVZhbHVlLCBzZXREaXNwbGF5VmFsdWVdID0gdXNlU3RhdGUobGl0ZXJhbFZhbHVlKTtcclxuICAgIGNvbnN0IFtzZXRTaWJsaW5nRGlzcGxheVZhbHVlLCBwcm92aWRlV2l0aFNpYmxpbmdzU2V0RGlzcGxheVZhbHVlXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgeyB0YWJiYWJsZSwgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMgfSA9IHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCh7IGluZGV4LCB0ZXh0OiBudWxsLCB2YWx1ZTogZGlzcGxheVZhbHVlLCBsaXRlcmFsVmFsdWUsIHByb3ZpZGVXaXRoU2libGluZ3NTZXREaXNwbGF5VmFsdWUsIHNldERpc3BsYXlWYWx1ZSB9KTtcclxuICAgIGNvbnN0IGRpc3BsYXlSb3dJbmRleCA9IHVzZUNvbnRleHQoRGlzcGxheVJvd0luZGV4Q29udGV4dCk7XHJcbiAgICBjb25zdCBjZWxsUHJvcHMgPSB1c2VNZXJnZWRQcm9wcygpKHtcclxuICAgICAgICByZWYsXHJcbiAgICAgICAgcm9sZTogXCJncmlkY2VsbFwiLFxyXG4gICAgICAgIFwiZGF0YS1saXRlcmFsLXZhbHVlXCI6IGxpdGVyYWxWYWx1ZSxcclxuICAgICAgICBcImRhdGEtZGlzcGxheS12YWx1ZVwiOiBkaXNwbGF5VmFsdWUsXHJcbiAgICAgICAgXCJkYXRhLWRpc3BsYXktcm93XCI6IGRpc3BsYXlSb3dJbmRleCxcclxuICAgICAgICBjbGFzc05hbWU6IGNsc3godmFyaWFudCAmJiBgdGFibGUtJHt2YXJpYW50fWApXHJcbiAgICB9LCBwcm9wcyk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldFNpYmxpbmdEaXNwbGF5VmFsdWU/LihsaXRlcmFsVmFsdWUpO1xyXG4gICAgfSwgW3NldFNpYmxpbmdEaXNwbGF5VmFsdWUsIGxpdGVyYWxWYWx1ZV0pO1xyXG4gICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgcmV0dXJuIChoKFwidGRcIiwgeyAuLi5jZWxsUHJvcHMgfSwgY3JlYXRlRWxlbWVudChjaGlsZHJlbiwgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMoeyBkaXNwbGF5Um93SW5kZXgsIGRpc3BsYXlWYWx1ZSwgY2xhc3NOYW1lOiBcInRlc3RcIiB9KSkpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAoaChcInRkXCIsIHsgLi4udXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMoY2VsbFByb3BzKSB9LCBzdHJpbmdpZnkoZGlzcGxheVZhbHVlKSkpO1xyXG4gICAgfVxyXG59KTtcclxuZXhwb3J0IGNvbnN0IFRhYmxlSGVhZGVyQ2VsbCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFRhYmxlSGVhZGVyQ2VsbCh7IGluZGV4LCBmb2N1cywgdmFsdWUsIGNoaWxkcmVuLCB2YXJpYW50LCBhY3RpdmUsIC4uLnByb3BzIH0sIHJlZikge1xyXG4gICAgZm9jdXMgPz89IFwiY2VsbFwiO1xyXG4gICAgY29uc3QgW3NvcnREaXJlY3Rpb24sIHNldFNvcnREaXJlY3Rpb24sIGdldFNvcnREaXJlY3Rpb25dID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBpc0luVEhlYWQgPSB1c2VDb250ZXh0KENlbGxJc0luSGVhZGVyQ29udGV4dCk7XHJcbiAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvbkNlbGwgPSB1c2VDb250ZXh0KFVzZUdyaWROYXZpZ2F0aW9uQ2VsbENvbnRleHQpO1xyXG4gICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQoKTtcclxuICAgIGNvbnN0IFt0ZXh0LCBzZXRUZXh0XSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBzZXRUZXh0KGVsZW1lbnQuaW5uZXJUZXh0KTtcclxuICAgIH0gfSwgW2VsZW1lbnRdKTtcclxuICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzIH0gPSB1c2VHcmlkTmF2aWdhdGlvbkNlbGwoeyBpbmRleCwgdGV4dCwgdmFsdWUsIGxpdGVyYWxWYWx1ZTogdmFsdWUsIHNldERpc3BsYXlWYWx1ZTogbm9vcCwgcHJvdmlkZVdpdGhTaWJsaW5nc1NldERpc3BsYXlWYWx1ZTogbm9vcCB9KTtcclxuICAgIGNvbnN0IGN1cnJlbnRTb3J0ZWRDb2x1bW4gPSB1c2VDb250ZXh0KEN1cnJlbnRTb3J0ZWRDb2x1bW5Db250ZXh0KTtcclxuICAgIGNvbnN0IHNldEN1cnJlbnRTb3J0ZWRDb2x1bW4gPSB1c2VDb250ZXh0KFNldEN1cnJlbnRTb3J0ZWRDb2x1bW5Db250ZXh0KTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRTb3J0ZWRDb2x1bW4gIT0gaW5kZXgpXHJcbiAgICAgICAgICAgIHNldFNvcnREaXJlY3Rpb24obnVsbCk7XHJcbiAgICB9LCBbY3VycmVudFNvcnRlZENvbHVtbiwgaW5kZXhdKTtcclxuICAgIGNvbnN0IG9uU29ydCA9IHVzZUNvbnRleHQoSW50ZXJuYWxTb3J0SGFuZGxlckNvbnRleHQpO1xyXG4gICAgY29uc3Qgb25Tb3J0Q2xpY2sgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgbGV0IG5leHRTb3J0RGlyZWN0aW9uID0gZ2V0U29ydERpcmVjdGlvbigpO1xyXG4gICAgICAgIGlmIChuZXh0U29ydERpcmVjdGlvbiA9PT0gXCJhc2NlbmRpbmdcIilcclxuICAgICAgICAgICAgbmV4dFNvcnREaXJlY3Rpb24gPSBcImRlc2NlbmRpbmdcIjtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIG5leHRTb3J0RGlyZWN0aW9uID0gXCJhc2NlbmRpbmdcIjtcclxuICAgICAgICBzZXRTb3J0RGlyZWN0aW9uKG5leHRTb3J0RGlyZWN0aW9uKTtcclxuICAgICAgICBvblNvcnQ/LihpbmRleCwgbmV4dFNvcnREaXJlY3Rpb24pO1xyXG4gICAgICAgIHNldEN1cnJlbnRTb3J0ZWRDb2x1bW4ocHJldiA9PiBpbmRleCk7XHJcbiAgICB9LCBbb25Tb3J0LCBpbmRleF0pO1xyXG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnMoXCJ0aFwiLCBvblNvcnRDbGljaywgdW5kZWZpbmVkKSh1c2VSZWZFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7XHJcbiAgICAgICAgcmVmLFxyXG4gICAgICAgIHJvbGU6IFwiY29sdW1uaGVhZGVyXCIsXHJcbiAgICAgICAgc2NvcGU6IChpc0luVEhlYWQgPyBcImNvbFwiIDogXCJyb3dcIiksXHJcbiAgICAgICAgY2xhc3NOYW1lOiBjbHN4KHZhcmlhbnQgJiYgYHRhYmxlLSR7dmFyaWFudH1gKVxyXG4gICAgfSwgcHJvcHMpKSk7XHJcbiAgICBjb25zdCBzb3J0SWNvbiA9IChoKFN3YXBwYWJsZSwgbnVsbCxcclxuICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3M6IGNsc3goXCJ0YWJsZS1zb3J0LWljb24tY29udGFpbmVyXCIsIGBzb3J0LWRpcmVjdGlvbi0ke3NvcnREaXJlY3Rpb24gPz8gXCJudWxsXCJ9YCkgfSxcclxuICAgICAgICAgICAgaChGYWRlLCB7IG9wZW46IHNvcnREaXJlY3Rpb24gPT0gbnVsbCB9LFxyXG4gICAgICAgICAgICAgICAgaChcImlcIiwgeyBjbGFzczogXCJiaSBiaS1zb3J0LWRvd24tYWx0IGhvdmVyLW9ubHlcIiB9KSksXHJcbiAgICAgICAgICAgIGgoRmFkZSwgeyBvcGVuOiBzb3J0RGlyZWN0aW9uID09IFwiZGVzY2VuZGluZ1wiIH0sXHJcbiAgICAgICAgICAgICAgICBoKFwiaVwiLCB7IGNsYXNzOiBcImJpIGJpLXNvcnQtdXAgbm8taG92ZXItb25seVwiIH0pKSxcclxuICAgICAgICAgICAgaChGYWRlLCB7IG9wZW46IHNvcnREaXJlY3Rpb24gPT0gXCJkZXNjZW5kaW5nXCIgfSxcclxuICAgICAgICAgICAgICAgIGgoXCJpXCIsIHsgY2xhc3M6IFwiYmkgYmktc29ydC1kb3duLWFsdCBob3Zlci1vbmx5XCIgfSkpLFxyXG4gICAgICAgICAgICBoKEZhZGUsIHsgb3Blbjogc29ydERpcmVjdGlvbiA9PSBcImFzY2VuZGluZ1wiIH0sXHJcbiAgICAgICAgICAgICAgICBoKFwiaVwiLCB7IGNsYXNzOiBcImJpIGJpLXNvcnQtZG93bi1hbHQgbm8taG92ZXItb25seVwiIH0pKSxcclxuICAgICAgICAgICAgaChGYWRlLCB7IG9wZW46IHNvcnREaXJlY3Rpb24gPT0gXCJhc2NlbmRpbmdcIiB9LFxyXG4gICAgICAgICAgICAgICAgaChcImlcIiwgeyBjbGFzczogXCJiaSBiaS1zb3J0LXVwIGhvdmVyLW9ubHlcIiB9KSkpKSk7XHJcbiAgICBpZiAoZm9jdXMgPT09IFwiY2hpbGRcIikge1xyXG4gICAgICAgIHJldHVybiBoKFwidGhcIiwgeyAuLi5jZWxsUHJvcHMgfSxcclxuICAgICAgICAgICAgaChcImRpdlwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgY2xvbmVFbGVtZW50KGNoaWxkcmVuLCB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyh7fSksIGNoaWxkcmVuLnByb3BzLmNoaWxkcmVuKSxcclxuICAgICAgICAgICAgICAgIHNvcnRJY29uKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gaChcInRoXCIsIHsgLi4udXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMoY2VsbFByb3BzKSB9LFxyXG4gICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA/PyBzdHJpbmdpZnkodmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgc29ydEljb24pKTtcclxuICAgIH1cclxufSk7XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGEgbG90IGJldHRlclxyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSlcclxuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgIHJldHVybiBgJHt2YWx1ZX1gO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmxlLmpzLm1hcCIsbnVsbF0sIm5hbWVzIjpbIl9fYXNzaWduIiwiT2JqZWN0IiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsInYiLCJvcCIsIlR5cGVFcnJvciIsInBvcCIsInB1c2giLCJFTVBUWV9PQkoiLCJFTVBUWV9BUlIiLCJJU19OT05fRElNRU5TSU9OQUwiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50Q29tcG9uZW50IiwicHJldlJhZiIsImN1cnJlbnRIb29rIiwiYWZ0ZXJQYWludEVmZmVjdHMiLCJvbGRCZWZvcmVEaWZmIiwib3B0aW9ucyIsIm9sZEJlZm9yZVJlbmRlciIsIm9sZEFmdGVyRGlmZiIsImRpZmZlZCIsIm9sZENvbW1pdCIsIm9sZEJlZm9yZVVubW91bnQiLCJ1bm1vdW50IiwiZ2V0SG9va1N0YXRlIiwiaW5kZXgiLCJ0eXBlIiwiaG9va3MiLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInVzZVJlZHVjZXIiLCJpbnZva2VPclJldHVybiIsInJlZHVjZXIiLCJpbml0IiwiaG9va1N0YXRlIiwiX3JlZHVjZXIiLCJ1bmRlZmluZWQiLCJuZXh0VmFsdWUiLCJhY3Rpb24iLCJzZXRTdGF0ZSIsInVzZUVmZmVjdCIsImNhbGxiYWNrIiwiYXJncyIsInN0YXRlIiwiYXJnc0NoYW5nZWQiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCJpbml0aWFsVmFsdWUiLCJ1c2VNZW1vIiwiY3VycmVudCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJyZWYiLCJjcmVhdGVIYW5kbGUiLCJjb25jYXQiLCJmYWN0b3J5IiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwiY29udGV4dCIsInByb3ZpZGVyIiwic3ViIiwicHJvcHMiLCJmbHVzaEFmdGVyUGFpbnRFZmZlY3RzIiwiZm9yRWFjaCIsImNvbXBvbmVudCIsImludm9rZUNsZWFudXAiLCJpbnZva2VFZmZlY3QiLCJ2bm9kZSIsImMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyYWYiLCJjbGVhclRpbWVvdXQiLCJ0aW1lb3V0IiwiSEFTX1JBRiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsInByZXZpb3VzQ29tcG9uZW50IiwiY29tbWl0UXVldWUiLCJzb21lIiwiZmlsdGVyIiwiY2IiLCJob29rIiwiY29tcCIsIm9sZEFyZ3MiLCJuZXdBcmdzIiwiYXJnIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwidG9WYWwiLCJtaXgiLCJrIiwic3RyIiwiQXJyYXkiLCJpc0FycmF5IiwidG1wIiwieCIsInVzZVN0YXRlUCIsInVzZUxheW91dEVmZmVjdE5hdGl2ZSIsInVzZUVmZmVjdE5hdGl2ZSIsIlRhYmxlIiwiY2FuZGlkYXRlU2VsZWN0b3JzIiwibWF0Y2hlcyIsIkVsZW1lbnQiLCJpc0lucHV0Iiwibm9kZSIsImlzSGlkZGVuSW5wdXQiLCJpc0RldGFpbHNXaXRoU3VtbWFyeSIsInIiLCJjaGlsZCIsImlzSGlkZGVuIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzRGlyZWN0U3VtbWFyeSIsIm5vZGVVbmRlckRldGFpbHMiLCJkaXNwbGF5Q2hlY2siLCJ3aWR0aCIsImhlaWdodCIsImlzRGlzYWJsZWRGcm9tRmllbGRzZXQiLCJwYXJlbnROb2RlIiwiaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSIsImZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yIiwiaXNGb2N1c2FibGUiLCJnbG9iYWwiLCJ0aGlzIiwiX2NyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJ3aW5kb3ciLCJzbGljZSIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nIiwiam9pbiIsIkluZXJ0Um9vdCIsInJvb3RFbGVtZW50IiwiaW5lcnRNYW5hZ2VyIiwiX2luZXJ0TWFuYWdlciIsIl9yb290RWxlbWVudCIsIl9tYW5hZ2VkTm9kZXMiLCJTZXQiLCJoYXNBdHRyaWJ1dGUiLCJfc2F2ZWRBcmlhSGlkZGVuIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUiLCJfb2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiX29uTXV0YXRpb24iLCJiaW5kIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiZGVzdHJ1Y3RvciIsImRpc2Nvbm5lY3QiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpbmVydE5vZGUiLCJfdW5tYW5hZ2VOb2RlIiwic3RhcnROb2RlIiwiX3RoaXMyIiwiY29tcG9zZWRUcmVlV2FsayIsIl92aXNpdE5vZGUiLCJhY3RpdmVFbGVtZW50IiwiZG9jdW1lbnQiLCJjb250YWlucyIsInJvb3QiLCJub2RlVHlwZSIsIk5vZGUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiYmx1ciIsImZvY3VzIiwiRUxFTUVOVF9OT0RFIiwiZWxlbWVudCIsIl9hZG9wdEluZXJ0Um9vdCIsIl9tYW5hZ2VOb2RlIiwicmVnaXN0ZXIiLCJhZGQiLCJkZXJlZ2lzdGVyIiwiX3VubWFuYWdlU3VidHJlZSIsIl90aGlzMyIsImluZXJ0U3Vicm9vdCIsImdldEluZXJ0Um9vdCIsInNldEluZXJ0IiwibWFuYWdlZE5vZGVzIiwic2F2ZWRJbmVydE5vZGUiLCJyZWNvcmRzIiwic2VsZiIsInJlY29yZCIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJhdHRyaWJ1dGVOYW1lIiwibWFuYWdlZE5vZGUiLCJnZXQiLCJzZXQiLCJhcmlhSGlkZGVuIiwiSW5lcnROb2RlIiwiaW5lcnRSb290IiwiX25vZGUiLCJfb3ZlcnJvZGVGb2N1c01ldGhvZCIsIl9pbmVydFJvb3RzIiwiX3NhdmVkVGFiSW5kZXgiLCJfZGVzdHJveWVkIiwiZW5zdXJlVW50YWJiYWJsZSIsIl90aHJvd0lmRGVzdHJveWVkIiwiZGVzdHJveWVkIiwiRXJyb3IiLCJ0YWJJbmRleCIsImhhc1NhdmVkVGFiSW5kZXgiLCJhZGRJbmVydFJvb3QiLCJyZW1vdmVJbmVydFJvb3QiLCJzaXplIiwiSW5lcnRNYW5hZ2VyIiwiX2RvY3VtZW50IiwiTWFwIiwiX3dhdGNoRm9ySW5lcnQiLCJhZGRJbmVydFN0eWxlIiwiaGVhZCIsImRvY3VtZW50RWxlbWVudCIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiX29uRG9jdW1lbnRMb2FkZWQiLCJpbmVydCIsImhhcyIsInBhcmVudCIsIl9pbmVydFJvb3QiLCJpbmVydEVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImluZXJ0RWxlbWVudCIsIl90aGlzIiwidW5zaGlmdCIsInNoYWRvd1Jvb3RBbmNlc3RvciIsInNoYWRvd1Jvb3QiLCJsb2NhbE5hbWUiLCJjb250ZW50IiwiZGlzdHJpYnV0ZWROb2RlcyIsImdldERpc3RyaWJ1dGVkTm9kZXMiLCJzbG90IiwiX2Rpc3RyaWJ1dGVkTm9kZXMiLCJhc3NpZ25lZE5vZGVzIiwiZmxhdHRlbiIsIl9pIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicXVlcnlTZWxlY3RvciIsInN0eWxlIiwidGV4dENvbnRlbnQiLCJhcHBlbmRDaGlsZCIsIm9iaiIsInNoYWxsb3dEaWZmZXJzIiwiYSIsImIiLCJmb3J3YXJkRWxlbWVudFJlZiIsImZvcndhcmRSZWYiLCJjbG9uZUVsZW1lbnQiLCJoIiwiY3JlYXRlQ29udGV4dCIsIm1lbW8iLCJjcmVhdGVQb3J0YWwiLCJPcHRpb25hbGx5SW5wdXRHcm91cCIsInRvcCIsImJvdHRvbSIsInJpZ2h0IiwibGVmdCIsImF1dG8iLCJiYXNlUGxhY2VtZW50cyIsInN0YXJ0IiwiZW5kIiwiY2xpcHBpbmdQYXJlbnRzIiwidmlld3BvcnQiLCJwb3BwZXIiLCJyZWZlcmVuY2UiLCJ2YXJpYXRpb25QbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwicGxhY2VtZW50IiwicGxhY2VtZW50cyIsImJlZm9yZVJlYWQiLCJyZWFkIiwiYWZ0ZXJSZWFkIiwiYmVmb3JlTWFpbiIsIm1haW4iLCJhZnRlck1haW4iLCJiZWZvcmVXcml0ZSIsIndyaXRlIiwiYWZ0ZXJXcml0ZSIsIm1vZGlmaWVyUGhhc2VzIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0V2luZG93IiwidG9TdHJpbmciLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0VsZW1lbnQiLCJPd25FbGVtZW50IiwiaXNIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNTaGFkb3dSb290IiwiU2hhZG93Um9vdCIsImFwcGx5U3R5bGVzIiwiX3JlZiIsImtleXMiLCJlbGVtZW50cyIsIm5hbWUiLCJzdHlsZXMiLCJlZmZlY3QiLCJfcmVmMiIsImluaXRpYWxTdHlsZXMiLCJwb3NpdGlvbiIsInN0cmF0ZWd5IiwibWFyZ2luIiwiYXJyb3ciLCJzdHlsZVByb3BlcnRpZXMiLCJwcm9wZXJ0eSIsImF0dHJpYnV0ZSIsImVuYWJsZWQiLCJwaGFzZSIsImZuIiwicmVxdWlyZXMiLCJnZXRCYXNlUGxhY2VtZW50Iiwic3BsaXQiLCJyb3VuZCIsIk1hdGgiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpbmNsdWRlU2NhbGUiLCJyZWN0Iiwic2NhbGVYIiwic2NhbGVZIiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJnZXRMYXlvdXRSZWN0IiwiY2xpZW50UmVjdCIsImFicyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJyb290Tm9kZSIsImdldFJvb3ROb2RlIiwiaXNTYW1lTm9kZSIsImhvc3QiLCJpc1RhYmxlRWxlbWVudCIsImdldERvY3VtZW50RWxlbWVudCIsImdldFBhcmVudE5vZGUiLCJhc3NpZ25lZFNsb3QiLCJnZXRUcnVlT2Zmc2V0UGFyZW50Iiwib2Zmc2V0UGFyZW50IiwiZ2V0Q29udGFpbmluZ0Jsb2NrIiwiaXNGaXJlZm94IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJRSIsImVsZW1lbnRDc3MiLCJjdXJyZW50Tm9kZSIsImNzcyIsInRyYW5zZm9ybSIsInBlcnNwZWN0aXZlIiwiY29udGFpbiIsIndpbGxDaGFuZ2UiLCJnZXRPZmZzZXRQYXJlbnQiLCJnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQiLCJtYXgiLCJtaW4iLCJ3aXRoaW4iLCJtYXRoTWF4IiwibWF0aE1pbiIsImdldEZyZXNoU2lkZU9iamVjdCIsIm1lcmdlUGFkZGluZ09iamVjdCIsInBhZGRpbmdPYmplY3QiLCJleHBhbmRUb0hhc2hNYXAiLCJoYXNoTWFwIiwidG9QYWRkaW5nT2JqZWN0IiwicGFkZGluZyIsInJlY3RzIiwiX3N0YXRlJG1vZGlmaWVyc0RhdGEkIiwiYXJyb3dFbGVtZW50IiwicG9wcGVyT2Zmc2V0cyIsIm1vZGlmaWVyc0RhdGEiLCJiYXNlUGxhY2VtZW50IiwiYXhpcyIsImlzVmVydGljYWwiLCJsZW4iLCJhcnJvd1JlY3QiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImVuZERpZmYiLCJzdGFydERpZmYiLCJhcnJvd09mZnNldFBhcmVudCIsImNsaWVudFNpemUiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsImNlbnRlclRvUmVmZXJlbmNlIiwiY2VudGVyIiwib2Zmc2V0IiwiYXhpc1Byb3AiLCJjZW50ZXJPZmZzZXQiLCJfb3B0aW9ucyRlbGVtZW50IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsImVycm9yIiwicmVxdWlyZXNJZkV4aXN0cyIsImdldFZhcmlhdGlvbiIsInVuc2V0U2lkZXMiLCJyb3VuZE9mZnNldHNCeURQUiIsIndpbiIsImRwciIsImRldmljZVBpeGVsUmF0aW8iLCJtYXBUb1N0eWxlcyIsIl9PYmplY3QkYXNzaWduMiIsInBvcHBlclJlY3QiLCJ2YXJpYXRpb24iLCJvZmZzZXRzIiwiZ3B1QWNjZWxlcmF0aW9uIiwiYWRhcHRpdmUiLCJyb3VuZE9mZnNldHMiLCJfcmVmMyIsIl9yZWYzJHgiLCJfcmVmMyR5IiwiaGFzWCIsImhhc1kiLCJzaWRlWCIsInNpZGVZIiwiaGVpZ2h0UHJvcCIsIndpZHRoUHJvcCIsImNvbW1vblN0eWxlcyIsIl9PYmplY3QkYXNzaWduIiwiY29tcHV0ZVN0eWxlcyIsIl9yZWY0IiwiX29wdGlvbnMkZ3B1QWNjZWxlcmF0IiwiX29wdGlvbnMkYWRhcHRpdmUiLCJfb3B0aW9ucyRyb3VuZE9mZnNldHMiLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJ3YXJuIiwiZGF0YSIsInBhc3NpdmUiLCJfb3B0aW9ucyRzY3JvbGwiLCJzY3JvbGwiLCJfb3B0aW9ucyRyZXNpemUiLCJyZXNpemUiLCJzY3JvbGxQYXJlbnRzIiwic2Nyb2xsUGFyZW50IiwidXBkYXRlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhc2giLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsInJlcGxhY2UiLCJtYXRjaGVkIiwiZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQiLCJnZXRXaW5kb3dTY3JvbGwiLCJzY3JvbGxMZWZ0IiwicGFnZVhPZmZzZXQiLCJzY3JvbGxUb3AiLCJwYWdlWU9mZnNldCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJnZXRWaWV3cG9ydFJlY3QiLCJodG1sIiwidmlzdWFsVmlld3BvcnQiLCJ0ZXN0IiwiZ2V0RG9jdW1lbnRSZWN0IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwid2luU2Nyb2xsIiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJkaXJlY3Rpb24iLCJpc1Njcm9sbFBhcmVudCIsIl9nZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJnZXRTY3JvbGxQYXJlbnQiLCJsaXN0U2Nyb2xsUGFyZW50cyIsImxpc3QiLCJpc0JvZHkiLCJ1cGRhdGVkTGlzdCIsInJlY3RUb0NsaWVudFJlY3QiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFRvcCIsImNsaWVudExlZnQiLCJnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZSIsImNsaXBwaW5nUGFyZW50IiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2FuRXNjYXBlQ2xpcHBpbmciLCJjbGlwcGVyRWxlbWVudCIsImdldENsaXBwaW5nUmVjdCIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwibWFpbkNsaXBwaW5nUGFyZW50cyIsImZpcnN0Q2xpcHBpbmdQYXJlbnQiLCJjbGlwcGluZ1JlY3QiLCJhY2NSZWN0IiwiY29tcHV0ZU9mZnNldHMiLCJjb21tb25YIiwiY29tbW9uWSIsIm1haW5BeGlzIiwiZGV0ZWN0T3ZlcmZsb3ciLCJfb3B0aW9ucyIsIl9vcHRpb25zJHBsYWNlbWVudCIsIl9vcHRpb25zJGJvdW5kYXJ5IiwiX29wdGlvbnMkcm9vdEJvdW5kYXJ5IiwiX29wdGlvbnMkZWxlbWVudENvbnRlIiwiZWxlbWVudENvbnRleHQiLCJfb3B0aW9ucyRhbHRCb3VuZGFyeSIsImFsdEJvdW5kYXJ5IiwiX29wdGlvbnMkcGFkZGluZyIsImFsdENvbnRleHQiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJjb250ZXh0RWxlbWVudCIsInJlZmVyZW5jZUNsaWVudFJlY3QiLCJwb3BwZXJDbGllbnRSZWN0IiwiZWxlbWVudENsaWVudFJlY3QiLCJvdmVyZmxvd09mZnNldHMiLCJvZmZzZXREYXRhIiwibXVsdGlwbHkiLCJjb21wdXRlQXV0b1BsYWNlbWVudCIsImZsaXBWYXJpYXRpb25zIiwiX29wdGlvbnMkYWxsb3dlZEF1dG9QIiwiYWxsb3dlZEF1dG9QbGFjZW1lbnRzIiwiYWxsUGxhY2VtZW50cyIsImFsbG93ZWRQbGFjZW1lbnRzIiwib3ZlcmZsb3dzIiwic29ydCIsImdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJmbGlwIiwiX3NraXAiLCJfb3B0aW9ucyRtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJfb3B0aW9ucyRhbHRBeGlzIiwiYWx0QXhpcyIsImNoZWNrQWx0QXhpcyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrUGxhY2VtZW50cyIsIl9vcHRpb25zJGZsaXBWYXJpYXRpbyIsInByZWZlcnJlZFBsYWNlbWVudCIsImlzQmFzZVBsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJfYmFzZVBsYWNlbWVudCIsImlzU3RhcnRWYXJpYXRpb24iLCJtYWluVmFyaWF0aW9uU2lkZSIsImFsdFZhcmlhdGlvblNpZGUiLCJjaGVja3MiLCJldmVyeSIsImNoZWNrIiwibnVtYmVyT2ZDaGVja3MiLCJfbG9vcCIsImZpdHRpbmdQbGFjZW1lbnQiLCJmaW5kIiwiX3JldCIsInJlc2V0IiwiZ2V0U2lkZU9mZnNldHMiLCJwcmV2ZW50ZWRPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic2lkZSIsImhpZGUiLCJwcmV2ZW50T3ZlcmZsb3ciLCJyZWZlcmVuY2VPdmVyZmxvdyIsInBvcHBlckFsdE92ZXJmbG93IiwicmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzIiwicG9wcGVyRXNjYXBlT2Zmc2V0cyIsImlzUmVmZXJlbmNlSGlkZGVuIiwiaGFzUG9wcGVyRXNjYXBlZCIsImRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZIiwiaW52ZXJ0RGlzdGFuY2UiLCJza2lkZGluZyIsImRpc3RhbmNlIiwiX29wdGlvbnMkb2Zmc2V0IiwiX2RhdGEkc3RhdGUkcGxhY2VtZW50IiwiZ2V0QWx0QXhpcyIsIl9vcHRpb25zJHRldGhlciIsInRldGhlciIsIl9vcHRpb25zJHRldGhlck9mZnNldCIsInRldGhlck9mZnNldCIsInRldGhlck9mZnNldFZhbHVlIiwibWFpblNpZGUiLCJhbHRTaWRlIiwiYWRkaXRpdmUiLCJtaW5MZW4iLCJtYXhMZW4iLCJhcnJvd1BhZGRpbmdPYmplY3QiLCJhcnJvd1BhZGRpbmdNaW4iLCJhcnJvd1BhZGRpbmdNYXgiLCJhcnJvd0xlbiIsIm1pbk9mZnNldCIsIm1heE9mZnNldCIsImNsaWVudE9mZnNldCIsIm9mZnNldE1vZGlmaWVyVmFsdWUiLCJ0ZXRoZXJNaW4iLCJ0ZXRoZXJNYXgiLCJwcmV2ZW50ZWRPZmZzZXQiLCJfbWFpblNpZGUiLCJfYWx0U2lkZSIsIl9vZmZzZXQiLCJfbWluIiwiX21heCIsIl9wcmV2ZW50ZWRPZmZzZXQiLCJnZXRIVE1MRWxlbWVudFNjcm9sbCIsImdldE5vZGVTY3JvbGwiLCJpc0VsZW1lbnRTY2FsZWQiLCJnZXRDb21wb3NpdGVSZWN0IiwiZWxlbWVudE9yVmlydHVhbEVsZW1lbnQiLCJpc0ZpeGVkIiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsIm9yZGVyIiwibW9kaWZpZXJzIiwibWFwIiwidmlzaXRlZCIsIm1vZGlmaWVyIiwiZGVwIiwiZGVwTW9kaWZpZXIiLCJvcmRlck1vZGlmaWVycyIsIm9yZGVyZWRNb2RpZmllcnMiLCJkZWJvdW5jZSIsInBlbmRpbmciLCJmb3JtYXQiLCJfbGVuIiwiX2tleSIsIklOVkFMSURfTU9ESUZJRVJfRVJST1IiLCJNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IiLCJWQUxJRF9QUk9QRVJUSUVTIiwidmFsaWRhdGVNb2RpZmllcnMiLCJTdHJpbmciLCJyZXF1aXJlbWVudCIsIm1vZCIsInVuaXF1ZUJ5IiwiYXJyIiwiaWRlbnRpZmllcnMiLCJpdGVtIiwiaWRlbnRpZmllciIsIm1lcmdlQnlOYW1lIiwibWVyZ2VkIiwiZXhpc3RpbmciLCJJTlZBTElEX0VMRU1FTlRfRVJST1IiLCJJTkZJTklURV9MT09QX0VSUk9SIiwiREVGQVVMVF9PUFRJT05TIiwiYXJlVmFsaWRFbGVtZW50cyIsInBvcHBlckdlbmVyYXRvciIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGVQb3BwZXIiLCJlZmZlY3RDbGVhbnVwRm5zIiwiaXNEZXN0cm95ZWQiLCJzZXRPcHRpb25zIiwic2V0T3B0aW9uc0FjdGlvbiIsImNsZWFudXBNb2RpZmllckVmZmVjdHMiLCJtIiwiZmxpcE1vZGlmaWVyIiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXJnaW5MZWZ0IiwicGFyc2VGbG9hdCIsInJ1bk1vZGlmaWVyRWZmZWN0cyIsImZvcmNlVXBkYXRlIiwiX3N0YXRlJGVsZW1lbnRzIiwiX19kZWJ1Z19sb29wc19fIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllMiIsImRlc3Ryb3kiLCJvbkZpcnN0VXBkYXRlIiwiX3JlZjMkb3B0aW9ucyIsImNsZWFudXBGbiIsIm5vb3BGbiIsImV2ZW50TGlzdGVuZXJzIiwic2xlZXAiLCJyZW5kZXIiXSwibWFwcGluZ3MiOiI7OztJQUFBO0lBQ0E7QUFDQTtJQUNBO0lBQ0E7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFrQk8sSUFBSUEsUUFBUSxHQUFHLFlBQVc7SUFDN0JBLEVBQUFBLFFBQVEsR0FBR0MsTUFBTSxDQUFDQyxNQUFQLElBQWlCLFNBQVNGLFFBQVQsQ0FBa0JHLENBQWxCLEVBQXFCO0lBQzdDLFNBQUssSUFBSUMsQ0FBSixFQUFPQyxDQUFDLEdBQUcsQ0FBWCxFQUFjQyxDQUFDLEdBQUdDLFNBQVMsQ0FBQ0MsTUFBakMsRUFBeUNILENBQUMsR0FBR0MsQ0FBN0MsRUFBZ0RELENBQUMsRUFBakQsRUFBcUQ7SUFDakRELE1BQUFBLENBQUMsR0FBR0csU0FBUyxDQUFDRixDQUFELENB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
