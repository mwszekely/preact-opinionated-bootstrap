(function () {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

      return __assign.apply(this, arguments);
    };
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }

      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator(thisArg, body) {
      var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) {
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];

            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;

              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };

              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;

              case 7:
                op = _.ops.pop();

                _.trys.pop();

                continue;

              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }

                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }

                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }

                if (t && _.label < t[2]) {
                  _.label = t[2];

                  _.ops.push(op);

                  break;
                }

                if (t[2]) _.ops.pop();

                _.trys.pop();

                continue;
            }

            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    }

    var n,
        l$1,
        u$1,
        t$1,
        o$1,
        r$1,
        f$1,
        e$1 = {},
        c$1 = [],
        s$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function a$1(n, l) {
      for (var u in l) {
        n[u] = l[u];
      }

      return n;
    }

    function h$1(n) {
      var l = n.parentNode;
      l && l.removeChild(n);
    }

    function v$1(l, u, i) {
      var t,
          o,
          r,
          f = {};

      for (r in u) {
        "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
      }

      if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) {
        void 0 === f[r] && (f[r] = l.defaultProps[r]);
      }
      return y$1(l, f, t, o, null);
    }

    function y$1(n, i, t, o, r) {
      var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u$1 : r
      };
      return null != l$1.vnode && l$1.vnode(f), f;
    }

    function d$1(n) {
      return n.children;
    }

    function _$1(n, l) {
      this.props = n, this.context = l;
    }

    function k$1(n, l) {
      if (null == l) return n.__ ? k$1(n.__, n.__.__k.indexOf(n) + 1) : null;

      for (var u; l < n.__k.length; l++) {
        if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
      }

      return "function" == typeof n.type ? k$1(n) : null;
    }

    function b$1(n) {
      var l, u;

      if (null != (n = n.__) && null != n.__c) {
        for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {
          if (null != (u = n.__k[l]) && null != u.__e) {
            n.__e = n.__c.base = u.__e;
            break;
          }
        }

        return b$1(n);
      }
    }

    function m$1(n) {
      (!n.__d && (n.__d = !0) && t$1.push(n) && !g$2.__r++ || r$1 !== l$1.debounceRendering) && ((r$1 = l$1.debounceRendering) || o$1)(g$2);
    }

    function g$2() {
      for (var n; g$2.__r = t$1.length;) {
        n = t$1.sort(function (n, l) {
          return n.__v.__b - l.__v.__b;
        }), t$1 = [], n.some(function (n) {
          var l, u, i, t, o, r;
          n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = a$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? k$1(t) : o, t.__h), z(u, t), t.__e != o && b$1(t)));
        });
      }
    }

    function w$2(n, l, u, i, t, o, r, f, s, a) {
      var h,
          v,
          p,
          _,
          b,
          m,
          g,
          w = i && i.__k || c$1,
          A = w.length;

      for (u.__k = [], h = 0; h < l.length; h++) {
        if (null != (_ = u.__k[h] = null == (_ = l[h]) || "boolean" == typeof _ ? null : "string" == typeof _ || "number" == typeof _ || "bigint" == typeof _ ? y$1(null, _, null, null, _) : Array.isArray(_) ? y$1(d$1, {
          children: _
        }, null, null, null) : _.__b > 0 ? y$1(_.type, _.props, _.key, null, _.__v) : _)) {
          if (_.__ = u, _.__b = u.__b + 1, null === (p = w[h]) || p && _.key == p.key && _.type === p.type) w[h] = void 0;else for (v = 0; v < A; v++) {
            if ((p = w[v]) && _.key == p.key && _.type === p.type) {
              w[v] = void 0;
              break;
            }

            p = null;
          }
          j$2(n, _, p = p || e$1, t, o, r, f, s, a), b = _.__e, (v = _.ref) && p.ref != v && (g || (g = []), p.ref && g.push(p.ref, null, _), g.push(v, _.__c || b, _)), null != b ? (null == m && (m = b), "function" == typeof _.type && null != _.__k && _.__k === p.__k ? _.__d = s = x$2(_, s, n) : s = P$1(n, _, p, w, b, s), a || "option" !== u.type ? "function" == typeof u.type && (u.__d = s) : n.value = "") : s && p.__e == s && s.parentNode != n && (s = k$1(p));
        }
      }

      for (u.__e = m, h = A; h--;) {
        null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = k$1(i, h + 1)), N(w[h], w[h]));
      }

      if (g) for (h = 0; h < g.length; h++) {
        M$1(g[h], g[++h], g[++h]);
      }
    }

    function x$2(n, l, u) {
      var i, t;

      for (i = 0; i < n.__k.length; i++) {
        (t = n.__k[i]) && (t.__ = n, l = "function" == typeof t.type ? x$2(t, l, u) : P$1(u, t, t, n.__k, t.__e, l));
      }

      return l;
    }

    function A$2(n, l) {
      return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
        A$2(n, l);
      }) : l.push(n)), l;
    }

    function P$1(n, l, u, i, t, o) {
      var r, f, e;
      if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
        for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) {
          if (f == t) break n;
        }

        n.insertBefore(t, o), r = o;
      }
      return void 0 !== r ? r : t.nextSibling;
    }

    function C$1(n, l, u, i, t) {
      var o;

      for (o in u) {
        "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);
      }

      for (o in l) {
        t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
      }
    }

    function $$1(n, l, u) {
      "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || s$1.test(l) ? u : u + "px";
    }

    function H$1(n, l, u, i, t) {
      var o;

      n: if ("style" === l) {
        if ("string" == typeof u) n.style.cssText = u;else {
          if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) {
            u && l in u || $$1(n.style, l, "");
          }
          if (u) for (l in u) {
            i && u[l] === i[l] || $$1(n.style, l, u[l]);
          }
        }
      } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$1 : I$1, o) : n.removeEventListener(l, o ? T$1 : I$1, o);else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
          n[l] = null == u ? "" : u;
          break n;
        } catch (n) {}
        "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
      }
    }

    function I$1(n) {
      this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
    }

    function T$1(n) {
      this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
    }

    function j$2(n, u, i, t, o, r, f, e, c) {
      var s,
          h,
          v,
          y,
          p,
          k,
          b,
          m,
          g,
          x,
          A,
          P = u.type;
      if (void 0 !== u.constructor) return null;
      null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (s = l$1.__b) && s(u);

      try {
        n: if ("function" == typeof P) {
          if (m = u.props, g = (s = P.contextType) && t[s.__c], x = s ? g ? g.props.value : s.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in P && P.prototype.render ? u.__c = h = new P(m, x) : (u.__c = h = new _$1(m, x), h.constructor = P, h.render = O$1), g && g.sub(h), h.props = m, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != P.getDerivedStateFromProps && (h.__s == h.state && (h.__s = a$1({}, h.__s)), a$1(h.__s, P.getDerivedStateFromProps(m, h.__s))), y = h.props, p = h.state, v) null == P.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
            if (null == P.getDerivedStateFromProps && m !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(m, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(m, h.__s, x) || u.__v === i.__v) {
              h.props = m, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
                n && (n.__ = u);
              }), h.__h.length && f.push(h);
              break n;
            }

            null != h.componentWillUpdate && h.componentWillUpdate(m, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
              h.componentDidUpdate(y, p, k);
            });
          }
          h.context = x, h.props = m, h.state = h.__s, (s = l$1.__r) && s(u), h.__d = !1, h.__v = u, h.__P = n, s = h.render(h.props, h.state, h.context), h.state = h.__s, null != h.getChildContext && (t = a$1(a$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, p)), A = null != s && s.type === d$1 && null == s.key ? s.props.children : s, w$2(n, Array.isArray(A) ? A : [A], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);

        (s = l$1.diffed) && s(u);
      } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
      }
    }

    function z(n, u) {
      l$1.__c && l$1.__c(u, n), n.some(function (u) {
        try {
          n = u.__h, u.__h = [], n.some(function (n) {
            n.call(u);
          });
        } catch (n) {
          l$1.__e(n, u.__v);
        }
      });
    }

    function L$1(l, u, i, t, o, r, f, c) {
      var s,
          a,
          v,
          y = i.props,
          p = u.props,
          d = u.type,
          _ = 0;
      if ("svg" === d && (o = !0), null != r) for (; _ < r.length; _++) {
        if ((s = r[_]) && (s === l || (d ? s.localName == d : 3 == s.nodeType))) {
          l = s, r[_] = null;
          break;
        }
      }

      if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
      }

      if (null === d) y === p || c && l.data === p || (l.data = p);else {
        if (r = r && n.call(l.childNodes), a = (y = i.props || e$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
          if (null != r) for (y = {}, _ = 0; _ < l.attributes.length; _++) {
            y[l.attributes[_].name] = l.attributes[_].value;
          }
          (v || a) && (v && (a && v.__html == a.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }

        if (C$1(l, p, y, o, c), v) u.__k = [];else if (_ = u.props.children, w$2(l, Array.isArray(_) ? _ : [_], u, i, t, o && "foreignObject" !== d, r, f, r ? r[0] : i.__k && k$1(i, 0), c), null != r) for (_ = r.length; _--;) {
          null != r[_] && h$1(r[_]);
        }
        c || ("value" in p && void 0 !== (_ = p.value) && (_ !== l.value || "progress" === d && !_) && H$1(l, "value", _, y.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && H$1(l, "checked", _, y.checked, !1));
      }
      return l;
    }

    function M$1(n, u, i) {
      try {
        "function" == typeof n ? n(u) : n.current = u;
      } catch (n) {
        l$1.__e(n, i);
      }
    }

    function N(n, u, i) {
      var t, o;

      if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$1(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
          t.componentWillUnmount();
        } catch (n) {
          l$1.__e(n, u);
        }
        t.base = t.__P = null;
      }

      if (t = n.__k) for (o = 0; o < t.length; o++) {
        t[o] && N(t[o], u, "function" != typeof n.type);
      }
      i || null == n.__e || h$1(n.__e), n.__e = n.__d = void 0;
    }

    function O$1(n, l, u) {
      return this.constructor(n, u);
    }

    function S$1(u, i, t) {
      var o, r, f;
      l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, f = [], j$2(i, u = (!o && t || i).__k = v$1(d$1, null, [u]), r || e$1, e$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, f, !o && t ? t : r ? r.__e : i.firstChild, o), z(f, u);
    }

    function B(l, u, i) {
      var t,
          o,
          r,
          f = a$1({}, l.props);

      for (r in u) {
        "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
      }

      return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), y$1(l.type, f, t || l.key, o || l.ref, null);
    }

    function D$1(n, l) {
      var u = {
        __c: l = "__cC" + f$1++,
        __: n,
        Consumer: function (n, l) {
          return n.children(l);
        },
        Provider: function (n) {
          var u, i;
          return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
            return i;
          }, this.shouldComponentUpdate = function (n) {
            this.props.value !== n.value && u.some(m$1);
          }, this.sub = function (n) {
            u.push(n);
            var l = n.componentWillUnmount;

            n.componentWillUnmount = function () {
              u.splice(u.indexOf(n), 1), l && l.call(n);
            };
          }), n.children;
        }
      };
      return u.Provider.__ = u.Consumer.contextType = u;
    }

    n = c$1.slice, l$1 = {
      __e: function (n, l) {
        for (var u, i, t; l = l.__;) {
          if ((u = l.__c) && !u.__) try {
            if ((i = u.constructor) && null != i.getDerivedStateFromError && (u.setState(i.getDerivedStateFromError(n)), t = u.__d), null != u.componentDidCatch && (u.componentDidCatch(n), t = u.__d), t) return u.__E = u;
          } catch (l) {
            n = l;
          }
        }

        throw n;
      }
    }, u$1 = 0, _$1.prototype.setState = function (n, l) {
      var u;
      u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a$1({}, this.state), "function" == typeof n && (n = n(a$1({}, u), this.props)), n && a$1(u, n), null != n && this.__v && (l && this.__h.push(l), m$1(this));
    }, _$1.prototype.forceUpdate = function (n) {
      this.__v && (this.__e = !0, n && this.__h.push(n), m$1(this));
    }, _$1.prototype.render = d$1, t$1 = [], o$1 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g$2.__r = 0, f$1 = 0;

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);

        if (enumerableOnly) {
          symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }

        keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }

      return target;
    }

    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }

      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }

    function _asyncToGenerator(fn) {
      return function () {
        var self = this,
            args = arguments;
        return new Promise(function (resolve, reject) {
          var gen = fn.apply(self, args);

          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }

          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }

          _next(undefined);
        });
      };
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};

      var target = _objectWithoutPropertiesLoose(source, excluded);

      var key, i;

      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }

      return target;
    }

    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];

      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }

      return (hint === "string" ? String : Number)(input);
    }

    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");

      return typeof key === "symbol" ? key : String(key);
    }

    var t,
        u,
        r,
        o = 0,
        i = [],
        c = l$1.__b,
        f = l$1.__r,
        e = l$1.diffed,
        a = l$1.__c,
        v = l$1.unmount;

    function m(t, r) {
      l$1.__h && l$1.__h(u, t, o || r), o = 0;
      var i = u.__H || (u.__H = {
        __: [],
        __h: []
      });
      return t >= i.__.length && i.__.push({}), i.__[t];
    }

    function l(n) {
      return o = 1, p(w$1, n);
    }

    function p(n, r, o) {
      var i = m(t++, 2);
      return i.t = n, i.__c || (i.__ = [o ? o(r) : w$1(void 0, r), function (n) {
        var t = i.t(i.__[0], n);
        i.__[0] !== t && (i.__ = [t, i.__[1]], i.__c.setState({}));
      }], i.__c = u), i.__;
    }

    function y(r, o) {
      var i = m(t++, 3);
      !l$1.__s && k(i.__H, o) && (i.__ = r, i.__H = o, u.__H.__h.push(i));
    }

    function h(r, o) {
      var i = m(t++, 4);
      !l$1.__s && k(i.__H, o) && (i.__ = r, i.__H = o, u.__h.push(i));
    }

    function s(n) {
      return o = 5, d(function () {
        return {
          current: n
        };
      }, []);
    }

    function _(n, t, u) {
      o = 6, h(function () {
        "function" == typeof n ? n(t()) : n && (n.current = t());
      }, null == u ? u : u.concat(n));
    }

    function d(n, u) {
      var r = m(t++, 7);
      return k(r.__H, u) && (r.__ = n(), r.__H = u, r.__h = n), r.__;
    }

    function A$1(n, t) {
      return o = 8, d(function () {
        return n;
      }, t);
    }

    function F(n) {
      var r = u.context[n.__c],
          o = m(t++, 9);
      return o.c = n, r ? (null == o.__ && (o.__ = !0, r.sub(u)), r.props.value) : n.__;
    }

    function x$1() {
      i.forEach(function (t) {
        if (t.__P) try {
          t.__H.__h.forEach(g$1), t.__H.__h.forEach(j$1), t.__H.__h = [];
        } catch (u) {
          t.__H.__h = [], l$1.__e(u, t.__v);
        }
      }), i = [];
    }

    l$1.__b = function (n) {
      u = null, c && c(n);
    }, l$1.__r = function (n) {
      f && f(n), t = 0;
      var r = (u = n.__c).__H;
      r && (r.__h.forEach(g$1), r.__h.forEach(j$1), r.__h = []);
    }, l$1.diffed = function (t) {
      e && e(t);
      var o = t.__c;
      o && o.__H && o.__H.__h.length && (1 !== i.push(o) && r === l$1.requestAnimationFrame || ((r = l$1.requestAnimationFrame) || function (n) {
        var t,
            u = function () {
          clearTimeout(r), b && cancelAnimationFrame(t), setTimeout(n);
        },
            r = setTimeout(u, 100);

        b && (t = requestAnimationFrame(u));
      })(x$1)), u = void 0;
    }, l$1.__c = function (t, u) {
      u.some(function (t) {
        try {
          t.__h.forEach(g$1), t.__h = t.__h.filter(function (n) {
            return !n.__ || j$1(n);
          });
        } catch (r) {
          u.some(function (n) {
            n.__h && (n.__h = []);
          }), u = [], l$1.__e(r, t.__v);
        }
      }), a && a(t, u);
    }, l$1.unmount = function (t) {
      v && v(t);
      var u = t.__c;
      if (u && u.__H) try {
        u.__H.__.forEach(g$1);
      } catch (t) {
        l$1.__e(t, u.__v);
      }
    };
    var b = "function" == typeof requestAnimationFrame;

    function g$1(n) {
      var t = u;
      "function" == typeof n.__c && n.__c(), u = t;
    }

    function j$1(n) {
      var t = u;
      n.__c = n.__(), u = t;
    }

    function k(n, t) {
      return !n || n.length !== t.length || t.some(function (t, u) {
        return t !== n[u];
      });
    }

    function w$1(n, t) {
      return "function" == typeof t ? t(n) : t;
    }

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */

    function useState(initialState) {
      // We keep both
      var [state, setState] = l(initialState);
      var ref = s(state); // Hijack the normal setter function 
      // to also set our ref to the new value

      var set = A$1(value => {
        if (typeof value === "function") {
          var callback = value;
          setState(prevValue => {
            var nextValue = callback(prevValue);
            ref.current = nextValue;
            return nextValue;
          });
        } else {
          ref.current = value;
          setState(value);
        }
      }, []);

      var get = () => {
        return ref.current;
      };

      console.assert(ref.current === state);
      return [state, set, get];
    }

    /**
     *
     * There are several different ways that a focus event can happen.  Assume
     * the following steps happen in order:
     *
     * 1. The page loads.
     *    * Nothing is focused, but `document.activeElement` is `body`.
     *    * No focus events are fired.
     * 2. The window is focused, an unfocusable element is clicked, text is selected, etc.
     *    * The `activeElement` remains as `body`.
     *    * A `focus`/`focusin` event *MIGHT* be fired for `body`. Depending on
     *      the browser, this depends on whether the handler was attached to `window` or `document`.
     *      Probably just best to not rely on it, or listen to `window` focus events directly.
     * 3. A focusable element is clicked, etc.
     *    * The `activeElement` is set to the new element before any event even fires.
     *    * `focusout` and `blur` are *not* fired on `body`.
     *    * `focus` and `focusin` are fired on the new element. `relatedTarget` is null.
     * 4. A focusable element is clicked, etc.
     *    * **The `activeElement` is set to the `body`** before any event even fires.
     *    * `blur` and `focusout` are fired on the old element. `relatedTarget` is the new element.
     *    * The `activeElement` is now set to the new element.
     *    * `focusin` is fired on the new element. `relatedTarget` is the old element.
     * 5. An unfocusable element is clicked, text is selected, etc.
     *    * The `activeElement` is set to `body`.
     *    * `blur` and `focusout` are fired on the old element. `relatedTarget` is null.
     *    * `focusin` is *not* fired on `body`.
     *
     *
     * In summary:
     * 1. Focus events *do* notify us of all changes in focus, but there is no one single comprehensive event that provides us with all available information.
     * 2. `document.activeElement` *is not* always the same as what's being referenced by a focus event. In particular, it may become `body` at any arbitrary time.
     * 3. A `blur` without a `focus` can and will occur. This means it is not possible to solely use `focus` to detect all changes.
     * 4. A `blur` event whose `relatedTarget` is null indicates that there will be no following `focus` event.
     *
     *
     * @param callback
     * @returns
     */

    var currentlyFocusedElement = null;
    var lastFocusedElement = null;

    function getLastFocusedElement() {
      return lastFocusedElement;
    }

    function getCurrentlyFocusedElement() {
      return currentlyFocusedElement;
    }

    var updaters = new Set();

    function focusout(e) {
      if (e.relatedTarget == null) {
        currentlyFocusedElement = null;

        for (var f of updaters) {
          f();
        }
      }
    }

    function focusin(e) {
      currentlyFocusedElement = lastFocusedElement = e.target;

      for (var f of updaters) {
        f();
      }
    }

    var windowFocused = true;

    function windowFocus() {
      windowFocused = true;

      for (var f of updaters) {
        f();
      }
    }

    function windowBlur() {
      windowFocused = false;

      for (var f of updaters) {
        f();
      }
    }

    function useActiveElement() {
      // TODO: Is this actually better than using proper state management?
      var [i, setI] = useState(0);
      h(() => {
        var F = () => setI(i => ++i);

        if (updaters.size === 0) {
          document.addEventListener("focusin", focusin, {
            passive: true
          });
          document.addEventListener("focusout", focusout, {
            passive: true
          });
          window.addEventListener("focus", windowFocus, {
            passive: true
          });
          window.addEventListener("blur", windowBlur, {
            passive: true
          });
        }

        updaters.add(F);
        return () => {
          updaters.delete(F);

          if (updaters.size === 0) {
            document.removeEventListener("focusin", focusin);
            document.removeEventListener("focusout", focusout);
            window.removeEventListener("focus", windowFocus);
            window.removeEventListener("blur", windowBlur);
          }
        };
      }, []);
      return {
        activeElement: currentlyFocusedElement,
        lastActiveElement: lastFocusedElement,
        getActiveElement: getCurrentlyFocusedElement,
        getLastActiveElement: getLastFocusedElement,
        windowFocused
      };
    }

    function useMergedChildren(lhsProps, rhsProps) {
      var lhs = lhsProps === null || lhsProps === void 0 ? void 0 : lhsProps.children;
      var rhs = rhsProps === null || rhsProps === void 0 ? void 0 : rhsProps.children;

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        var ret = v$1(d$1, {}, lhs, rhs);
        return ret;
      }
    }

    function toVal(mix) {
      var k,
          y,
          str = '';

      if (typeof mix === 'string' || typeof mix === 'number') {
        str += mix;
      } else if (typeof mix === 'object') {
        if (Array.isArray(mix)) {
          for (k = 0; k < mix.length; k++) {
            if (mix[k]) {
              if (y = toVal(mix[k])) {
                str && (str += ' ');
                str += y;
              }
            }
          }
        } else {
          for (k in mix) {
            if (mix[k]) {
              str && (str += ' ');
              str += k;
            }
          }
        }
      }

      return str;
    }

    function clsx () {
      var i = 0,
          tmp,
          x,
          str = '';

      while (i < arguments.length) {
        if (tmp = arguments[i++]) {
          if (x = toVal(tmp)) {
            str && (str += ' ');
            str += x;
          }
        }
      }

      return str;
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */

    function useMergedClasses(lhs, rhs) {
      // Note: For the sake of forward compatibility, this function is labelled as
      // a hook, but as it uses no other hooks it technically isn't one.
      return mergeClasses(lhs, rhs);
    }

    function mergeClasses(lhs, rhs) {
      var lhsClass = lhs === null || lhs === void 0 ? void 0 : lhs.class;
      var lhsClassName = lhs === null || lhs === void 0 ? void 0 : lhs.className;
      var rhsClass = rhs === null || rhs === void 0 ? void 0 : rhs.class;
      var rhsClassName = rhs === null || rhs === void 0 ? void 0 : rhs.className;

      if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
        var lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
        var rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
        var allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
        return Array.from(allClasses).join(" ");
      } else {
        return undefined;
      }
    }

    function processRef(instance, ref) {
      if (typeof ref === "function") {
        ref(instance);
      } else if (ref != null) {
        ref.current = instance;
      }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */


    function useMergedRefs() {
      return function (lhsProps, rhsProps) {
        var lhs = lhsProps === null || lhsProps === void 0 ? void 0 : lhsProps.ref;
        var rhs = rhsProps === null || rhsProps === void 0 ? void 0 : rhsProps.ref;

        if (lhs == null && rhs == null) {
          return undefined;
        } else if (lhs == null) {
          return rhs;
        } else if (rhs == null) {
          return lhs;
        } else {
          var ret = A$1(current => {
            processRef(current, lhs);
            processRef(current, rhs);
          }, [lhs, rhs]);
          return ret;
        }
      };
    }
    /*
    function typetest<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const ref: RefObject<HTMLInputElement> = useRef<HTMLInputElement>(null);

        function acceptsRef(ref: Ref<any>) { }
        function acceptsOptionalRef(ref: Ref<any> | undefined) { }

        const c = [
            useMergedRefs<HTMLInputElement>()(undefined, undefined),
            useMergedRefs<HTMLInputElement>()({}, undefined),
            useMergedRefs<HTMLInputElement>()(props, undefined),
            useMergedRefs<HTMLInputElement>()(undefined, props),
            useMergedRefs<HTMLInputElement>()(props, props),
            useMergedRefs<HTMLInputElement>()({ ref }, props),
            useMergedRefs<HTMLInputElement>()({ ref }, { ref: undefined }),
            useMergedRefs<HTMLInputElement>()({ ref: undefined }, { ref }),
            useMergedRefs<HTMLInputElement>()({ ref }, { ref }),
        ] as const;

        /// @ts-expect-error
        acceptsRef(c[0]);
        /// @ts-expect-error
        acceptsRef(c[1]);

        acceptsOptionalRef(c[2]);
        acceptsOptionalRef(c[3]);
        acceptsOptionalRef(c[4]);

        /// @ts-expect-error TODO
        acceptsRef(c[5]);
        acceptsRef(c[6]);
        acceptsRef(c[7]);
        acceptsRef(c[8]);
    }
    */

    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */
    function useMergedStyles(lhs, rhs) {
      var _lhs$style, _rhs$style;

      // Easy case, when there are no styles to merge return nothing.
      if (!lhs && !rhs) return undefined;

      if (typeof lhs != typeof rhs) {
        // Easy cases, when one is null and the other isn't.
        if (lhs && !rhs) return lhs;
        if (!lhs && rhs) return rhs; // They're both non-null but different types.
        // Convert the string type to an object bag type and run it again.

        if (lhs && rhs) {
          if (typeof lhs == "string") return useMergedStyles({
            style: Object.fromEntries(lhs.split(";").map(statement => statement.split(":")))
          }, rhs);
          if (typeof rhs == "string") return useMergedStyles(lhs, {
            style: Object.fromEntries(lhs.split(";").map(statement => statement.split(":")))
          });
        } // Logic???


        return undefined;
      } // They're both strings, just concatenate them.


      if (typeof lhs == "string") {
        return "".concat(lhs, ";").concat(rhs); // TODO: Improve the typing to make this possible
      } // They're both objects, just merge them.


      return _objectSpread2(_objectSpread2({}, (_lhs$style = lhs === null || lhs === void 0 ? void 0 : lhs.style) !== null && _lhs$style !== void 0 ? _lhs$style : {}), (_rhs$style = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style !== void 0 ? _rhs$style : {});
    }

    var _excluded$F = ["children", "class", "className", "style", "ref"],
        _excluded2$c = ["children", "class", "className", "style", "ref"];

    var log = str => {
      debugger;
      /* Intentional */
    };
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */

    function useMergedProps() {
      return function (lhs2, rhs2) {
        // First, put in all the properties that are easy to reason about
        // and all lhs props. We're going to merge in rhs just after.
        var lhs = _objectWithoutProperties(lhs2, _excluded$F);

        var rhs = _objectWithoutProperties(rhs2, _excluded2$c);

        var ret = _objectSpread2(_objectSpread2({}, lhs), {}, {
          ref: useMergedRefs()(lhs2, rhs2),
          style: useMergedStyles(lhs2, rhs2),
          className: useMergedClasses(lhs2, rhs2),
          children: useMergedChildren(lhs2, rhs2)
        }); // Now, do *everything* else
        // Merge every remaining existing entry in lhs with what we've already put in ret.
        //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];


        var rhsEntries = Object.entries(rhs);

        for (var [rhsKey, rhsValue] of rhsEntries) {
          var lhsValue = lhs[rhsKey];

          if (typeof lhsValue === "function" || typeof rhsValue === "function") {
            // They're both functions that can be merged (or one's a function and the other's null).
            // Not an *easy* case, but a well-defined one.
            var merged = mergeFunctions(lhsValue, rhsValue);
            ret[rhsKey] = merged;
          } else {
            // Uh...we're here because one of them's null, right?
            if (lhsValue == null && rhsValue == null) {
              if (rhsValue === null && lhsValue === undefined) ret[rhsKey] = rhsValue;else ret[rhsKey] = lhsValue;
            }

            if (lhsValue == null) ret[rhsKey] = rhsValue;else if (rhsValue == null) ret[rhsKey] = lhsValue;else if (rhsValue == lhsValue) ; else {
              var _log;

              // Ugh.
              // No good strategies here, just log it if requested
              (_log = log) === null || _log === void 0 ? void 0 : _log("Could not merge incompatible prop \"".concat(rhsKey, "\" (type: ").concat(typeof rhsValue, ", values: [").concat(lhsValue, ", ").concat(rhsValue, "])"));
              ret[rhsKey] = rhsValue;
            }
          }
        }

        return ret;
      };
    }

    function mergeFunctions(lhs, rhs) {
      if (!lhs) return rhs;
      if (!rhs) return lhs;
      return (...args) => {
        var lv = lhs === null || lhs === void 0 ? void 0 : lhs(...args);
        var rv = rhs === null || rhs === void 0 ? void 0 : rhs(...args);
        if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
      };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */

    function useRefElement() {
      // Let us store the actual (reference to) the element we capture
      var [element, setElement, getElement] = useState(null); // Create a RefCallback that's fired when mounted 
      // and that notifies us of our element when we have it

      var myRef = A$1(e => {
        if (e) setElement(() => e);
      }, []);
      var useRefElementProps = A$1(props => useMergedProps()({
        ref: myRef
      }, props), []); // Return both the element and the hook that modifies 
      // the props and allows us to actually find the element

      return {
        useRefElementProps,
        element,
        getElement
      };
    }

    function useHasFocus({} = {}) {
      //const [focusedElement, setFocusedElement, getFocusedElement] = useState<EventTarget | null>(null);
      //const [focused, setFocused] = useState(false);
      //const [focusedInner, setFocusedInner] = useState(false);
      var {
        element,
        getElement,
        useRefElementProps
      } = useRefElement();
      var {
        activeElement,
        lastActiveElement
      } = useActiveElement();
      var useHasFocusProps = A$1(props => {
        return useRefElementProps(props);
      }, []);
      var focused = d(() => {
        return element == activeElement;
      }, [element, activeElement]);
      var focusedInner = d(() => {
        var _element$contains;

        return (_element$contains = element === null || element === void 0 ? void 0 : element.contains(activeElement)) !== null && _element$contains !== void 0 ? _element$contains : false;
      }, [element, activeElement]);
      var lastFocused = d(() => {
        return element == lastActiveElement;
      }, [element, lastActiveElement]);
      var lastFocusedInner = d(() => {
        var _element$contains2;

        return (_element$contains2 = element === null || element === void 0 ? void 0 : element.contains(lastActiveElement)) !== null && _element$contains2 !== void 0 ? _element$contains2 : false;
      }, [element, lastActiveElement]);
      return {
        useHasFocusProps,
        focusedElement: activeElement,
        lastFocusedElement: lastActiveElement,
        focused,
        focusedInner,
        lastFocused,
        lastFocusedInner
      };
    }

    var Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";

    function base64(value) {
      return Table[value];
    }

    function random6Bits() {
      return Math.floor(Math.random() * 0b1000000);
    }

    function random64Bits() {
      return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     */


    function generateRandomId(prefix) {
      return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits().map(n => base64(n)).join(""));
    }
    /**
     * Returns a hook that modifies a set of props to provide a randomly-generated ID if one was not provided.
     *
     * If you'd like to use the ID in a property that's *not* named `id` (like `for` or `aria-labelledby` or whatnot), `useReferencedIdProps` is also provided.
     *
     * And the randomly-generated id itself is also provided in case you want to handle the logic yourself without `useMergedProps`.
     *
     * Unlike most other `use*Props` hooks, these are mostly stable.
     */

    function useRandomId({
      prefix
    } = {}) {
      var [randomId, setRandomId] = useState(() => generateRandomId(prefix));
      var [watchPrefixUpdates, setWatchPrefixUpdates, getWatchPrefixUpdates] = useState(false);
      h(() => {
        var watchPrefixUpdates = getWatchPrefixUpdates();
        if (watchPrefixUpdates) setRandomId(() => generateRandomId(prefix));
        setWatchPrefixUpdates(true);
      }, [prefix]); // Whatever ID was most recently used by the actual "id" prop.
      // Used so that any ID-referencing props don't need to provide the same value.
      //
      // TODO: This does mean that on the first render, if just the ID is provided,
      // there will be a temporary mismatch, but it's corrected before rendering finishes.
      // Is this okay?

      var [usedId, setUsedId, getUsedId] = useState(undefined);
      var useReferencedIdProps = A$1(function useReferencedIdProps(idPropName) {
        var ret = function (_ref) {
          var _ref2, _ref3;

          var {
            [idPropName]: givenId
          } = _ref,
              props = _objectWithoutProperties(_ref, [idPropName].map(_toPropertyKey));

          var usedId2 = (_ref2 = (_ref3 = givenId !== null && givenId !== void 0 ? givenId : usedId) !== null && _ref3 !== void 0 ? _ref3 : randomId) !== null && _ref2 !== void 0 ? _ref2 : undefined;
          if (idPropName === "id") setUsedId(usedId2);
          return useMergedProps()({
            [idPropName]: usedId2
          }, props);
        };

        return ret;
      }, [usedId, randomId]);
      var useRandomIdProps = A$1(function useRandomIdProps(p) {
        return useReferencedIdProps("id")(p);
      }, [useReferencedIdProps]);
      return {
        randomId,
        id: usedId,
        getId: getUsedId,
        useRandomIdProps,
        useReferencedIdProps
      };
    }

    function useElementSize({
      observeBox
    } = {}) {
      var {
        element,
        useRefElementProps
      } = useRefElement();
      var [size, setSize, getSize] = useState(null);
      y(() => {
        if (element) {
          var handleUpdate = () => {
            var {
              clientWidth,
              scrollWidth,
              offsetWidth,
              clientHeight,
              scrollHeight,
              offsetHeight,
              clientLeft,
              scrollLeft,
              offsetLeft,
              clientTop,
              scrollTop,
              offsetTop
            } = element;
            setSize({
              clientWidth,
              scrollWidth,
              offsetWidth,
              clientHeight,
              scrollHeight,
              offsetHeight,
              clientLeft,
              scrollLeft,
              offsetLeft,
              clientTop,
              scrollTop,
              offsetTop
            });
          };

          if (!("ResizeObserver" in window)) {
            document.addEventListener("resize", handleUpdate, {
              passive: true
            });
            return () => document.removeEventListener("resize", handleUpdate);
          } else {
            var observer = new ResizeObserver(entries => {
              handleUpdate();
            });
            observer.observe(element, {
              box: observeBox
            });
            return () => observer.disconnect();
          }
        }
      }, [element, observeBox]);
      return {
        element,
        elementSize: size,
        getElementSize: getSize,
        useElementSizeProps: useRefElementProps
      };
    }

    function capitalize(str) {
      return str[0].toUpperCase() + str.substr(1);
    }
    /**
     * Inspects the element's style and determines the logical direction that text flows.
     *
     * Certain CSS properties, like `block-size`, respect the current writing mode and text direction.
     * But `transform`, `clip`, etc. don't.
     *
     * This is provided so that CSS properties can consistently use those logical properties.
     *
     * See https://drafts.csswg.org/css-writing-modes/#logical-to-physical
     *
     * @returns An object containing the following functions:
     * * `getLogicalDirection`: retrieves a `LogicalDirectionInfo` representing the current state of the element. (Function is constant between renders)
     * * `convertElementSize`: When used in conjunction with `useElementSize`, allows you to retrieve the logical size of an element instead of the physical size.
     * * `convertToLogicalOrientation`: Based on the current direction, converts "horizontal" or "vertical" to "inline" or "block".
     * * `convertToPhysicalOrientation`:  Based on the current direction, converts "inline" or "block" to "horizontal" or "vertical".
     */


    function useLogicalDirection(element) {
      var [writingMode, setWritingMode] = l(null);
      var [direction, setDirection] = l(null);
      var [textOrientation, setTextOrientation] = l(null);
      var writingModeRef = s(writingMode);
      var directionRef = s(direction);
      var textOrientationRef = s(textOrientation);
      h(() => {
        writingModeRef.current = writingMode;
      }, [writingMode]);
      h(() => {
        directionRef.current = direction;
      }, [direction]);
      h(() => {
        textOrientationRef.current = textOrientation;
      }, [textOrientation]);
      h(() => {
        if (element) {
          var computedStyles = window.getComputedStyle(element);
          var w = computedStyles.writingMode;
          var t = computedStyles.textOrientation;
          var d = computedStyles.direction;
          setWritingMode(w || "horizontal-tb");
          setDirection(d || "rtl");
          setTextOrientation(t || "mixed");
        }
      });
      var getLogicalDirection = A$1(() => {
        var _direction;

        var writingMode = writingModeRef.current;
        var direction = directionRef.current;
        var textOrientation = textOrientationRef.current;
        if (!writingMode || !direction || !textOrientation) return null;
        if (textOrientation == "upright") direction = "ltr";
        return _objectSpread2({}, WritingModes[writingMode !== null && writingMode !== void 0 ? writingMode : "horizontal-tb"][(_direction = direction) !== null && _direction !== void 0 ? _direction : "ltr"]);
      }, [writingModeRef, directionRef, textOrientationRef]);
      var convertToLogicalOrientation = A$1((elementOrientation, direction) => {
        var _direction2, _direction3;

        (_direction2 = direction) !== null && _direction2 !== void 0 ? _direction2 : direction = getLogicalDirection();
        if (((_direction3 = direction) === null || _direction3 === void 0 ? void 0 : _direction3.inlineOrientation) === elementOrientation) return "inline";
        return "block";
      }, [getLogicalDirection]);
      var convertToPhysicalOrientation = A$1((elementOrientation, direction) => {
        var _direction4;

        (_direction4 = direction) !== null && _direction4 !== void 0 ? _direction4 : direction = getLogicalDirection();

        if (elementOrientation == "inline") {
          var _direction5;

          if (((_direction5 = direction) === null || _direction5 === void 0 ? void 0 : _direction5.inlineOrientation) == "horizontal") return "horizontal";
          return "vertical";
        } else {
          var _direction6;

          if (((_direction6 = direction) === null || _direction6 === void 0 ? void 0 : _direction6.blockOrientation) == "vertical") return "vertical";
          return "horizontal";
        }
      }, [getLogicalDirection]);
      var convertElementSize = A$1((elementSize, direction) => {
        var _direction7;

        (_direction7 = direction) !== null && _direction7 !== void 0 ? _direction7 : direction = getLogicalDirection();

        if (direction) {
          var {
            inlineSize,
            blockSize,
            inlineDirection,
            blockDirection
          } = direction; // Size is relatively simple

          var clientInlineSize = elementSize["client".concat(capitalize(inlineSize))];
          var clientBlockSize = elementSize["client".concat(capitalize(blockSize))];
          var offsetInlineSize = elementSize["offset".concat(capitalize(inlineSize))];
          var offsetBlockSize = elementSize["offset".concat(capitalize(blockSize))];
          var scrollInlineSize = elementSize["scroll".concat(capitalize(inlineSize))];
          var scrollBlockSize = elementSize["scroll".concat(capitalize(blockSize))]; // Position requires us to sometimes use one property (like `left`)
          // or sometimes two (like `left` + `width`)

          function getPhysicalLeftTop(dir) {
            if (dir === "ltr" || dir == "rtl") return "left";
            return "top";
          }

          function getPhysicalRightBottom(dir) {
            if (dir === "rtl") return "width";
            if (dir === "btt") return "height";
            return null;
          }

          var f1 = getPhysicalLeftTop(inlineDirection);
          var f2 = getPhysicalRightBottom(inlineDirection);
          var f3 = getPhysicalLeftTop(blockDirection);
          var f4 = getPhysicalRightBottom(blockDirection);
          var clientInlineInset = elementSize["client".concat(capitalize(f1))] + (!f2 ? 0 : elementSize["client".concat(capitalize(f2))]);
          var scrollInlineInset = elementSize["scroll".concat(capitalize(f1))] + (!f2 ? 0 : elementSize["scroll".concat(capitalize(f2))]);
          var offsetInlineInset = elementSize["offset".concat(capitalize(f1))] + (!f2 ? 0 : elementSize["offset".concat(capitalize(f2))]);
          var clientBlockInset = elementSize["client".concat(capitalize(f3))] + (!f4 ? 0 : elementSize["client".concat(capitalize(f4))]);
          var scrollBlockInset = elementSize["scroll".concat(capitalize(f3))] + (!f4 ? 0 : elementSize["scroll".concat(capitalize(f4))]);
          var offsetBlockInset = elementSize["offset".concat(capitalize(f3))] + (!f4 ? 0 : elementSize["offset".concat(capitalize(f4))]);
          return {
            clientInlineSize,
            scrollInlineSize,
            offsetInlineSize,
            clientBlockSize,
            scrollBlockSize,
            offsetBlockSize,
            clientInlineInset,
            scrollInlineInset,
            offsetInlineInset,
            clientBlockInset,
            scrollBlockInset,
            offsetBlockInset
          };
        }

        return null;
      }, [getLogicalDirection]);
      return {
        getLogicalDirection,
        convertElementSize,
        convertToLogicalOrientation,
        convertToPhysicalOrientation
      };
    }
    var HorizontalTbLtr = {
      inlineDirection: "ltr",
      blockDirection: "ttb",
      inlineOrientation: "horizontal",
      blockOrientation: "vertical",
      inlineSize: "width",
      blockSize: "height",
      leftRightDirection: "ltr",
      overUnderDirection: "ttb"
    };

    var HorizontalTbRtl = _objectSpread2(_objectSpread2({}, HorizontalTbLtr), {}, {
      inlineDirection: "rtl"
    });

    var VerticalRlLtr = {
      inlineDirection: "ttb",
      blockDirection: "rtl",
      inlineOrientation: "vertical",
      blockOrientation: "horizontal",
      inlineSize: "height",
      blockSize: "width",
      leftRightDirection: "ttb",
      overUnderDirection: "rtl"
    };

    var VerticalRlRtl = _objectSpread2(_objectSpread2({}, VerticalRlLtr), {}, {
      inlineDirection: "btt"
    });

    var SidewaysRlLtr = _objectSpread2({}, VerticalRlLtr);

    var SidewaysRlRtl = _objectSpread2({}, VerticalRlRtl);

    var VerticalLrLtr = _objectSpread2(_objectSpread2({}, VerticalRlLtr), {}, {
      blockDirection: "ltr"
    });

    var VerticalLrRtl = _objectSpread2(_objectSpread2({}, VerticalRlRtl), {}, {
      blockDirection: "ltr"
    });

    var SidewaysLtLtr = _objectSpread2(_objectSpread2({}, VerticalLrLtr), {}, {
      inlineDirection: "btt",
      leftRightDirection: "btt",
      overUnderDirection: "ltr"
    });

    var SidewaysLtRtl = _objectSpread2(_objectSpread2({}, SidewaysLtLtr), {}, {
      inlineDirection: "ttb"
    });

    var HorizontalTb = {
      ltr: HorizontalTbLtr,
      rtl: HorizontalTbRtl
    };
    var VerticalRl = {
      ltr: VerticalRlLtr,
      rtl: VerticalRlRtl
    };
    var VerticalLr = {
      ltr: VerticalLrLtr,
      rtl: VerticalLrRtl
    };
    var SidewaysRl = {
      ltr: SidewaysRlLtr,
      rtl: SidewaysRlRtl
    };
    var SidewaysLr = {
      ltr: SidewaysLtLtr,
      rtl: SidewaysLtRtl
    };
    var WritingModes = {
      "horizontal-tb": HorizontalTb,
      "vertical-lr": VerticalLr,
      "vertical-rl": VerticalRl,
      "sideways-lr": SidewaysLr,
      "sideways-rl": SidewaysRl
    };

    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * Use with caution, and **do not use the getter in useLayoutEffect!!**
     * `setState`'s getter does not have this problem, but then you're using your own state
     * instead of an existing value, which might not always be feasible.
     *
     * Weigh your options, and hopefully one of them gets the job done.
     *
     * @param value
     * @returns
     */

    function useStableGetter(value) {
      var ref = s(value);
      _(ref, () => value);
      return A$1(() => {
        return ref.current;
      }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * DO NOT USE THE RESULT IN useLayoutEffect!!
     *
     * TODO: Investigate options.diffed if the useLayoutEffect limitation becomes limitlessly limiting.
     *
     * Source: https://github.com/facebook/react/issues/14099#issuecomment-659298422
     */

    function useStableCallback(fn) {
      var currentCallbackGetter = useStableGetter(fn);
      return A$1((...args) => {
        var currentFunc = currentCallbackGetter();

        if (!currentFunc) {
          throw new Error('Callback retrieved from useStableCallback() cannot be called from useLayoutEffect().');
        }

        return currentFunc(...args);
      }, []);
    }

    /**
     * Wrap the native `useLayoutEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     */

    function useLayoutEffect(effect, inputs) {
      var prevInputs = s(inputs);

      var effect2 = () => {
        var changes = [];

        for (var i = 0; i < Math.max(prevInputs.current.length, inputs.length); ++i) {
          if (prevInputs.current[i] != inputs[i]) changes[i] = {
            from: prevInputs.current[i],
            to: inputs[i]
          };
        }

        effect(prevInputs.current, changes);
        prevInputs.current = inputs;
      };

      h(effect2, inputs);
    }

    function useTimeout({
      timeout,
      callback,
      triggerIndex
    }) {
      var stableCallback = useStableCallback(callback);
      var getTimeout = useStableGetter(timeout);
      var timeoutIsNull = timeout == null;
      y(() => {
        var timeout = getTimeout();
        console.assert(timeoutIsNull == (timeout == null));

        if (timeout) {
          var handle = setTimeout(stableCallback, timeout);
          return () => clearTimeout(handle);
        }
      }, [triggerIndex, timeoutIsNull]);
    }

    /**
     * Given an asyncronous event handler, returns a syncronous one that works on the DOM,
     * along with some other information related to the current state.
     * Does not modify any props.
     *
     * The handler is automatically throttled to only run one at a time.
     * If the handler is called, and then before it finishes, is called again,
     * it will be put on hold until the current one finishes, at which point
     * the second one will run.  If the handler is called a third time before
     * the first has finished, it will *replace* the second, so only the most
     * recently called iteration of the handler will run.
     *
     * You may optionally *also* specify a debounce parameter that waits until the
     * syncronous handler has not been called for the specified number of
     * milliseconds, at which point we *actually* run the asyncronous handler
     * according to the logic in the previous paragraph. This is in
     * *addition* to throttling the handler, and does not replace that behavior.
     *
     * Note that the parameters to the async handler are slightly different than
     * the sync handler &ndash; the first argument, as decided by you with the
     * `capture` parameter for this hook, is the "saved" information from the
     * event.  For example, the event's currentTarget's `value`, which may have
     * changed by the time the handler is *actually* called.  The second argument
     * is the original event, which might still have some useful fields on it
     * like `mouseX` or something, but is stale at least in regards to the
     * element it references.
     */

    function useAsyncHandler() {
      return function ({
        capture,
        debounce
      }) {
        // Always represents whatever promise is currently being waited on, or null if none.
        var [promise, setPromise, getPromise] = useState(null); // Keep track of how many times we've actually called the async handler

        var [runCount, setRunCount] = useState(0);
        var [resolveCount, setResolveCount] = useState(0);
        var [rejectCount, setRejectCount] = useState(0); // If we're set to use a debounce, then when the timeout finishes,
        // the promise from this state object is transferred over to either 
        // the current promise or the pending promise.

        var [debouncedPromiseStarter, setDebouncedPromiseStarter, getDebouncedPromiseStarter] = useState(null); // When we want to start a new promise, we won't allow it to start if one is still running.
        // In that case, we store the promise (or rather, a way to start the promise) in state.

        var [pendingPromiseStarter, setPendingPromiseStarter, getPendingPromiseStarter] = useState(null); // We need to differentiate between `undefined` and "no error has been thrown".
        // We could also keep a separate boolean state to track that.

        var [error, setError, getError] = useState(undefined);
        var [hasError, setHasError, getHasError] = useState(false);
        var [currentCapture, setCurrentCapture, getCurrentCapture] = useState(undefined);
        var [hasCapture, setHasCapture] = useState(false); // Handle the debounce. Logically this happens before the main step as a sort of step 0.
        // Resets the timeout any time the handler was requested to be called again
        // and when it finishes, actually call the handler (or set it as the pending promise)

        useTimeout({
          timeout: debounce !== null && debounce !== void 0 ? debounce : null,
          callback: () => {
            if (debouncedPromiseStarter) wantToStartANewPromise(debouncedPromiseStarter);
            setDebouncedPromiseStarter(null);
          },
          triggerIndex: debouncedPromiseStarter
        }); // See if we should set our current promise to be whatever the pending promise is
        // (usually because the current promise finished and became null).

        useLayoutEffect(() => {
          // Our current promise just finished and there's one waiting?
          if (promise == null && pendingPromiseStarter != null) {
            wantToStartANewPromise(pendingPromiseStarter);
            setPendingPromiseStarter(null);
          }
        }, [promise, pendingPromiseStarter]); // Called any time the async handler is about to be called for whatever reason,
        // except for debounce, which comes first, as a sort of "step 0".
        // Handles all the necessary boilerplate related to choosing whether to
        // run or set as pending, resetting state variables, etc.

        function wantToStartANewPromise(startPromise) {
          var alreadyRunningPromise = getPromise() != null; // Boilerplate wrapper around the given promise starter

          var P = () => {
            // When it starts, notify the caller
            setRunCount(r => ++r); // When it completes, notify the caller

            var onThen = () => {
              setResolveCount(c => ++c);
            }; // When it fails, save the error and notify the caller


            var onCatch = ex => {
              setError(ex);
              setHasError(true);
              setRejectCount(c => ++c);
            }; // When it settles, reset our state so we can 
            // run a pending promise if it exists


            var onFinally = () => {
              setPromise(null);
            };

            var result;

            try {
              result = startPromise();

              if (result == undefined) {
                // It's synchronous and returned successfully.
                // Bail out early.
                onThen();
                onFinally();
                return;
              }
            } catch (ex) {
              // It's synchronous and threw an error.
              // Bail out early.
              onCatch(ex);
              onFinally();
            } // The handler is asynchronous


            return _asyncToGenerator(function* () {
              yield result;
            })().then(onThen).catch(onCatch).finally(onFinally);
          };

          if (!alreadyRunningPromise) {
            // Start the promise immediately, because there wasn't one running already.
            var nextPromise = P();

            if (nextPromise == undefined) ; else {
              setError(undefined);
              setHasError(false);
              setPromise(nextPromise);
            }
          } else {
            // Don't start the promise yet, 
            // and allow it to start in the future instead.
            setPendingPromiseStarter(_ => P);
          }
        }

        var ret = {
          getSyncHandler,
          getCurrentCapture,
          callCount: runCount,
          currentCapture,
          hasCapture,
          pending: promise != null,
          hasError,
          error,
          resolveCount,
          rejectCount,
          settleCount: rejectCount + resolveCount
        };
        return ret;

        function getSyncHandler(asyncHandler) {
          var syncHandler = useStableCallback(function syncHandler(event) {
            if (asyncHandler == null) return; // Get the most significant information from the event at this time,
            // which is necessary since the promise could actually be called much later
            // when the element's value (etc.) has changed.

            var captured = capture(event);
            setCurrentCapture(captured);
            setHasCapture(true);

            var startPromise = () => asyncHandler(captured, event);

            if (debounce == null) {
              wantToStartANewPromise(startPromise);
            } else {
              setDebouncedPromiseStarter(_ => startPromise);
            }
          });
          return asyncHandler == null ? undefined : syncHandler;
        }
      };
    }

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */

    function useGlobalHandler(target, type, handler, options) {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      var stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
      y(() => {
        target.addEventListener(type, stableHandler, options);
        return () => target.removeEventListener(type, stableHandler, options);
      }, [target, type, stableHandler]);
    }

    function useInterval({
      interval,
      callback
    }) {
      // Get a wrapper around the given callback that's stable
      var stableCallback = useStableCallback(callback);
      var getInterval = useStableGetter(interval);
      y(() => {
        var interval = getInterval();
        var lastDelayUsed = interval;
        if (interval == null) return; // Get a wrapper around the wrapper around the callback
        // that clears and resets the interval if it changes.

        var adjustableCallback = () => {
          stableCallback();
          var currentInterval = getInterval();

          if (currentInterval != lastDelayUsed) {
            clearInterval(handle);
            if (currentInterval != null) handle = setInterval(adjustableCallback, lastDelayUsed = currentInterval);
          }
        };

        var handle = setInterval(adjustableCallback, interval);
        return () => clearInterval(handle);
      }, []);
    }

    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is slightly more complicated in that it returns both a
     * prop-modifying hook, but also a hook that each child will need
     * to use: `useManagedChild`.  It's stable across renders, so just
     * toss it into a `Context` so the children can have access to it.
     * This function registers the child with the parent and provides
     * it with any requested information, but doesn't do anything else
     * until it unmounts and retracts that information.
     */

    function useChildManager() {
      // This is blindly updated any time a child mounts or unmounts itself.
      // Used to make sure that any time the array of managed children updates,
      // we also re-render.
      var [childUpdateIndex, setChildUpdateIndex] = useState(0);
      var [totalChildrenMounted, setTotalChildrenMounted, getTotalChildrenMounted] = useState(0);
      var [totalChildrenUnounted, setTotalChildrenUnounted, getTotalChildrenUnounted] = useState(0);
      var childrenCurrentlyMounted = totalChildrenMounted - totalChildrenUnounted;
      var managedChildren = s([]
      /** TODO: Any problems caused by using an array when it should be an object? */
      );
      var mountedChildren = s([]);
      var mountOrder = s(new Map());
      var indicesByElement = s(new Map());
      var getMountIndex = A$1(index => {
        return mountOrder.current.get(index);
      }, []);
      var useManagedChild = A$1(info => {
        var {
          element,
          getElement,
          useRefElementProps
        } = useRefElement();
        useLayoutEffect(() => {
          var index = getTotalChildrenMounted();
          mountOrder.current.set(info.index, index);
          mountedChildren.current[index] = info;
          setTotalChildrenMounted(t => ++t);
          return () => {
            mountOrder.current.delete(info.index);
            mountedChildren.current[index] = null;
            setTotalChildrenUnounted(t => ++t);
          };
        }, [info.index]); // As soon as the component mounts, notify the parent and request a rerender.

        useLayoutEffect(([prevElement, prevIndex], changes) => {
          if (element) {
            indicesByElement.current.set(element, info.index);

            if (managedChildren.current[info.index] != undefined) {
              console.assert(info.index == undefined, "Two children with the same index were added, which may result in unexpected behavior.");
              debugger; // Intentional
            }

            setChildUpdateIndex(c => ++c);
            managedChildren.current[info.index] = _objectSpread2({}, info);
            return () => {
              setChildUpdateIndex(c => ++c);
              delete managedChildren.current[info.index];
              indicesByElement.current.delete(element);
            };
          }
        }, [element, info.index]); // Any time our child props change, make that information available generally.
        // *Don't re-render*, otherwise we'd be stuck in an
        // infinite loop every time an anonymous function is passed.
        // It comes in from the props so the child was already updated by it --
        // we don't need the parent to re-render every single child any time
        // "onClick" updates or whatever.  The relevant child already knows,
        // and that's what matters.

        useLayoutEffect(() => {
          if (managedChildren.current[info.index] != undefined) managedChildren.current[info.index] = _objectSpread2({}, info);
        }, [...Object.entries(info).flat()]);
        return {
          element,
          getElement,
          useManagedChildProps: useRefElementProps
        };
      }, []);
      return {
        useManagedChild,
        childCount: childrenCurrentlyMounted,
        managedChildren: managedChildren.current,
        mountedChildren: mountedChildren.current,
        indicesByElement: indicesByElement.current,
        totalChildrenMounted,
        totalChildrenUnounted,
        getMountIndex
      };
    }
    /**
     * Helper function for letting children know when they are or are not the
     * current selected/expanded/focused/whatever child.
     *
     * Automatically handles when children are mounted & unmounted and such.
     *
     * @param activatedIndex What index the current selected (etc.) child is
     * @param length How many children exist (as managedChildren.length)
     * @param setFlag A function that probably looks like (i, flag) => managedChildren[i].setActive(flag)
     */

    function useChildFlag(activatedIndex, length, setFlag) {
      var [prevActivatedIndex, setPrevActivatedIndex, getPrevActivatedIndex] = useState(null);
      var [prevChildCount, setPrevChildCount, getPrevChildCount] = useState(length); // Any time the number of components changes,
      // reset any initial, possibly incorrect state they might have had, just in case.

      useLayoutEffect(() => {
        var direction = Math.sign(length - getPrevChildCount());

        if (direction !== 0) {
          for (var i = (_getPrevChildCount = getPrevChildCount()) !== null && _getPrevChildCount !== void 0 ? _getPrevChildCount : 0; i != length; i += direction) {
            var _getPrevChildCount;

            setFlag(i, i === activatedIndex);
          }

          setPrevChildCount(length);
        }
      }, [setFlag, activatedIndex, length]);
      useLayoutEffect(() => {
        // Deactivate the previously activated component
        var prevActivatedIndex = getPrevActivatedIndex();

        if (prevActivatedIndex != activatedIndex) {
          if (prevActivatedIndex != null && prevActivatedIndex >= 0 && prevActivatedIndex < length) setFlag(prevActivatedIndex, false);
        } // Activate the current component


        if (activatedIndex != null && activatedIndex >= 0 && activatedIndex < length) {
          setFlag(activatedIndex, true);
          setPrevActivatedIndex(activatedIndex);
        }
      }, [setFlag, activatedIndex, length]);
    }

    var _excluded$E = ["managedChildren", "childCount", "useManagedChild", "indicesByElement"],
        _excluded2$b = ["tabIndex"],
        _excluded3$3 = ["tabIndex"];
    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `focusOnChange` should be set to true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const { focused, focusedInner, useHasFocusProps } = useHasFocus<ParentElement>();
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */

    function useRovingTabIndex({
      focusOnChange,
      tabbableIndex
    }) {
      var getTabbableIndex = useStableGetter(tabbableIndex);
      s(-Infinity); // Call the hook that allows us to collect information from children who provide it

      var _useChildManager = useChildManager(),
          {
        managedChildren,
        childCount,
        useManagedChild,
        indicesByElement
      } = _useChildManager,
          rest = _objectWithoutProperties(_useChildManager, _excluded$E); // Any time the tabbable index changes,
      // notify the previous child that it's no longer tabbable,
      // and notify the next child that is allowed to be tabbed to.


      useChildFlag(tabbableIndex, childCount, (index, tabbable) => {
        var _managedChildren$inde;

        (_managedChildren$inde = managedChildren[index]) === null || _managedChildren$inde === void 0 ? void 0 : _managedChildren$inde.setTabbable(tabbable, tabbable && focusOnChange ? "focus" : undefined);
      });
      var focusSelf = A$1(() => {
        managedChildren[tabbableIndex].setTabbable(true, "focus");
      }, [tabbableIndex]);
      var useRovingTabIndexChild = A$1(info => {
        var setTabbable = A$1((tabbable, shouldFocus) => {
          setTabbable2(tabbable);
          if (tabbable && shouldFocus) setShouldFocus(!!shouldFocus);
        }, []);

        var newInfo = _objectSpread2(_objectSpread2({}, info), {}, {
          setTabbable
        });

        var {
          element,
          getElement,
          useManagedChildProps
        } = useManagedChild(newInfo);
        var [tabbable, setTabbable2] = useState(getTabbableIndex() == info.index);
        var [shouldFocus, setShouldFocus] = useState(false);

        function useRovingTabIndexSiblingProps(_ref) {
          var {
            tabIndex
          } = _ref,
              props = _objectWithoutProperties(_ref, _excluded2$b);

          if (tabIndex == null) {
            if (tabbable) tabIndex = 0;else tabIndex = -1;
          }

          return useMergedProps()({
            tabIndex
          }, props);
        }

        function useRovingTabIndexChildProps(_ref2) {
          var {
            tabIndex
          } = _ref2,
              props = _objectWithoutProperties(_ref2, _excluded3$3);

          //const { element, useRefElementProps } = useRefElement<ChildElement>();
          useLayoutEffect(() => {
            if (element && shouldFocus && "focus" in element) {
              requestAnimationFrame(() => {
                queueMicrotask(() => {
                  element.focus();
                });
              });
              setShouldFocus(false);
            }
          }, [element, shouldFocus]);

          if (tabIndex == null) {
            if (tabbable) tabIndex = 0;else tabIndex = -1;
          }

          return useMergedProps()(useManagedChildProps({
            tabIndex
          }), props);
        }
        return {
          useRovingTabIndexChildProps,
          useRovingTabIndexSiblingProps,
          tabbable
        };
      }, [useManagedChild]);
      return _objectSpread2({
        useRovingTabIndexChild,
        childCount,
        managedChildren,
        indicesByElement,
        focusSelf
      }, rest);
    }

    var _excluded$D = ["text"];
    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useLinearNavigation({
      getIndex,
      setIndex,
      managedChildren,
      navigationDirection
    }) {
      var _navigationDirection;

      (_navigationDirection = navigationDirection) !== null && _navigationDirection !== void 0 ? _navigationDirection : navigationDirection = "either";
      var index = getIndex();
      var childCount = managedChildren.length; // Make sure the tabbable index never escapes the bounds of all available children
      // TODO: Keep track of the original index and keep it, at least until keyboard navigation.

      useLayoutEffect(() => {
        if (index < 0) {
          setIndex(0);
        } else if (childCount > 0 && index >= childCount) {
          setIndex(childCount - 1);
        }
      }, [index, childCount]); // These allow us to manipulate what our current tabbable child is.

      var navigateToIndex = A$1(index => {
        setIndex(index < 0 ? managedChildren.length + index : index);
      }, []);
      var navigateToNext = A$1(() => {
        setIndex(i => ++i);
      }, []);
      var navigateToPrev = A$1(() => {
        setIndex(i => --i);
      }, []);
      var navigateToStart = A$1(() => {
        navigateToIndex(0);
      }, [navigateToIndex]);
      var navigateToEnd = A$1(() => {
        navigateToIndex(-1);
      }, [navigateToIndex]);
      var useLinearNavigationChild = A$1(() => {
        var _element$parentElemen;

        var {
          useRefElementProps,
          element
        } = useRefElement(); // Prefer the parent element's direction so that we're not calling getComputedStyle
        // on every single individual child, which is likely redundant.
        // TODO: Does useLogicalDirection need to hold a per-render & per-element cache to make this work?
        // Or does the browser automatically cache the computations until something changes?
        // Given that the values are live, it seems like it should be the latter...

        var {
          convertElementSize,
          getLogicalDirection
        } = useLogicalDirection((_element$parentElemen = element === null || element === void 0 ? void 0 : element.parentElement) !== null && _element$parentElemen !== void 0 ? _element$parentElemen : element);

        var useLinearNavigationChildProps = props => {
          var onKeyDown = e => {
            // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
            if (e.ctrlKey || e.metaKey) return;
            var info = getLogicalDirection();
            var allowsBlockNavigation = navigationDirection == "block" || navigationDirection == "either";
            var allowsInlineNavigation = navigationDirection == "inline" || navigationDirection == "either";

            switch (e.key) {
              case "ArrowUp":
                {
                  var propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  var directionAllowed = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation;

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowDown":
                {
                  var _propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";

                  var _directionAllowed = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation;

                  if (_directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[_propName]) === "btt") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowLeft":
                {
                  var _propName2 = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";

                  var _directionAllowed2 = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation;

                  if (_directionAllowed2) {
                    if ((info === null || info === void 0 ? void 0 : info[_propName2]) === "rtl") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowRight":
                {
                  var _propName3 = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";

                  var _directionAllowed3 = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation;

                  if (_directionAllowed3) {
                    if ((info === null || info === void 0 ? void 0 : info[_propName3]) === "rtl") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  e.preventDefault();
                  e.stopPropagation();
                  break;
                }

              case "Home":
                navigateToStart();
                e.preventDefault();
                e.stopPropagation();
                break;

              case "End":
                navigateToEnd();
                e.preventDefault();
                e.stopPropagation();
                break;
            }
          };

          return useRefElementProps(useMergedProps()({
            onKeyDown
          }, props));
        };

        return {
          useLinearNavigationChildProps
        };
      }, []);
      return {
        useLinearNavigationChild,
        navigateToIndex,
        navigateToNext,
        navigateToPrev,
        navigateToStart,
        navigateToEnd
      };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useTypeaheadNavigation({
      collator,
      getIndex,
      typeaheadTimeout,
      setIndex
    }) {
      // For typeahead, keep track of what our current "search" string is (if we have one)
      // and also clear it every 1000 ms since the last time it changed.
      // Next, keep a mapping of typeahead values to indices for faster searching.
      // And, for the user's sake, let them know when their typeahead can't match anything anymore
      var [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
      useTimeout({
        timeout: typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000,
        callback: () => {
          setCurrentTypeahead(null);
          setInvalidTypeahead(null);
        },
        triggerIndex: currentTypeahead
      });
      var sortedTypeaheadInfo = s([]);
      var [invalidTypeahead, setInvalidTypeahead] = useState(false); // Handle typeahead for input method editors as well
      // Essentially, when active, ignore further keys 
      // because we're waiting for a CompositionEnd event

      var [imeActive, setImeActive, getImeActive] = useState(false); // Because composition events fire *after* keydown events 
      // (but within the same task, which, TODO, could be browser-dependent),
      // we can use this to keep track of which event we're listening for on the first keydown.

      var [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
      useLayoutEffect(() => {
        if (nextTypeaheadChar !== null) {
          setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar);
          setNextTypeaheadChar(null);
        }
      }, [nextTypeaheadChar]);
      var comparator = useStableCallback((lhs, rhs) => {
        var _safeRhs$toLowerCase;

        var compare; // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
        // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.

        var safeLhs = lhs.normalize("NFD");
        var safeRhs = rhs.text.normalize("NFD").substr(0, safeLhs.length);
        if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
        return compare;
      }); // Handle changes in typeahead that cause changes to the tabbable index

      y(() => {
        if (currentTypeahead && sortedTypeaheadInfo.current.length) {
          var sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, comparator);

          if (sortedTypeaheadIndex < 0) {
            // The user has typed an entry that doesn't exist in the list
            // (or more specifically "for which there is no entry that starts with that input")
            setInvalidTypeahead(true);
          } else {
            setInvalidTypeahead(false);
            /*
              We know roughly where, in the sorted array of strings, our next typeahead location is.
              But roughly isn't good enough if there are multiple matches.
              To convert our sorted index to the unsorted index we need, we have to find the first
              element that matches us *and* (if any such exist) is *after* our current selection.
               In other words, the only way typeahead moves backwards relative to our current
              position is if the only other option is behind us.
               It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
              Though there's also a case for just going upwards to the nearest to prevent jumpiness.
              But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
              I dunno. Going back to the start is the simplist though.
               Basically what this does: Starting from where we found ourselves after our binary search,
              scan backwards and forwards through all adjacent entries that also compare equally so that
              we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
              (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
               TODO: The binary search starts this off with a solid O(log n), but one-character
              searches are, thanks to pigeonhole principal, eventually guaranteed to become
              O(n*log n). This is annoying but probably not easily solvable? There could be an
              exception for one-character strings, but that's just kicking the can down
              the road. Maybe one or two characters would be good enough though.
            */
            // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.

            var lowestUnsortedIndexAll = null;
            var lowestSortedIndexAll = sortedTypeaheadIndex; // These two are only set for elements that are ahead of us, but the principle's the same otherwise

            var lowestUnsortedIndexNext = null;
            var lowestSortedIndexNext = sortedTypeaheadIndex;

            var updateBestFit = u => {
              if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                lowestUnsortedIndexAll = u;
                lowestSortedIndexAll = i;
              }

              if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > getIndex()) {
                lowestUnsortedIndexNext = u;
                lowestSortedIndexNext = i;
              }
            };

            var i = sortedTypeaheadIndex;

            while (i >= 0 && comparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              --i;
            }

            i = sortedTypeaheadIndex;

            while (i < sortedTypeaheadInfo.current.length && comparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              ++i;
            }

            if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
          }
        }
      }, [currentTypeahead]);
      var useTypeaheadNavigationChild = A$1(_ref => {
        var {
          text
        } = _ref,
            i = _objectWithoutProperties(_ref, _excluded$D);

        y(() => {
          if (text) {
            // Find where to insert this item.
            // Because all index values should be unique, the returned sortedIndex
            // should always refer to a new location (i.e. be negative)                
            var sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, comparator);
            console.assert(sortedIndex < 0);

            if (sortedIndex < 0) {
              sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, {
                text,
                unsortedIndex: i.index
              });
            }

            return () => {
              // When unmounting, find where we were and remove ourselves.
              // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
              var sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, comparator);
              console.assert(sortedIndex >= 0);

              if (sortedIndex >= 0) {
                sortedTypeaheadInfo.current.splice(sortedIndex, 1);
              }
            };
          }
        }, [text]);

        var useTypeaheadNavigationChildProps = function (_ref2) {
          var props = _extends({}, _ref2);

          var {
            useRefElementProps,
            element
          } = useRefElement();

          var onCompositionStart = e => {
            setImeActive(true);
          };

          var onCompositionEnd = e => {
            setNextTypeaheadChar(e.data);
            setImeActive(false);
          };

          var onKeyDown = e => {
            var imeActive = getImeActive();
            var key = e.key; // Not handled by typeahead (i.e. assume this is a keyboard shortcut)

            if (e.ctrlKey || e.metaKey) return;

            if (!imeActive && e.key === "Backspace") {
              // Remove the last character in a way that doesn't split UTF-16 surrogates.
              setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
              e.preventDefault();
              e.stopPropagation();
              return;
            } // The key property represents the typed character OR the "named key attribute" of the key pressed.
            // There's no definite way to tell the difference, but for all intents and purposes
            // there are no one-character names, and there are no non-ASCII-alpha names.
            // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.


            var isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);

            if (isCharacterKey) {
              var _getCurrentTypeahead;

              if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ; else {
                e.preventDefault();
                e.stopPropagation(); // Note: Won't be true for the first keydown
                // but will be overwritten before useLayoutEffect is called
                // to actually apply the change

                if (!imeActive) setNextTypeaheadChar(key);
              }
            }
          };

          return useMergedProps()(useRefElementProps({
            onKeyDown,
            onCompositionStart,
            onCompositionEnd
          }), props);
        };

        return {
          useTypeaheadNavigationChildProps
        };
      }, []);
      return {
        useTypeaheadNavigationChild,
        currentTypeahead,
        invalidTypeahead
      };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */

    function binarySearch(array, wanted, comparator) {
      var firstIndex = 0;
      var lastIndex = array.length - 1;

      while (firstIndex <= lastIndex) {
        var testIndex = lastIndex + firstIndex >> 1;
        var comparisonResult = comparator(wanted, array[testIndex]);

        if (comparisonResult > 0) {
          firstIndex = testIndex + 1;
        } else if (comparisonResult < 0) {
          lastIndex = testIndex - 1;
        } else {
          return testIndex;
        }
      }

      return -firstIndex - 1;
    }

    var _excluded$C = ["managedChildren", "indicesByElement", "useRovingTabIndexChild", "focusSelf"];
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */

    function useListNavigation({
      focusOnChange,
      collator,
      keyNavigation
    }) {
      var _keyNavigation;

      (_keyNavigation = keyNavigation) !== null && _keyNavigation !== void 0 ? _keyNavigation : keyNavigation = "either"; // Keep track of three things related to the currently tabbable element's index:
      // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.

      var [tabbableIndex, setTabbableIndex, getTabbableIndex] = useState(0);
      var setIndex = A$1(index => {
        setTabbableIndex(index);
      }, []);

      var _useRovingTabIndex = useRovingTabIndex({
        focusOnChange,
        tabbableIndex: tabbableIndex
      }),
          {
        managedChildren,
        indicesByElement,
        useRovingTabIndexChild,
        focusSelf
      } = _useRovingTabIndex,
          rest = _objectWithoutProperties(_useRovingTabIndex, _excluded$C);

      var {
        currentTypeahead,
        invalidTypeahead,
        useTypeaheadNavigationChild
      } = useTypeaheadNavigation({
        collator,
        getIndex: getTabbableIndex,
        setIndex,
        typeaheadTimeout: 1000
      });
      var {
        navigateToEnd,
        navigateToIndex,
        navigateToNext,
        navigateToPrev,
        navigateToStart,
        useLinearNavigationChild
      } = useLinearNavigation({
        getIndex: getTabbableIndex,
        setIndex,
        managedChildren
      });
      var useListNavigationChild = A$1(info => {
        var {
          useTypeaheadNavigationChildProps
        } = useTypeaheadNavigationChild(info);
        var {
          useLinearNavigationChildProps
        } = useLinearNavigationChild();
        var {
          useRovingTabIndexChildProps,
          useRovingTabIndexSiblingProps,
          tabbable
        } = useRovingTabIndexChild(info);

        var useListNavigationChildProps = function (_ref) {
          var props = _extends({}, _ref);

          return useMergedProps()(useRovingTabIndexChildProps(useTypeaheadNavigationChildProps(useLinearNavigationChildProps({
            onClick: roveToSelf
          }))), props);
        };

        var roveToSelf = A$1(() => {
          navigateToIndex(info.index);
        }, []);
        return {
          useListNavigationChildProps,
          useListNavigationSiblingProps: useRovingTabIndexSiblingProps,
          tabbable //roveToSelf,
          //element

        };
      }, [useTypeaheadNavigationChild, useLinearNavigationChild, useRovingTabIndexChild, navigateToIndex]);
      return _objectSpread2({
        useListNavigationChild,
        currentTypeahead,
        invalidTypeahead,
        tabbableIndex,
        setTabbableIndex,
        managedChildren,
        indicesByElement,
        navigateToIndex,
        navigateToNext,
        navigateToPrev,
        navigateToStart,
        navigateToEnd,
        focusSelf
      }, rest);
    }

    /*!
    * tabbable 5.2.0
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };

    var isHidden = function isHidden(node, displayCheck) {
      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      }

      if (!displayCheck || displayCheck === 'full') {
        while (node) {
          if (getComputedStyle(node).display === 'none') {
            return true;
          }

          node = node.parentElement;
        }
      } else if (displayCheck === 'non-zero-area') {
        var _node$getBoundingClie = node.getBoundingClientRect(),
            width = _node$getBoundingClie.width,
            height = _node$getBoundingClie.height;

        return width === 0 && height === 0;
      }

      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options.displayCheck) ||
      /* For a details element with a summary, the summary element gets the focused  */
      isDetailsWithSummary(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
      var _a, _b, _c;
      /* Symbols for private properties */


      var _blockingElements = Symbol();

      var _alreadyInertElements = Symbol();

      var _topElParents = Symbol();

      var _siblingsToRestore = Symbol();

      var _parentMO = Symbol();
      /* Symbols for private static methods */


      var _topChanged = Symbol();

      var _swapInertedSibling = Symbol();

      var _inertSiblings = Symbol();

      var _restoreInertedSiblings = Symbol();

      var _getParents = Symbol();

      var _getDistributedChildren = Symbol();

      var _isInertable = Symbol();

      var _handleMutations = Symbol();

      class BlockingElementsImpl {
        constructor() {
          /**
           * The blocking elements.
           */
          this[_a] = [];
          /**
           * Used to keep track of the parents of the top element, from the element
           * itself up to body. When top changes, the old top might have been removed
           * from the document, so we need to memoize the inerted parents' siblings
           * in order to restore their inerteness when top changes.
           */

          this[_b] = [];
          /**
           * Elements that are already inert before the first blocking element is
           * pushed.
           */

          this[_c] = new Set();
        }

        destructor() {
          // Restore original inertness.
          this[_restoreInertedSiblings](this[_topElParents]); // Note we don't want to make these properties nullable on the class,
          // since then we'd need non-null casts in many places. Calling a method on
          // a BlockingElements instance after calling destructor will result in an
          // exception.


          var nullable = this;
          nullable[_blockingElements] = null;
          nullable[_topElParents] = null;
          nullable[_alreadyInertElements] = null;
        }

        get top() {
          var elems = this[_blockingElements];
          return elems[elems.length - 1] || null;
        }

        push(element) {
          if (!element || element === this.top) {
            return;
          } // Remove it from the stack, we'll bring it to the top.


          this.remove(element);

          this[_topChanged](element);

          this[_blockingElements].push(element);
        }

        remove(element) {
          var i = this[_blockingElements].indexOf(element);

          if (i === -1) {
            return false;
          }

          this[_blockingElements].splice(i, 1); // Top changed only if the removed element was the top element.


          if (i === this[_blockingElements].length) {
            this[_topChanged](this.top);
          }

          return true;
        }

        pop() {
          var top = this.top;
          top && this.remove(top);
          return top;
        }

        has(element) {
          return this[_blockingElements].indexOf(element) !== -1;
        }
        /**
         * Sets `inert` to all document elements except the new top element, its
         * parents, and its distributed content.
         */


        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
          var toKeepInert = this[_alreadyInertElements];
          var oldParents = this[_topElParents]; // No new top, reset old top if any.

          if (!newTop) {
            this[_restoreInertedSiblings](oldParents);

            toKeepInert.clear();
            this[_topElParents] = [];
            return;
          }

          var newParents = this[_getParents](newTop); // New top is not contained in the main document!


          if (newParents[newParents.length - 1].parentNode !== document.body) {
            throw Error('Non-connected element cannot be a blocking element');
          } // Cast here because we know we'll call _inertSiblings on newParents
          // below.


          this[_topElParents] = newParents;

          var toSkip = this[_getDistributedChildren](newTop); // No previous top element.


          if (!oldParents.length) {
            this[_inertSiblings](newParents, toSkip, toKeepInert);

            return;
          }

          var i = oldParents.length - 1;
          var j = newParents.length - 1; // Find common parent. Index 0 is the element itself (so stop before it).

          while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
            i--;
            j--;
          } // If up the parents tree there are 2 elements that are siblings, swap
          // the inerted sibling.


          if (oldParents[i] !== newParents[j]) {
            this[_swapInertedSibling](oldParents[i], newParents[j]);
          } // Restore old parents siblings inertness.


          i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i)); // Make new parents siblings inert.

          j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
        }
        /**
         * Swaps inertness between two sibling elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_swapInertedSibling](oldInert, newInert) {
          var siblingsToRestore = oldInert[_siblingsToRestore]; // oldInert is not contained in siblings to restore, so we have to check
          // if it's inertable and if already inert.

          if (this[_isInertable](oldInert) && !oldInert.inert) {
            oldInert.inert = true;
            siblingsToRestore.add(oldInert);
          } // If newInert was already between the siblings to restore, it means it is
          // inertable and must be restored.


          if (siblingsToRestore.has(newInert)) {
            newInert.inert = false;
            siblingsToRestore.delete(newInert);
          }

          newInert[_parentMO] = oldInert[_parentMO];
          newInert[_siblingsToRestore] = siblingsToRestore;
          oldInert[_parentMO] = undefined;
          oldInert[_siblingsToRestore] = undefined;
        }
        /**
         * Restores original inertness to the siblings of the elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_restoreInertedSiblings](elements) {
          for (var element of elements) {
            var mo = element[_parentMO];
            mo.disconnect();
            element[_parentMO] = undefined;
            var siblings = element[_siblingsToRestore];

            for (var sibling of siblings) {
              sibling.inert = false;
            }

            element[_siblingsToRestore] = undefined;
          }
        }
        /**
         * Inerts the siblings of the elements except the elements to skip. Stores
         * the inerted siblings into the element's symbol `_siblingsToRestore`.
         * Pass `toKeepInert` to collect the already inert elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_inertSiblings](elements, toSkip, toKeepInert) {
          for (var element of elements) {
            // Assume element is not a Document, so it must have a parentNode.
            var parent = element.parentNode;
            var children = parent.children;
            var inertedSiblings = new Set();

            for (var j = 0; j < children.length; j++) {
              var sibling = children[j]; // Skip the input element, if not inertable or to be skipped.

              if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
                continue;
              } // Should be collected since already inerted.


              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            } // Store the siblings that were inerted.


            element[_siblingsToRestore] = inertedSiblings; // Observe only immediate children mutations on the parent.

            var mo = new MutationObserver(this[_handleMutations].bind(this));
            element[_parentMO] = mo;
            var parentToObserve = parent; // If we're using the ShadyDOM polyfill, then our parent could be a
            // shady root, which is an object that acts like a ShadowRoot, but isn't
            // actually a node in the real DOM. Observe the real DOM parent instead.

            var maybeShadyRoot = parentToObserve;

            if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
              parentToObserve = maybeShadyRoot.host;
            }

            mo.observe(parentToObserve, {
              childList: true
            });
          }
        }
        /**
         * Handles newly added/removed nodes by toggling their inertness.
         * It also checks if the current top Blocking Element has been removed,
         * notifying and removing it.
         */


        [_handleMutations](mutations) {
          var parents = this[_topElParents];
          var toKeepInert = this[_alreadyInertElements];

          for (var mutation of mutations) {
            // If the target is a shadowRoot, get its host as we skip shadowRoots when
            // computing _topElParents.
            var target = mutation.target.host || mutation.target;
            var idx = target === document.body ? parents.length : parents.indexOf(target);
            var inertedChild = parents[idx - 1];
            var inertedSiblings = inertedChild[_siblingsToRestore]; // To restore.

            for (var i = 0; i < mutation.removedNodes.length; i++) {
              var sibling = mutation.removedNodes[i];

              if (sibling === inertedChild) {
                console.info('Detected removal of the top Blocking Element.');
                this.pop();
                return;
              }

              if (inertedSiblings.has(sibling)) {
                sibling.inert = false;
                inertedSiblings.delete(sibling);
              }
            } // To inert.


            for (var _i = 0; _i < mutation.addedNodes.length; _i++) {
              var _sibling = mutation.addedNodes[_i];

              if (!this[_isInertable](_sibling)) {
                continue;
              }

              if (toKeepInert && _sibling.inert) {
                toKeepInert.add(_sibling);
              } else {
                _sibling.inert = true;
                inertedSiblings.add(_sibling);
              }
            }
          }
        }
        /**
         * Returns if the element is inertable.
         */


        [_isInertable](element) {
          return false === /^(style|template|script)$/.test(element.localName);
        }
        /**
         * Returns the list of newParents of an element, starting from element
         * (included) up to `document.body` (excluded).
         */


        [_getParents](element) {
          var parents = [];
          var current = element; // Stop to body.

          while (current && current !== document.body) {
            // Skip shadow roots.
            if (current.nodeType === Node.ELEMENT_NODE) {
              parents.push(current);
            } // ShadowDom v1


            if (current.assignedSlot) {
              // Collect slots from deepest slot to top.
              while (current = current.assignedSlot) {
                parents.push(current);
              } // Continue the search on the top slot.


              current = parents.pop();
              continue;
            }

            current = current.parentNode || current.host;
          }

          return parents;
        }
        /**
         * Returns the distributed children of the element's shadow root.
         * Returns null if the element doesn't have a shadow root.
         */


        [_getDistributedChildren](element) {
          var shadowRoot = element.shadowRoot;

          if (!shadowRoot) {
            return null;
          }

          var result = new Set();
          var i;
          var j;
          var nodes;
          var slots = shadowRoot.querySelectorAll('slot');

          if (slots.length && slots[0].assignedNodes) {
            for (i = 0; i < slots.length; i++) {
              nodes = slots[i].assignedNodes({
                flatten: true
              });

              for (j = 0; j < nodes.length; j++) {
                if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                  result.add(nodes[j]);
                }
              }
            } // No need to search for <content>.

          }

          return result;
        }

      }

      document.$blockingElements = new BlockingElementsImpl();
    })();

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    createCommonjsModule(function (module, exports) {
      (function (global, factory) {
        factory() ;
      })(commonjsGlobal, function () {

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        /**
         * This work is licensed under the W3C Software and Document License
         * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
         */


        (function () {
          // Return early if we're not running inside of the browser.
          if (typeof window === 'undefined') {
            return;
          } // Convenience function for converting NodeLists.

          /** @type {typeof Array.prototype.slice} */


          var slice = Array.prototype.slice;
          /**
           * IE has a non-standard name for "matches".
           * @type {typeof Element.prototype.matches}
           */

          var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
          /** @type {string} */

          var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
          /**
           * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
           * attribute.
           *
           * Its main functions are:
           *
           * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
           *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
           *   each focusable node in the subtree with the singleton `InertManager` which manages all known
           *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
           *   instance exists for each focusable node which has at least one inert root as an ancestor.
           *
           * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
           *   attribute is removed from the root node). This is handled in the destructor, which calls the
           *   `deregister` method on `InertManager` for each managed inert node.
           */


          var InertRoot = function () {
            /**
             * @param {!Element} rootElement The Element at the root of the inert subtree.
             * @param {!InertManager} inertManager The global singleton InertManager object.
             */
            function InertRoot(rootElement, inertManager) {
              _classCallCheck(this, InertRoot);
              /** @type {!InertManager} */


              this._inertManager = inertManager;
              /** @type {!Element} */

              this._rootElement = rootElement;
              /**
               * @type {!Set<!InertNode>}
               * All managed focusable nodes in this InertRoot's subtree.
               */

              this._managedNodes = new Set(); // Make the subtree hidden from assistive technology

              if (this._rootElement.hasAttribute('aria-hidden')) {
                /** @type {?string} */
                this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
              } else {
                this._savedAriaHidden = null;
              }

              this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes


              this._makeSubtreeUnfocusable(this._rootElement); // Watch for:
              // - any additions in the subtree: make them unfocusable too
              // - any removals from the subtree: remove them from this inert root's managed nodes
              // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
              //   element, make that node a managed node.


              this._observer = new MutationObserver(this._onMutation.bind(this));

              this._observer.observe(this._rootElement, {
                attributes: true,
                childList: true,
                subtree: true
              });
            }
            /**
             * Call this whenever this object is about to become obsolete.  This unwinds all of the state
             * stored in this object and updates the state of all of the managed nodes.
             */


            _createClass(InertRoot, [{
              key: 'destructor',
              value: function destructor() {
                this._observer.disconnect();

                if (this._rootElement) {
                  if (this._savedAriaHidden !== null) {
                    this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                  } else {
                    this._rootElement.removeAttribute('aria-hidden');
                  }
                }

                this._managedNodes.forEach(function (inertNode) {
                  this._unmanageNode(inertNode.node);
                }, this); // Note we cast the nulls to the ANY type here because:
                // 1) We want the class properties to be declared as non-null, or else we
                //    need even more casts throughout this code. All bets are off if an
                //    instance has been destroyed and a method is called.
                // 2) We don't want to cast "this", because we want type-aware optimizations
                //    to know which properties we're setting.


                this._observer =
                /** @type {?} */
                null;
                this._rootElement =
                /** @type {?} */
                null;
                this._managedNodes =
                /** @type {?} */
                null;
                this._inertManager =
                /** @type {?} */
                null;
              }
              /**
               * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
               */

            }, {
              key: '_makeSubtreeUnfocusable',

              /**
               * @param {!Node} startNode
               */
              value: function _makeSubtreeUnfocusable(startNode) {
                var _this2 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this2._visitNode(node);
                });
                var activeElement = document.activeElement;

                if (!document.body.contains(startNode)) {
                  // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                  var node = startNode;
                  /** @type {!ShadowRoot|undefined} */

                  var root = undefined;

                  while (node) {
                    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      root =
                      /** @type {!ShadowRoot} */
                      node;
                      break;
                    }

                    node = node.parentNode;
                  }

                  if (root) {
                    activeElement = root.activeElement;
                  }
                }

                if (startNode.contains(activeElement)) {
                  activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1
                  // calling blur() will not actually move the focus.
                  // To work around this we call focus() on the body instead.

                  if (activeElement === document.activeElement) {
                    document.body.focus();
                  }
                }
              }
              /**
               * @param {!Node} node
               */

            }, {
              key: '_visitNode',
              value: function _visitNode(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!Element} */
                node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of
                // this inert root, so all of its managed nodes need to be adopted by this InertRoot.

                if (element !== this._rootElement && element.hasAttribute('inert')) {
                  this._adoptInertRoot(element);
                }

                if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                  this._manageNode(element);
                }
              }
              /**
               * Register the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_manageNode',
              value: function _manageNode(node) {
                var inertNode = this._inertManager.register(node, this);

                this._managedNodes.add(inertNode);
              }
              /**
               * Unregister the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_unmanageNode',
              value: function _unmanageNode(node) {
                var inertNode = this._inertManager.deregister(node, this);

                if (inertNode) {
                  this._managedNodes['delete'](inertNode);
                }
              }
              /**
               * Unregister the entire subtree starting at `startNode`.
               * @param {!Node} startNode
               */

            }, {
              key: '_unmanageSubtree',
              value: function _unmanageSubtree(startNode) {
                var _this3 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this3._unmanageNode(node);
                });
              }
              /**
               * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
               * @param {!Element} node
               */

            }, {
              key: '_adoptInertRoot',
              value: function _adoptInertRoot(node) {
                var inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,
                // so register it now if need be.


                if (!inertSubroot) {
                  this._inertManager.setInert(node, true);

                  inertSubroot = this._inertManager.getInertRoot(node);
                }

                inertSubroot.managedNodes.forEach(function (savedInertNode) {
                  this._manageNode(savedInertNode.node);
                }, this);
              }
              /**
               * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_onMutation',
              value: function _onMutation(records, self) {
                records.forEach(function (record) {
                  var target =
                  /** @type {!Element} */
                  record.target;

                  if (record.type === 'childList') {
                    // Manage added nodes
                    slice.call(record.addedNodes).forEach(function (node) {
                      this._makeSubtreeUnfocusable(node);
                    }, this); // Un-manage removed nodes

                    slice.call(record.removedNodes).forEach(function (node) {
                      this._unmanageSubtree(node);
                    }, this);
                  } else if (record.type === 'attributes') {
                    if (record.attributeName === 'tabindex') {
                      // Re-initialise inert node if tabindex changes
                      this._manageNode(target);
                    } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                      // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                      // already managed nodes from this inert subroot.
                      this._adoptInertRoot(target);

                      var inertSubroot = this._inertManager.getInertRoot(target);

                      this._managedNodes.forEach(function (managedNode) {
                        if (target.contains(managedNode.node)) {
                          inertSubroot._manageNode(managedNode.node);
                        }
                      });
                    }
                  }
                }, this);
              }
            }, {
              key: 'managedNodes',
              get: function get() {
                return new Set(this._managedNodes);
              }
              /** @return {boolean} */

            }, {
              key: 'hasSavedAriaHidden',
              get: function get() {
                return this._savedAriaHidden !== null;
              }
              /** @param {?string} ariaHidden */

            }, {
              key: 'savedAriaHidden',
              set: function set(ariaHidden) {
                this._savedAriaHidden = ariaHidden;
              }
              /** @return {?string} */
              ,
              get: function get() {
                return this._savedAriaHidden;
              }
            }]);

            return InertRoot;
          }();
          /**
           * `InertNode` initialises and manages a single inert node.
           * A node is inert if it is a descendant of one or more inert root elements.
           *
           * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
           * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
           * is intrinsically focusable or not.
           *
           * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
           * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
           * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
           * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
           * or removes the `tabindex` attribute if the element is intrinsically focusable.
           */


          var InertNode = function () {
            /**
             * @param {!Node} node A focusable element to be made inert.
             * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
             */
            function InertNode(node, inertRoot) {
              _classCallCheck(this, InertNode);
              /** @type {!Node} */


              this._node = node;
              /** @type {boolean} */

              this._overrodeFocusMethod = false;
              /**
               * @type {!Set<!InertRoot>} The set of descendant inert roots.
               *    If and only if this set becomes empty, this node is no longer inert.
               */

              this._inertRoots = new Set([inertRoot]);
              /** @type {?number} */

              this._savedTabIndex = null;
              /** @type {boolean} */

              this._destroyed = false; // Save any prior tabindex info and make this node untabbable

              this.ensureUntabbable();
            }
            /**
             * Call this whenever this object is about to become obsolete.
             * This makes the managed node focusable again and deletes all of the previously stored state.
             */


            _createClass(InertNode, [{
              key: 'destructor',
              value: function destructor() {
                this._throwIfDestroyed();

                if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                  var element =
                  /** @type {!Element} */
                  this._node;

                  if (this._savedTabIndex !== null) {
                    element.setAttribute('tabindex', this._savedTabIndex);
                  } else {
                    element.removeAttribute('tabindex');
                  } // Use `delete` to restore native focus method.


                  if (this._overrodeFocusMethod) {
                    delete element.focus;
                  }
                } // See note in InertRoot.destructor for why we cast these nulls to ANY.


                this._node =
                /** @type {?} */
                null;
                this._inertRoots =
                /** @type {?} */
                null;
                this._destroyed = true;
              }
              /**
               * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
               * If the object has been destroyed, any attempt to access it will cause an exception.
               */

            }, {
              key: '_throwIfDestroyed',

              /**
               * Throw if user tries to access destroyed InertNode.
               */
              value: function _throwIfDestroyed() {
                if (this.destroyed) {
                  throw new Error('Trying to access destroyed InertNode');
                }
              }
              /** @return {boolean} */

            }, {
              key: 'ensureUntabbable',

              /** Save the existing tabindex value and make the node untabbable and unfocusable */
              value: function ensureUntabbable() {
                if (this.node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!Element} */
                this.node;

                if (matches.call(element, _focusableElementsString)) {
                  if (
                  /** @type {!HTMLElement} */
                  element.tabIndex === -1 && this.hasSavedTabIndex) {
                    return;
                  }

                  if (element.hasAttribute('tabindex')) {
                    this._savedTabIndex =
                    /** @type {!HTMLElement} */
                    element.tabIndex;
                  }

                  element.setAttribute('tabindex', '-1');

                  if (element.nodeType === Node.ELEMENT_NODE) {
                    element.focus = function () {};

                    this._overrodeFocusMethod = true;
                  }
                } else if (element.hasAttribute('tabindex')) {
                  this._savedTabIndex =
                  /** @type {!HTMLElement} */
                  element.tabIndex;
                  element.removeAttribute('tabindex');
                }
              }
              /**
               * Add another inert root to this inert node's set of managing inert roots.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'addInertRoot',
              value: function addInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots.add(inertRoot);
              }
              /**
               * Remove the given inert root from this inert node's set of managing inert roots.
               * If the set of managing inert roots becomes empty, this node is no longer inert,
               * so the object should be destroyed.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'removeInertRoot',
              value: function removeInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots['delete'](inertRoot);

                if (this._inertRoots.size === 0) {
                  this.destructor();
                }
              }
            }, {
              key: 'destroyed',
              get: function get() {
                return (
                  /** @type {!InertNode} */
                  this._destroyed
                );
              }
            }, {
              key: 'hasSavedTabIndex',
              get: function get() {
                return this._savedTabIndex !== null;
              }
              /** @return {!Node} */

            }, {
              key: 'node',
              get: function get() {
                this._throwIfDestroyed();

                return this._node;
              }
              /** @param {?number} tabIndex */

            }, {
              key: 'savedTabIndex',
              set: function set(tabIndex) {
                this._throwIfDestroyed();

                this._savedTabIndex = tabIndex;
              }
              /** @return {?number} */
              ,
              get: function get() {
                this._throwIfDestroyed();

                return this._savedTabIndex;
              }
            }]);

            return InertNode;
          }();
          /**
           * InertManager is a per-document singleton object which manages all inert roots and nodes.
           *
           * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
           * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
           * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
           * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
           * is created for each such node, via the `_managedNodes` map.
           */


          var InertManager = function () {
            /**
             * @param {!Document} document
             */
            function InertManager(document) {
              _classCallCheck(this, InertManager);

              if (!document) {
                throw new Error('Missing required argument; InertManager needs to wrap a document.');
              }
              /** @type {!Document} */


              this._document = document;
              /**
               * All managed nodes known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertNode>}
               */

              this._managedNodes = new Map();
              /**
               * All inert roots known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertRoot>}
               */

              this._inertRoots = new Map();
              /**
               * Observer for mutations on `document.body`.
               * @type {!MutationObserver}
               */

              this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.

              addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.

              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
              } else {
                this._onDocumentLoaded();
              }
            }
            /**
             * Set whether the given element should be an inert root or not.
             * @param {!Element} root
             * @param {boolean} inert
             */


            _createClass(InertManager, [{
              key: 'setInert',
              value: function setInert(root, inert) {
                if (inert) {
                  if (this._inertRoots.has(root)) {
                    // element is already inert
                    return;
                  }

                  var inertRoot = new InertRoot(root, this);
                  root.setAttribute('inert', '');

                  this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.
                  // Ensure inert styles are added there.


                  if (!this._document.body.contains(root)) {
                    var parent = root.parentNode;

                    while (parent) {
                      if (parent.nodeType === 11) {
                        addInertStyle(parent);
                      }

                      parent = parent.parentNode;
                    }
                  }
                } else {
                  if (!this._inertRoots.has(root)) {
                    // element is already non-inert
                    return;
                  }

                  var _inertRoot = this._inertRoots.get(root);

                  _inertRoot.destructor();

                  this._inertRoots['delete'](root);

                  root.removeAttribute('inert');
                }
              }
              /**
               * Get the InertRoot object corresponding to the given inert root element, if any.
               * @param {!Node} element
               * @return {!InertRoot|undefined}
               */

            }, {
              key: 'getInertRoot',
              value: function getInertRoot(element) {
                return this._inertRoots.get(element);
              }
              /**
               * Register the given InertRoot as managing the given node.
               * In the case where the node has a previously existing inert root, this inert root will
               * be added to its set of inert roots.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {!InertNode} inertNode
               */

            }, {
              key: 'register',
              value: function register(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (inertNode !== undefined) {
                  // node was already in an inert subtree
                  inertNode.addInertRoot(inertRoot);
                } else {
                  inertNode = new InertNode(node, inertRoot);
                }

                this._managedNodes.set(node, inertNode);

                return inertNode;
              }
              /**
               * De-register the given InertRoot as managing the given inert node.
               * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
               * node from the InertManager's set of managed nodes if it is destroyed.
               * If the node is not currently managed, this is essentially a no-op.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
               */

            }, {
              key: 'deregister',
              value: function deregister(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (!inertNode) {
                  return null;
                }

                inertNode.removeInertRoot(inertRoot);

                if (inertNode.destroyed) {
                  this._managedNodes['delete'](node);
                }

                return inertNode;
              }
              /**
               * Callback used when document has finished loading.
               */

            }, {
              key: '_onDocumentLoaded',
              value: function _onDocumentLoaded() {
                // Find all inert roots in document and make them actually inert.
                var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
                inertElements.forEach(function (inertElement) {
                  this.setInert(inertElement, true);
                }, this); // Comment this out to use programmatic API only.

                this._observer.observe(this._document.body || this._document.documentElement, {
                  attributes: true,
                  subtree: true,
                  childList: true
                });
              }
              /**
               * Callback used when mutation observer detects attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_watchForInert',
              value: function _watchForInert(records, self) {
                var _this = this;

                records.forEach(function (record) {
                  switch (record.type) {
                    case 'childList':
                      slice.call(record.addedNodes).forEach(function (node) {
                        if (node.nodeType !== Node.ELEMENT_NODE) {
                          return;
                        }

                        var inertElements = slice.call(node.querySelectorAll('[inert]'));

                        if (matches.call(node, '[inert]')) {
                          inertElements.unshift(node);
                        }

                        inertElements.forEach(function (inertElement) {
                          this.setInert(inertElement, true);
                        }, _this);
                      }, _this);
                      break;

                    case 'attributes':
                      if (record.attributeName !== 'inert') {
                        return;
                      }

                      var target =
                      /** @type {!Element} */
                      record.target;
                      var inert = target.hasAttribute('inert');

                      _this.setInert(target, inert);

                      break;
                  }
                }, this);
              }
            }]);

            return InertManager;
          }();
          /**
           * Recursively walk the composed tree from |node|.
           * @param {!Node} node
           * @param {(function (!Element))=} callback Callback to be called for each element traversed,
           *     before descending into child nodes.
           * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
           */


          function composedTreeWalk(node, callback, shadowRootAncestor) {
            if (node.nodeType == Node.ELEMENT_NODE) {
              var element =
              /** @type {!Element} */
              node;

              if (callback) {
                callback(element);
              } // Descend into node:
              // If it has a ShadowRoot, ignore all child elements - these will be picked
              // up by the <content> or <shadow> elements. Descend straight into the
              // ShadowRoot.


              var shadowRoot =
              /** @type {!HTMLElement} */
              element.shadowRoot;

              if (shadowRoot) {
                composedTreeWalk(shadowRoot, callback);
                return;
              } // If it is a <content> element, descend into distributed elements - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'content') {
                var content =
                /** @type {!HTMLContentElement} */
                element; // Verifies if ShadowDom v0 is supported.

                var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];

                for (var i = 0; i < distributedNodes.length; i++) {
                  composedTreeWalk(distributedNodes[i], callback);
                }

                return;
              } // If it is a <slot> element, descend into assigned nodes - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'slot') {
                var slot =
                /** @type {!HTMLSlotElement} */
                element; // Verify if ShadowDom v1 is supported.

                var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                  flatten: true
                }) : [];

                for (var _i = 0; _i < _distributedNodes.length; _i++) {
                  composedTreeWalk(_distributedNodes[_i], callback);
                }

                return;
              }
            } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
            // element, nor a <shadow> element recurse normally.


            var child = node.firstChild;

            while (child != null) {
              composedTreeWalk(child, callback);
              child = child.nextSibling;
            }
          }
          /**
           * Adds a style element to the node containing the inert specific styles
           * @param {!Node} node
           */


          function addInertStyle(node) {
            if (node.querySelector('style#inert-style, link#inert-style')) {
              return;
            }

            var style = document.createElement('style');
            style.setAttribute('id', 'inert-style');
            style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
            node.appendChild(style);
          }

          if (!Element.prototype.hasOwnProperty('inert')) {
            /** @type {!InertManager} */
            var inertManager = new InertManager(document);
            Object.defineProperty(Element.prototype, 'inert', {
              enumerable: true,

              /** @this {!Element} */
              get: function get() {
                return this.hasAttribute('inert');
              },

              /** @this {!Element} */
              set: function set(inert) {
                inertManager.setInert(this, inert);
              }
            });
          }
        })();
      });
    });

    var blockingElements = document.$blockingElements;
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */

    function useBlockingElement(target) {
      /**
       * Push/pop the element from the blockingElements stack.
       */
      h(() => {
        if (target) {
          blockingElements.push(target);
          return () => {
            blockingElements.remove(target);
          };
        }
      }, [target]);
    }
    function getTopElement() {
      return blockingElements.top;
    }

    var elementsToRestoreFocusTo = new Map();
    function useFocusTrap({
      trapActive
    }) {
      var {
        element,
        useRefElementProps,
        getElement
      } = useRefElement();
      var {
        getLastActiveElement
      } = useActiveElement(); // When the trap becomes active, before we let the blockingElements hook run,
      // keep track of whatever's currently focused and save it.

      h(() => {
        if (trapActive && element) {
          var _getLastActiveElement;

          // Save the currently focused element
          // to whatever's currently at the top of the stack
          elementsToRestoreFocusTo.set(getTopElement(), (_getLastActiveElement = getLastActiveElement()) !== null && _getLastActiveElement !== void 0 ? _getLastActiveElement : document.body);
        }
      }, [trapActive, element]);
      useBlockingElement(trapActive ? element : null);
      /**
       * Any time we activate or deactivate the trap,
       * change focus to something else (something in
       * the trap if it's active, or whatever we've
       * tracked in elementsToRestoreFocusTo if not)
       */

      h(() => {
        if (trapActive && element) {
          var rafHandle = requestAnimationFrame(() => {
            // TODO: This extra queueMicrotask is needed for
            // ...reasons?
            queueMicrotask(() => {
              var _findFirstFocusable;

              (_findFirstFocusable = findFirstFocusable(element)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        } else if (element) {
          // Restore the focus to the element
          // that has returned to the top of the stack
          var _rafHandle = requestAnimationFrame(() => {
            queueMicrotask(() => {
              var _elementsToRestoreFoc;

              (_elementsToRestoreFoc = elementsToRestoreFocusTo.get(getTopElement())) === null || _elementsToRestoreFoc === void 0 ? void 0 : _elementsToRestoreFoc.focus();
              _rafHandle = 0;
            });
          });

          return () => {
            if (_rafHandle) cancelAnimationFrame(_rafHandle);
          };
        }
      }, [trapActive, element]);

      var useFocusTrapProps = props => {
        return useMergedProps()({
          "aria-modal": trapActive ? "true" : undefined
        }, useRefElementProps(props));
      };

      return {
        useFocusTrapProps,
        element,
        getElement
      };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */

    function findFirstFocusable(element) {
      var treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: node => node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      });
      var firstFocusable = treeWalker.firstChild();
      return firstFocusable;
    }

    function useAriaTooltip({
      mouseoverDelay
    }) {
      var _mouseoverDelay;

      (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
      var [open, setOpen, getOpen] = useState(false);
      var [hasAnyMouseover, setHasAnyMouseover] = useState(false); //const [mouseoverIsValid, setMouseoverIsValid] = useState(false);

      var {
        useRandomIdProps: useTooltipIdProps,
        useReferencedIdProps: useTooltipIdReferencingProps
      } = useRandomId({
        prefix: "aria-tooltip-"
      });
      var {
        focusedInner: triggerFocused,
        useHasFocusProps
      } = useHasFocus();
      var [triggerHasMouseover, setTriggerHasMouseover] = useState(false);
      var [tooltipHasMouseover, setTooltipHasMouseover] = useState(false);
      useTimeout({
        timeout: mouseoverDelay,
        triggerIndex: +triggerHasMouseover + +tooltipHasMouseover,
        callback: () => {
          if (triggerHasMouseover || tooltipHasMouseover) setHasAnyMouseover(true);
        }
      });
      useTimeout({
        timeout: 50,
        triggerIndex: +triggerHasMouseover + +tooltipHasMouseover,
        callback: () => {
          if (!triggerHasMouseover && !tooltipHasMouseover) setHasAnyMouseover(false);
        }
      });
      y(() => {
        setOpen(hasAnyMouseover || triggerFocused);
      }, [hasAnyMouseover, triggerFocused]);
      var useTooltipTrigger = A$1(function useTooltipTrigger() {
        function onPointerEnter(e) {
          setTriggerHasMouseover(true);
        }

        function onPointerLeave(e) {
          setTriggerHasMouseover(false);
        }

        function useTooltipTriggerProps(_ref) {
          var props = _extends({}, _ref);

          // Note: Though it's important to make sure that focusing activates a tooltip,
          // it's perfectly reasonable that a child element will be the one that's focused,
          // not this one, so we don't set tabIndex=0
          return useTooltipIdReferencingProps("aria-describedby")(useMergedProps()({
            onPointerEnter,
            onPointerLeave
          }, useHasFocusProps(props)));
        }

        return {
          useTooltipTriggerProps
        };
      }, [useTooltipIdReferencingProps]);
      var useTooltip = A$1(function useTooltip() {
        function onPointerEnter(e) {
          setTooltipHasMouseover(true);
        }

        function onPointerLeave(e) {
          setTooltipHasMouseover(false);
        }

        function useTooltipProps(_ref2) {
          var props = _extends({}, _ref2);

          props.role = "tooltip";
          return useTooltipIdProps(useMergedProps()({
            onPointerEnter,
            onPointerLeave
          }, props));
        }

        return {
          useTooltipProps
        };
      }, [useTooltipIdProps]);
      return {
        useTooltip,
        useTooltipTrigger,
        isOpen: open,
        getIsOpen: getOpen
      };
    }

    function S(n, t) {
      for (var e in t) {
        n[e] = t[e];
      }

      return n;
    }

    function C(n, t) {
      for (var e in n) {
        if ("__source" !== e && !(e in t)) return !0;
      }

      for (var r in t) {
        if ("__source" !== r && n[r] !== t[r]) return !0;
      }

      return !1;
    }

    function E(n) {
      this.props = n;
    }

    function g(n, t) {
      function e(n) {
        var e = this.props.ref,
            r = e == n.ref;
        return !r && e && (e.call ? e(null) : e.current = null), t ? !t(this.props, n) || !r : C(this.props, n);
      }

      function r(t) {
        return this.shouldComponentUpdate = e, v$1(n, t);
      }

      return r.displayName = "Memo(" + (n.displayName || n.name) + ")", r.prototype.isReactComponent = !0, r.__f = !0, r;
    }

    (E.prototype = new _$1()).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function (n, t) {
      return C(this.props, n) || C(this.state, t);
    };
    var w = l$1.__b;

    l$1.__b = function (n) {
      n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), w && w(n);
    };

    var R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;

    function x(n) {
      function t(t, e) {
        var r = S({}, t);
        return delete r.ref, n(r, (e = t.ref || e) && ("object" != typeof e || "current" in e) ? e : null);
      }

      return t.$$typeof = R, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
    }

    var A = l$1.__e;

    l$1.__e = function (n, t, e) {
      if (n.then) for (var r, u = t; u = u.__;) {
        if ((r = u.__c) && r.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), r.__c(n, t);
      }
      A(n, t, e);
    };

    var O = l$1.unmount;

    function L() {
      this.__u = 0, this.t = null, this.__b = null;
    }

    function U(n) {
      var t = n.__.__c;
      return t && t.__e && t.__e(n);
    }

    function M() {
      this.u = null, this.o = null;
    }

    l$1.unmount = function (n) {
      var t = n.__c;
      t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), O && O(n);
    }, (L.prototype = new _$1()).__c = function (n, t) {
      var e = t.__c,
          r = this;
      null == r.t && (r.t = []), r.t.push(e);

      var u = U(r.__v),
          o = !1,
          i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };

      e.__R = i;

      var l = function () {
        if (! --r.__u) {
          if (r.state.__e) {
            var n = r.state.__e;

            r.__v.__k[0] = function n(t, e, r) {
              return t && (t.__v = null, t.__k = t.__k && t.__k.map(function (t) {
                return n(t, e, r);
              }), t.__c && t.__c.__P === e && (t.__e && r.insertBefore(t.__e, t.__d), t.__c.__e = !0, t.__c.__P = r)), t;
            }(n, n.__c.__P, n.__c.__O);
          }

          var t;

          for (r.setState({
            __e: r.__b = null
          }); t = r.t.pop();) {
            t.forceUpdate();
          }
        }
      },
          f = !0 === t.__h;

      r.__u++ || f || r.setState({
        __e: r.__b = r.__v.__k[0]
      }), n.then(i, i);
    }, L.prototype.componentWillUnmount = function () {
      this.t = [];
    }, L.prototype.render = function (n, t) {
      if (this.__b) {
        if (this.__v.__k) {
          var e = document.createElement("div"),
              r = this.__v.__k[0].__c;

          this.__v.__k[0] = function n(t, e, r) {
            return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach(function (n) {
              "function" == typeof n.__c && n.__c();
            }), t.__c.__H = null), null != (t = S({}, t)).__c && (t.__c.__P === r && (t.__c.__P = e), t.__c = null), t.__k = t.__k && t.__k.map(function (t) {
              return n(t, e, r);
            })), t;
          }(this.__b, e, r.__O = r.__P);
        }

        this.__b = null;
      }

      var u = t.__e && v$1(d$1, null, n.fallback);
      return u && (u.__h = null), [v$1(d$1, null, t.__e ? null : n.children), u];
    };

    var T = function (n, t, e) {
      if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
        for (; e.length > 3;) {
          e.pop()();
        }

        if (e[1] < e[0]) break;
        n.u = e = e[2];
      }
    };

    function D(n) {
      return this.getChildContext = function () {
        return n.context;
      }, n.children;
    }

    function I(n) {
      var t = this,
          e = n.i;
      t.componentWillUnmount = function () {
        S$1(null, t.l), t.l = null, t.i = null;
      }, t.i && t.i !== e && t.componentWillUnmount(), n.__v ? (t.l || (t.i = e, t.l = {
        nodeType: 1,
        parentNode: e,
        childNodes: [],
        appendChild: function (n) {
          this.childNodes.push(n), t.i.appendChild(n);
        },
        insertBefore: function (n, e) {
          this.childNodes.push(n), t.i.appendChild(n);
        },
        removeChild: function (n) {
          this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), t.i.removeChild(n);
        }
      }), S$1(v$1(D, {
        context: t.context
      }, n.__v), t.l)) : t.l && t.componentWillUnmount();
    }

    function W(n, t) {
      return v$1(I, {
        __v: n,
        i: t
      });
    }

    (M.prototype = new _$1()).__e = function (n) {
      var t = this,
          e = U(t.__v),
          r = t.o.get(n);
      return r[0]++, function (u) {
        var o = function () {
          t.props.revealOrder ? (r.push(u), T(t, n, r)) : u();
        };

        e ? e(o) : o();
      };
    }, M.prototype.render = function (n) {
      this.u = null, this.o = new Map();
      var t = A$2(n.children);
      n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

      for (var e = t.length; e--;) {
        this.o.set(t[e], this.u = [1, 0, this.u]);
      }

      return n.children;
    }, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function () {
      var n = this;
      this.o.forEach(function (t, e) {
        T(n, e, t);
      });
    };

    var j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        P = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        V = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };

    _$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (n) {
      Object.defineProperty(_$1.prototype, n, {
        configurable: !0,
        get: function () {
          return this["UNSAFE_" + n];
        },
        set: function (t) {
          Object.defineProperty(this, n, {
            configurable: !0,
            writable: !0,
            value: t
          });
        }
      });
    });
    var H = l$1.event;

    function Z() {}

    function Y() {
      return this.cancelBubble;
    }

    function $() {
      return this.defaultPrevented;
    }

    l$1.event = function (n) {
      return H && (n = H(n)), n.persist = Z, n.isPropagationStopped = Y, n.isDefaultPrevented = $, n.nativeEvent = n;
    };

    var G = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
        J = l$1.vnode;

    l$1.vnode = function (n) {
      var t = n.type,
          e = n.props,
          r = e;

      if ("string" == typeof t) {
        for (var u in r = {}, e) {
          var o = e[u];
          "value" === u && "defaultValue" in e && null == o || ("defaultValue" === u && "value" in e && null == e.value ? u = "value" : "download" === u && !0 === o ? o = "" : /ondoubleclick/i.test(u) ? u = "ondblclick" : /^onchange(textarea|input)/i.test(u + t) && !V(e.type) ? u = "oninput" : /^on(Ani|Tra|Tou|BeforeInp)/.test(u) ? u = u.toLowerCase() : P.test(u) ? u = u.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === o && (o = void 0), r[u] = o);
        }

        "select" == t && r.multiple && Array.isArray(r.value) && (r.value = A$2(e.children).forEach(function (n) {
          n.props.selected = -1 != r.value.indexOf(n.props.value);
        })), "select" == t && null != r.defaultValue && (r.value = A$2(e.children).forEach(function (n) {
          n.props.selected = r.multiple ? -1 != r.defaultValue.indexOf(n.props.value) : r.defaultValue == n.props.value;
        })), n.props = r;
      }

      t && e.class != e.className && (G.enumerable = "className" in e, null != e.className && (r.class = e.className), Object.defineProperty(r, "className", G)), n.$$typeof = j, J && J(n);
    };

    var K = l$1.__r;

    l$1.__r = function (n) {
      K && K(n);
    };

    /**
     * Shortcut for preact/compat's `forwardRef` that auto-assumes some things that are useful for forwarding refs to `HTMLElements` specifically.
     * Namely it involves de-gunking the type system by letting us return *generic* function and playing nice with React. In all other respects, it acts like `forwardRef`.
     */

    function forwardElementRef$1(Component) {
      var ForwardedComponent = x(Component);
      return ForwardedComponent;
    }

    var _excluded$B = ["children", "duration", "classBase", "measure", "exitVisibility", "open", "onTransitionUpdate", "animateOnMount"];

    function getClassName(classBase, open, phase) {
      if (phase) return "".concat(classBase || "transition", "-").concat(open, "-").concat(phase);else return "".concat(classBase || "transition", "-").concat(open);
    }

    function forceReflow(e) {
      // Try really hard to make sure this isn't optimized out by anything.
      // We need it for its document reflow side effect.
      e.getBoundingClientRect();
      return e;
    }
    /**
     * A hook that adds & removes class names in a way that facilitates proper transitions.
     *
     * The first argument contains the props related directly to the transition.
     *
     * The second argument contains any other props you might want merged into the final product (these are not read or manipulated or anything -- it's purely shorthand and can be omitted with `{}` and then your own `useMergedProps`).
     */


    function useCreateTransitionableProps({
      measure,
      animateOnMount,
      classBase,
      onTransitionUpdate,
      exitVisibility,
      duration,
      open,
      ref
    }, otherProps) {
      var _classBase;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      var {
        element,
        useRefElementProps
      } = useRefElement();
      var [phase, setPhase] = l(animateOnMount ? "init" : null);
      var [direction, setDirection] = l(open == null ? null : open ? "enter" : "exit");
      var [surfaceWidth, setSurfaceWidth] = l(null);
      var [surfaceHeight, setSurfaceHeight] = l(null);
      var [surfaceX, setSurfaceX] = l(null);
      var [surfaceY, setSurfaceY] = l(null);
      var [transitioningWidth, setTransitioningWidth] = l(null);
      var [transitioningHeight, setTransitioningHeight] = l(null);
      var [transitioningX, setTransitioningX] = l(null);
      var [transitioningY, setTransitioningY] = l(null);
      var {
        getLogicalDirection
      } = useLogicalDirection(element);
      var logicalDirection = getLogicalDirection();
      var onTransitionUpdateRef = s(onTransitionUpdate);
      var phaseRef = s(phase);
      var directionRef = s(direction);
      var durationRef = s(duration);
      var tooEarlyTimeoutRef = s(null);
      var tooEarlyValueRef = s(true);
      var tooLateTimeoutRef = s(null);
      var onTransitionEnd = A$1(e => {
        if (e.target === element && tooEarlyValueRef.current == false) {
          setPhase("finalize");
        }
      }, [element]);
      h(() => {
        onTransitionUpdateRef.current = onTransitionUpdate;
      }, [onTransitionUpdate]);
      h(() => {
        phaseRef.current = phase;
      }, [phase]);
      h(() => {
        directionRef.current = direction;
      }, [direction]);
      h(() => {
        durationRef.current = duration;
      }, [duration]);
      h(() => {
        var _onTransitionUpdateRe;

        if (direction && phase) (_onTransitionUpdateRe = onTransitionUpdateRef.current) === null || _onTransitionUpdateRe === void 0 ? void 0 : _onTransitionUpdateRe.call(onTransitionUpdateRef, direction, phase);
      }, [direction, phase]); // Every time the phase changes to "transition", add our transition timeout timeouts
      // to catch any time onTransitionEnd fails to report for whatever reason to be safe

      h(() => {
        if (phase == "transition") {
          var _durationRef$current;

          var timeoutDuration = (_durationRef$current = durationRef.current) !== null && _durationRef$current !== void 0 ? _durationRef$current : 1000;
          tooEarlyTimeoutRef.current = window.setTimeout(() => {
            tooEarlyValueRef.current = false;
            tooEarlyTimeoutRef.current = null;
          }, 50);
          tooLateTimeoutRef.current = window.setTimeout(() => {
            tooEarlyValueRef.current = true;
            tooLateTimeoutRef.current = null;
            setPhase("finalize");
          }, timeoutDuration);
        }

        return () => {
          if (tooEarlyTimeoutRef.current) clearTimeout(tooEarlyTimeoutRef.current);
          if (tooLateTimeoutRef.current) clearTimeout(tooLateTimeoutRef.current);
        };
      }, [phase]); // Any time "open" changes, update our direction and phase.
      // In addition, measure the size of the element if requested.

      h(() => {
        if (element && open != null) {
          var previousPhase = phaseRef.current; // Swap our direction

          if (open) setDirection("enter");else setDirection("exit");
          setPhase(previousPhase === null ? "finalize" : "init");

          if (measure) {
            var currentSizeWithTransition = element.getBoundingClientRect();
            {
              var {
                x,
                y,
                width,
                height
              } = currentSizeWithTransition;
              setTransitioningX(x + "px");
              setTransitioningY(y + "px");
              setTransitioningWidth(width + "px");
              setTransitioningHeight(height + "px");
            }

            if (previousPhase === "finalize") {
              // We're going to be messing with the actual element's class, 
              // so we'll want an easy way to restore it later.
              var backup = element.className;
              element.classList.add("".concat(classBase, "-measure"));
              element.classList.remove("".concat(classBase, "-enter"), "".concat(classBase, "-enter-init"), "".concat(classBase, "-enter-transition"), "".concat(classBase, "-enter-finalize"), "".concat(classBase, "-exit"), "".concat(classBase, "-exit-init"), "".concat(classBase, "-exit-transition"), "".concat(classBase, "-exit-finalize"));
              forceReflow(element);
              var sizeWithoutTransition = element.getBoundingClientRect();
              var {
                x: _x,
                y: _y,
                width: _width,
                height: _height
              } = sizeWithoutTransition;
              setSurfaceX(_x + "px");
              setSurfaceY(_y + "px");
              setSurfaceWidth(_width + "px");
              setSurfaceHeight(_height + "px");
              element.className = backup;
              forceReflow(element);
            }
          }
        }
      }, [open, element, measure, classBase]); // Any time the phase changes to init, immediately before the screen is painted,
      // change the phase to "transition" and re-render ().

      h(() => {
        if (element && directionRef.current != null) {
          var _classBase2;

          (_classBase2 = classBase) !== null && _classBase2 !== void 0 ? _classBase2 : classBase = "transition";

          if (phase === "init") {
            // Preact just finished rendering init
            // Now set our transition style.
            setPhase("transition");

            if (measure) {
              forceReflow(element);
            }
          }
        }
      }, [phase, measure, element]);
      var inlineDirection = logicalDirection === null || logicalDirection === void 0 ? void 0 : logicalDirection.inlineDirection;
      var blockDirection = logicalDirection === null || logicalDirection === void 0 ? void 0 : logicalDirection.blockDirection;
      var writingModeIsHorizontal = inlineDirection == "rtl" || inlineDirection == "ltr";
      var surfaceInlineInset = writingModeIsHorizontal ? surfaceX : surfaceY;
      var surfaceBlockInset = writingModeIsHorizontal ? surfaceY : surfaceX;
      var surfaceInlineSize = writingModeIsHorizontal ? surfaceWidth : surfaceHeight;
      var surfaceBlockSize = writingModeIsHorizontal ? surfaceHeight : surfaceWidth;
      var transitioningInlineInset = writingModeIsHorizontal ? transitioningX : transitioningY;
      var transitioningBlockInset = writingModeIsHorizontal ? transitioningY : transitioningX;
      var transitioningInlineSize = writingModeIsHorizontal ? transitioningWidth : transitioningHeight;
      var transitioningBlockSize = writingModeIsHorizontal ? transitioningHeight : transitioningWidth;
      var almostDone = useRefElementProps(_objectSpread2(_objectSpread2({
        ref,
        style: removeEmpty({
          ["--".concat(classBase, "-duration")]: duration,
          ["--".concat(classBase, "-surface-x")]: surfaceX,
          ["--".concat(classBase, "-surface-y")]: surfaceY,
          ["--".concat(classBase, "-surface-width")]: surfaceWidth,
          ["--".concat(classBase, "-surface-height")]: surfaceHeight,
          ["--".concat(classBase, "-surface-inline-inset")]: surfaceInlineInset,
          ["--".concat(classBase, "-surface-block-inset")]: surfaceBlockInset,
          ["--".concat(classBase, "-surface-inline-size")]: surfaceInlineSize,
          ["--".concat(classBase, "-surface-block-size")]: surfaceBlockSize,
          ["--".concat(classBase, "-transitioning-x")]: transitioningX,
          ["--".concat(classBase, "-transitioning-y")]: transitioningY,
          ["--".concat(classBase, "-transitioning-width")]: transitioningWidth,
          ["--".concat(classBase, "-transitioning-height")]: transitioningHeight,
          ["--".concat(classBase, "-transitioning-inline-inset")]: transitioningInlineInset,
          ["--".concat(classBase, "-transitioning-block-inset")]: transitioningBlockInset,
          ["--".concat(classBase, "-transitioning-inline-size")]: transitioningInlineSize,
          ["--".concat(classBase, "-transitioning-block-size")]: transitioningBlockSize
        }),
        onTransitionEnd
      }, {
        "aria-hidden": open ? undefined : "true"
      }), {}, {
        className: clsx(direction && getClassName(classBase, direction), direction && phase && getClassName(classBase, direction, phase), exitVisibility == "removed" && "".concat(classBase, "-removed-on-exit"), exitVisibility == "visible" && "".concat(classBase, "-visible-on-exit"), "".concat(classBase, "-inline-direction-").concat(inlineDirection !== null && inlineDirection !== void 0 ? inlineDirection : "ltr"), "".concat(classBase, "-block-direction-").concat(blockDirection !== null && blockDirection !== void 0 ? blockDirection : "ttb"))
      }));
      return useMergedProps()(almostDone, otherProps);
    }

    function removeEmpty(obj) {
      return Object.fromEntries(Object.entries(obj).filter(([_, v]) => v != null));
    }
    /**
     * A component that *wraps an HTMLElement or other ref-forwarding component* and allows it to use CSS to transition in/out.
     * Combines the props passed to it, the props its child has, and the props needed for the CSS transition, and passes them
     * all to the child element you provide.
     *
     * This is the most general component that others use as a base. By default, this component by itself doesn't actually add any CSS classes that animate anything (like opacity, for example).
     * It adds classes like `transition-enter-finalize`, but you need to provide the additional e.g. `fade` class that reacts to it.
     *
     * Use this if the other, more specialized Transition components don't fit your needs.
     *
     * @example `<Transitionable open={open} {...useCreateFadeProps(...)}><div>{children}</div></Transitionable>`
     * @example `<Transitionable open={open}><div {...useCreateFadeProps(...)}>{children}</div></Transitionable>`
     */


    var Transitionable = forwardElementRef$1(function Transition(_ref, r) {
      var {
        children: child,
        duration,
        classBase,
        measure,
        exitVisibility,
        open,
        onTransitionUpdate,
        animateOnMount
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$B);

      if (!childIsVNode(child)) {
        throw new Error("A Transitionable component must have exactly one component child (e.g. a <div>, but not \"a string\").");
      }

      var transitionProps = useCreateTransitionableProps({
        classBase,
        duration,
        measure,
        open,
        animateOnMount,
        onTransitionUpdate,
        ref: r,
        exitVisibility
      }, props);
      var mergedWithChildren = useMergedProps()(transitionProps, _objectSpread2(_objectSpread2({}, child.props), {}, {
        ref: child.ref
      }));
      return B(child, mergedWithChildren);
    });

    function childIsVNode(child) {
      if (!child) return false;

      if (Array.isArray(child)) {
        return false;
      }

      if (typeof child != "object") return false;
      return "props" in child;
    }

    var _excluded$A = ["classBase", "clipOrigin", "clipOriginInline", "clipOriginBlock", "clipMin", "clipMinInline", "clipMinBlock", "open"];
    /**
     * Creates a set of props that implement a Clip transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     * Be sure to merge these returned props with whatever the user passed in.
     */

    function useCreateClipProps({
      classBase,
      clipOrigin,
      clipOriginInline,
      clipOriginBlock,
      clipMin,
      clipMinInline,
      clipMinBlock
    }, otherProps) {
      var _classBase, _ref, _ref2, _ref3, _ref4;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      return useMergedProps()({
        className: clsx("".concat(classBase, "-clip")),
        classBase,
        style: {
          ["--".concat(classBase, "-clip-origin-inline")]: (_ref = clipOriginInline !== null && clipOriginInline !== void 0 ? clipOriginInline : clipOrigin) !== null && _ref !== void 0 ? _ref : 0.5,
          ["--".concat(classBase, "-clip-origin-block")]: (_ref2 = clipOriginBlock !== null && clipOriginBlock !== void 0 ? clipOriginBlock : clipOrigin) !== null && _ref2 !== void 0 ? _ref2 : 0,
          ["--".concat(classBase, "-clip-min-inline")]: (_ref3 = clipMinInline !== null && clipMinInline !== void 0 ? clipMinInline : clipMin) !== null && _ref3 !== void 0 ? _ref3 : 1,
          ["--".concat(classBase, "-clip-min-block")]: (_ref4 = clipMinBlock !== null && clipMinBlock !== void 0 ? clipMinBlock : clipMin) !== null && _ref4 !== void 0 ? _ref4 : 0
        }
      }, otherProps);
    }
    var Clip = forwardElementRef$1(function Clip(_ref5, ref) {
      var {
        classBase,
        clipOrigin,
        clipOriginInline,
        clipOriginBlock,
        clipMin,
        clipMinInline,
        clipMinBlock,
        open
      } = _ref5,
          rest = _objectWithoutProperties(_ref5, _excluded$A);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateClipProps({
        classBase,
        clipOrigin,
        clipOriginInline,
        clipOriginBlock,
        clipMin,
        clipMinInline,
        clipMinBlock
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$z = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Creates a set of props that implement a Fade transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     * Be sure to merge these returned props with whatever the user passed in.
     */

    function useCreateFadeProps({
      classBase,
      fadeMin,
      fadeMax
    }, otherProps) {
      var _classBase;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      return useMergedProps()({
        className: "".concat(classBase, "-fade"),
        classBase,
        style: {
          ["--".concat(classBase, "-fade-min")]: fadeMin !== null && fadeMin !== void 0 ? fadeMin : 0,
          ["--".concat(classBase, "-fade-max")]: fadeMax !== null && fadeMax !== void 0 ? fadeMax : 1
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Fade effect.
     *
     * Note that while it is absolutely possible to wrap another transition with `<Fade>`,
     * there will be some duplicate code run as two `<Transitionable>` components end up operating on the same element.
     * It's generally recommended to either use the components that include a combined fade effect,
     * or just directly a `<Transitionable>` on your own.
     *
     * @see `Transitionable`
     */

    var Fade = forwardElementRef$1(function Fade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$z);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$y = ["classBase", "fadeMin", "fadeMax", "open"];
    var ClipFade = forwardElementRef$1(function ClipFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$y);

      return v$1(Clip, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$x = ["classBase", "open", "minBlockSize"];
    /**
     * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     * Be sure to merge these returned props with whatever the user passed in.
     *
     * IMPORTANT: If used outside of a `<Collapse />`, you must include the `measure` prop on the `<Transitionable>` that you use.
     *
     * @example <Transitionable measure {...useCreateCollapseProps(...)} />
     */

    function useCreateCollapseProps({
      classBase,
      minBlockSize
    }, otherProps) {
      var _classBase;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      return useMergedProps()({
        classBase,
        measure: true,
        className: "".concat(classBase, "-collapse"),
        style: {
          ["--".concat(classBase, "-collapse-min-block")]: minBlockSize !== null && minBlockSize !== void 0 ? minBlockSize : 0
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Collapse effect.
     *
     * *Important*: This component is *not* efficient for the browser to animate!
     * Make sure you do testing on lower power devices, or prefer a lighter
     * alternative, like `<Clip>`.
     *
     * @see `Transitionable`
     */

    var Collapse = forwardElementRef$1(function Collapse(_ref, ref) {
      var {
        classBase,
        open,
        minBlockSize
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$x);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateCollapseProps({
        classBase,
        minBlockSize
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$w = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with both Collapse and Fade effects.
     *
     * @see `Transitionable` `Collapse` `Fade`
     */

    forwardElementRef$1(function CollapseFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$w);

      return v$1(Collapse, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$v = ["classBase", "slideTargetInline", "slideTargetBlock", "open"];
    /**
     * Creates a set of props that implement a Slide transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     */

    function useCreateSlideProps({
      classBase,
      slideTargetInline,
      slideTargetBlock
    }, otherProps) {
      var _classBase, _slideTargetInline, _slideTargetBlock, _slideTargetInline2, _slideTargetBlock2;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      var lastValidTargetInline = s((_slideTargetInline = slideTargetInline) !== null && _slideTargetInline !== void 0 ? _slideTargetInline : 1);
      var lastValidTargetBlock = s((_slideTargetBlock = slideTargetBlock) !== null && _slideTargetBlock !== void 0 ? _slideTargetBlock : 0);
      y(() => {
        if (slideTargetInline) lastValidTargetInline.current = slideTargetInline;
      }, [slideTargetInline]);
      y(() => {
        if (slideTargetBlock) lastValidTargetBlock.current = slideTargetBlock;
      }, [slideTargetBlock]);
      if (slideTargetInline == 0) slideTargetInline = lastValidTargetInline.current;
      if (slideTargetBlock == 0) slideTargetBlock = lastValidTargetBlock.current;
      return useMergedProps()({
        className: "".concat(classBase, "-slide"),
        classBase,
        style: {
          ["--".concat(classBase, "-slide-target-inline")]: "".concat((_slideTargetInline2 = slideTargetInline) !== null && _slideTargetInline2 !== void 0 ? _slideTargetInline2 : 0),
          ["--".concat(classBase, "-slide-target-block")]: "".concat((_slideTargetBlock2 = slideTargetBlock) !== null && _slideTargetBlock2 !== void 0 ? _slideTargetBlock2 : 0)
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Slide effect.
     *
     * Provide the direction the element will travel in with `slideInline` and `slideBlock`,
     * with `1` being `100%` of the element's width or height.
     *
     * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
     * which allows for convenient setups inside of a `SwapContainer`
     * (`slideInline={index - selectedIndex}` or similar.)
     *
     * @see `Transitionable`
     */

    var Slide = forwardElementRef$1(function Slide(_ref, ref) {
      var {
        classBase,
        slideTargetInline,
        slideTargetBlock,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$v);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateSlideProps({
        classBase,
        slideTargetInline,
        slideTargetBlock
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$u = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with both Slide and Fade effects.
     *
     * `slideInline={(index - selectedIndex) / 10}` would make the element look like it fades out before it travels to its target destination.
     *
     * @see `Transitionable` `Zoom`
     */

    var SlideFade = forwardElementRef$1(function SlideFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$u);

      return v$1(Slide, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$t = ["classBase", "zoomOrigin", "zoomOriginInline", "zoomOriginBlock", "zoomMin", "zoomMinInline", "zoomMinBlock", "open"];
    /**
     * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     */

    function useCreateZoomProps({
      classBase,
      zoomOrigin,
      zoomOriginInline,
      zoomOriginBlock,
      zoomMin,
      zoomMinInline,
      zoomMinBlock
    }, otherProps) {
      var _classBase, _ref, _ref2, _ref3, _ref4;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      return useMergedProps()({
        className: "".concat(classBase, "-zoom"),
        classBase,
        style: {
          ["--".concat(classBase, "-zoom-origin-inline")]: "".concat((_ref = zoomOriginInline !== null && zoomOriginInline !== void 0 ? zoomOriginInline : zoomOrigin) !== null && _ref !== void 0 ? _ref : 0.5),
          ["--".concat(classBase, "-zoom-origin-block")]: "".concat((_ref2 = zoomOriginBlock !== null && zoomOriginBlock !== void 0 ? zoomOriginBlock : zoomOrigin) !== null && _ref2 !== void 0 ? _ref2 : 0.5),
          ["--".concat(classBase, "-zoom-min-inline")]: "".concat((_ref3 = zoomMinInline !== null && zoomMinInline !== void 0 ? zoomMinInline : zoomMin) !== null && _ref3 !== void 0 ? _ref3 : 0),
          ["--".concat(classBase, "-zoom-min-block")]: "".concat((_ref4 = zoomMinBlock !== null && zoomMinBlock !== void 0 ? zoomMinBlock : zoomMin) !== null && _ref4 !== void 0 ? _ref4 : 0)
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Zoom effect.
     * @see `Transitionable` `ZoomFade`
     */

    var Zoom = forwardElementRef$1(function Zoom(_ref5, ref) {
      var {
        classBase,
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        zoomMin,
        zoomMinInline,
        zoomMinBlock,
        open
      } = _ref5,
          rest = _objectWithoutProperties(_ref5, _excluded$t);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateZoomProps({
        classBase,
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        zoomMin,
        zoomMinInline,
        zoomMinBlock
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$s = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with both Zoom and Fade effects.
     *
     * This is an ideal time to use the minimum size Zoom properties.
     *
     * @see `Transitionable` `Zoom`
     */

    var ZoomFade = forwardElementRef$1(function ZoomFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$s);

      return v$1(Zoom, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$r = ["classBase", "zoomMin", "zoomMinInline", "zoomMinBlock", "zoomOrigin", "zoomOriginInline", "zoomOriginBlock", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with both Slide and Zoom effects.
     *
     * Probably best combined with `useCreateFadeProps` (or just using a `SlideZoomFade`?).
     *
     * @see `Transitionable` `SlideFadeZoom` `Zoom` `Fade`
     */

    var SlideZoom = forwardElementRef$1(function SlideZoom(_ref, ref) {
      var {
        classBase,
        zoomMin,
        zoomMinInline,
        zoomMinBlock,
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$r);

      return v$1(Slide, _objectSpread2({
        open: open
      }, useCreateZoomProps({
        classBase,
        zoomMin,
        zoomMinInline,
        zoomMinBlock,
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$q = ["classBase", "fadeMin", "fadeMax", "open"];
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with Zoom, Slide, and Fade effects.
     *
     * Note that this is basically just shorthand for some prop creation and prop merging functions.
     *
     * @see `Transitionable` `Slide` `Zoom` `Fade`
     */

    forwardElementRef$1(function SlideZoomFade(_ref, ref) {
      var {
        classBase,
        fadeMin,
        fadeMax,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$q);

      return v$1(SlideZoom, _objectSpread2({
        open: open
      }, useCreateFadeProps({
        classBase,
        fadeMin,
        fadeMax
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$p = ["classBase", "flipAngleInline", "flipAngleBlock", "perspective", "open"];
    /**
     * Creates a set of props that implement a Flip transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
     */

    function useCreateFlipProps({
      classBase,
      flipAngleInline,
      flipAngleBlock,
      perspective
    }, otherProps) {
      var _classBase, _flipAngleInline, _flipAngleBlock, _flipAngleInline2, _flipAngleBlock2;

      (_classBase = classBase) !== null && _classBase !== void 0 ? _classBase : classBase = "transition";
      var lastValidTargetInline = s((_flipAngleInline = flipAngleInline) !== null && _flipAngleInline !== void 0 ? _flipAngleInline : 180);
      var lastValidTargetBlock = s((_flipAngleBlock = flipAngleBlock) !== null && _flipAngleBlock !== void 0 ? _flipAngleBlock : 0);
      y(() => {
        if (flipAngleInline) lastValidTargetInline.current = flipAngleInline;
      }, [flipAngleInline]);
      y(() => {
        if (flipAngleBlock) lastValidTargetBlock.current = flipAngleBlock;
      }, [flipAngleBlock]);
      if (flipAngleInline == 0) flipAngleInline = lastValidTargetInline.current;
      if (flipAngleBlock == 0) flipAngleBlock = lastValidTargetBlock.current;
      return useMergedProps()({
        className: "".concat(classBase, "-flip"),
        classBase,
        style: {
          ["--".concat(classBase, "-flip-angle-inline")]: "".concat((_flipAngleInline2 = flipAngleInline) !== null && _flipAngleInline2 !== void 0 ? _flipAngleInline2 : 0, "deg"),
          ["--".concat(classBase, "-flip-angle-block")]: "".concat((_flipAngleBlock2 = flipAngleBlock) !== null && _flipAngleBlock2 !== void 0 ? _flipAngleBlock2 : 0, "deg"),
          ["--".concat(classBase, "-perspective")]: "".concat(perspective !== null && perspective !== void 0 ? perspective : 800, "px")
        }
      }, otherProps);
    }
    /**
     * Wraps a div (etc.) and allows it to transition in/out smoothly with a Flip effect.
     *
     * Provide the direction the element will travel in with `flipInline` and `flipBlock`,
     * with `1` being `100%` of the element's width or height.
     *
     * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
     * which allows for convenient setups inside of a `SwapContainer`
     * (`flipInline={index - selectedIndex}` or similar.)
     *
     * @see `Transitionable`
     */

    forwardElementRef$1(function Flip(_ref, ref) {
      var {
        classBase,
        flipAngleInline,
        flipAngleBlock,
        perspective,
        open
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$p);

      return v$1(Transitionable, _objectSpread2({
        open: open
      }, useCreateFlipProps({
        classBase,
        flipAngleInline,
        flipAngleBlock,
        perspective
      }, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref
      }))));
    });

    var _excluded$o = ["children", "classBase", "inline"];
    /**
     * Creates a set of props that implement a swap container.
     * Be sure to merge these returned props with whatever the user passed in.
     */

    function useCreateSwappableProps({
      inline,
      classBase
    }, otherProps) {
      return useMergedProps()({
        className: clsx("".concat(classBase !== null && classBase !== void 0 ? classBase : "transition", "-swap-container"), inline && "".concat(classBase !== null && classBase !== void 0 ? classBase : "transition", "-swap-container-inline"))
      }, otherProps);
    }
    /**
     * Allows a set of child <Transitionable> components to animate in & out in-place. Very useful for, e.g., tab panels.
     *
     * You must manage each child `<Transitionable>` component's `open` prop -- this component *does not* manage any sort of state in that regard.
     *
     * Like `<Transitionable>`, *this wraps an HTMLElement (or other ref-forwarding component)*. This will be your container that holds each `<Transitionable>` (or component that uses it). Strictly speaking it could be anything, not a `<Transitionable>`, but if it doesnt't transition out then it's just going to be hanging around 100% of the time.
     *
     * Long way of saying, if you get a cryptic error with this component, make sure it has a single `<div>` child or something.
     * @param param0
     * @returns
     */

    var Swappable = forwardElementRef$1(function Swappable(_ref, ref) {
      var _inline;

      var {
        children,
        classBase,
        inline
      } = _ref,
          p = _objectWithoutProperties(_ref, _excluded$o);

      (_inline = inline) !== null && _inline !== void 0 ? _inline : inline = typeof children.type === "string" && inlineElements.has(children.type);
      var transitionProps = useCreateSwappableProps({
        classBase,
        inline
      }, _objectSpread2(_objectSpread2({}, p), {}, {
        ref
      }));
      var mergedWithChildren = useMergedProps()(transitionProps, children.props);
      return B(children, mergedWithChildren);
    }); // If "inline" isn't explicitly provided, we try to implicitly do it based on the child's tag.
    // Not perfect, but it's not supposed to be. `inline` is for perfect.

    var inlineElements = new Set(["a", "abbr", "acronym", "audio", "b", "bdi", "bdo", "big", "br", "button", "canvas", "cite", "code", "data", "datalist", "del", "dfn", "em", "embed", "i", "iframe", "img", "input", "ins", "kbd", "label", "map", "mark", "meter", "noscript", "object", "output", "picture", "progress", "q", "ruby", "s", "samp", "script", "select", "slot", "small", "span", "strong", "sub", "sup", "svg", "template", "textarea", "time", "u", "tt", "var", "video", "wbr"]);

    var EventDetail = Symbol("event-detail");
    function enhanceEvent(e, detail) {
      var event = e;
      event[EventDetail] = detail;
      return event;
    }

    var _excluded$n = ["aria-pressed", "tabIndex", "role"];
    var pulse = "vibrate" in navigator ? () => navigator.vibrate(10) : () => {};

    function excludes(tag, target, exclude) {
      if (exclude !== null && exclude !== void 0 && exclude[target]) return true;
      if (target === "space" || target === "enter") return tag == "button";
      return false;
    }
    /**
     * Easy way to "polyfill" button-like interactions onto, e.g., a div.
     *
     * Adds click, space on keyDown, and enter on keyUp, as well as haptic
     * feedback via a momentary vibration pulse when there's an onClick handler provided
     * (this can be disabled app-wide with `setButtonVibrate`).
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClick
     * @param exclude Whether the polyfill should apply (can specify for specific interactions)
     */


    function useButtonLikeEventHandlers(tag, onClickSync, exclude) {
      //type E = Ev extends h.JSX.TargetedEvent<infer E, any>? E : EventTarget;
      var [active, setActive] = useState(false);
      var onKeyUp = excludes(tag, "space", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync) {
          e.preventDefault();
          onClickSync(e);
          setActive(false);
        }
      };
      var onMouseDown = excludes(tag, "click", exclude) ? undefined : e => {
        if (e.button === 0) setActive(true);
      };

      var onBlur = e => {
        setActive(false);
      };

      var onMouseUp = excludes(tag, "click", exclude) ? undefined : onBlur;
      var onMouseOut = excludes(tag, "click", exclude) ? undefined : onBlur;
      var onKeyDown = excludes(tag, "space", exclude) && excludes(tag, "enter", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync && !excludes(tag, "space", exclude)) {
          // We don't actually activate it on a space keydown
          // but we do preventDefault to stop the page from scrolling.
          setActive(true);
          e.preventDefault();
        }

        if (e.key == "Enter" && onClickSync && !excludes(tag, "enter", exclude)) {
          e.preventDefault();
          onClickSync(e);
        }
      };
      var onClick2 = excludes(tag, "click", exclude) ? undefined : e => {
        if (onClickSync && !excludes(tag, "click", exclude)) {
          pulse();
          onClickSync(e);
        }
      };
      return props => useMergedProps()(_objectSpread2({
        onKeyDown,
        onKeyUp,
        onClick: onClick2,
        onBlur,
        onMouseDown,
        onMouseUp,
        onMouseOut
      }, {
        "data-pseudo-active": active ? "true" : undefined
      }), props);
    }
    function useAriaButton({
      tag,
      pressed,
      onClick
    }) {
      function useAriaButtonProps(_ref) {
        var {
          "aria-pressed": ariaPressed,
          tabIndex,
          role
        } = _ref,
            p = _objectWithoutProperties(_ref, _excluded$n);

        var props = useButtonLikeEventHandlers(tag, e => onClick === null || onClick === void 0 ? void 0 : onClick(enhanceEvent(e, {
          pressed: pressed == null ? null : !pressed
        })), undefined)(p);
        var buttonProps = {
          role,
          tabIndex,
          "aria-pressed": ariaPressed !== null && ariaPressed !== void 0 ? ariaPressed : pressed === true ? "true" : pressed === false ? "false" : undefined
        };

        var divProps = _objectSpread2(_objectSpread2({}, buttonProps), {}, {
          tabIndex: tabIndex !== null && tabIndex !== void 0 ? tabIndex : 0,
          role: role !== null && role !== void 0 ? role : "button"
        });

        var anchorProps = _objectSpread2({}, divProps);

        switch (tag) {
          case "button":
            return useMergedProps()(buttonProps, props);

          case "a":
            return useMergedProps()(anchorProps, props);

          default:
            return useMergedProps()(divProps, props);
        }
      }

      return {
        useAriaButtonProps
      };
    }

    var _excluded$m = ["aria-expanded", "aria-disabled"],
        _excluded2$a = ["role"];
    function useAriaAccordion({
      expandedIndex,
      setExpandedIndex
    }) {
      var [lastFocusedIndex, setLastFocusedIndex, getLastFocusedIndex] = useState(0);
      var stableSetExpandedIndex = useStableCallback(setExpandedIndex !== null && setExpandedIndex !== void 0 ? setExpandedIndex : () => {});
      var {
        managedChildren: managedAccordionSections,
        useManagedChild: useManagedChildSection
      } = useChildManager();
      var {
        useLinearNavigationChild
      } = useLinearNavigation({
        managedChildren: managedAccordionSections,
        navigationDirection: "block",
        getIndex: getLastFocusedIndex,
        setIndex: setLastFocusedIndex
      }); // Any time list management changes the focused index, manually focus the child
      // TODO: Can this be cut?

      useLayoutEffect(() => {
        var _managedAccordionSect;

        if (lastFocusedIndex != null && lastFocusedIndex >= 0) (_managedAccordionSect = managedAccordionSections[lastFocusedIndex]) === null || _managedAccordionSect === void 0 ? void 0 : _managedAccordionSect.focus();
      }, [lastFocusedIndex]);
      useChildFlag(expandedIndex, managedAccordionSections.length, (i, open) => {
        var _managedAccordionSect2;

        return (_managedAccordionSect2 = managedAccordionSections[i]) === null || _managedAccordionSect2 === void 0 ? void 0 : _managedAccordionSect2.setOpenFromParent(open);
      });
      var useAriaAccordionSection = A$1(args => {
        var _ref, _args$open;

        var [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
        var {
          randomId: bodyRandomId,
          useRandomIdProps: useBodyRandomIdProps,
          useReferencedIdProps: useReferencedBodyIdProps
        } = useRandomId({
          prefix: "aria-accordion-section-body-"
        });
        var {
          randomId: headRandomId,
          useRandomIdProps: useHeadRandomIdProps,
          useReferencedIdProps: useReferencedHeadIdProps
        } = useRandomId({
          prefix: "aria-accordion-section-header-"
        });
        var open = (_ref = (_args$open = args.open) !== null && _args$open !== void 0 ? _args$open : openFromParent) !== null && _ref !== void 0 ? _ref : null; // TODO: Convert to use useManagedChild so that this hook 
        // is stable without (directly) depending on the open state.

        var useAriaAccordionSectionHeader = A$1(function useAriaAccordionSectionHeader({
          tag
        }) {
          var {
            useRefElementProps,
            element
          } = useRefElement();
          var focus = A$1(() => {
            element === null || element === void 0 ? void 0 : element.focus();
          }, [element]);
          var {
            useManagedChildProps
          } = useManagedChildSection({
            index: args.index,
            open: open,
            setOpenFromParent,
            focus
          });
          var {
            useLinearNavigationChildProps
          } = useLinearNavigationChild();

          function useAriaAccordionSectionHeaderProps(_ref2) {
            var {
              ["aria-expanded"]: ariaExpanded,
              ["aria-disabled"]: ariaDisabled
            } = _ref2,
                props = _objectWithoutProperties(_ref2, _excluded$m);

            var onFocus = () => {
              setLastFocusedIndex(args.index);
            };

            var onClick = () => {
              if (getOpenFromParent()) stableSetExpandedIndex(null);else stableSetExpandedIndex(args.index);
            };

            var retB = useMergedProps()({
              tabIndex: 0
            }, useButtonLikeEventHandlers(tag, onClick, undefined)(props));
            var ret3 = useMergedProps()(useHeadRandomIdProps(useReferencedBodyIdProps("aria-controls")(_objectSpread2({
              "aria-expanded": ariaExpanded !== null && ariaExpanded !== void 0 ? ariaExpanded : (!!open).toString(),
              "aria-disabled": ariaDisabled !== null && ariaDisabled !== void 0 ? ariaDisabled : open ? "true" : undefined
            }, useRefElementProps(useManagedChildProps(retB))))), {
              onFocus
            });
            return useLinearNavigationChildProps(ret3);
          }
          return {
            useAriaAccordionSectionHeaderProps
          };
        }, [open]);
        var useAriaAccordionSectionBody = A$1(function useAriaAccordionSectionBody() {
          function useAriaAccordionSectionBodyProps(_ref3) {
            var {
              role
            } = _ref3,
                props = _objectWithoutProperties(_ref3, _excluded2$a);

            var ret1 = useReferencedHeadIdProps("aria-labelledby")(_objectSpread2({
              role: role !== null && role !== void 0 ? role : "region"
            }, props));
            var ret2 = useBodyRandomIdProps(ret1);
            return ret2;
          }
          return {
            useAriaAccordionSectionBodyProps
          };
        }, []);
        return {
          expanded: open,
          useAriaAccordionSectionHeader,
          useAriaAccordionSectionBody
        };
      }, [useLinearNavigationChild]);
      return {
        useAriaAccordionSection
      };
    }

    var _excluded$l = ["aria-labelledby", "aria-label"];
    /**
     * Adds an ID and "aria-labelledby" for two elements, an "input" element and a "label" element.
     *
     * Returns the `useReferencedIdProps` hooks if you need to also add other ID-referencing attributes, like `for`
     *
     * @see useInputLabel
     */

    function useGenericLabel({
      labelPrefix,
      inputPrefix,
      backupText
    } = {
      labelPrefix: "label-",
      inputPrefix: "input-"
    }) {
      var {
        element: labelElement,
        getElement: getLabelElement,
        useRefElementProps: useLabelRefElementProps
      } = useRefElement();
      var {
        element: inputElement,
        getElement: getInputElement,
        useRefElementProps: useInputRefElementProps
      } = useRefElement();
      var {
        useRandomIdProps: useLabelRandomIdProps,
        id: labelId,
        randomId: labelRandomId,
        useReferencedIdProps: useReferencedLabelIdProps
      } = useRandomId({
        prefix: labelPrefix
      });
      var {
        useRandomIdProps: useInputRandomIdProps,
        id: inputId,
        randomId: inputRandomId,
        useReferencedIdProps: useReferencedInputIdProps
      } = useRandomId({
        prefix: inputPrefix
      });
      var labelHasMounted = !!labelElement;
      var useGenericLabelLabel = A$1(function useGenericLabelLabel() {
        return {
          useGenericLabelLabelProps: props => {
            return useLabelRandomIdProps(useLabelRefElementProps(props));
          }
        };
      }, []);
      var useGenericLabelInput = A$1(function useGenericLabelInput() {
        return {
          useGenericLabelInputProps: _ref => {
            var _ref2;

            var {
              "aria-labelledby": ariaLabelledby,
              "aria-label": ariaLabel
            } = _ref,
                props = _objectWithoutProperties(_ref, _excluded$l);

            return useInputRandomIdProps(useReferencedLabelIdProps("aria-labelledby")(useInputRefElementProps(useMergedProps()({
              "aria-label": (_ref2 = !labelHasMounted ? backupText : ariaLabel) !== null && _ref2 !== void 0 ? _ref2 : ariaLabel
            }, props))));
          }
        };
      }, [labelHasMounted]);
      return {
        useGenericLabelInput,
        useGenericLabelLabel,
        useReferencedLabelIdProps,
        useReferencedInputIdProps,
        labelId,
        inputId,
        labelElement,
        inputElement,
        getLabelElement,
        getInputElement
      };
    }
    /**
     * Handles the attributes `id`, `for`, and `aria-labelledby` for to related elements.
     *
     * It's assumed that the label is an `HTMLLabelElement`, and the input is something for which
     * the `for` attribute can reference.
     *
     */

    function useInputLabel({
      labelPrefix,
      inputPrefix
    } = {
      labelPrefix: "label-",
      inputPrefix: "input-"
    }) {
      var {
        useGenericLabelInput,
        useGenericLabelLabel,
        useReferencedInputIdProps,
        useReferencedLabelIdProps,
        inputId,
        labelId,
        inputElement,
        getInputElement,
        labelElement,
        getLabelElement
      } = useGenericLabel({
        labelPrefix,
        inputPrefix
      });
      var useInputLabelLabel = A$1(function useInputLabelLabel({
        tag
      }) {
        var {
          useGenericLabelLabelProps
        } = useGenericLabelLabel();
        return {
          useInputLabelLabelProps(props) {
            var withFor = useReferencedInputIdProps("for")(props);
            var withoutFor = props;
            return useGenericLabelLabelProps(tag == "label" ? withFor : withoutFor);
          }

        };
      }, [useGenericLabelInput]);
      var useInputLabelInput = A$1(function useInputLabelInput() {
        var {
          useGenericLabelInputProps
        } = useGenericLabelInput();
        return {
          useInputLabelInputProps(props) {
            return useGenericLabelInputProps(props);
          }

        };
      }, [useGenericLabelLabel]);
      return {
        useInputLabelLabel,
        useInputLabelInput,
        labelId,
        inputId,
        inputElement,
        labelElement,
        getInputElement,
        getLabelElement
      };
    }

    var handlesInput = (tag, labelPosition, which) => {
      if (labelPosition === "separate") {
        if (which === "input-element") return true;else if (which === "label-element") return tag != "input";
      } else if (labelPosition === "wrapping") {
        if (which === "input-element") return false;
        if (which == "label-element") return true;
      }
    };
    /**
     * Handles label type (wrapping or separate) for checkboxes, radios, switches, etc.
     * @param param0
     * @returns
     */


    function useCheckboxLike({
      disabled,
      labelPosition,
      onInput,
      role
    }) {
      var stableOnInput = useStableCallback(e => {
        e.preventDefault();
        onInput === null || onInput === void 0 ? void 0 : onInput(e);
      });
      var {
        inputId,
        labelId,
        useInputLabelInput: useILInput,
        useInputLabelLabel: useILLabel,
        getLabelElement,
        getInputElement
      } = useInputLabel({
        labelPrefix: "aria-checkbox-label-",
        inputPrefix: "aria-checkbox-input-"
      });
      var useCheckboxLikeInputElement = A$1(function useCheckboxInputElement({
        tag
      }) {
        var {
          useInputLabelInputProps: useILInputProps
        } = useILInput();
        var {
          element,
          useRefElementProps
        } = useRefElement();
        return {
          inputElement: element,
          useCheckboxLikeInputElementProps
        };

        function useCheckboxLikeInputElementProps(_ref3) {
          var p0 = _extends({}, _ref3);

          // For some reason, Chrome won't fire onInput events for radio buttons that are tabIndex=-1??
          // Needs investigating, but onInput works fine in Firefox
          // TODO
          var props = useButtonLikeEventHandlers(tag, disabled || !handlesInput(tag, labelPosition, "input-element") ? undefined : stableOnInput, undefined)({});
          if (tag == "input") props.onInput = e => e.preventDefault();
          props = useRefElementProps(useILInputProps(props));

          if (labelPosition == "wrapping") {
            // Because the wrapped label handles all interactions,
            // we need to make sure this element can't be interacted with
            // even if it's an input element.
            props.inert = true;
            props.tabIndex = -1;

            props.onFocus = e => getLabelElement().focus();
          } else {
            if (tag != "input") {
              props.role = role;
              props.tabIndex = 0;
            }

            props["aria-disabled"] = disabled.toString();
          }

          return useMergedProps()(p0, props);
        }
      }, [useILInput, role, labelPosition, disabled]);
      var useCheckboxLikeLabelElement = A$1(function useCheckboxLabelElement({
        tag
      }) {
        var {
          useInputLabelLabelProps: useILLabelProps
        } = useILLabel({
          tag
        });

        function useCheckboxLikeLabelElementProps(_ref4) {
          var p0 = _extends({}, _ref4);

          var newProps = useButtonLikeEventHandlers("div", disabled || !handlesInput(tag, labelPosition, "label-element") ? undefined : stableOnInput, undefined)({});

          if (labelPosition == "wrapping") {
            newProps.tabIndex = 0;
            newProps.role = role;
            newProps["aria-disabled"] = disabled.toString();
          }

          return useMergedProps()(newProps, useILLabelProps(p0));
        }

        return {
          useCheckboxLikeLabelElementProps
        };
      }, [useILLabel, role, labelPosition]);
      return {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        getLabelElement,
        getInputElement
      };
    }

    function useAriaCheckbox({
      labelPosition,
      checked,
      onInput,
      disabled
    }) {
      var onInputEnhanced = e => onInput === null || onInput === void 0 ? void 0 : onInput(enhanceEvent(e, {
        checked: !checked
      }));

      var {
        getInputElement,
        getLabelElement,
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement
      } = useCheckboxLike({
        labelPosition,
        role: "checkbox",
        disabled,
        onInput: onInputEnhanced
      });
      var useCheckboxInputElement = A$1(function useCheckboxInputElement({
        tag
      }) {
        var {
          inputElement,
          useCheckboxLikeInputElementProps
        } = useCheckboxLikeInputElement({
          tag
        });
        var isMixed = checked == "mixed";
        h(() => {
          if (inputElement) {
            if (tag === "input") {
              inputElement.indeterminate = isMixed;
            }
          }
        }, [inputElement, isMixed, tag]);
        return {
          useCheckboxInputElementProps
        };

        function useCheckboxInputElementProps(_ref) {
          var _props$checked;

          var p0 = _extends({}, _ref);

          var props = useCheckboxLikeInputElementProps(p0);
          (_props$checked = props.checked) !== null && _props$checked !== void 0 ? _props$checked : props.checked = !!checked;

          if (labelPosition == "separate") {
            props["aria-checked"] = checked.toString();
            if (tag != "input") props.tabIndex = 0;
          }

          if (tag == "input") props.type = "checkbox";
          return props;
        }
      }, [checked, labelPosition, disabled]);
      var useCheckboxLabelElement = A$1(function useCheckboxLabelElement({
        tag
      }) {
        var {
          useCheckboxLikeLabelElementProps
        } = useCheckboxLikeLabelElement({
          tag
        });

        function useCheckboxLabelElementProps(_ref2) {
          var props = _extends({}, _ref2);

          if (labelPosition == "wrapping") {
            props["aria-checked"] = checked.toString();
            if (tag != "input") props.tabIndex = 0;
          }

          return useCheckboxLikeLabelElementProps(props);
        }
        return {
          useCheckboxLabelElementProps
        };
      }, [useCheckboxLikeLabelElement, disabled, labelPosition]);
      return {
        useCheckboxInputElement,
        useCheckboxLabelElement
      };
    }

    var _excluded$k = ["aria-modal", "role"];
    /**
     * Adds event handlers for a modal-like soft-dismiss interaction.
     *
     * That is, any clicks or taps outside of the given component,
     * or any time the Escape key is pressed within the component,
     * (with various browser oddities regarding clicks on blank or inert areas handled)
     * the component will request to close itself.
     *
     * Of course, if you don't do anything in the `onClose` function,
     * it won't be a soft dismiss anymore.
     *
     * @param param0
     * @returns
     */

    function useSoftDismiss({
      onClose
    }) {
      var {
        element,
        useRefElementProps
      } = useRefElement();

      function onBackdropClick(e) {
        // Basically, "was this event fired on the root-most element, or at least an element not contained by the modal?"
        // Either could be how the browser handles these sorts of "interacting with nothing" events.
        if (e.target == document.documentElement || !(element && e.target instanceof Element && element instanceof Element && element.contains(e.target))) {
          onClose("backdrop");
        }
      } // Since everything else is inert, we listen for captured clicks on the window
      // (we don't use onClick since that doesn't fire when clicked on empty/inert areas)
      // Note: We need a *separate* touch event on mobile Safari, because
      // it doesn't let click events bubble or be captured from traditionally non-interactive elements,
      // but touch events work as expected.


      useGlobalHandler(window, "mousedown", !open ? null : onBackdropClick, {
        capture: true
      });
      useGlobalHandler(window, "touchstart", !open ? null : onBackdropClick, {
        capture: true
      });

      var onKeyDown = e => {
        if (e.key === "Escape") {
          onClose("escape");
        }
      };

      return {
        useSoftDismissProps: props => useMergedProps()(useRefElementProps({
          onKeyDown
        }), props)
      };
    }
    /**
     * A generic modal hook, used by modal dialogs, but can also
     * be used by anything that's modal with a backdrop.
     * @param param0
     * @returns
     */

    function useAriaModal({
      open,
      onClose
    }) {
      var [modalDescribedByBody, setModalDescribedByBody] = useState(false);
      useHideScroll(open);
      var {
        id: modalId,
        useRandomIdProps: useModalIdProps,
        useReferencedIdProps: useModalReferencingIdProps
      } = useRandomId({
        prefix: "aria-modal-"
      });
      var {
        id: bodyId,
        useRandomIdProps: useBodyIdProps,
        useReferencedIdProps: useBodyReferencingIdProps
      } = useRandomId({
        prefix: "aria-modal-body-"
      });
      var {
        id: titleId,
        useRandomIdProps: useTitleIdProps,
        useReferencedIdProps: useTitleReferencingIdProps
      } = useRandomId({
        prefix: "aria-modal-title-"
      });
      var {
        useSoftDismissProps
      } = useSoftDismiss({
        onClose
      });
      var useModalBackdrop = A$1(function useModalBackdrop() {
        function useModalBackdropProps(props) {
          return useMergedProps()({}, props);
        }

        return {
          useModalBackdropProps
        };
      }, []);

      var useModalProps = function (_ref) {
        var p0 = _objectWithoutProperties(_ref, _excluded$k);

        var {
          useFocusTrapProps
        } = useFocusTrap({
          trapActive: open
        });
        var p1 = useTitleReferencingIdProps("aria-labelledby")(p0);
        var p2 = useModalIdProps(p1);
        var pFinal = useBodyReferencingIdProps("aria-describedby")(p2);
        return useFocusTrapProps(useMergedProps()(useSoftDismissProps({
          role: "dialog"
        }), modalDescribedByBody ? pFinal : p2));
      };

      var useModalTitle = A$1(function useModalTitle() {
        var useModalTitleProps = function (props) {
          return useTitleIdProps(props);
        };

        return {
          useModalTitleProps
        };
      }, []);
      var useModalBody = A$1(function useModalBody({
        descriptive
      }) {
        setModalDescribedByBody(descriptive);

        var useModalBodyProps = function (props) {
          return useBodyIdProps(props);
        };

        return {
          useModalBodyProps
        };
      }, []);
      return {
        useModalProps,
        useModalTitle,
        useModalBody,
        useModalBackdrop
      };
    }
    /**
     * Allows for hiding the scroll bar of the root HTML element
     * without shifting the layout of the page more than adding a fow pixels
     * of padding to the root element if necessary.
     * @param hideScroll
     */

    function useHideScroll(hideScroll) {
      var [scrollbarWidth, setScrollbarWidth, getScrollbarWidth] = useState(null);
      y(() => {
        if (hideScroll) {
          var widthWithScrollBar = document.documentElement.scrollWidth;
          document.documentElement.classList.add("document-scroll-hidden");
          document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") + 1).toString();
          var widthWithoutScrollBar = document.documentElement.scrollWidth;

          var _scrollbarWidth = widthWithoutScrollBar - widthWithScrollBar; // Failsafe -- if this measuring trick does something unexpected, just ignore it


          if (_scrollbarWidth > 80) _scrollbarWidth = 0;
          document.documentElement.style.setProperty("--scrollbar-width", "".concat(_scrollbarWidth, "px"));
          setScrollbarWidth(_scrollbarWidth);
          return () => {
            document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") - 1).toString();

            if (document.documentElement.dataset["scrollHiders"] == "0") {
              document.documentElement.removeAttribute("data-scroll-hiders");
              document.documentElement.classList.remove("document-scroll-hidden");
            }
          };
        }
      }, [hideScroll]);
      return {
        scrollbarWidth,
        getScrollbarWidth
      };
    }

    function useAriaDialog({
      open,
      onClose
    }) {
      // TODO: Differences between dialog and modal go here, presumably
      var {
        useModalBackdrop,
        useModalBody,
        useModalProps,
        useModalTitle
      } = useAriaModal({
        open,
        onClose
      });
      return {
        useDialogProps: useModalProps,
        useDialogTitle: useModalTitle,
        useDialogBody: useModalBody,
        useDialogBackdrop: useModalBackdrop
      };
    }

    var _excluded$j = ["selectedIndex", "onSelect", "selectionMode"],
        _excluded2$9 = ["useListNavigationChild", "navigateToIndex", "managedChildren", "setTabbableIndex"];
    function useAriaListboxSingle(_ref) {
      var {
        selectedIndex,
        onSelect,
        selectionMode
      } = _ref,
          args = _objectWithoutProperties(_ref, _excluded$j);

      var {
        lastFocusedInner,
        useHasFocusProps
      } = useHasFocus();
      var {
        useGenericLabelInput,
        useGenericLabelLabel,
        useReferencedInputIdProps,
        useReferencedLabelIdProps,
        inputElement
      } = useGenericLabel({
        labelPrefix: "aria-listbox-label-",
        inputPrefix: "aria-listbox-"
      });

      var _useListNavigation = useListNavigation(_objectSpread2(_objectSpread2({}, args), {}, {
        focusOnChange: lastFocusedInner
      })),
          {
        useListNavigationChild,
        navigateToIndex,
        managedChildren,
        setTabbableIndex
      } = _useListNavigation,
          listRest = _objectWithoutProperties(_useListNavigation, _excluded2$9);

      var {
        useGenericLabelInputProps
      } = useGenericLabelInput();
      var stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
      useChildFlag(selectedIndex, managedChildren.length, (i, selected) => {
        var _managedChildren$i;

        return (_managedChildren$i = managedChildren[i]) === null || _managedChildren$i === void 0 ? void 0 : _managedChildren$i.setSelected(selected);
      });
      useLayoutEffect(([]) => {
        navigateToIndex(selectedIndex);
      }, [selectedIndex, managedChildren.length]);
      var childCount = managedChildren.length;
      var {
        lastActiveElement
      } = useActiveElement();
      var anyRadiosFocused = !!(inputElement !== null && inputElement !== void 0 && inputElement.contains(lastActiveElement));
      y(() => {
        if (!anyRadiosFocused) setTabbableIndex(selectedIndex);
      }, [anyRadiosFocused, selectedIndex, setTabbableIndex]);
      var useListboxSingleItem = A$1(info => {
        var [selected, setSelected, getSelected] = useState(false);
        var {
          tabbable,
          useListNavigationSiblingProps,
          useListNavigationChildProps
        } = useListNavigationChild(_objectSpread2({
          setSelected
        }, info));
        var {
          element,
          useRefElementProps
        } = useRefElement();
        var index = info.index;
        y(() => {
          if (element && tabbable && selectionMode == "focus") {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
          }
        }, [element, tabbable, selectionMode, index]);
        return {
          useListboxSingleItemProps,
          tabbable,
          selected,
          getSelected
        };

        function useListboxSingleItemProps(props) {
          var newProps = useButtonLikeEventHandlers(info.tag, e => {
            navigateToIndex(info.index);
            if (element) stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
            e.preventDefault();
          }, undefined)({});
          props.role = "option";
          props["aria-setsize"] = childCount.toString();
          props["aria-posinset"] = (info.index + 1).toString();
          props["aria-selected"] = selected.toString();
          return useListNavigationChildProps(useMergedProps()(newProps, useRefElementProps(props)));
        }
      }, [useListNavigationChild, selectionMode, childCount]);
      var useListboxSingleLabel = A$1(function useListboxSingleLabel() {
        function useListboxSingleLabelProps(props) {
          var {
            useGenericLabelLabelProps
          } = useGenericLabelLabel();
          useGenericLabelLabelProps(props);
        }

        return {
          useListboxSingleLabelProps
        };
      }, [useGenericLabelLabel]);
      return _objectSpread2({
        useListboxSingleItem,
        useListboxSingleProps,
        useListboxSingleLabel
      }, listRest);

      function useListboxSingleProps(props) {
        props.role = "listbox";
        return useHasFocusProps(useGenericLabelInputProps(props));
      }
    }

    var _excluded$i = ["collator", "keyNavigation", "noTypeahead", "noWrap", "typeaheadTimeout"];
    function useAriaMenu(_ref) {
      var {
        collator,
        keyNavigation,
        noTypeahead,
        noWrap,
        typeaheadTimeout
      } = _ref,
          args = _objectWithoutProperties(_ref, _excluded$i);

      var [focusTrapActive, setFocusTrapActive] = l(false);
      var onClose = args.onClose;
      var onOpen = args.onOpen;
      var menubar = args.menubar;
      var open = menubar ? true : args.open;
      var stableOnClose = useStableCallback(onClose !== null && onClose !== void 0 ? onClose : () => {}); // TODO: It's awkward that the button focus props are out here where we don't have its type,
      // but focus management is super sensitive, and even waiting for a useLayoutEffect to sync state here
      // would be too late, so it would look like there's a moment between menu focus lost and button focus gained
      // where nothing is focused. 

      var {
        focusedInner: menuHasFocus,
        useHasFocusProps: useMenuHasFocusProps
      } = useHasFocus();
      var {
        focusedInner: buttonHasFocus,
        useHasFocusProps: useButtonHasFocusProps
      } = useHasFocus();
      var {
        activeElement,
        lastActiveElement,
        windowFocused
      } = useActiveElement();
      var {
        managedChildren,
        useListNavigationChild,
        tabbableIndex,
        focusSelf: focusMenu
      } = useListNavigation({
        collator,
        keyNavigation,
        noTypeahead,
        noWrap,
        typeaheadTimeout,
        focusOnChange: menuHasFocus || buttonHasFocus
      });
      var {
        useRandomIdProps: useMenuIdProps,
        useReferencedIdProps: useMenuIdReferencingProps
      } = useRandomId({
        prefix: "aria-menu-"
      });
      var [openerElement, setOpenerElement] = l(null);
      var {
        useSoftDismissProps
      } = useSoftDismiss({
        onClose: stableOnClose
      });
      y(() => {
        setFocusTrapActive(open);
      }, [open]);
      y(() => {
        if (focusTrapActive) focusMenu();else openerElement === null || openerElement === void 0 ? void 0 : openerElement.focus();
      }, [focusTrapActive]); // Focus management is really finicky, and there's always going to be 
      // an edge case where nothing's focused for two consecutive frames 
      // on iOS or whatever, which would immediately close the menu 
      // any time it's been opened. So any time it *looks* like we should close,
      // try waiting 100ms. If it's still true then, then yeah, we should close.

      var shouldClose = focusTrapActive && windowFocused && !menuHasFocus && !buttonHasFocus;
      useTimeout({
        timeout: 100,
        callback: () => {
          if (shouldClose) {
            onClose === null || onClose === void 0 ? void 0 : onClose();
          }
        },
        triggerIndex: "".concat(shouldClose)
      }); // A menu sentinal is a hidden but focusable element that comes at the start or end of the element
      // that, when activated or focused over, closes the menu.
      // (if focused within 100ms of the open prop changing, instead of
      // closing the menu, focusing the sentinel immediately asks the menu to focus itself).
      // This exists because while mouse users can click out of a menu
      // and keyboard users can escape to close the menu,
      // screen readers and other input methods that don't use those two become stuck.

      var useMenuSentinel = A$1(() => {
        var [firstSentinelIsActive, setFirstSentinelIsActive] = l(false);
        useTimeout({
          callback: () => {
            setFirstSentinelIsActive(open);
          },
          timeout: 100,
          triggerIndex: "".concat(firstSentinelIsActive)
        });
        var onFocus = firstSentinelIsActive ? () => stableOnClose() : () => focusMenu();

        var onClick = () => stableOnClose();

        return {
          useMenuSentinelProps: function (p) {
            return useMergedProps()({
              onFocus,
              onClick
            }, p);
          }
        };
      }, [open]);
      var useMenuButton = A$1(({
        tag
      }) => {
        var {
          element,
          getElement,
          useRefElementProps
        } = useRefElement();
        useLayoutEffect(() => {
          setOpenerElement(element);
        }, [element]);
        return {
          useMenuButtonProps: function (p) {
            var props = useRefElementProps(useMergedProps()({
              onClick: () => {
                return open ? onClose === null || onClose === void 0 ? void 0 : onClose() : onOpen === null || onOpen === void 0 ? void 0 : onOpen();
              }
            }, useMenuIdReferencingProps("aria-controls")(useButtonHasFocusProps(p))));
            props["aria-haspopup"] = "menu";
            props["aria-expanded"] = open ? "true" : undefined;
            return props;
          }
        };
      }, [open, onClose, onOpen, useMenuIdReferencingProps]);
      var useMenuSubmenuItem = A$1(args => {
        var {
          useMenuProps,
          useMenuButton
        } = useAriaMenu(args);
        var {
          useMenuButtonProps
        } = useMenuButton({
          tag: "li"
        });
        var {
          element,
          getElement,
          useRefElementProps
        } = useRefElement();
        useLayoutEffect(() => {
          setOpenerElement(element);
        }, [element]);
        return {
          element,
          getElement,
          useMenuProps,
          useMenuSubmenuItemProps: function (_ref2) {
            var props = _extends({}, _ref2);

            props.role = "menuitem";
            return useRefElementProps(useMenuButtonProps(useMenuIdReferencingProps("aria-controls")(props)));
          }
        };
      }, []);
      var useMenuItem = A$1(args => {
        var {
          useListNavigationChildProps
        } = useListNavigationChild(args); // const { getSyncHandler, ...asyncInfo } = useAsyncHandler<E>()({ capture: _ => void (0) });
        // const onClick = getSyncHandler(asyncInfo.pending ? null : (args.onClick ?? null));

        var onClick = args.onClick;

        function useMenuItemProps(_ref3) {
          var props = _extends({}, _ref3);

          props.role = "menuitem";
          return useMergedProps()({
            onClick
          }, useListNavigationChildProps(props));
        }

        return {
          useMenuItemProps
        };
      }, []);
      var useMenuItemCheckbox = A$1(args => {
        //const { getSyncHandler, ...asyncInfo } = useAsyncHandler<E>()({ capture: _ => !args.checked });
        //const onClick = getSyncHandler(asyncInfo.pending ? null : args.onChange);
        var onClick = e => args.onChange(enhanceEvent(e, {
          checked: !args.checked
        }));

        function useMenuItemProps(_ref4) {
          var props = _extends({}, _ref4);

          props.role = "menuitemcheckbox";
          return useMergedProps()({
            onClick
          }, props);
        }

        return {
          useMenuItemProps
        };
      }, []);

      function useMenuProps(_ref5) {
        var props = _extends({}, _ref5);

        props.role = "menu";

        function onKeyDown(e) {
          if (e.key == "Escape" && onClose) {
            onClose();
          }
        }

        return useMenuIdProps(useMenuHasFocusProps(useMergedProps()({
          onKeyDown
        }, useSoftDismissProps(props))));
      }

      return {
        useMenuProps,
        useMenuButton,
        useMenuItem,
        useMenuSentinel,
        useMenuItemCheckbox,
        useMenuSubmenuItem,
        focusMenu
      };
    }

    var _excluded$h = ["selectionMode", "selectedIndex", "onSelect", "orientation"];
    function useAriaTabs(_ref) {
      var {
        selectionMode,
        selectedIndex,
        onSelect,
        orientation: logicalOrientation
      } = _ref,
          args = _objectWithoutProperties(_ref, _excluded$h);

      var {
        useHasFocusProps: useTabListHasFocusProps,
        focusedInner: tabListFocused
      } = useHasFocus();
      var {
        element: listElement,
        useRefElementProps
      } = useRefElement();
      var {
        getLogicalDirection,
        convertToPhysicalOrientation
      } = useLogicalDirection(listElement);
      var physicalOrientation = convertToPhysicalOrientation(logicalOrientation);
      useRandomId({
        prefix: "aria-tab-list-"
      });
      var {
        useRandomIdProps: useTabLabelIdProps,
        useReferencedIdProps: useReferencedTabLabelId
      } = useRandomId({
        prefix: "aria-tab-label-"
      });
      var {
        managedChildren: managedTabs,
        navigateToIndex,
        useListNavigationChild
      } = useListNavigation(_objectSpread2(_objectSpread2({}, args), {}, {
        focusOnChange: useTabListHasFocusProps,
        keyNavigation: logicalOrientation
      }));
      var {
        managedChildren: managedPanels,
        useManagedChild: useManagedTabPanel
      } = useChildManager();
      useStableCallback(onSelect);
      var childCount = managedTabs.length;
      useLayoutEffect(() => {
        for (var child of managedTabs) {
          child.setSelectionMode(selectionMode);
        }
      }, [selectionMode]);
      useChildFlag(selectedIndex, managedTabs.length, (i, selected) => {
        var _managedTabs$i;

        return (_managedTabs$i = managedTabs[i]) === null || _managedTabs$i === void 0 ? void 0 : _managedTabs$i.setSelected(selected);
      });
      useChildFlag(selectedIndex, managedPanels.length, (i, visible) => {
        var _managedPanels$i;

        return (_managedPanels$i = managedPanels[i]) === null || _managedPanels$i === void 0 ? void 0 : _managedPanels$i.setVisible(visible);
      });
      useLayoutEffect(([prevChildCount, prevSelectedIndex]) => {
        if (selectedIndex != null && selectionMode == "activate") {
          var _managedPanels$select;

          (_managedPanels$select = managedPanels[selectedIndex]) === null || _managedPanels$select === void 0 ? void 0 : _managedPanels$select.focus();
        }
      }, [childCount, selectedIndex, selectionMode]);
      var getTabListIsFocused = useStableGetter(tabListFocused);
      var useTab = A$1(function useTab(info) {
        //const [selectedTabId, setSelectedTabId, getSelectedTabId] = useState<string | undefined>(undefined);
        var [selectionModeL, setSelectionModeL] = useState(selectionMode);
        var {
          element,
          useRefElementProps
        } = useRefElement();
        var [tabPanelId, setTabPanelId] = useState(undefined);
        var {
          useRandomIdProps: useTabIdProps,
          id: tabId,
          getId: getTabId
        } = useRandomId({
          prefix: "aria-tab-"
        });
        var [selected, setSelected, getSelected] = useState(null);
        var {
          tabbable,
          useListNavigationChildProps,
          useListNavigationSiblingProps
        } = useListNavigationChild(_objectSpread2(_objectSpread2({}, info), {}, {
          setSelected,
          tabId,
          setTabPanelId,
          setSelectionMode: setSelectionModeL
        }));
        var getIndex = useStableGetter(info.index); // const { getSyncHandler, ...asyncInfo } = useAsyncHandler<Element>()({ capture: (e: unknown) => info.index });
        // const onSelect = getSyncHandler(asyncInfo.pending? null : (stableAsyncOnSelect ?? null));

        y(() => {
          if (tabbable && selectionModeL == "focus") {
            onSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: getIndex()
              }
            });
          }
        }, [tabbable, selectionModeL, element]);
        y(() => {
          var _managedPanels$info$i;

          (_managedPanels$info$i = managedPanels[info.index]) === null || _managedPanels$info$i === void 0 ? void 0 : _managedPanels$info$i.setTabId(tabId);
        }, [tabId, info.index]);
        /*useEffect(() => {
            if (selected)
                setSelectedTabId(tabId);
        }, [selected, tabId])*/

        function useTabProps(_ref2) {
          var props = _extends({}, _ref2);

          var newProps = useButtonLikeEventHandlers(info.tag, e => {
            navigateToIndex(info.index);
            onSelect === null || onSelect === void 0 ? void 0 : onSelect(enhanceEvent(e, {
              selectedIndex: getIndex()
            }));
            e.preventDefault();
          }, undefined)(props);
          newProps.role = "tab";
          newProps["aria-selected"] = (selected !== null && selected !== void 0 ? selected : false).toString();
          newProps["aria-controls"] = tabPanelId;
          return useMergedProps()({}, useTabIdProps(useListNavigationChildProps(useRefElementProps(newProps))));
        }

        return {
          useTabProps,
          selected
        };
      }, []);
      var useTabPanel = A$1(function usePanel(info) {
        //const [selectedTabPanelId, setSelectedTabPanelId, getSelectedTabPanelId] = useState<string | undefined>(undefined);
        var [shouldFocus, setShouldFocus] = useState(false);
        var [tabId, setTabId] = useState(undefined);
        var [selected, setSelected, getSelected] = useState(null);
        var {
          useRandomIdProps: usePanelIdProps,
          useReferencedIdProps: useReferencedPanelId,
          id: tabPanelId
        } = useRandomId({
          prefix: "aria-tab-panel-"
        });
        var {
          element,
          useManagedChildProps
        } = useManagedTabPanel(_objectSpread2(_objectSpread2({}, info), {}, {
          tabPanelId,
          setTabId,
          focus,
          setVisible: setSelected
        }));

        function focus() {
          if (getTabListIsFocused()) {
            setShouldFocus(true);
          }
        }

        y(() => {
          if (shouldFocus) {
            element === null || element === void 0 ? void 0 : element.focus();
            setShouldFocus(false);
          }
        }, [element, shouldFocus]);
        y(() => {
          var _managedTabs$info$ind;

          (_managedTabs$info$ind = managedTabs[info.index]) === null || _managedTabs$info$ind === void 0 ? void 0 : _managedTabs$info$ind.setTabPanelId(tabPanelId);
        }, [tabPanelId, info.index]);

        function useTabPanelProps(_ref3) {
          var _managedTabs$info$ind2, _props$tabIndex;

          var props = _extends({}, _ref3);

          props["aria-labelledby"] = (_managedTabs$info$ind2 = managedTabs[info.index]) === null || _managedTabs$info$ind2 === void 0 ? void 0 : _managedTabs$info$ind2.tabId;
          props.role = "tabpanel";
          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1; // Make sure the tab panel is tabbable.

          return useMergedProps()({}, usePanelIdProps(useManagedChildProps(props)));
        }

        return {
          useTabPanelProps,
          selected
        };
      }, []);
      var useTabsList = A$1(function useTabList() {
        function useTabListProps(_ref4) {
          var props = _extends({}, _ref4);

          props.role = "tablist";
          props["aria-orientation"] = physicalOrientation;
          return useReferencedTabLabelId("aria-labelledby")(useTabListHasFocusProps(useRefElementProps(props)));
        }

        return {
          useTabListProps
        };
      }, [physicalOrientation]);
      var useTabsLabel = A$1(function useTabsLabel() {
        function useTabsLabelProps(_ref5) {
          var props = _extends({}, _ref5);

          return useTabLabelIdProps(props);
        }

        return {
          useTabsLabelProps
        };
      }, []);
      return {
        useTab,
        useTabPanel,
        useTabsList,
        useTabsLabel
      };
    }

    var _excluded$g = ["value", "index", "text", "disabled", "labelPosition"];
    function useAriaRadioGroup({
      name,
      selectedValue,
      onInput
    }) {
      var {
        element,
        useRefElementProps
      } = useRefElement();
      var [selectedIndex, setSelectedIndex, getSelectedIndex] = useState(null);
      var byName = s(new Map());
      var stableOnInput = useStableCallback(onInput);
      var {
        useHasFocusProps,
        lastFocusedInner
      } = useHasFocus();
      var {
        currentTypeahead,
        managedChildren,
        useListNavigationChild,
        setTabbableIndex
      } = useListNavigation({
        focusOnChange: lastFocusedInner
      });
      var useRadioGroupProps = A$1(_ref => {
        var props = _extends({}, _ref);

        props.role = "radiogroup";
        return useRefElementProps(useHasFocusProps(props));
      }, [useHasFocusProps, useRefElementProps]);
      useChildFlag(selectedIndex, managedChildren.length, (i, checked) => {
        var _managedChildren$i;

        return (_managedChildren$i = managedChildren[i]) === null || _managedChildren$i === void 0 ? void 0 : _managedChildren$i.setChecked(checked);
      });
      var {
        lastActiveElement
      } = useActiveElement();
      var anyRadiosFocused = !!(element !== null && element !== void 0 && element.contains(lastActiveElement));
      y(() => {
        if (!anyRadiosFocused && selectedIndex != null) setTabbableIndex(selectedIndex);
      }, [anyRadiosFocused, selectedIndex, setTabbableIndex]);
      y(() => {
        getSelectedIndex();
        var newIndex = byName.current.get(selectedValue);
        setSelectedIndex(newIndex);
      }, [selectedValue]);
      var useRadio = A$1(function useAriaRadio(_ref2) {
        var {
          value,
          index,
          text,
          disabled,
          labelPosition
        } = _ref2,
            rest = _objectWithoutProperties(_ref2, _excluded$g);

        var onInput = A$1(e => {
          stableOnInput(enhanceEvent(e, {
            selectedValue: value
          }));
        }, [stableOnInput, value, index]);
        var {
          getInputElement,
          getLabelElement,
          useCheckboxLikeInputElement,
          useCheckboxLikeLabelElement
        } = useCheckboxLike({
          disabled,
          labelPosition,
          onInput,
          role: "radio"
        }); //const {} = useCheckboxLikeInputElement({  })

        var byName2 = byName.current;
        var [checked, setChecked] = useState(false);
        h(() => {
          console.assert(!byName2.has(value));
          byName2.set(value, index);
          return () => {
            byName2.delete(value);
          };
        }, [value, index]);
        var {
          tabbable,
          useListNavigationChildProps,
          useListNavigationSiblingProps
        } = useListNavigationChild(_objectSpread2({
          index,
          setChecked,
          text
        }, rest));

        var useRadioInput = ({
          tag
        }) => {
          var useRadioInputProps = props => {
            if (tag == "input") {
              props.name = name;
              props.checked = checked;
            } else {
              props["aria-checked"] = checked.toString();
            }

            var {
              useCheckboxLikeInputElementProps
            } = useCheckboxLikeInputElement({
              tag
            });
            return useMergedProps()(useListNavigationChildProps(useCheckboxLikeInputElementProps({})), props);
          };

          return {
            useRadioInputProps
          };
        };

        var useRadioLabel = A$1(({
          tag
        }) => {
          var useRadioLabelProps = props => {
            var {
              useCheckboxLikeLabelElementProps
            } = useCheckboxLikeLabelElement({
              tag
            });
            return useCheckboxLikeLabelElementProps(useMergedProps()({}, props));
          };

          return {
            useRadioLabelProps
          };
        }, [useCheckboxLikeLabelElement]);
        return {
          useRadioInput,
          useRadioLabel
        };
      }, [byName, useListNavigationChild]);
      return {
        useRadio,
        useRadioGroupProps,
        managedChildren,
        getIndex: A$1(value => {
          return byName.current.get(value);
        }, [byName])
      };
    }

    var _excluded$f = ["role", "aria-live", "aria-relevant"];
    function useToasts({}) {
      // "Pointer" to whatever index toast is currently being shown.
      // E.g. it's 0 when the first toast is shown, then when dismissed, it becomes 1.
      // When the second toast is shown, it stays at 1 until dismissed, when it then becomes 2, etc.
      // Because toasts can potentially be dismissed out of order, this represents the "oldest" toast that still hasn't been dismissed,
      // even if "younger" ones have.
      var [activeToastIndex, setActiveToastIndex, getActiveToastIndex] = useState(-1);
      var [politeness, setPoliteness] = useState("polite");
      var {
        element,
        getElement,
        useRefElementProps
      } = useRefElement();
      var {
        indicesByElement,
        managedChildren,
        mountedChildren: toastQueue,
        useManagedChild,
        getMountIndex
      } = useChildManager(); // Any time a new toast mounts, update our bottommostToastIndex to point to it if necessary
      // ("necessary" just meaning if it's the first toast ever or all prior toasts have been dismissed)

      var onAnyToastMounted = A$1(index => {
        var bottom = getActiveToastIndex();

        while (bottom < toastQueue.length && (bottom < 0 || (_toastQueue$bottom = toastQueue[bottom]) !== null && _toastQueue$bottom !== void 0 && _toastQueue$bottom.dismissed)) {
          var _toastQueue$bottom;

          ++bottom;
        }

        setActiveToastIndex(bottom);
      }, [setActiveToastIndex]); // Any time a toast is dismissed, update our bottommostToastIndex to point to the next toast in the queue, if one exists.

      var onAnyToastDismissed = A$1(index => {
        var _getElement, _toastQueue$bottom3;

        var bottom = getActiveToastIndex();

        while (bottom < toastQueue.length && (bottom < 0 || bottom === index || (_toastQueue$bottom2 = toastQueue[bottom]) !== null && _toastQueue$bottom2 !== void 0 && _toastQueue$bottom2.dismissed)) {
          var _toastQueue$bottom2;

          ++bottom;
        }

        setActiveToastIndex(bottom);
        if ((_getElement = getElement()) !== null && _getElement !== void 0 && _getElement.contains(document.activeElement)) (_toastQueue$bottom3 = toastQueue[bottom]) === null || _toastQueue$bottom3 === void 0 ? void 0 : _toastQueue$bottom3.focus();
      }, [setActiveToastIndex]); // Any time the index pointing to the currently-showing toast changes,
      // update the relevant children and let them know that they're now either active or dismissed.

      useChildFlag(activeToastIndex, toastQueue.length, (i, set) => {
        var _toastQueue$i;

        if (set) console.assert(i <= getActiveToastIndex());
        (_toastQueue$i = toastQueue[i]) === null || _toastQueue$i === void 0 ? void 0 : _toastQueue$i.setStatus(set ? "active" : i < getActiveToastIndex() ? "dismissed" : "pending");
      });
      var useToast = A$1(({
        politeness,
        timeout
      }) => {
        var [status, setStatus, getStatus] = useState("pending");
        var dismissed = status === "dismissed";
        var dismiss = A$1(() => {
          setStatus("dismissed");
        }, []);
        var {
          randomId: toastId
        } = useRandomId({
          prefix: "toast-"
        }); //const [toastId, setToastId] = useState(() => generateRandomId("toast-"));

        h(() => {
          setPoliteness(politeness !== null && politeness !== void 0 ? politeness : "polite");
        }, [politeness]);
        var focus = A$1(() => {
          var element = getElement();

          if (element) {
            var firstFocusable = findFirstFocusable(element);
            firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
          }
        }, []);
        var {
          element,
          useManagedChildProps,
          getElement
        } = useManagedChild({
          dismissed,
          index: toastId,
          setStatus,
          focus
        });
        var isActive = status === "active";
        y(() => {
          onAnyToastMounted(getMountIndex(toastId));
        }, []);
        y(() => {
          if (dismissed) onAnyToastDismissed(getMountIndex(toastId));
        }, [dismissed]);
        useTimeout({
          timeout,
          callback: () => {
            if (isActive) setStatus("dismissed");
          },
          triggerIndex: isActive
        });
        return {
          status,
          getStatus,
          dismiss,
          useToastProps: function (_ref) {
            var props = _extends({}, _ref);

            return useMergedProps()(useManagedChildProps({}), props);
          }
        };
      }, []);

      function useToastContainerProps(_ref2) {
        var _ref3;

        var {
          role,
          "aria-live": ariaLive,
          "aria-relevant": ariaRelevant
        } = _ref2,
            props = _objectWithoutProperties(_ref2, _excluded$f);

        return useMergedProps()(useRefElementProps({
          class: "toasts-container",
          role: "status",
          "aria-live": (_ref3 = politeness !== null && politeness !== void 0 ? politeness : ariaLive) !== null && _ref3 !== void 0 ? _ref3 : "polite",
          "aria-relevant": ariaRelevant !== null && ariaRelevant !== void 0 ? ariaRelevant : "additions"
        }), props);
      }

      return {
        useToast,
        useToastContainerProps
      };
    }

    var _excluded$e = ["data-pseudo-active"];
    function forwardElementRef(component) {
      return x(component);
    }
    function usePseudoActive(_ref) {
      var {
        "data-pseudo-active": active
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$e);

      return useMergedProps()({
        className: clsx((active == true || active == "true") && "active")
      }, props);
    }
    var SpinnerDelayContext = D$1(1000);
    function useSpinnerDelay(pending) {
      var [showSpinner, setShowSpinner] = useState(false);
      y(() => {
        if (!pending) {
          setShowSpinner(false);
        }
      }, [pending]);
      useTimeout({
        timeout: F(SpinnerDelayContext),
        callback: () => {
          setShowSpinner(pending);
        },
        triggerIndex: pending
      });
      return showSpinner;
    }

    var _excluded$d = ["expandedIndex", "setExpandedIndex", "children"],
        _excluded2$8 = ["index", "open", "header", "headerLevel", "children", "Transition"];
    var UseAriaAccordionSectionContext = D$1(null);
    var Accordion = forwardElementRef(function Accordion(_ref, ref) {
      var {
        expandedIndex,
        setExpandedIndex,
        children
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$d);

      var {
        useAriaAccordionSection
      } = useAriaAccordion({
        expandedIndex,
        setExpandedIndex
      });
      return v$1("div", _objectSpread2({}, useMergedProps()({
        ref,
        className: "accordian"
      }, props)), v$1(UseAriaAccordionSectionContext.Provider, {
        value: useAriaAccordionSection
      }, children));
    });
    var AccordionSection = forwardElementRef(function AccordionSection(_ref2, ref) {
      var _Transition, _headerLevel;

      var {
        index,
        open,
        header,
        headerLevel,
        children,
        Transition
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$8);

      var useAriaAccordionSection = F(UseAriaAccordionSectionContext);
      var {
        expanded,
        useAriaAccordionSectionHeader,
        useAriaAccordionSectionBody
      } = useAriaAccordionSection({
        index,
        open
      });
      var {
        useAriaAccordionSectionHeaderProps
      } = useAriaAccordionSectionHeader({
        tag: "button"
      });
      var {
        useAriaAccordionSectionBodyProps
      } = useAriaAccordionSectionBody();
      (_Transition = Transition) !== null && _Transition !== void 0 ? _Transition : Transition = Collapse;
      (_headerLevel = headerLevel) !== null && _headerLevel !== void 0 ? _headerLevel : headerLevel = 2;
      console.log("".concat(index, ": ").concat(expanded === null || expanded === void 0 ? void 0 : expanded.toString()));
      var headerButtonProps = useAriaAccordionSectionHeaderProps({
        type: "button",
        class: clsx("accordion-button", !expanded ? " collapsed" : "")
      });
      var headerProps = {
        class: "accordion-header",
        children: v$1("button", _objectSpread2({}, headerButtonProps), header)
      };
      var headerJsx = headerLevel >= 1 && headerLevel <= 6 ? v$1("h".concat(headerLevel), headerProps) : v$1("div", useMergedProps()(headerProps, {
        role: "heading",
        "aria-level": "".concat(headerLevel)
      }));
      return v$1("div", _objectSpread2({}, {
        ref,
        class: "accordion-item"
      }), headerJsx, v$1(Transition, _objectSpread2({
        open: expanded
      }, useAriaAccordionSectionBodyProps(useMergedProps()(props, {
        class: ""
      }))), v$1("div", null, v$1("div", {
        class: "accordion-body"
      }, children))));
    });

    var _excluded$c = ["aria-valuemax", "aria-valuenow", "aria-valuetext", "role"],
        _excluded3$2 = ["mode", "colorFill", "childrenPosition", "children", "color"];
    function useAriaProgressBar({
      tag,
      max,
      value,
      valueText
    }) {
      //const { inputId, labelId, useGenericLabelInput, useGenericLabelLabel, useReferencedInputIdProps, useReferencedLabelIdProps } = useGenericLabel({ inputPrefix: "progressbar-", labelPrefix: "progressbar-reference-" });
      var {
        id: progressBarId,
        getId,
        useRandomIdProps,
        useReferencedIdProps
      } = useRandomId({
        prefix: "progressbar-"
      });

      function useProgressProps(_ref) {
        var p = _objectWithoutProperties(_ref, _excluded$c);

        var extraProps = tag === "progress" ? {
          max,
          value: value !== null && value !== void 0 ? value : undefined,
          "aria-valuenow": value == null ? undefined : "".concat(value)
        } : {
          "aria-valuemax": max == null ? undefined : "".concat(max),
          "aria-valuetext": valueText == null ? undefined : "".concat(valueText),
          "aria-valuenow": value == null ? undefined : "".concat(value),
          role: "progressbar"
        };
        return useRandomIdProps(useMergedProps()(extraProps, p));
      }

      var useReferencedElement = A$1(function useReferencedElement() {
        function useReferencedProps(props) {
          return useReferencedIdProps("aria-controls")(props);
        }

        return {
          useReferencedProps
        };
      }, [useReferencedIdProps]);
      return {
        useProgressProps,
        useReferencedElement
      };
    }
    var ProgressAsChildContext = D$1(undefined);
    D$1(undefined);
    D$1(undefined);
    D$1(undefined);

    new Date().getDate() % 2;

    function Check() {
      return v$1("i", {
        class: "bi bi-check text-success"
      });
    }

    function Cross() {
      return v$1("i", {
        class: "bi bi-x text-warning"
      });
    }

    var ProgressCircular = forwardElementRef(function (_ref3, ref) {
      var _childrenPosition;

      var {
        mode,
        colorFill,
        childrenPosition,
        children,
        color
      } = _ref3,
          p = _objectWithoutProperties(_ref3, _excluded3$2);

      F(ProgressAsChildContext);
      var {
        useProgressProps,
        useReferencedElement
      } = useAriaProgressBar({
        value: null,
        valueText: undefined,
        max: undefined,
        tag: "div"
      }); //useLayoutEffect(() => { provideParentWithHook?.(useReferencedElement) }, [useReferencedElement, provideParentWithHook])

      var {
        useReferencedProps
      } = useReferencedElement();
      var showSpinner = useSpinnerDelay(mode === "pending"); //const [spinnerShowCount, setSpinnerShowCount] = useState(0);
      //useEffect(() => { setSpinnerShowCount(s => ++s) }, [showSpinner]);

      y(() => {
        setShownStatusLongEnough(false);
      }, [mode]);
      var [shownStatusLongEnough, setShownStatusLongEnough] = useState(false);
      useTimeout({
        callback: () => {
          if (mode == "failed" || mode == "succeeded") setShownStatusLongEnough(true);
        },
        timeout: 1000,
        triggerIndex: mode
      });
      var progressElement = v$1("div", _objectSpread2({}, useMergedProps()(useProgressProps({
        ref,
        className: clsx("circular-progress-container")
      }), p)), v$1(Swappable, null, v$1("div", {
        className: "circular-progress-swappable"
      }, v$1(Fade, {
        open: mode === "pending" && showSpinner
      }, v$1("div", {
        className: clsx("circular-progress", "circular-progress-".concat(color !== null && color !== void 0 ? color : "primary"), colorFill == "foreground" && "inverse-fill", colorFill === "foreground-only" && "no-fill")
      }, v$1("div", null, v$1("div", null)), v$1("div", null, v$1("div", null)), v$1("div", null, v$1("div", null)), v$1("div", null, v$1("div", null)), v$1("div", null, v$1("div", null)), v$1("div", null, v$1("div", null)), v$1("div", null, v$1("div", null)), v$1("div", null, v$1("div", null)))), v$1(Fade, {
        open: !shownStatusLongEnough && mode === "succeeded"
      }, v$1("div", null, v$1(Check, null))), v$1(Fade, {
        open: !shownStatusLongEnough && mode === "failed"
      }, v$1("div", null, v$1(Cross, null))))));
      (_childrenPosition = childrenPosition) !== null && _childrenPosition !== void 0 ? _childrenPosition : childrenPosition = "after";
      return v$1(d$1, null, childrenPosition == "before" && progressElement, children && v$1(children.type, useMergedProps()({
        children: childrenPosition === "child" ? progressElement : undefined,
        ref: children.ref
      }, useReferencedProps(children.props))), childrenPosition == "after" && progressElement);
    });

    var DefaultFillStyleContext = D$1("fill");
    var DefaultColorStyleContext = D$1("primary");
    var DefaultSizeContext = D$1("md");
    var DefaultDisabledContext = D$1(false);
    var ProvideDefaultButtonFill = g(function ProvideDefaultButtonFill({
      value,
      children
    }) {
      return v$1(DefaultFillStyleContext.Provider, {
        value: value
      }, children);
    });
    var ProvideDefaultButtonColor = g(function ProvideDefaultButtonColor({
      value,
      children
    }) {
      return v$1(DefaultColorStyleContext.Provider, {
        value: value
      }, children);
    });
    var ProvideDefaultButtonSize = g(function ProvideDefaultButtonSize({
      value,
      children
    }) {
      return v$1(DefaultSizeContext.Provider, {
        value: value
      }, children);
    });
    var ProvideDefaultButtonDisabled = g(function ProvideDefaultButtonDisabled({
      value,
      children
    }) {
      return v$1(DefaultDisabledContext.Provider, {
        value: value
      }, children);
    });
    function useButtonFillVariant(providedValue) {
      var defaultFill = F(DefaultFillStyleContext);
      return providedValue !== null && providedValue !== void 0 ? providedValue : defaultFill;
    }
    function useButtonColorVariant(providedValue) {
      var defaultColor = F(DefaultColorStyleContext);
      return providedValue !== null && providedValue !== void 0 ? providedValue : defaultColor;
    }
    function useButtonSize(providedValue) {
      var defaultSize = F(DefaultSizeContext);
      return providedValue !== null && providedValue !== void 0 ? providedValue : defaultSize;
    }
    function useButtonDisabled(providedValue) {
      var defaultDisabled = F(DefaultDisabledContext);
      return providedValue !== null && providedValue !== void 0 ? providedValue : defaultDisabled;
    }
    function useButtonStyles(p) {
      var {
        colorVariant,
        size,
        fillVariant,
        disabled
      } = p;
      colorVariant = useButtonColorVariant(colorVariant);
      size = useButtonSize(size);
      fillVariant = useButtonFillVariant(fillVariant);
      disabled = useButtonDisabled(disabled);

      var useButtonStylesProps = props => useMergedProps()({
        "aria-disabled": disabled ? "true" : undefined,
        className: clsx(disabled && "disabled", "btn", "btn-".concat(fillVariant == "outline" ? "outline-" : "").concat(colorVariant), "btn-".concat(size), disabled && "disabled")
      }, props);

      return {
        colorVariant,
        size,
        fillVariant,
        disabled,
        useButtonStylesProps
      };
    }

    var _excluded$b = ["colorVariant", "size", "fillVariant", "disabled"],
        _excluded2$7 = ["colorVariant", "size", "fillVariant", "disabled", "debounce", "showAsyncSuccess", "onClick"];

    function ButtonR(p, ref) {
      var _p$tag;

      if (((_p$tag = p.tag) === null || _p$tag === void 0 ? void 0 : _p$tag.toLowerCase()) === "a") return v$1(AnchorButton, _objectSpread2({
        ref: ref
      }, p));else return v$1(ButtonButton, _objectSpread2({
        ref: ref
      }, p));
    }

    var AnchorButton = forwardElementRef(function AnchorButton(p, ref) {
      var {
        colorVariant,
        size,
        fillVariant,
        disabled
      } = p,
          props = _objectWithoutProperties(p, _excluded$b);

      var {
        useAriaButtonProps
      } = useAriaButton({
        tag: "a"
      });
      var buttonStyleInfo = useButtonStyles({
        colorVariant,
        size,
        fillVariant,
        disabled
      });
      disabled = buttonStyleInfo.disabled;
      colorVariant = buttonStyleInfo.colorVariant;
      size = buttonStyleInfo.size;
      fillVariant = buttonStyleInfo.fillVariant;
      var useButtonStylesProps = buttonStyleInfo.useButtonStylesProps;
      return v$1("a", _objectSpread2({}, useAriaButtonProps(useButtonStylesProps(_objectSpread2(_objectSpread2({}, props), {}, {
        ref
      })))));
    });
    var ButtonButton = forwardElementRef(function ButtonButton(p, ref) {
      var {
        colorVariant,
        size,
        fillVariant,
        disabled,
        debounce,
        showAsyncSuccess,
        onClick: onClickAsync
      } = p,
          props = _objectWithoutProperties(p, _excluded2$7);

      var {
        getSyncHandler,
        pending,
        settleCount,
        hasError
      } = useAsyncHandler()({
        debounce,
        capture: A$1(() => {
          return undefined;
        }, [])
      });
      disabled || (disabled = pending);
      var {
        useAriaButtonProps
      } = useAriaButton({
        tag: "button"
      });
      var buttonStyleInfo = useButtonStyles({
        colorVariant,
        size,
        fillVariant,
        disabled
      });
      disabled = buttonStyleInfo.disabled;
      colorVariant = buttonStyleInfo.colorVariant;
      size = buttonStyleInfo.size;
      fillVariant = buttonStyleInfo.fillVariant;
      var useButtonStylesProps = buttonStyleInfo.useButtonStylesProps;
      var onClick = getSyncHandler(pending ? null : onClickAsync);
      return v$1(ProgressCircular, {
        mode: hasError ? "failed" : pending ? "pending" : settleCount && showAsyncSuccess ? "succeeded" : null,
        childrenPosition: "child",
        color: colorVariant === "link" ? "primary" : colorVariant,
        colorFill: fillVariant == "fill" ? "foreground" : "background"
      }, v$1("button", _objectSpread2({}, useAriaButtonProps(useButtonStylesProps(_objectSpread2(_objectSpread2({}, props), {}, {
        onClick,
        ref
      }))))));
    });
    var Button = forwardElementRef(ButtonR);

    var _excluded$a = ["colorVariant", "size", "disabled", "pressed", "debounce", "onClick"];
    var ToggleButton = forwardElementRef(function ToggleButton(p, ref) {
      var {
        colorVariant,
        size,
        disabled,
        pressed,
        debounce,
        onClick: onClickAsync
      } = p,
          props = _objectWithoutProperties(p, _excluded$a);

      var fillVariant = pressed ? "fill" : "outline";
      var getPressed = useStableGetter(pressed);
      var {
        getSyncHandler,
        pending
      } = useAsyncHandler()({
        debounce,
        capture: A$1(() => {
          return !getPressed();
        }, [])
      });
      disabled || (disabled = pending);
      var {
        useAriaButtonProps
      } = useAriaButton({
        tag: "button",
        pressed
      });
      var buttonStyleInfo = useButtonStyles({
        colorVariant,
        size,
        fillVariant,
        disabled
      });
      disabled = buttonStyleInfo.disabled;
      colorVariant = buttonStyleInfo.colorVariant;
      size = buttonStyleInfo.size;
      var useButtonStylesProps = buttonStyleInfo.useButtonStylesProps;
      var onClick = getSyncHandler(pending ? null : onClickAsync);
      return v$1("button", _objectSpread2({}, useAriaButtonProps(useButtonStylesProps(_objectSpread2(_objectSpread2({}, props), {}, {
        onClick,
        ref
      })))));
    });

    var _excluded$9 = ["colorVariant", "fillVariant", "size", "disabled", "selectedIndex"],
        _excluded2$6 = ["index"];
    var UseButtonGroupChild = D$1(null);
    var ButtonGroup = forwardElementRef(function ButtonGroup(p, ref) {
      var {
        lastFocusedInner,
        useHasFocusProps
      } = useHasFocus();
      var {
        indicesByElement,
        managedChildren,
        useListNavigationChild,
        navigateToIndex,
        childCount
      } = useListNavigation({
        focusOnChange: lastFocusedInner
      }); // Styling props

      var {
        colorVariant,
        fillVariant,
        size,
        disabled,
        selectedIndex
      } = p,
          p3 = _objectWithoutProperties(p, _excluded$9);

      y(() => {
        if (selectedIndex != null) navigateToIndex(selectedIndex);
      }, [selectedIndex]); // Build new DOM props to merge based off the styling props

      colorVariant = useButtonColorVariant(colorVariant);
      size = useButtonSize(size);
      fillVariant = useButtonFillVariant(fillVariant);
      disabled = useButtonDisabled(disabled);
      var newDomProps = {
        ref,
        role: "group",
        disabled,
        className: clsx("btn-group")
      }; // Remaining props, forwarded onto the DOM

      var domProps = useHasFocusProps(useMergedProps()(newDomProps, p3));
      domProps["data-child-count"] = "".concat(childCount);
      return v$1(UseButtonGroupChild.Provider, {
        value: useListNavigationChild
      }, v$1(ProvideDefaultButtonColor, {
        value: colorVariant
      }, v$1(ProvideDefaultButtonFill, {
        value: fillVariant
      }, v$1(ProvideDefaultButtonSize, {
        value: size
      }, v$1(ProvideDefaultButtonDisabled, {
        value: disabled
      }, v$1("div", _objectSpread2({}, domProps)))))));
    });

    function ButtonGroupChild1(_ref, ref) {
      var {
        index
      } = _ref,
          buttonProps = _objectWithoutProperties(_ref, _excluded2$6);

      // This is more-or-less forced to be a separate component because of the index prop.
      // It would be really nice to find a way to make that implicit based on DOM location,
      // specifically for small things like button groups...
      var useButtonGroupChild = F(UseButtonGroupChild);
      var {
        tabbable,
        useListNavigationChildProps,
        useListNavigationSiblingProps
      } = useButtonGroupChild({
        index,
        text: null
      }); // TODO: It's kinda fragile here how the sync onClick of listNavigation 
      // and the async onClick of button are mixing.

      var p = useListNavigationChildProps(_objectSpread2({
        ref
      }, buttonProps));
      if (p.pressed != null) return v$1(ToggleButton, _objectSpread2({}, p));else return v$1(Button, _objectSpread2({}, p));
    }

    var ButtonGroupChild = forwardElementRef(ButtonGroupChild1);

    var baseId = generateRandomId("render-portal-container-");
    function BodyPortal({
      children
    }) {
      var id = s(null);
      var [portalElement, setPortalElement] = l(null);
      y(() => {
        if (id.current == null) {
          id.current = generateRandomId();
        }

        var container = document.getElementById(baseId);

        if (!container) {
          container = document.createElement("div");
          container.id = baseId;
          container.className = "body-portal-container";
          document.body.appendChild(container);
        }

        var element = document.getElementById(id.current);

        if (!element) {
          element = document.createElement("div");
          element.className = "body-portal";
          element.id = id.current;
          container.appendChild(element);
        }

        setPortalElement(element);
        return () => document.removeChild(element);
      }, []);
      if (portalElement) return W(children, portalElement);else return null;
    }

    var _excluded$8 = ["onClose", "open", "descriptive", "title", "footer", "Transition", "children"];
    var Dialog = forwardElementRef(function Dialog(_ref, ref) {
      var {
        onClose,
        open,
        descriptive,
        title,
        footer,
        Transition,
        children
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$8);

      var {
        useDialogBackdrop,
        useDialogBody,
        useDialogProps,
        useDialogTitle
      } = useAriaDialog({
        open,
        onClose
      });
      var {
        useModalBackdropProps
      } = useDialogBackdrop();
      var {
        useModalBodyProps
      } = useDialogBody({
        descriptive
      });
      var {
        useModalTitleProps
      } = useDialogTitle();
      return v$1(BodyPortal, null, v$1("div", {
        class: "modal-portal-container"
      }, v$1(Fade, {
        open: open
      }, v$1("div", _objectSpread2({}, useModalBackdropProps({
        class: "modal-backdrop  backdrop-filter-transition",
        onPointerUp: () => onClose("backdrop")
      })))), v$1(Transition, _objectSpread2({}, _objectSpread2({
        ref,
        open
      }, rest)), v$1("div", _objectSpread2({}, useDialogProps({
        class: "modal-dialog modal-dialog-scrollable"
      })), v$1("div", {
        class: "modal-content "
      }, title != null && v$1("div", _objectSpread2({}, useModalTitleProps({
        class: "modal-header"
      })), v$1("h1", {
        class: "modal-title"
      }, title)), v$1("div", _objectSpread2({}, useModalBodyProps({
        class: "modal-body"
      })), children), footer != null && v$1("div", {
        class: "modal-footer"
      }, footer))))));
    });

    var _excluded$7 = ["onSelect", "selectedIndex", "selectionMode", "collator", "keyNavigation", "noTypeahead", "noWrap", "typeaheadTimeout", "tag", "select"],
        _excluded2$5 = ["index"];
    var UseListboxSingleItemContext = D$1(null);
    function ListSingle(props, ref) {
      var {
        onSelect: onSelectAsync,
        selectedIndex,
        selectionMode,
        collator,
        keyNavigation,
        noTypeahead,
        noWrap,
        typeaheadTimeout,
        tag,
        select
      } = props,
          domProps = _objectWithoutProperties(props, _excluded$7);

      var {
        getSyncHandler
      } = useAsyncHandler()({
        capture: e => e[EventDetail].selectedIndex
      });
      var onSelect = getSyncHandler(onSelectAsync);
      var {
        useListboxSingleItem,
        useListboxSingleLabel,
        useListboxSingleProps
      } = useAriaListboxSingle({
        onSelect,
        selectedIndex,
        selectionMode,
        typeaheadTimeout,
        noWrap,
        noTypeahead,
        keyNavigation,
        collator
      });
      return v$1(UseListboxSingleItemContext.Provider, {
        value: useListboxSingleItem
      }, v$1(tag, useMergedProps()({
        class: "list-group",
        ref
      }, useListboxSingleProps(domProps))));
    }
    function ListItemSingle(props, ref) {
      var useListItemSingle = F(UseListboxSingleItemContext);

      var _props$ref = _objectSpread2(_objectSpread2({}, props), {}, {
        ref
      }),
          {
        index
      } = _props$ref,
          domProps = _objectWithoutProperties(_props$ref, _excluded2$5);

      var [text, setText] = useState(null);
      var {
        useRefElementProps,
        element
      } = useRefElement();
      h(() => {
        if (element) setText(element.innerText);
      }, [element]);
      var {
        getSelected,
        tabbable,
        selected,
        useListboxSingleItemProps
      } = useListItemSingle({
        index,
        text,
        tag: "li"
      });
      return v$1("li", _objectSpread2({}, usePseudoActive(useMergedProps()({
        class: clsx("list-group-item", "list-group-item-action", selected && "active")
      }, useListboxSingleItemProps(useRefElementProps(domProps))))));
    }

    var _excluded$6 = ["onSelect", "orientation", "selectedIndex", "selectionMode", "tag", "children", "visualVariant"],
        _excluded2$4 = ["index", "children"],
        _excluded3$1 = ["index", "children", "Transition"];
    var UseTabContext = D$1(null);
    var UseTabPanelContext = D$1(null);
    function Tabs(_ref) {
      var _orientation;

      var {
        onSelect: onSelectAsync,
        orientation,
        selectedIndex,
        selectionMode,
        tag,
        children,
        visualVariant
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded$6);

      var capture = e => {
        return e[EventDetail].selectedIndex;
      };

      (_orientation = orientation) !== null && _orientation !== void 0 ? _orientation : orientation = "inline";
      var {
        getSyncHandler
      } = useAsyncHandler()({
        capture: capture
      });
      var onSelect = getSyncHandler(onSelectAsync);
      var {
        useTab,
        useTabPanel,
        useTabsLabel,
        useTabsList
      } = useAriaTabs({
        onSelect,
        selectedIndex,
        selectionMode,
        orientation
      });
      var {
        useTabListProps
      } = useTabsList();
      return v$1("div", {
        class: clsx("tabs-container", "tabs-orientation-".concat(orientation))
      }, v$1(UseTabContext.Provider, {
        value: useTab
      }, B(children[0], useTabListProps(useMergedProps()({
        className: clsx("nav", visualVariant == "pills" ? "nav-pills" : "nav-tabs")
      }, _objectSpread2({}, props))), children[0].props.children)), v$1(UseTabPanelContext.Provider, {
        value: useTabPanel
      }, v$1(Swappable, null, v$1("div", {
        class: "tab-content"
      }, children.slice(1)))));
    }
    function Tab(_ref2) {
      var {
        index,
        children
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded2$4);

      var useTabContext = F(UseTabContext);
      var {
        useTabProps,
        selected
      } = useTabContext({
        index,
        text: null,
        tag: "button"
      });
      return v$1("li", {
        className: "nav-item",
        role: "presentation"
      }, v$1("button", _objectSpread2({}, useTabProps(useMergedProps()({
        class: clsx("nav-link", selected && "active")
      }, props))), children));
    }
    function TabPanel(_ref3) {
      var {
        index,
        children,
        Transition
      } = _ref3,
          rest = _objectWithoutProperties(_ref3, _excluded3$1);

      var useTabPanel = F(UseTabPanelContext);
      var {
        useTabPanelProps,
        selected
      } = useTabPanel({
        index
      });
      return v$1(Transition, useTabPanelProps(_objectSpread2({
        class: "",
        open: selected,
        children
      }, rest)));
    }

    var DemoUseInterval = function () {
        var _a = l(1000), interval = _a[0], setInterval = _a[1];
        var _b = l(0), fireCount = _b[0], setFireCount = _b[1];
        useInterval({ interval: interval, callback: function () { return setFireCount(function (i) { return ++i; }); } });
        return (v$1("div", { class: "demo" },
            v$1("label", null,
                "Interval duration: ",
                v$1("input", { type: "number", value: interval, onInput: function (e) { return setInterval(e.currentTarget.valueAsNumber); } })),
            v$1("div", null,
                "The callback has been called ",
                fireCount,
                " time",
                fireCount === 1 ? "" : "s",
                ".")));
    };

    var DemoUseTimeout = function () {
        var _a = l(1000), timeout = _a[0], setTimeout = _a[1];
        var _b = l(""), triggerIndex = _b[0], setTriggerIndex = _b[1];
        var _c = l(0), fireCount = _c[0], setFireCount = _c[1];
        useTimeout({ timeout: timeout, triggerIndex: triggerIndex, callback: function () { return setFireCount(function (i) { return ++i; }); } });
        return (v$1("div", { class: "demo" },
            v$1("label", null,
                "Timeout duration: ",
                v$1("input", { type: "number", value: timeout, onInput: function (e) { return setTimeout(e.currentTarget.valueAsNumber); } })),
            v$1("label", null,
                "Refresh key: ",
                v$1("input", { type: "text", value: triggerIndex, onInput: function (e) { return setTriggerIndex(e.currentTarget.value); } })),
            v$1("div", null,
                "The callback has been called ",
                fireCount,
                " time",
                fireCount === 1 ? "" : "s",
                ".")));
    };

    var _globalThis$process, _globalThis$process2, _globalThis$process2$, _globalThis$process$e, _globalThis$process$e2;

    (_globalThis$process = globalThis.process) !== null && _globalThis$process !== void 0 ? _globalThis$process : globalThis.process = {};
    (_globalThis$process2$ = (_globalThis$process2 = globalThis.process).env) !== null && _globalThis$process2$ !== void 0 ? _globalThis$process2$ : _globalThis$process2.env = {};
    (_globalThis$process$e2 = (_globalThis$process$e = globalThis.process.env).NODE_ENV) !== null && _globalThis$process$e2 !== void 0 ? _globalThis$process$e2 : _globalThis$process$e.NODE_ENV = "development";

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }

      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }

      return node;
    }

    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }

    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }

      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }

          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$2,
      requires: ['computeStyles']
    };

    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }

    var round$1 = Math.round;
    function getBoundingClientRect(element, includeScale) {
      if (includeScale === void 0) {
        includeScale = false;
      }

      var rect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;

      if (isHTMLElement(element) && includeScale) {
        // Fallback to 1 in case both values are `0`
        scaleX = rect.width / element.offsetWidth || 1;
        scaleY = rect.height / element.offsetHeight || 1;
      }

      return {
        width: round$1(rect.width / scaleX),
        height: round$1(rect.height / scaleY),
        top: round$1(rect.top / scaleY),
        right: round$1(rect.right / scaleX),
        bottom: round$1(rect.bottom / scaleY),
        left: round$1(rect.left / scaleX),
        x: round$1(rect.left / scaleX),
        y: round$1(rect.top / scaleY)
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;

      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }

      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }

      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;

        do {
          if (next && parent.isSameNode(next)) {
            return true;
          } // $FlowFixMe[prop-missing]: need a better way to handle this...


          next = next.parentNode || next.host;
        } while (next);
      } // Give up, the result is false


      return false;
    }

    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === 'fixed') {
        return null;
      }

      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
      var isIE = navigator.userAgent.indexOf('Trident') !== -1;

      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle$1(element);

        if (elementCss.position === 'fixed') {
          return null;
        }
      }

      var currentNode = getParentNode(element);

      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    var max = Math.max;
    var min = Math.min;
    var round = Math.round;

    function within(min$1, value, max$1) {
      return max(min$1, min(value, max$1));
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect$1(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      if (process.env.NODE_ENV !== "production") {
        if (!isHTMLElement(arrowElement)) {
          console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
        }
      }

      if (!contains(state.elements.popper, arrowElement)) {
        if (process.env.NODE_ENV !== "production") {
          console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
        }

        return;
      }

      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$1,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(round(x * dpr) / dpr) || 0,
        y: round(round(y * dpr) / dpr) || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets;

      var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,
          _ref3$x = _ref3.x,
          x = _ref3$x === void 0 ? 0 : _ref3$x,
          _ref3$y = _ref3.y,
          y = _ref3$y === void 0 ? 0 : _ref3$y;

      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);

          if (getComputedStyle$1(offsetParent).position !== 'static') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


        offsetParent = offsetParent;

        if (placement === top) {
          sideY = bottom; // $FlowFixMe[prop-missing]

          y -= offsetParent[heightProp] - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left) {
          sideX = right; // $FlowFixMe[prop-missing]

          x -= offsetParent[widthProp] - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref4) {
      var state = _ref4.state,
          options = _ref4.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

      if (process.env.NODE_ENV !== "production") {
        var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';

        if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
          return transitionProperty.indexOf(property) >= 0;
        })) {
          console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
        }
      }

      var commonStyles = {
        placement: getBasePlacement(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }

      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    var passive = {
      passive: true
    };

    function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getViewportRect(element) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
      // can be obscured underneath it.
      // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
      // if it isn't open, so if this isn't available, the popper will be detected
      // to overflow the bottom of the screen too early.

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent

        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;

      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle$1(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;

      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element) {
      var rect = getBoundingClientRect(element);
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

      if (!isElement(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var referenceElement = state.elements.reference;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
      var referenceClientRect = getBoundingClientRect(referenceElement);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;

        if (process.env.NODE_ENV !== "production") {
          console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
        }
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement(placement);

        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases – research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name; // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step

      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis || checkAltAxis) {
        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
        var max$1 = popperOffsets[mainAxis] - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
        var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;

        if (checkMainAxis) {
          var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
          popperOffsets[mainAxis] = preventedOffset;
          data[mainAxis] = preventedOffset - offset;
        }

        if (checkAltAxis) {
          var _mainSide = mainAxis === 'x' ? top : left;

          var _altSide = mainAxis === 'x' ? bottom : right;

          var _offset = popperOffsets[altAxis];

          var _min = _offset + overflow[_mainSide];

          var _max = _offset - overflow[_altSide];

          var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);

          popperOffsets[altAxis] = _preventedOffset;
          data[altAxis] = _preventedOffset - _offset;
        }
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = rect.width / element.offsetWidth || 1;
      var scaleY = rect.height / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.


    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function format(str) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return [].concat(args).reduce(function (p, c) {
        return p.replace(/%s/, c);
      }, str);
    }

    var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
    var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
    var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
    function validateModifiers(modifiers) {
      modifiers.forEach(function (modifier) {
        Object.keys(modifier).forEach(function (key) {
          switch (key) {
            case 'name':
              if (typeof modifier.name !== 'string') {
                console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
              }

              break;

            case 'enabled':
              if (typeof modifier.enabled !== 'boolean') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
              }

            case 'phase':
              if (modifierPhases.indexOf(modifier.phase) < 0) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
              }

              break;

            case 'fn':
              if (typeof modifier.fn !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'effect':
              if (typeof modifier.effect !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'requires':
              if (!Array.isArray(modifier.requires)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
              }

              break;

            case 'requiresIfExists':
              if (!Array.isArray(modifier.requiresIfExists)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
              }

              break;

            case 'options':
            case 'data':
              break;

            default:
              console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
                return "\"" + s + "\"";
              }).join(', ') + "; but \"" + key + "\" was provided.");
          }

          modifier.requires && modifier.requires.forEach(function (requirement) {
            if (modifiers.find(function (mod) {
              return mod.name === requirement;
            }) == null) {
              console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
            }
          });
        });
      });
    }

    function uniqueBy(arr, fn) {
      var identifiers = new Set();
      return arr.filter(function (item) {
        var identifier = fn(item);

        if (!identifiers.has(identifier)) {
          identifiers.add(identifier);
          return true;
        }
      });
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
    var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(options) {
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned
            // if one of the modifiers is invalid for any reason

            if (process.env.NODE_ENV !== "production") {
              var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
                var name = _ref.name;
                return name;
              });
              validateModifiers(modifiers);

              if (getBasePlacement(state.options.placement) === auto) {
                var flipModifier = state.orderedModifiers.find(function (_ref2) {
                  var name = _ref2.name;
                  return name === 'flip';
                });

                if (!flipModifier) {
                  console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
                }
              }

              var _getComputedStyle = getComputedStyle$1(popper),
                  marginTop = _getComputedStyle.marginTop,
                  marginRight = _getComputedStyle.marginRight,
                  marginBottom = _getComputedStyle.marginBottom,
                  marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
              // cause bugs with positioning, so we'll warn the consumer


              if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
                return parseFloat(margin);
              })) {
                console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
              }
            }

            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {
              if (process.env.NODE_ENV !== "production") {
                console.error(INVALID_ELEMENT_ERROR);
              }

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            var __debug_loops__ = 0;

            for (var index = 0; index < state.orderedModifiers.length; index++) {
              if (process.env.NODE_ENV !== "production") {
                __debug_loops__ += 1;

                if (__debug_loops__ > 100) {
                  console.error(INFINITE_LOOP_ERROR);
                  break;
                }
              }

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    function usePopperApi({
      updating,
      position,
      skidding,
      distance,
      paddingTop,
      paddingBottom,
      paddingLeft,
      paddingRight
    }) {
      var [popperInstance, setPopperInstance, getPopperInstance] = useState(null);
      var [usedPlacement, setUsedPlacement] = useState(null);
      var {
        element: sourceElement,
        getElement: getSourceElement,
        useRefElementProps: useSourceElementRefProps
      } = useRefElement();
      var {
        element: popperElement,
        getElement: getPopperElement,
        useRefElementProps: usePopperElementRefProps
      } = useRefElement();
      var {
        element: arrowElement,
        getElement: getArrowElement,
        useRefElementProps: useArrowElementRefProps
      } = useRefElement();
      var [sourceStyle, setSourceStyle] = useState(null);
      var [sourceAttributes, setSourceAttributes] = useState({});
      var [popperStyle, setPopperStyle] = useState(null);
      var [popperAttributes, setPopperAttributes] = useState({});
      var [arrowStyle, setArrowStyle] = useState(null);
      var [arrowAttributes, setArrowAttributes] = useState({});
      y(() => {
        if (updating) {
          var rafHandle = 0;

          function raf() {
            var _ref, _getPopperInstance;

            var p = (_ref = closed ? Promise.resolve() : (_getPopperInstance = getPopperInstance()) === null || _getPopperInstance === void 0 ? void 0 : _getPopperInstance.update()) !== null && _ref !== void 0 ? _ref : Promise.resolve();
            p.then(_ => {
              if (rafHandle != 0) {
                rafHandle = requestAnimationFrame(raf);
              }
            });
          }

          rafHandle = requestAnimationFrame(raf);
          return () => {
            cancelAnimationFrame(rafHandle); // Single-threaded languages are nice sometimes.

            rafHandle = 0;
          };
        }
      }, [updating]);
      var updateStateModifier = d(() => {
        var modifier = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({
            state,
            options,
            name,
            instance
          }) => {
            var usedPlacement = state.placement;
            if (usedPlacement.includes("-")) usedPlacement = usedPlacement.substr(0, usedPlacement.indexOf("-"));
            setUsedPlacement(usedPlacement);
            if (state.styles.reference) setSourceStyle(state.styles.reference);
            if (state.attributes.reference) setSourceAttributes(state.attributes.reference);
            if (state.styles.popper) setPopperStyle(state.styles.popper);
            if (state.attributes.popper) setPopperAttributes(state.attributes.popper);
            if (state.styles.arrow) setArrowStyle(state.styles.arrow);
            if (state.attributes.arrow) setArrowAttributes(state.attributes.arrow);
          },
          requires: ["computeStyles", "flip"]
        };
        return modifier;
      }, []);
      var {
        convertElementSize,
        getLogicalDirection
      } = useLogicalDirection(sourceElement);
      y(() => {
        if (sourceElement && popperElement) {
          var onFirstUpdate = () => {};

          var strategy = "absolute";
          var placement = logicalToPlacement(getLogicalDirection(), position);
          setPopperInstance(createPopper(sourceElement, popperElement, {
            modifiers: [{
              name: "flip",
              options: {}
            }, {
              name: "preventOverflow",
              options: {
                padding: {
                  bottom: paddingBottom,
                  top: paddingTop,
                  left: paddingLeft,
                  right: paddingRight
                }
              }
            }, updateStateModifier, {
              name: 'eventListeners',
              enabled: false
            }, {
              name: "applyStyles",
              enabled: false
            }],
            onFirstUpdate,
            placement,
            strategy
          }));
        }
      }, [sourceElement, popperElement, position, skidding, distance, paddingTop, paddingBottom, paddingLeft, paddingRight]);

      function usePopperSource() {
        function usePopperSourceProps(props) {
          var style = _objectSpread2({}, sourceStyle);

          return useMergedProps()(sourceAttributes, useMergedProps()({
            style
          }, useSourceElementRefProps(props)));
        }

        return {
          usePopperSourceProps
        };
      }

      function usePopperPopup({
        open
      }) {
        function usePopperPopupProps(props) {
          var style = _objectSpread2(_objectSpread2({}, popperStyle), {}, {
            pointerEvents: open ? undefined : "none"
          });

          return useMergedProps()(popperAttributes, useMergedProps()({
            style
          }, usePopperElementRefProps(props)));
        }

        return {
          usePopperPopupProps
        };
      }

      function usePopperArrow() {
        function usePopperArrowProps(props) {
          var style = _objectSpread2({}, arrowStyle);

          return useMergedProps()(popperAttributes, useMergedProps()({
            style
          }, useArrowElementRefProps(props)));
        }

        return {
          usePopperArrowProps
        };
      }

      return {
        usePopperSource,
        usePopperPopup,
        usePopperArrow,
        usedPlacement,
        getLogicalDirection
      };
    }
    function placementToLogical(logicalDirection, placement) {
      var {
        blockDirection,
        blockOrientation,
        inlineDirection,
        inlineOrientation
      } = logicalDirection;
      var logical;

      switch ("".concat(inlineDirection, "-").concat(blockDirection, ",").concat(placement)) {
        // There's a pattern, and it could be coded as a pattern
        case "ltr-ttb,top":
          logical = "block-start";
          break;

        case "ltr-btt,bottom":
          logical = "block-start";
          break;

        case "rtl-ttb,top":
          logical = "block-start";
          break;

        case "rtl-btt,bottom":
          logical = "block-start";
          break;

        case "ttb-ltr,left":
          logical = "block-start";
          break;

        case "btt-ltr,right":
          logical = "block-start";
          break;

        case "ttb-rtl,left":
          logical = "block-start";
          break;

        case "btt-rtl,right":
          logical = "block-start";
          break;

        case "ltr-ttb,bottom":
          logical = "block-end";
          break;

        case "rtl-ttb,bottom":
          logical = "block-end";
          break;

        case "ltr-btt,top":
          logical = "block-end";
          break;

        case "rtl-btt,top":
          logical = "block-end";
          break;

        case "ttb-ltr,right":
          logical = "block-end";
          break;

        case "ttb-rtl,right":
          logical = "block-end";
          break;

        case "btt-ltr,left":
          logical = "block-end";
          break;

        case "btt-rtl,left":
          logical = "block-end";
          break;

        case "ttb-ltr,top":
          logical = "inline-start";
          break;

        case "ttb-rtl,top":
          logical = "inline-start";
          break;

        case "btt-ltr,bottom":
          logical = "inline-start";
          break;

        case "btt-rtl,bottom":
          logical = "inline-start";
          break;

        case "ltr-ttb,left":
          logical = "inline-start";
          break;

        case "rtl-ttb,left":
          logical = "inline-start";
          break;

        case "ltr-btt,right":
          logical = "inline-start";
          break;

        case "rtl-btt,right":
          logical = "inline-start";
          break;

        case "ttb-ltr,bottom":
          logical = "inline-end";
          break;

        case "ttb-rtl,bottom":
          logical = "inline-end";
          break;

        case "btt-ltr,top":
          logical = "inline-end";
          break;

        case "btt-rtl,top":
          logical = "inline-end";
          break;

        case "ltr-ttb,right":
          logical = "inline-end";
          break;

        case "rtl-ttb,right":
          logical = "inline-end";
          break;

        case "ltr-btt,left":
          logical = "inline-end";
          break;

        case "rtl-btt,left":
          logical = "inline-end";
          break;
        // Shouldn't happen, but here for type correctness.

        case "ttb-ttb,bottom":
        case "ttb-ttb,top":
        case "btt-btt,bottom":
        case "btt-btt,top":
        case "ltr-ltr,bottom":
        case "ltr-ltr,top":
        case "rtl-rtl,bottom":
        case "rtl-rtl,top":
        case "ttb-btt,bottom":
        case "btt-ttb,top":
        case "btt-ttb,bottom":
        case "ttb-btt,top":
        case "ltr-rtl,bottom":
        case "rtl-ltr,top":
        case "rtl-ltr,bottom":
        case "ltr-rtl,top":
        case "ttb-ttb,right":
        case "ttb-ttb,left":
        case "btt-btt,right":
        case "btt-btt,left":
        case "ltr-ltr,right":
        case "ltr-ltr,left":
        case "rtl-rtl,right":
        case "rtl-rtl,left":
        case "ttb-btt,right":
        case "btt-ttb,left":
        case "btt-ttb,right":
        case "ttb-btt,left":
        case "ltr-rtl,right":
        case "rtl-ltr,left":
        case "rtl-ltr,right":
        case "ltr-rtl,left":
          debugger;
          logical = logical;
          break;
      }

      return logical;
    }
    function logicalToPlacement(logicalDirection, position) {
      var placement;
      var {
        blockDirection,
        blockOrientation,
        inlineDirection,
        inlineOrientation
      } = logicalDirection;

      if (position === "block-start" || position == "block-end") {
        switch ("".concat(position, "-").concat(blockDirection)) {
          case "block-start-ttb":
            placement = "top";
            break;

          case "block-end-btt":
            placement = "top";
            break;

          case "block-start-btt":
            placement = "bottom";
            break;

          case "block-end-ttb":
            placement = "bottom";
            break;

          case "block-start-ltr":
            placement = "left";
            break;

          case "block-end-rtl":
            placement = "left";
            break;

          case "block-end-ltr":
            placement = "right";
            break;

          case "block-start-rtl":
            placement = "right";
            break;

          default:
            placement = "bottom";
            break;
        }
      } else {
        switch ("".concat(position, "-").concat(inlineDirection)) {
          case "inline-start-ltr":
            placement = "left";
            break;

          case "inline-end-rtl":
            placement = "left";
            break;

          case "inline-end-ltr":
            placement = "right";
            break;

          case "inline-start-rtl":
            placement = "right";
            break;

          case "inline-start-ttb":
            placement = "top";
            break;

          case "inline-end-btt":
            placement = "top";
            break;

          case "inline-end-ttb":
            placement = "bottom";
            break;

          case "inline-start-btt":
            placement = "bottom";
            break;

          default:
            placement = "right";
            break;
        }
      }

      return placement;
    }
    function useShouldUpdatePopper(open, elementSize) {
      // Since scroll events are asynchronous, especially on iOS devices,
      // just manually adjust the position of the popper for a bit
      // any time basically any user interaction happens.
      var [updatingForABit, setUpdatingForABit] = useState(0);
      useTimeout({
        callback: () => {
          setUpdatingForABit(0);
        },
        timeout: 100,
        triggerIndex: updatingForABit
      });
      var onInteraction = A$1(() => {
        setUpdatingForABit(u => ++u);
      }, [closed]);
      if (!open) onInteraction = null;
      useGlobalHandler(document, "keydown", onInteraction, {
        passive: true,
        capture: true
      });
      useGlobalHandler(window, "scroll", onInteraction, {
        passive: true,
        capture: true
      });
      useGlobalHandler(window, "pointermove", onInteraction, {
        passive: true,
        capture: true
      });
      useGlobalHandler(window, "click", onInteraction, {
        passive: true,
        capture: true
      });
      useGlobalHandler(window, "resize", onInteraction, {
        passive: true,
        capture: true
      });
      y(() => {
        var _onInteraction;

        (_onInteraction = onInteraction) === null || _onInteraction === void 0 ? void 0 : _onInteraction();
      }, Object.values(elementSize !== null && elementSize !== void 0 ? elementSize : {}));
      return {
        shouldUpdate: !!updatingForABit,
        onInteraction
      };
    }
    /**
     * Handle the e.g. zoomOriginDynamic props, to turn them into zoomOriginInline or zoomOriginBlock as appropriate.
     * TODO: Right now, all *Dynamic props are just handled as 1 - prop. Some probably need to be -1 * prop though.
     */

    function fixProps(logicalDirection, requestedPlacement, usedPlacement, props) {
      var logicalSnake = placementToLogical(logicalDirection, usedPlacement);
      var propAxis;
      var reverse;

      switch (logicalSnake) {
        case "block-start":
          propAxis = "Block";
          reverse = requestedPlacement == "block-end";
          break;

        case "block-end":
          propAxis = "Block";
          reverse = requestedPlacement == "block-start";
          break;

        case "inline-start":
          propAxis = "Inline";
          reverse = requestedPlacement == "inline-end";
          break;

        case "inline-end":
          propAxis = "Inline";
          reverse = requestedPlacement == "inline-start";
          break;
      }

      var newProps = _objectSpread2({}, props);

      for (var propName in props) {
        if (propName.endsWith("Dynamic") && typeof props[propName] === "number") {
          var newPropName = "".concat(propName.substr(0, propName.indexOf("Dynamic"))).concat(propAxis);
          newProps[newPropName] = !reverse ? newProps[propName] : 1 - newProps[propName];
          delete newProps[propName];
        }
      }

      return newProps;
    }

    var _excluded$5 = ["anchor", "anchorTag", "children", "tag", "Transition"],
        _excluded2$3 = ["children", "index"];

    var OnCloseContext = D$1(undefined);
    var UseMenuItemContext = D$1(null);
    function Menu(_ref) {
      var {
        anchor,
        anchorTag,
        children,
        tag,
        Transition
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$5);

      var [open, setOpen] = useState(false);
      var onClose = A$1(() => setOpen(false), []);

      var onOpen = () => setOpen(true);

      var {
        useElementSizeProps,
        elementSize
      } = useElementSize();
      var {
        shouldUpdate: updatingForABit,
        onInteraction
      } = useShouldUpdatePopper(open, elementSize);
      var {
        usePopperArrow,
        usePopperPopup,
        usePopperSource,
        usedPlacement,
        getLogicalDirection
      } = usePopperApi({
        position: "block-end",
        updating: updatingForABit
      });
      var {
        useMenuButton,
        useMenuItem,
        useMenuItemCheckbox,
        useMenuProps,
        useMenuSubmenuItem,
        focusMenu
      } = useAriaMenu({
        open,
        onClose,
        onOpen
      });
      var {
        useMenuButtonProps
      } = useMenuButton({
        tag: anchorTag !== null && anchorTag !== void 0 ? anchorTag : "button"
      });
      var {
        usePopperSourceProps
      } = usePopperSource();
      var {
        usePopperPopupProps
      } = usePopperPopup({
        open
      });
      var {
        usePopperArrowProps
      } = usePopperArrow();
      /*const [sentinelFocused, setSentinelFocused] = useState(false);
      useTimeout({ callback: () => { if (sentinelFocused) onClose(); setSentinelFocused(false); }, timeout: 1000, triggerIndex: sentinelFocused.toString() })*/

      var [firstSentinelIsActive, setFirstSentinelIsActive] = useState(false);
      useTimeout({
        callback: () => {
          setFirstSentinelIsActive(open);
        },
        timeout: 100,
        triggerIndex: "".concat(firstSentinelIsActive)
      });
      var menuChildren = v$1(d$1, null, v$1("div", _objectSpread2({}, usePopperArrowProps({}))), v$1("button", {
        className: "visually-hidden",
        onFocus: !firstSentinelIsActive ? () => focusMenu() : () => onClose(),
        onClick: onClose
      }, "Close menu"), children, v$1("button", {
        className: "visually-hidden",
        onFocus: onClose,
        onClick: onClose
      }, "Close menu"));
      var logicalDirection = getLogicalDirection();
      if (logicalDirection && usedPlacement) rest = fixProps(logicalDirection, "block-end", usedPlacement, rest);
      return v$1(d$1, null, v$1(OnCloseContext.Provider, {
        value: onClose
      }, v$1(UseMenuItemContext.Provider, {
        value: useMenuItem
      }, B(anchor, useMergedProps()(useElementSizeProps({
        ref: anchor.ref,
        class: "dropdown-toggle ".concat(open ? "active" : "")
      }), usePopperSourceProps(useMenuButtonProps(anchor.props)))), v$1(BodyPortal, null, v$1("div", _objectSpread2({}, usePopperPopupProps({
        class: "dropdown-menu-popper"
      })), v$1(Transition, _objectSpread2(_objectSpread2({}, useMenuProps(rest)), {}, {
        open: open,
        onTransitionUpdate: onInteraction,
        exitVisibility: "hidden"
      }), v$1("div", null, v$1(tag, {
        children: menuChildren,
        className: "dropdown-menu"
      }))))))));
    }
    function MenuItem(_ref2) {
      var {
        children,
        index
      } = _ref2,
          rest = _objectWithoutProperties(_ref2, _excluded2$3);

      var useMenuItem = F(UseMenuItemContext);
      var [text, setText] = useState(null);
      var {
        useRefElementProps,
        element
      } = useRefElement();
      h(() => {
        if (element) setText(element.innerText);
      }, [element]);
      var {
        useMenuItemProps
      } = useMenuItem({
        index,
        text
      });
      return v$1("li", null, v$1("button", _objectSpread2({}, useMenuItemProps(useRefElementProps(useMergedProps()(rest, {
        class: "dropdown-item"
      })))), children));
    }

    var _excluded$4 = ["aria-modal", "role"],
        _excluded2$2 = ["onClose", "open", "descriptive", "title", "footer", "Transition", "children"];
    function useAriaOffcanvas({
      open,
      onClose
    }) {
      var [offcanvasDescribedByBody, setOffcanvasDescribedByBody] = useState(false);
      var {
        id: offcanvasId,
        useRandomIdProps: useOffcanvasIdProps,
        useReferencedIdProps: useOffcanvasReferencingIdProps
      } = useRandomId({
        prefix: "aria-offcanvas-"
      });
      var {
        id: bodyId,
        useRandomIdProps: useBodyIdProps,
        useReferencedIdProps: useBodyReferencingIdProps
      } = useRandomId({
        prefix: "aria-offcanvas-body-"
      });
      var {
        id: titleId,
        useRandomIdProps: useTitleIdProps,
        useReferencedIdProps: useTitleReferencingIdProps
      } = useRandomId({
        prefix: "aria-offcanvas-title-"
      });
      useGlobalHandler(window, "mousedown", e => {
        var _document$getElementB;

        if (!(offcanvasId && e.target instanceof Element && (_document$getElementB = document.getElementById(offcanvasId)) !== null && _document$getElementB !== void 0 && _document$getElementB.contains(e.target))) {
          onClose("backdrop");
        }
      }, {
        capture: true
      });

      var onKeyDown = e => {
        if (e.key === "Escape") {
          onClose("escape");
        }
      };

      var useOffcanvasBackdrop = function () {
        //const onClick: h.JSX.EventHandler<h.JSX.TargetedEvent<BackdropElement>> = e => onClose("escape");
        function useOffcanvasBackdropProps(props) {
          return useMergedProps()({}, props);
        }

        return {
          useOffcanvasBackdropProps
        };
      };

      var useOffcanvasProps = function (_ref) {
        var p0 = _objectWithoutProperties(_ref, _excluded$4);

        var {
          useFocusTrapProps
        } = useFocusTrap({
          trapActive: open
        });
        var p1 = useTitleReferencingIdProps("aria-labelledby")(p0);
        var p2 = useOffcanvasIdProps(p1);
        var pFinal = useBodyReferencingIdProps("aria-describedby")(p2);
        return useFocusTrapProps(useMergedProps()({
          role: "offcanvas",
          onKeyDown
        }, offcanvasDescribedByBody ? pFinal : p2));
      };

      function useOffcanvasTitle() {
        var useOffcanvasTitleProps = function (props) {
          return useTitleIdProps(props);
        };

        return {
          useOffcanvasTitleProps
        };
      }

      function useOffcanvasBody({
        descriptive
      }) {
        setOffcanvasDescribedByBody(descriptive);

        var useOffcanvasBodyProps = function (props) {
          return useBodyIdProps(props);
        };

        return {
          useOffcanvasBodyProps
        };
      }

      return {
        useOffcanvasProps,
        useOffcanvasTitle,
        useOffcanvasBody,
        useOffcanvasBackdrop
      };
    }
    function Offcanvas(_ref2) {
      var {
        onClose,
        open,
        descriptive,
        title,
        footer,
        Transition,
        children
      } = _ref2,
          rest = _objectWithoutProperties(_ref2, _excluded2$2);

      var {
        useOffcanvasBackdrop,
        useOffcanvasBody,
        useOffcanvasProps,
        useOffcanvasTitle
      } = useAriaOffcanvas({
        open,
        onClose
      });
      var {
        useOffcanvasBackdropProps
      } = useOffcanvasBackdrop();
      var {
        useOffcanvasBodyProps
      } = useOffcanvasBody({
        descriptive
      });
      var {
        useOffcanvasTitleProps
      } = useOffcanvasTitle();
      return v$1(BodyPortal, null, v$1("div", null, v$1(Fade, {
        open: open
      }, v$1("div", _objectSpread2({}, useOffcanvasBackdropProps({
        class: "offcanvas-backdrop backdrop-filter-transition"
      })))), v$1(Transition, _objectSpread2({}, _objectSpread2({
        open
      }, rest)), v$1("div", _objectSpread2({}, useOffcanvasProps({
        class: "offcanvas offcanvas-start",
        tabindex: -1
      })), v$1("div", {
        class: "offcanvas-header"
      }, v$1("h5", _objectSpread2({}, useOffcanvasTitleProps({
        class: "offcanvas-title"
      })), "Offcanvas"), v$1(Button, {
        tag: "button",
        class: "btn-close text-reset",
        "aria-label": "Close",
        onClick: () => onClose("escape")
      })), v$1("div", _objectSpread2({}, useOffcanvasBodyProps({
        class: "offcanvas-body"
      })), "Content for the offcanvas goes here.You can place just about any Bootstrap component or custom elements here.")))));
    }

    var InInputGroupContext = D$1(false);
    function useInputCaptures(type) {
      var capture = A$1(event => {
        switch (type) {
          case "text":
            return event.currentTarget.value;

          case "number":
            return event.currentTarget.valueAsNumber;
        }
      }, [type]);
      var uncapture = A$1(value => {
        switch (type) {
          case "text":
            return value;

          case "number":
            return "".concat(value);
        }
      }, [type]);
      return {
        capture,
        uncapture
      };
    }

    var _excluded$3 = ["checked", "disabled", "onInput", "label", "labelPosition"];

    function capture(e) {
      return e[EventDetail].checked;
    }
    /**
     * TODO: When inside an InputGroup, Checkboxes don't forward any properties or refs because there's no one DOM element to attach to.
     *
     * Probably need separate `inputRef` & `labelRef` properties for that,
     * but given there's also no easy way to forward props to just them a solution like that feels incomplete.
     */


    function Checkbox(_ref, ref) {
      var _labelPosition;

      var {
        checked,
        disabled,
        onInput: onInputAsync,
        label,
        labelPosition
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$3);

      (_labelPosition = labelPosition) !== null && _labelPosition !== void 0 ? _labelPosition : labelPosition = "end";
      var {
        getSyncHandler,
        pending
      } = useAsyncHandler()({
        capture
      });
      var onInput = getSyncHandler(onInputAsync);
      var {
        useCheckboxInputElement,
        useCheckboxLabelElement
      } = useAriaCheckbox({
        checked: checked === "indeterminate" ? "mixed" : checked,
        disabled: disabled !== null && disabled !== void 0 ? disabled : false,
        onInput,
        labelPosition: "separate"
      });
      var {
        useCheckboxInputElementProps
      } = useCheckboxInputElement({
        tag: "input"
      });
      var {
        useCheckboxLabelElementProps
      } = useCheckboxLabelElement({
        tag: "label"
      });
      var inInputGroup = F(InInputGroupContext);
      var stringLabel = "".concat(label);

      if (label != null && labelPosition === "hidden" && !["string", "number", "boolean"].includes(typeof label)) {
        console.error("Hidden labels require a string-based label for the aria-label attribute.");
      }

      var inputElement = v$1(OptionallyInputGroup$1, null, v$1("input", _objectSpread2({}, useCheckboxInputElementProps({
        type: "checkbox",
        className: clsx("form-check-input", inInputGroup && "mt-0"),
        "aria-label": labelPosition === "hidden" ? stringLabel : undefined
      }))));
      var labelElement = v$1(d$1, null, label != null && v$1(OptionallyInputGroup$1, null, v$1("label", _objectSpread2({}, useCheckboxLabelElementProps({
        className: "form-check-label",
        "aria-hidden": "true"
      })), label)));
      var ret = v$1(d$1, null, labelPosition == "start" && labelElement, inputElement, labelPosition == "end" && labelElement);
      if (!inInputGroup) return v$1("div", _objectSpread2({}, useMergedProps()(rest, {
        ref,
        class: "form-check"
      })), ret);
      return ret;
    }
    D$1(null);
    D$1(null);

    function OptionallyInputGroup$1({
      children
    }) {
      var inInputGroup = F(InInputGroupContext);
      if (!inInputGroup) return v$1(d$1, null, children);
      return v$1("div", {
        class: "input-group-text"
      }, children);
    }

    var RadioGroupContext = D$1(null);
    function RadioGroup({
      children,
      name,
      selectedValue,
      label,
      labelPosition,
      onInput: onInputAsync
    }) {
      var {
        getSyncHandler,
        pending,
        hasError,
        settleCount,
        currentCapture
      } = useAsyncHandler()({
        capture: e => e[EventDetail].selectedValue
      });
      var onInput = getSyncHandler(onInputAsync);
      var {
        useRadio,
        useRadioGroupProps,
        managedChildren,
        getIndex
      } = useAriaRadioGroup({
        name,
        selectedValue: currentCapture !== null && currentCapture !== void 0 ? currentCapture : selectedValue,
        onInput: onInput
      });
      var stringLabel = undefined;

      if (labelPosition === "hidden") {
        if (label != null && !["string", "number", "boolean"].includes(typeof label)) {
          console.error("Hidden labels require a string-based label for the aria-label attribute.");
        } else {
          stringLabel = "".concat(label);
        }
      }

      var selectedIndex = getIndex(currentCapture !== null && currentCapture !== void 0 ? currentCapture : selectedValue); //const capturedIndex = getIndex(currentCapture!);

      useChildFlag(selectedIndex, managedChildren.length, (index, isSelected) => managedChildren[index].setAsyncState(isSelected ? hasError ? "failed" : pending ? "pending" : "succeeded" : null)); // useChildFlag(pending ? capturedIndex : null, managedChildren.length, useCallback((index, isCaptured) => managedChildren[index].setPending(isCaptured? "in" : false), []));

      var {
        useGenericLabelLabel,
        useGenericLabelInput
      } = useGenericLabel({
        inputPrefix: "aria-radiogroup",
        labelPrefix: "aria-radiogroup-label",
        backupText: stringLabel
      });
      var {
        useGenericLabelInputProps
      } = useGenericLabelInput();
      var {
        useGenericLabelLabelProps
      } = useGenericLabelLabel();
      var labelJsx = v$1("div", _objectSpread2({}, useGenericLabelLabelProps({})));
      var groupJsx = v$1("div", _objectSpread2({}, useGenericLabelInputProps(useRadioGroupProps({
        "aria-label": labelPosition === "hidden" ? stringLabel : undefined
      }))), children);
      return v$1(RadioGroupContext.Provider, {
        value: useRadio
      }, labelPosition == "start" && labelJsx, groupJsx, labelPosition == "end" && labelJsx);
    }
    function Radio({
      disabled,
      label,
      index,
      value,
      labelPosition
    }) {
      var _labelPosition, _label;

      var useAriaRadio = F(RadioGroupContext);
      (_labelPosition = labelPosition) !== null && _labelPosition !== void 0 ? _labelPosition : labelPosition = "end";
      var text = null;
      var [asyncState, setAsyncState] = useState(null);
      var {
        useRadioInput,
        useRadioLabel
      } = useAriaRadio({
        disabled: disabled !== null && disabled !== void 0 ? disabled : false,
        labelPosition: "separate",
        index,
        text,
        value,
        setAsyncState
      });
      var {
        useRadioInputProps
      } = useRadioInput({
        tag: "input"
      });
      var {
        useRadioLabelProps
      } = useRadioLabel({
        tag: "label"
      });
      useSpinnerDelay(asyncState === "pending");
      var inInputGroup = F(InInputGroupContext);
      (_label = label) !== null && _label !== void 0 ? _label : label = value;
      var stringLabel = "".concat(label);

      if (label != null && labelPosition === "hidden" && !["string", "number", "boolean"].includes(typeof label)) {
        console.error("Hidden labels require a string-based label for the aria-label attribute.");
      }

      var inputElement = v$1(OptionallyInputGroup, null, v$1(ProgressCircular, {
        childrenPosition: "after",
        colorFill: "foreground-only",
        mode: asyncState,
        color: "info"
      }, v$1("input", _objectSpread2({}, useRadioInputProps({
        type: "radio",
        className: "form-check-input",
        "aria-label": labelPosition === "hidden" ? stringLabel : undefined
      })))));
      var labelElement = v$1(d$1, null, label != null && v$1(OptionallyInputGroup, null, v$1("label", _objectSpread2({}, useRadioLabelProps({
        className: "form-check-label",
        "aria-hidden": "true"
      })), label)));
      var ret = v$1(d$1, null, labelPosition == "start" && labelElement, inputElement, labelPosition == "end" && labelElement);
      if (!inInputGroup) return v$1("div", {
        class: "form-check"
      }, ret);
      return ret;
    }

    function OptionallyInputGroup({
      children
    }) {
      var inInputGroup = F(InInputGroupContext);
      if (!inInputGroup) return v$1(d$1, null, children);
      return v$1("div", {
        class: "input-group-text"
      }, children);
    }

    var _excluded$2 = ["children", "position", "tooltip", "Transition", "mouseoverDelay"];
    function Tooltip(_ref) {
      var {
        children,
        position,
        tooltip,
        Transition,
        mouseoverDelay
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$2);

      var {
        getIsOpen,
        isOpen,
        useTooltip,
        useTooltipTrigger
      } = useAriaTooltip({
        mouseoverDelay
      });
      var {
        useElementSizeProps,
        elementSize
      } = useElementSize();
      var cloneable;

      if (typeof children === "string" || typeof children === "number" || typeof children == "boolean" || typeof children === "bigint") {
        cloneable = v$1("span", null, children);
      } else if (Array.isArray(children)) {
        cloneable = v$1("span", null, children);
      } else {
        cloneable = children;
      }

      var {
        useTooltipProps
      } = useTooltip();
      var {
        useTooltipTriggerProps
      } = useTooltipTrigger();
      var {
        shouldUpdate,
        onInteraction
      } = useShouldUpdatePopper(isOpen, elementSize);
      var {
        getLogicalDirection,
        usePopperArrow,
        usePopperPopup,
        usePopperSource,
        usedPlacement
      } = usePopperApi({
        updating: shouldUpdate,
        position
      });
      var {
        usePopperPopupProps
      } = usePopperPopup({
        open: isOpen
      });
      var {
        usePopperArrowProps
      } = usePopperArrow();
      var {
        usePopperSourceProps
      } = usePopperSource();
      var logicalDirection = getLogicalDirection();
      if (logicalDirection && usedPlacement) rest = fixProps(logicalDirection, "block-end", usedPlacement, rest); // TODO: It's required for this to be exitVisibility="hidden" for transforms to work?
      // Probably an issue in the Transition element itself because it's not browser-specific but it's a little weird

      return v$1(d$1, null, B(cloneable, useTooltipTriggerProps(useElementSizeProps(usePopperSourceProps({})))), v$1(BodyPortal, null, v$1("div", _objectSpread2({}, usePopperPopupProps({
        class: "tooltip-wrapper"
      })), v$1(Transition, _objectSpread2(_objectSpread2({}, rest), {}, {
        open: isOpen,
        onTransitionUpdate: onInteraction,
        exitVisibility: "hidden"
      }), v$1("div", _objectSpread2({}, useTooltipProps(useMergedProps()({
        class: "tooltip show",
        role: "tooltip"
      }, {}))), v$1("div", _objectSpread2({}, usePopperArrowProps({
        class: "tooltip-arrow"
      }))), v$1("div", {
        class: "tooltip-inner"
      }, tooltip))))));
    }

    var PushToastContext = D$1(null);
    var DefaultToastTimeout = D$1(5000);
    function ToastsProvider({
      children,
      defaultTimeout
    }) {
      var [pushToast, setPushToast] = useState(null);
      return v$1(d$1, null, v$1(DefaultToastTimeout.Provider, {
        value: defaultTimeout !== null && defaultTimeout !== void 0 ? defaultTimeout : 5000
      }, v$1(ToastsProviderHelper, {
        setPushToast: setPushToast
      }), pushToast && v$1(PushToastContext.Provider, {
        value: pushToast
      }, children)));
    }
    function usePushToast() {
      var pushToast = F(PushToastContext);
      return pushToast;
    } // Extracted to a separate component to avoid rerendering all non-toast children

    function ToastsProviderHelper({
      setPushToast
    }) {
      var [children, setChildren] = useState([]);
      var pushToast = A$1(toast => {
        var randomKey = generateRandomId();
        setChildren(prev => [...prev, B(toast, {
          key: randomKey
        })]);
      }, []);
      h(() => {
        setPushToast(_ => pushToast);
      }, [pushToast]);
      return v$1(BodyPortal, null, v$1(ToastsContainerChildrenContext.Provider, {
        value: children
      }, v$1(ToastsContainer, null)));
    }

    var ToastsContainerChildrenContext = D$1([]);
    var UseToastContext = D$1(null);

    function ToastsContainer(props) {
      var children = F(ToastsContainerChildrenContext);
      var {
        useToast,
        useToastContainerProps
      } = useToasts(props);
      return v$1(UseToastContext.Provider, {
        value: useToast
      }, v$1("div", _objectSpread2({}, useToastContainerProps(props)), children));
    }

    var ToastDismissContext = D$1(null);
    function Toast({
      timeout,
      politeness,
      children
    }) {
      var useToast = F(UseToastContext);
      var defaultTimeout = F(DefaultToastTimeout);
      var {
        useToastProps,
        dismiss,
        status
      } = useToast({
        timeout: timeout !== null && timeout !== void 0 ? timeout : defaultTimeout,
        politeness
      });
      return v$1(ToastDismissContext.Provider, {
        value: dismiss
      }, v$1(SlideFade, {
        open: status != "dismissed",
        slideTargetInline: 1,
        animateOnMount: true,
        exitVisibility: "removed"
      }, v$1("div", _objectSpread2({}, useToastProps({
        class: "toast show",
        role: "alert",
        "aria-atomic": "true"
      })), v$1("div", {
        class: "d-flex"
      }, v$1("div", {
        class: "toast-body"
      }, children), v$1(Button, {
        class: "btn-close me-2 m-auto",
        "aria-label": "Close",
        onClick: dismiss
      })))));
    }
    /*
    export function ToastHeader({ children }: { children: ComponentChildren }) {
        return (
            <div class="toast-header">
                <div class="me-auto">
                    {children}
                </div>
                <Button class="btn-close" aria-label="Close" />
            </div>
        )
    }*/

    var preact = createCommonjsModule(function (module, exports) {
      var n,
          l,
          u,
          t,
          i,
          o,
          r,
          f,
          e = {},
          c = [],
          s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

      function a(n, l) {
        for (var u in l) {
          n[u] = l[u];
        }

        return n;
      }

      function p(n) {
        var l = n.parentNode;
        l && l.removeChild(n);
      }

      function v(l, u, t) {
        var i,
            o,
            r,
            f = {};

        for (r in u) {
          "key" == r ? i = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
        }

        if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : t), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) {
          void 0 === f[r] && (f[r] = l.defaultProps[r]);
        }
        return h(l, f, i, o, null);
      }

      function h(n, t, i, o, r) {
        var f = {
          type: n,
          props: t,
          key: i,
          ref: o,
          __k: null,
          __: null,
          __b: 0,
          __e: null,
          __d: void 0,
          __c: null,
          __h: null,
          constructor: void 0,
          __v: null == r ? ++u : r
        };
        return null != l.vnode && l.vnode(f), f;
      }

      function y(n) {
        return n.children;
      }

      function d(n, l) {
        this.props = n, this.context = l;
      }

      function _(n, l) {
        if (null == l) return n.__ ? _(n.__, n.__.__k.indexOf(n) + 1) : null;

        for (var u; l < n.__k.length; l++) {
          if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
        }

        return "function" == typeof n.type ? _(n) : null;
      }

      function k(n) {
        var l, u;

        if (null != (n = n.__) && null != n.__c) {
          for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {
            if (null != (u = n.__k[l]) && null != u.__e) {
              n.__e = n.__c.base = u.__e;
              break;
            }
          }

          return k(n);
        }
      }

      function x(n) {
        (!n.__d && (n.__d = !0) && i.push(n) && !b.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)(b);
      }

      function b() {
        for (var n; b.__r = i.length;) {
          n = i.sort(function (n, l) {
            return n.__v.__b - l.__v.__b;
          }), i = [], n.some(function (n) {
            var l, u, t, i, o, r;
            n.__d && (o = (i = (l = n).__v).__e, (r = l.__P) && (u = [], (t = a({}, i)).__v = i.__v + 1, I(r, i, t, l.__n, void 0 !== r.ownerSVGElement, null != i.__h ? [o] : null, u, null == o ? _(i) : o, i.__h), T(u, i), i.__e != o && k(i)));
          });
        }
      }

      function m(n, l, u, t, i, o, r, f, s, a) {
        var p,
            v,
            d,
            k,
            x,
            b,
            m,
            A = t && t.__k || c,
            P = A.length;

        for (u.__k = [], p = 0; p < l.length; p++) {
          if (null != (k = u.__k[p] = null == (k = l[p]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? h(null, k, null, null, k) : Array.isArray(k) ? h(y, {
            children: k
          }, null, null, null) : k.__b > 0 ? h(k.type, k.props, k.key, null, k.__v) : k)) {
            if (k.__ = u, k.__b = u.__b + 1, null === (d = A[p]) || d && k.key == d.key && k.type === d.type) A[p] = void 0;else for (v = 0; v < P; v++) {
              if ((d = A[v]) && k.key == d.key && k.type === d.type) {
                A[v] = void 0;
                break;
              }

              d = null;
            }
            I(n, k, d = d || e, i, o, r, f, s, a), x = k.__e, (v = k.ref) && d.ref != v && (m || (m = []), d.ref && m.push(d.ref, null, k), m.push(v, k.__c || x, k)), null != x ? (null == b && (b = x), "function" == typeof k.type && null != k.__k && k.__k === d.__k ? k.__d = s = g(k, s, n) : s = w(n, k, d, A, x, s), a || "option" !== u.type ? "function" == typeof u.type && (u.__d = s) : n.value = "") : s && d.__e == s && s.parentNode != n && (s = _(d));
          }
        }

        for (u.__e = b, p = P; p--;) {
          null != A[p] && ("function" == typeof u.type && null != A[p].__e && A[p].__e == u.__d && (u.__d = _(t, p + 1)), L(A[p], A[p]));
        }

        if (m) for (p = 0; p < m.length; p++) {
          z(m[p], m[++p], m[++p]);
        }
      }

      function g(n, l, u) {
        var t, i;

        for (t = 0; t < n.__k.length; t++) {
          (i = n.__k[t]) && (i.__ = n, l = "function" == typeof i.type ? g(i, l, u) : w(u, i, i, n.__k, i.__e, l));
        }

        return l;
      }

      function w(n, l, u, t, i, o) {
        var r, f, e;
        if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || i != o || null == i.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(i), r = null;else {
          for (f = o, e = 0; (f = f.nextSibling) && e < t.length; e += 2) {
            if (f == i) break n;
          }

          n.insertBefore(i, o), r = o;
        }
        return void 0 !== r ? r : i.nextSibling;
      }

      function A(n, l, u, t, i) {
        var o;

        for (o in u) {
          "children" === o || "key" === o || o in l || C(n, o, null, u[o], t);
        }

        for (o in l) {
          i && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || C(n, o, l[o], u[o], t);
        }
      }

      function P(n, l, u) {
        "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || s.test(l) ? u : u + "px";
      }

      function C(n, l, u, t, i) {
        var o;

        n: if ("style" === l) {
          if ("string" == typeof u) n.style.cssText = u;else {
            if ("string" == typeof t && (n.style.cssText = t = ""), t) for (l in t) {
              u && l in u || P(n.style, l, "");
            }
            if (u) for (l in u) {
              t && u[l] === t[l] || P(n.style, l, u[l]);
            }
          }
        } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? t || n.addEventListener(l, o ? H : $, o) : n.removeEventListener(l, o ? H : $, o);else if ("dangerouslySetInnerHTML" !== l) {
          if (i) l = l.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
            n[l] = null == u ? "" : u;
            break n;
          } catch (n) {}
          "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
        }
      }

      function $(n) {
        this.l[n.type + !1](l.event ? l.event(n) : n);
      }

      function H(n) {
        this.l[n.type + !0](l.event ? l.event(n) : n);
      }

      function I(n, u, t, i, o, r, f, e, c) {
        var s,
            p,
            v,
            h,
            _,
            k,
            x,
            b,
            g,
            w,
            A,
            P = u.type;

        if (void 0 !== u.constructor) return null;
        null != t.__h && (c = t.__h, e = u.__e = t.__e, u.__h = null, r = [e]), (s = l.__b) && s(u);

        try {
          n: if ("function" == typeof P) {
            if (b = u.props, g = (s = P.contextType) && i[s.__c], w = s ? g ? g.props.value : s.__ : i, t.__c ? x = (p = u.__c = t.__c).__ = p.__E : ("prototype" in P && P.prototype.render ? u.__c = p = new P(b, w) : (u.__c = p = new d(b, w), p.constructor = P, p.render = M), g && g.sub(p), p.props = b, p.state || (p.state = {}), p.context = w, p.__n = i, v = p.__d = !0, p.__h = []), null == p.__s && (p.__s = p.state), null != P.getDerivedStateFromProps && (p.__s == p.state && (p.__s = a({}, p.__s)), a(p.__s, P.getDerivedStateFromProps(b, p.__s))), h = p.props, _ = p.state, v) null == P.getDerivedStateFromProps && null != p.componentWillMount && p.componentWillMount(), null != p.componentDidMount && p.__h.push(p.componentDidMount);else {
              if (null == P.getDerivedStateFromProps && b !== h && null != p.componentWillReceiveProps && p.componentWillReceiveProps(b, w), !p.__e && null != p.shouldComponentUpdate && !1 === p.shouldComponentUpdate(b, p.__s, w) || u.__v === t.__v) {
                p.props = b, p.state = p.__s, u.__v !== t.__v && (p.__d = !1), p.__v = u, u.__e = t.__e, u.__k = t.__k, u.__k.forEach(function (n) {
                  n && (n.__ = u);
                }), p.__h.length && f.push(p);
                break n;
              }

              null != p.componentWillUpdate && p.componentWillUpdate(b, p.__s, w), null != p.componentDidUpdate && p.__h.push(function () {
                p.componentDidUpdate(h, _, k);
              });
            }
            p.context = w, p.props = b, p.state = p.__s, (s = l.__r) && s(u), p.__d = !1, p.__v = u, p.__P = n, s = p.render(p.props, p.state, p.context), p.state = p.__s, null != p.getChildContext && (i = a(a({}, i), p.getChildContext())), v || null == p.getSnapshotBeforeUpdate || (k = p.getSnapshotBeforeUpdate(h, _)), A = null != s && s.type === y && null == s.key ? s.props.children : s, m(n, Array.isArray(A) ? A : [A], u, t, i, o, r, f, e, c), p.base = u.__e, u.__h = null, p.__h.length && f.push(p), x && (p.__E = p.__ = null), p.__e = !1;
          } else null == r && u.__v === t.__v ? (u.__k = t.__k, u.__e = t.__e) : u.__e = j(t.__e, u, t, i, o, r, f, c);

          (s = l.diffed) && s(u);
        } catch (n) {
          u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l.__e(n, u, t);
        }
      }

      function T(n, u) {
        l.__c && l.__c(u, n), n.some(function (u) {
          try {
            n = u.__h, u.__h = [], n.some(function (n) {
              n.call(u);
            });
          } catch (n) {
            l.__e(n, u.__v);
          }
        });
      }

      function j(l, u, t, i, o, r, f, c) {
        var s,
            a,
            v,
            h = t.props,
            y = u.props,
            d = u.type,
            k = 0;
        if ("svg" === d && (o = !0), null != r) for (; k < r.length; k++) {
          if ((s = r[k]) && (s === l || (d ? s.localName == d : 3 == s.nodeType))) {
            l = s, r[k] = null;
            break;
          }
        }

        if (null == l) {
          if (null === d) return document.createTextNode(y);
          l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, y.is && y), r = null, c = !1;
        }

        if (null === d) h === y || c && l.data === y || (l.data = y);else {
          if (r = r && n.call(l.childNodes), a = (h = t.props || e).dangerouslySetInnerHTML, v = y.dangerouslySetInnerHTML, !c) {
            if (null != r) for (h = {}, k = 0; k < l.attributes.length; k++) {
              h[l.attributes[k].name] = l.attributes[k].value;
            }
            (v || a) && (v && (a && v.__html == a.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
          }

          if (A(l, y, h, o, c), v) u.__k = [];else if (k = u.props.children, m(l, Array.isArray(k) ? k : [k], u, t, i, o && "foreignObject" !== d, r, f, r ? r[0] : t.__k && _(t, 0), c), null != r) for (k = r.length; k--;) {
            null != r[k] && p(r[k]);
          }
          c || ("value" in y && void 0 !== (k = y.value) && (k !== l.value || "progress" === d && !k) && C(l, "value", k, h.value, !1), "checked" in y && void 0 !== (k = y.checked) && k !== l.checked && C(l, "checked", k, h.checked, !1));
        }
        return l;
      }

      function z(n, u, t) {
        try {
          "function" == typeof n ? n(u) : n.current = u;
        } catch (n) {
          l.__e(n, t);
        }
      }

      function L(n, u, t) {
        var i, o;

        if (l.unmount && l.unmount(n), (i = n.ref) && (i.current && i.current !== n.__e || z(i, null, u)), null != (i = n.__c)) {
          if (i.componentWillUnmount) try {
            i.componentWillUnmount();
          } catch (n) {
            l.__e(n, u);
          }
          i.base = i.__P = null;
        }

        if (i = n.__k) for (o = 0; o < i.length; o++) {
          i[o] && L(i[o], u, "function" != typeof n.type);
        }
        t || null == n.__e || p(n.__e), n.__e = n.__d = void 0;
      }

      function M(n, l, u) {
        return this.constructor(n, u);
      }

      function N(u, t, i) {
        var o, r, f;
        l.__ && l.__(u, t), r = (o = "function" == typeof i) ? null : i && i.__k || t.__k, f = [], I(t, u = (!o && i || t).__k = v(y, null, [u]), r || e, e, void 0 !== t.ownerSVGElement, !o && i ? [i] : r ? null : t.firstChild ? n.call(t.childNodes) : null, f, !o && i ? i : r ? r.__e : t.firstChild, o), T(f, u);
      }

      n = c.slice, l = {
        __e: function (n, l) {
          for (var u, t, i; l = l.__;) {
            if ((u = l.__c) && !u.__) try {
              if ((t = u.constructor) && null != t.getDerivedStateFromError && (u.setState(t.getDerivedStateFromError(n)), i = u.__d), null != u.componentDidCatch && (u.componentDidCatch(n), i = u.__d), i) return u.__E = u;
            } catch (l) {
              n = l;
            }
          }

          throw n;
        }
      }, u = 0, t = function (n) {
        return null != n && void 0 === n.constructor;
      }, d.prototype.setState = function (n, l) {
        var u;
        u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a({}, this.state), "function" == typeof n && (n = n(a({}, u), this.props)), n && a(u, n), null != n && this.__v && (l && this.__h.push(l), x(this));
      }, d.prototype.forceUpdate = function (n) {
        this.__v && (this.__e = !0, n && this.__h.push(n), x(this));
      }, d.prototype.render = y, i = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, b.__r = 0, f = 0, exports.render = N, exports.hydrate = function n(l, u) {
        N(l, u, n);
      }, exports.createElement = v, exports.h = v, exports.Fragment = y, exports.createRef = function () {
        return {
          current: null
        };
      }, exports.isValidElement = t, exports.Component = d, exports.cloneElement = function (l, u, t) {
        var i,
            o,
            r,
            f = a({}, l.props);

        for (r in u) {
          "key" == r ? i = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
        }

        return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : t), h(l.type, f, i || l.key, o || l.ref, null);
      }, exports.createContext = function (n, l) {
        var u = {
          __c: l = "__cC" + f++,
          __: n,
          Consumer: function (n, l) {
            return n.children(l);
          },
          Provider: function (n) {
            var u, t;
            return this.getChildContext || (u = [], (t = {})[l] = this, this.getChildContext = function () {
              return t;
            }, this.shouldComponentUpdate = function (n) {
              this.props.value !== n.value && u.some(x);
            }, this.sub = function (n) {
              u.push(n);
              var l = n.componentWillUnmount;

              n.componentWillUnmount = function () {
                u.splice(u.indexOf(n), 1), l && l.call(n);
              };
            }), n.children;
          }
        };
        return u.Provider.__ = u.Consumer.contextType = u;
      }, exports.toChildArray = function n(l, u) {
        return u = u || [], null == l || "boolean" == typeof l || (Array.isArray(l) ? l.some(function (l) {
          n(l, u);
        }) : u.push(l)), u;
      }, exports.options = l;
    });

    createCommonjsModule(function (module, exports) {
      "undefined" != typeof window && window.__PREACT_DEVTOOLS__ && window.__PREACT_DEVTOOLS__.attachPreact("10.5.14", preact.options, {
        Fragment: preact.Fragment,
        Component: preact.Component
      }), exports.addHookName = function (e, o) {
        return preact.options.__a && preact.options.__a(o), e;
      };
    });

    createCommonjsModule(function (module, exports) {
      var n = preact;
      var e = {};

      function t(e) {
        return e.type === n.Fragment ? "Fragment" : "function" == typeof e.type ? e.type.displayName || e.type.name : "string" == typeof e.type ? e.type : "#text";
      }

      var o = [],
          r = [];

      function a() {
        return o.length > 0 ? o[o.length - 1] : null;
      }

      var i = !1;

      function s(e) {
        return "function" == typeof e.type && e.type != n.Fragment;
      }

      function c(n) {
        for (var e = [n], o = n; null != o.__o;) {
          e.push(o.__o), o = o.__o;
        }

        return e.reduce(function (n, e) {
          n += "  in " + t(e);
          var o = e.__source;
          return o ? n += " (at " + o.fileName + ":" + o.lineNumber + ")" : i || (i = !0, console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")), n + "\n";
        }, "");
      }

      var l = "function" == typeof WeakMap,
          u = n.Component.prototype.setState;

      n.Component.prototype.setState = function (n, e) {
        return null == this.__v ? null == this.state && console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n' + c(a())) : null == this.__P && console.warn('Can\'t call "this.setState" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n' + c(this.__v)), u.call(this, n, e);
      };

      var f = n.Component.prototype.forceUpdate;

      function p(n) {
        var e = n.props,
            o = t(n),
            r = "";

        for (var a in e) {
          if (e.hasOwnProperty(a) && "children" !== a) {
            var i = e[a];
            "function" == typeof i && (i = "function " + (i.displayName || i.name) + "() {}"), i = Object(i) !== i || i.toString ? i + "" : Object.prototype.toString.call(i), r += " " + a + "=" + JSON.stringify(i);
          }
        }

        var s = e.children;
        return "<" + o + r + (s && s.length ? ">..</" + o + ">" : " />");
      }

      n.Component.prototype.forceUpdate = function (n) {
        return null == this.__v ? console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n' + c(a())) : null == this.__P && console.warn('Can\'t call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n' + c(this.__v)), f.call(this, n);
      }, function () {
        !function () {
          var e = n.options.__b,
              t = n.options.diffed,
              a = n.options.__,
              i = n.options.vnode,
              c = n.options.__r;
          n.options.diffed = function (n) {
            s(n) && r.pop(), o.pop(), t && t(n);
          }, n.options.__b = function (n) {
            s(n) && o.push(n), e && e(n);
          }, n.options.__ = function (n, e) {
            r = [], a && a(n, e);
          }, n.options.vnode = function (n) {
            n.__o = r.length > 0 ? r[r.length - 1] : null, i && i(n);
          }, n.options.__r = function (n) {
            s(n) && r.push(n), c && c(n);
          };
        }();
        var a = !1,
            i = n.options.__b,
            u = n.options.diffed,
            f = n.options.vnode,
            d = n.options.__e,
            h = n.options.__,
            y = n.options.__h,
            v = l ? {
          useEffect: new WeakMap(),
          useLayoutEffect: new WeakMap(),
          lazyPropTypes: new WeakMap()
        } : null,
            m = [];
        n.options.__e = function (n, e, o) {
          if (e && e.__c && "function" == typeof n.then) {
            var r = n;
            n = new Error("Missing Suspense. The throwing component was: " + t(e));

            for (var a = e; a; a = a.__) {
              if (a.__c && a.__c.__c) {
                n = r;
                break;
              }
            }

            if (n instanceof Error) throw n;
          }

          try {
            d(n, e, o), "function" != typeof n.then && setTimeout(function () {
              throw n;
            });
          } catch (n) {
            throw n;
          }
        }, n.options.__ = function (n, e) {
          if (!e) throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");
          var o;

          switch (e.nodeType) {
            case 1:
            case 11:
            case 9:
              o = !0;
              break;

            default:
              o = !1;
          }

          if (!o) {
            var r = t(n);
            throw new Error("Expected a valid HTML node as a second argument to render.\tReceived " + e + " instead: render(<" + r + " />, " + e + ");");
          }

          h && h(n, e);
        }, n.options.__b = function (n) {
          var o = n.type,
              r = function n(e) {
            return e ? "function" == typeof e.type ? n(e.__) : e : {};
          }(n.__);

          if (a = !0, void 0 === o) throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports" + p(n) + "\n\n" + c(n));

          if (null != o && "object" == typeof o) {
            if (void 0 !== o.__k && void 0 !== o.__e) throw new Error("Invalid type passed to createElement(): " + o + "\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My" + t(n) + " = " + p(o) + ";\n  let vnode = <My" + t(n) + " />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n" + c(n));
            throw new Error("Invalid type passed to createElement(): " + (Array.isArray(o) ? "array" : o));
          }

          if ("thead" !== o && "tfoot" !== o && "tbody" !== o || "table" === r.type ? "tr" === o && "thead" !== r.type && "tfoot" !== r.type && "tbody" !== r.type && "table" !== r.type ? console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent." + p(n) + "\n\n" + c(n)) : "td" === o && "tr" !== r.type ? console.error("Improper nesting of table. Your <td> should have a <tr> parent." + p(n) + "\n\n" + c(n)) : "th" === o && "tr" !== r.type && console.error("Improper nesting of table. Your <th> should have a <tr>." + p(n) + "\n\n" + c(n)) : console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent." + p(n) + "\n\n" + c(n)), void 0 !== n.ref && "function" != typeof n.ref && "object" != typeof n.ref && !("$$typeof" in n)) throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got [' + typeof n.ref + "] instead\n" + p(n) + "\n\n" + c(n));
          if ("string" == typeof n.type) for (var s in n.props) {
            if ("o" === s[0] && "n" === s[1] && "function" != typeof n.props[s] && null != n.props[s]) throw new Error("Component's \"" + s + '" property should be a function, but got [' + typeof n.props[s] + "] instead\n" + p(n) + "\n\n" + c(n));
          }

          if ("function" == typeof n.type && n.type.propTypes) {
            if ("Lazy" === n.type.displayName && v && !v.lazyPropTypes.has(n.type)) {
              var l = "PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";

              try {
                var u = n.type();
                v.lazyPropTypes.set(n.type, !0), console.warn(l + "Component wrapped in lazy() is " + t(u));
              } catch (n) {
                console.warn(l + "We will log the wrapped component's name once it is loaded.");
              }
            }

            var f = n.props;
            n.type.__f && delete (f = function (n, e) {
              for (var t in e) {
                n[t] = e[t];
              }

              return n;
            }({}, f)).ref, function (n, t, o, r, a) {
              Object.keys(n).forEach(function (o) {
                var i;

                try {
                  i = n[o](t, o, r, "prop", null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (n) {
                  i = n;
                }

                !i || i.message in e || (e[i.message] = !0, console.error("Failed prop type: " + i.message + (a && "\n" + a() || "")));
              });
            }(n.type.propTypes, f, 0, t(n), function () {
              return c(n);
            });
          }

          i && i(n);
        }, n.options.__h = function (n, e, t) {
          if (!n || !a) throw new Error("Hook can only be invoked from render methods.");
          y && y(n, e, t);
        };

        var b = function (n, e) {
          return {
            get: function () {
              var t = "get" + n + e;
              m && m.indexOf(t) < 0 && (m.push(t), console.warn("getting vnode." + n + " is deprecated, " + e));
            },
            set: function () {
              var t = "set" + n + e;
              m && m.indexOf(t) < 0 && (m.push(t), console.warn("setting vnode." + n + " is not allowed, " + e));
            }
          };
        },
            w = {
          nodeName: b("nodeName", "use vnode.type"),
          attributes: b("attributes", "use vnode.props"),
          children: b("children", "use vnode.props.children")
        },
            g = Object.create({}, w);

        n.options.vnode = function (n) {
          var e = n.props;

          if (null !== n.type && null != e && ("__source" in e || "__self" in e)) {
            var t = n.props = {};

            for (var o in e) {
              var r = e[o];
              "__source" === o ? n.__source = r : "__self" === o ? n.__self = r : t[o] = r;
            }
          }

          n.__proto__ = g, f && f(n);
        }, n.options.diffed = function (n) {
          if (n.__k && n.__k.forEach(function (e) {
            if (e && void 0 === e.type) {
              delete e.__, delete e.__b;
              var t = Object.keys(e).join(",");
              throw new Error("Objects are not valid as a child. Encountered an object with the keys {" + t + "}.\n\n" + c(n));
            }
          }), a = !1, u && u(n), null != n.__k) for (var e = [], t = 0; t < n.__k.length; t++) {
            var o = n.__k[t];

            if (o && null != o.key) {
              var r = o.key;

              if (-1 !== e.indexOf(r)) {
                console.error('Following component has two or more children with the same key attribute: "' + r + '". This may cause glitches and misbehavior in rendering process. Component: \n\n' + p(n) + "\n\n" + c(n));
                break;
              }

              e.push(r);
            }
          }
        };
      }(), exports.resetPropWarnings = function () {
        e = {};
      };
    });

    var _excluded$1 = ["children"],
        _excluded2$1 = ["children"];
    /**
     * An InputGroup, that puts an Input and its Label together, visually, into one component.
     *
     * All Input-type components automatically detect when they're in an InputGroup and render different accordingly.
     */

    var InputGroup = forwardElementRef(function InputGroup(_ref, ref) {
      var {
        children
      } = _ref,
          rest = _objectWithoutProperties(_ref, _excluded$1);

      return v$1("div", _objectSpread2({}, useMergedProps()({
        class: "input-group",
        ref
      }, rest)), v$1(InInputGroupContext.Provider, {
        value: true
      }, children));
    });
    /**
     * Not generally needed, since most input components come with labels that do this for you.
     *
     * That being said, if you just need a static block of text not hooked up to any input element, this is your component.
     */

    forwardElementRef(function InputGroupText(_ref2, ref) {
      var rest = _objectWithoutProperties(_ref2, _excluded2$1);

      return v$1("span", _objectSpread2({}, useMergedProps()({
        class: "input-group-text",
        ref
      }, rest)));
    });

    var _excluded = ["type", "value", "onInput"],
        _excluded2 = ["getSyncHandler", "currentCapture", "pending", "hasError", "settleCount"],
        _excluded3 = ["label", "labelPosition"];
    function Input(_ref) {
      var {
        type,
        value,
        onInput: onInputAsync
      } = _ref,
          props = _objectWithoutProperties(_ref, _excluded);

      var {
        capture,
        uncapture
      } = useInputCaptures(type);

      var _useAsyncHandler = useAsyncHandler()({
        capture
      }),
          {
        getSyncHandler,
        currentCapture,
        pending,
        hasError,
        settleCount
      } = _useAsyncHandler;
          _objectWithoutProperties(_useAsyncHandler, _excluded2);

      var onInput = getSyncHandler(onInputAsync);
      return v$1(ProgressCircular, {
        mode: hasError ? "failed" : pending ? "pending" : settleCount ? "succeeded" : null,
        childrenPosition: "after",
        color: "info"
      }, v$1("input", _objectSpread2({}, useMergedProps()(props, {
        class: clsx("form-control", pending && "with-end-icon"),
        type,
        value: currentCapture !== null && currentCapture !== void 0 ? currentCapture : uncapture(value),
        onInput
      }))));
    }
    function LabelledInput(_ref2) {
      var _labelPosition;

      var {
        label,
        labelPosition
      } = _ref2,
          props = _objectWithoutProperties(_ref2, _excluded3);

      (_labelPosition = labelPosition) !== null && _labelPosition !== void 0 ? _labelPosition : labelPosition = "start";
      var {
        inputId,
        labelId,
        useInputLabelInput,
        useInputLabelLabel
      } = useInputLabel({
        inputPrefix: "input-",
        labelPrefix: "input-label-"
      });
      var {
        useInputLabelInputProps
      } = useInputLabelInput();
      var {
        useInputLabelLabelProps
      } = useInputLabelLabel({
        tag: "label"
      });
      var isInInputGroup = F(InInputGroupContext);
      var labelJsx = v$1("label", _objectSpread2({}, useInputLabelLabelProps({
        class: isInInputGroup ? "input-group-text" : labelPosition != "floating" ? "form-label" : ""
      })), label);
      var inputJsx = v$1(Input, _objectSpread2({}, useInputLabelInputProps(props)));
      var inputWithLabel = v$1(d$1, null, labelPosition === "start" && labelJsx, inputJsx, (labelPosition === "end" || labelPosition == "floating") && labelJsx);
      if (labelPosition !== "floating") return inputWithLabel;else return v$1("div", {
        class: "form-floating"
      }, inputJsx);
    }

    var RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    g(function (_a) {
        var depth = _a.depth;
        var _b = useState(false), active = _b[0], setActive = _b[1];
        var useFocusTrapProps = useFocusTrap({ trapActive: active }).useFocusTrapProps;
        //const { useRovingTabIndexChild, useRovingTabIndexProps } = useRovingTabIndex<HTMLUListElement, RovingTabIndexChildInfo>({ tabbableIndex, focusOnChange: false });
        var divProps = useFocusTrapProps({ ref: undefined, className: "focus-trap-demo" });
        if (depth == 2)
            return v$1("div", null);
        return (v$1("div", { className: "demo" },
            v$1("label", null,
                "Active: ",
                v$1("input", { type: "checkbox", checked: active, onInput: function (e) { e.preventDefault(); setActive(e.currentTarget.checked); } })),
            v$1("div", __assign({}, divProps),
                v$1(DemoUseFocusTrapChild, { active: active, setActive: setActive, depth: depth !== null && depth !== void 0 ? depth : 0 }))));
    });
    var DemoUseFocusTrapChild = g(function (_a) {
        var setActive = _a.setActive, active = _a.active; _a.depth;
        return (v$1(d$1, null,
            v$1("button", null, "Button 1"),
            v$1("button", null, "Button 2"),
            v$1("button", null, "Button 3"),
            v$1("label", null,
                "Active: ",
                v$1("input", { type: "checkbox", checked: active, onInput: function (e) { e.preventDefault(); setActive(e.currentTarget.checked); } }))));
    });
    var DemoDialog = g(function () {
        var onClose = (function () { return setOpen(false); });
        var _a = useState(false), open = _a[0], setOpen = _a[1];
        return (v$1("div", { class: "demo" },
            v$1(Tooltip, { tooltip: "Open dialog", position: "block-start", Transition: ZoomFade, zoomOriginDynamic: 0, zoomMin: 0.85 },
                v$1(InputGroup, null,
                    v$1(Checkbox, { checked: open, onInput: setOpen, label: "Open dialog" }))),
            v$1(Dialog, { Transition: ClipFade, clipOriginBlock: 0, open: open, onClose: onClose, descriptive: false, title: "Dialog Title", footer: v$1("button", { onClick: onClose }, "Close") },
                v$1("p", { tabIndex: -1 }, "Dialog body content"),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")))));
    });
    var DemoOffcanvas = g(function () {
        var onClose = (function () { return setOpen(false); });
        var _a = useState(false), open = _a[0], setOpen = _a[1];
        //open = true;
        return (v$1("div", { class: "demo" },
            v$1(Checkbox, { checked: open, onInput: setOpen, label: "Open offcanvas" }),
            v$1(Offcanvas, { Transition: Slide, slideTargetInline: -1, open: open, onClose: onClose, descriptive: false, title: "Dialog Title" },
                v$1("p", { tabIndex: -1 }, "Dialog body content"),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")),
                v$1("p", null, RandomWords.join(" ")))));
    });
    var DemoMenu = g(function () {
        return (v$1("div", { class: "demo" },
            v$1(Menu, { Transition: ZoomFade, zoomOriginDynamic: 0, zoomMin: 0.85, tag: "ul", anchor: v$1(Button, null, "Open menu") },
                v$1(MenuItem, { index: 0 }, "AItem #1"),
                v$1(MenuItem, { index: 1 }, "BItem #2"),
                v$1(MenuItem, { index: 2 }, "CItem #3"),
                v$1(MenuItem, { index: 3 }, "DItem #4"))));
    });
    var DemoFocus = g(function () {
        var _a = useHasFocus(), focused = _a.focused, focusedInner = _a.focusedInner, useHasFocusProps = _a.useHasFocusProps;
        return (v$1("div", { class: "demo" },
            v$1("h2", null, "useHasFocus"),
            v$1("div", __assign({}, useHasFocusProps({ style: { border: "1px solid black" }, tabIndex: 0 })),
                "Outer ",
                v$1("div", { tabIndex: 0, style: { border: "1px solid black" } }, "Inner element")),
            v$1("div", null,
                v$1("ul", null,
                    v$1("li", null,
                        "Strictly focused: ",
                        focused.toString()),
                    v$1("li", null,
                        "Inner focused: ",
                        focusedInner.toString())))));
    });
    var DemoTabs = g(function () {
        var _a = useState(0), selectedIndex = _a[0], setSelectedIndex = _a[1];
        var _b = useState("activate"), selectionMode = _b[0];
        return (v$1("div", { class: "demo" },
            v$1("div", null,
                v$1(Tabs, { orientation: "block", onSelect: setSelectedIndex, selectedIndex: selectedIndex, selectionMode: selectionMode, tag: "ol" },
                    v$1("ol", null,
                        v$1(Tab, { index: 0 }, "Tab #1"),
                        v$1(Tab, { index: 1 }, "Tab #2"),
                        v$1(Tab, { index: 2 }, "Tab #3")),
                    v$1(TabPanel, { index: 0, Transition: ZoomFade, zoomMin: 0.8, zoomOriginBlock: 0 },
                        v$1("div", null, RandomWords.slice(0, Math.floor((1 / 3) * RandomWords.length)).join(" "))),
                    v$1(TabPanel, { index: 1, Transition: ZoomFade, zoomMin: 0.8, zoomOriginBlock: 0 },
                        v$1("div", null, RandomWords.slice(0, Math.floor((2 / 3) * RandomWords.length)).join(" "))),
                    v$1(TabPanel, { index: 2, Transition: ZoomFade, zoomMin: 0.8, zoomOriginBlock: 0 },
                        v$1("div", null, RandomWords.slice(0, Math.floor((3 / 3) * RandomWords.length)).join(" ")))))));
    });
    g(function () {
        var _a = useAriaTooltip({}), useTooltip = _a.useTooltip, useTooltipTrigger = _a.useTooltipTrigger, isOpen = _a.isOpen;
        var useTooltipProps = useTooltip().useTooltipProps;
        var useTooltipTriggerProps = useTooltipTrigger().useTooltipTriggerProps;
        return (v$1("div", { class: "demo" },
            v$1("p", null,
                "This is a paragraph with a ",
                v$1("span", __assign({}, useTooltipTriggerProps({})), "tooltip right here."),
                v$1("span", __assign({}, useTooltipProps({ hidden: !isOpen })), "This is the tooltip content."))));
    });
    function sleep(ms) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, ms); })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    }
    var DemoButtons = g(function () {
        var _a = useState("outline"), buttonsFill = _a[0], setButtonsFill = _a[1];
        var _b = useState("md"), buttonsSize = _b[0];
        var pushToast = usePushToast();
        function onClick(str) {
            return function onClick() {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, sleep(5000)];
                            case 1:
                                _a.sent();
                                pushToast(v$1(Toast, null,
                                    "Button was clicked (",
                                    str,
                                    ")"));
                                return [2 /*return*/];
                        }
                    });
                });
            };
        }
        return (v$1("div", { class: "demo" },
            v$1(ButtonGroup, null,
                v$1(ButtonGroupChild, { index: 0, onClick: function () { return setButtonsFill("fill"); }, pressed: buttonsFill === "fill", colorVariant: "primary" }, "Fill"),
                v$1(ButtonGroupChild, { index: 1, onClick: function () { return setButtonsFill("outline"); }, pressed: buttonsFill === "outline", colorVariant: "primary" }, "Outline")),
            v$1(ProvideDefaultButtonFill, { value: buttonsFill },
                v$1(ProvideDefaultButtonSize, { value: buttonsSize },
                    v$1(ButtonGroup, null,
                        v$1(ButtonGroupChild, { onClick: onClick("primary"), index: 0, tag: "button", colorVariant: "primary" }, "Primary"),
                        v$1(ButtonGroupChild, { onClick: onClick("secondary"), index: 1, tag: "button", colorVariant: "secondary" }, "Secondary"),
                        v$1(ButtonGroupChild, { onClick: onClick("success"), index: 2, tag: "button", colorVariant: "success" }, "Success"),
                        v$1(ButtonGroupChild, { onClick: onClick("warning"), index: 3, tag: "button", colorVariant: "warning" }, "Warning")),
                    v$1(ButtonGroup, null,
                        v$1(ButtonGroupChild, { onClick: onClick("danger"), index: 0, tag: "button", colorVariant: "danger" }, "Danger"),
                        v$1(ButtonGroupChild, { onClick: onClick("info"), index: 1, tag: "button", colorVariant: "info" }, "Info"),
                        v$1(ButtonGroupChild, { onClick: onClick("light"), index: 2, tag: "button", colorVariant: "light" }, "Light"),
                        v$1(ButtonGroupChild, { onClick: onClick("dark"), index: 3, tag: "button", colorVariant: "dark" }, "Dark"),
                        v$1(ButtonGroupChild, { tag: "a", index: 4, href: "#", colorVariant: "link" }, "Link"))))));
    });
    var DemoAccordion = g(function () {
        var _a = useState(-1), expandedIndex = _a[0], setExpandedIndex = _a[1];
        return (v$1("div", { class: "demo" },
            v$1("div", null,
                v$1(Accordion, { expandedIndex: expandedIndex, setExpandedIndex: setExpandedIndex },
                    v$1(AccordionSection, { index: 0, header: "Accordion Item #1" },
                        v$1("div", null,
                            v$1("strong", null, "This is the 1st item's accordion body."),
                            " It is visible by default, You can modify any of this with custom CSS or overriding our default variables. It's also worth noting that just about any HTML can go within the ",
                            v$1("code", null, "AccordionSection"),
                            ".")),
                    v$1(AccordionSection, { index: 1, header: "Accordion Item #2" },
                        v$1("div", null,
                            v$1("strong", null, "This is the 2nd item's accordion body."),
                            " It is hidden by default,  You can modify any of this with custom CSS or overriding our default variables. It's also worth noting that just about any HTML can go within the ",
                            v$1("code", null, "AccordionSection"),
                            ".")),
                    v$1(AccordionSection, { index: 2, header: "Accordion Item #3" },
                        v$1("div", null,
                            v$1("strong", null, "This is the 3rd item's accordion body."),
                            " It is hidden by default,  You can modify any of this with custom CSS or overriding our default variables. It's also worth noting that just about any HTML can go within the ",
                            v$1("code", null, "AccordionSection"),
                            "."))))));
    });
    var DemoList = g(function () {
        var _a = useState(0), index = _a[0], setIndex = _a[1];
        return (v$1("div", { class: "demo" },
            "Selected: ",
            index,
            v$1(ListSingle, { select: "single", onSelect: setIndex, selectedIndex: index, selectionMode: "activate", tag: "ul" },
                v$1(ListItemSingle, { index: 0 }, "Primary"),
                v$1(ListItemSingle, { index: 1 }, "Secondary"),
                v$1(ListItemSingle, { index: 2 }, "Success"),
                v$1(ListItemSingle, { index: 3 }, "Warning"),
                v$1(ListItemSingle, { index: 4 }, "Danger"),
                v$1(ListItemSingle, { index: 5 }, "Info"),
                v$1(ListItemSingle, { index: 6 }, "Light"),
                v$1(ListItemSingle, { index: 7 }, "Dark"),
                v$1(ListItemSingle, { index: 8 }, "Link"))));
    });
    var DemoInput = g(function () {
        var _a = useState(""), text = _a[0], setText = _a[1];
        var _b = useState(""), radioValue = _b[0], setRadioValue = _b[1];
        var onInput1 = A$1(function (value) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep(5000)];
                    case 1:
                        _a.sent();
                        setText(value);
                        return [2 /*return*/];
                }
            });
        }); }, [setRadioValue]);
        var onInput2 = A$1(function (value) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sleep(5000)];
                    case 1:
                        _a.sent();
                        setRadioValue(value);
                        return [2 /*return*/];
                }
            });
        }); }, [setRadioValue]);
        return (v$1("div", { class: "demo" },
            v$1(InputGroup, null,
                v$1(LabelledInput, { type: "text", label: "Test input", onInput: onInput1, value: text })),
            v$1(RadioGroup, { selectedValue: radioValue, name: "demo-radio", onInput: onInput2 },
                v$1(InputGroup, null,
                    v$1(Radio, { index: 0, value: "ARadio" })),
                v$1(InputGroup, null,
                    v$1(Radio, { index: 1, value: "BRadio" })),
                v$1(InputGroup, null,
                    v$1(Radio, { index: 2, value: "CRadio" })))));
    });
    var Component = function () {
        return v$1("div", { class: "flex", style: { flexWrap: "wrap" } },
            v$1(ToastsProvider, null,
                v$1(DemoAccordion, null),
                v$1(DemoDialog, null),
                v$1(DemoOffcanvas, null),
                v$1(DemoInput, null),
                v$1(DemoButtons, null),
                v$1(DemoList, null),
                v$1(DemoTabs, null),
                v$1(DemoMenu, null),
                v$1(DemoFocus, null),
                v$1(DemoUseTimeout, null),
                v$1(DemoUseInterval, null),
                v$1("input", null)));
    };
    requestAnimationFrame(function () {
        S$1(v$1(Component, null), document.getElementById("root"));
    });

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5tanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL2Rpc3QvaG9va3MubWpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXN0YXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWFjdGl2ZS1lbGVtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1jaGlsZHJlbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1jbGFzc2VzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1yZWZzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1zdHlsZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXJlZi1lbGVtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWhhcy1mb2N1cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1yYW5kb20taWQuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtZWxlbWVudC1zaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxvZ2ljYWwtZGlyZWN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXN0YWJsZS1nZXR0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2Utc3RhYmxlLWNhbGxiYWNrLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxheW91dC1lZmZlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtdGltZW91dC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1hc3luYy1oYW5kbGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWV2ZW50LWhhbmRsZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtaW50ZXJ2YWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtY2hpbGQtbWFuYWdlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1yb3ZpbmctdGFiaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1saXN0LW5hdmlnYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvZGlzdC9pbmRleC5lc20uanMiLCIuLi9ub2RlX21vZHVsZXMvYmxvY2tpbmctZWxlbWVudHMvZGlzdC9ibG9ja2luZy1lbGVtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy93aWNnLWluZXJ0L2Rpc3QvaW5lcnQuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy91c2UtYmxvY2tpbmctZWxlbWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1mb2N1cy10cmFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLXRvb2x0aXAuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9kaXN0L2NvbXBhdC5tanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vZm9yd2FyZC1lbGVtZW50LXJlZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi90cmFuc2l0aW9uYWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9jbGlwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL2ZhZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vY2xpcC1mYWRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL2NvbGxhcHNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL2NvbGxhcHNlLWZhZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc2xpZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc2xpZGUtZmFkZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi96b29tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3pvb20tZmFkZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zbGlkZS16b29tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NsaWRlLXpvb20tZmFkZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9mbGlwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3N3YXBwYWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3Byb3BzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWJ1dHRvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1hY2NvcmRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtbGFiZWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtY2hlY2tib3guanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtbW9kYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtZGlhbG9nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWxpc3Rib3gtc2luZ2xlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1hcmlhLXdpZGdldHMvdXNlLW1lbnUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtdGFicy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1yYWRpby1ncm91cC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtYXJpYS13aWRnZXRzL3VzZS10b2FzdHMuanMiLCIuLi9wcm9wcy5qcyIsIi4uL2FjY29yZGlvbi9hY2NvcmRpb24uanMiLCIuLi9wcm9ncmVzcy9saW5lYXIuanMiLCIuLi9idXR0b24vZGVmYXVsdHMuanMiLCIuLi9idXR0b24vYnV0dG9uLmpzIiwiLi4vYnV0dG9uL3RvZ2dsZS1idXR0b24uanMiLCIuLi9idXR0b24vYnV0dG9uLWdyb3VwLmpzIiwiLi4vcG9ydGFsL2luZGV4LmpzIiwiLi4vZGlhbG9nL2RpYWxvZy5qcyIsIi4uL2xpc3QvbGlzdC1zaW5nbGUuanMiLCIuLi90YWJzL3RhYnMuanMiLCJkZW1vcy91c2UtaW50ZXJ2YWwudHN4IiwiZGVtb3MvdXNlLXRpbWVvdXQudHN4IiwiLi4vbWVudS9wb3BwZXItY29uZmlnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy93aXRoaW4uanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9leHBhbmRUb0hhc2hNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFZpZXdwb3J0UmVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0U2Nyb2xsUGFyZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZVNjcm9sbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZWJvdW5jZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZm9ybWF0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdW5pcXVlQnkuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyIsIi4uL21lbnUvcG9wcGVyLWFwaS5qcyIsIi4uL21lbnUvbWVudS5qcyIsIi4uL29mZmNhbnZhcy9vZmZjYW52YXMuanMiLCIuLi9pbnB1dC1ncm91cC9wcm9wcy5qcyIsIi4uL2lucHV0LWdyb3VwL2lucHV0LWNoZWNrLmpzIiwiLi4vaW5wdXQtZ3JvdXAvaW5wdXQtcmFkaW8uanMiLCIuLi90b29sdGlwL3Rvb2x0aXAuanMiLCIuLi90b2FzdC90b2FzdC5qcyIsIi4uL2lucHV0LWdyb3VwL2lucHV0LWdyb3VwLmpzIiwiLi4vaW5wdXQtZ3JvdXAvaW5wdXQtdGV4dC5qcyIsImluZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IGZyb20pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuIiwidmFyIG4sbCx1LGksdCxvLHIsZixlPXt9LGM9W10scz0vYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO2Z1bmN0aW9uIGEobixsKXtmb3IodmFyIHUgaW4gbCluW3VdPWxbdV07cmV0dXJuIG59ZnVuY3Rpb24gaChuKXt2YXIgbD1uLnBhcmVudE5vZGU7bCYmbC5yZW1vdmVDaGlsZChuKX1mdW5jdGlvbiB2KGwsdSxpKXt2YXIgdCxvLHIsZj17fTtmb3IociBpbiB1KVwia2V5XCI9PXI/dD11W3JdOlwicmVmXCI9PXI/bz11W3JdOmZbcl09dVtyXTtpZihhcmd1bWVudHMubGVuZ3RoPjImJihmLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOmkpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGwmJm51bGwhPWwuZGVmYXVsdFByb3BzKWZvcihyIGluIGwuZGVmYXVsdFByb3BzKXZvaWQgMD09PWZbcl0mJihmW3JdPWwuZGVmYXVsdFByb3BzW3JdKTtyZXR1cm4geShsLGYsdCxvLG51bGwpfWZ1bmN0aW9uIHkobixpLHQsbyxyKXt2YXIgZj17dHlwZTpuLHByb3BzOmksa2V5OnQscmVmOm8sX19rOm51bGwsX186bnVsbCxfX2I6MCxfX2U6bnVsbCxfX2Q6dm9pZCAwLF9fYzpudWxsLF9faDpudWxsLGNvbnN0cnVjdG9yOnZvaWQgMCxfX3Y6bnVsbD09cj8rK3U6cn07cmV0dXJuIG51bGwhPWwudm5vZGUmJmwudm5vZGUoZiksZn1mdW5jdGlvbiBwKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19ZnVuY3Rpb24gZChuKXtyZXR1cm4gbi5jaGlsZHJlbn1mdW5jdGlvbiBfKG4sbCl7dGhpcy5wcm9wcz1uLHRoaXMuY29udGV4dD1sfWZ1bmN0aW9uIGsobixsKXtpZihudWxsPT1sKXJldHVybiBuLl9fP2sobi5fXyxuLl9fLl9fay5pbmRleE9mKG4pKzEpOm51bGw7Zm9yKHZhciB1O2w8bi5fX2subGVuZ3RoO2wrKylpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXJldHVybiB1Ll9fZTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuLnR5cGU/ayhuKTpudWxsfWZ1bmN0aW9uIGIobil7dmFyIGwsdTtpZihudWxsIT0obj1uLl9fKSYmbnVsbCE9bi5fX2Mpe2ZvcihuLl9fZT1uLl9fYy5iYXNlPW51bGwsbD0wO2w8bi5fX2subGVuZ3RoO2wrKylpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXtuLl9fZT1uLl9fYy5iYXNlPXUuX19lO2JyZWFrfXJldHVybiBiKG4pfX1mdW5jdGlvbiBtKG4peyghbi5fX2QmJihuLl9fZD0hMCkmJnQucHVzaChuKSYmIWcuX19yKyt8fHIhPT1sLmRlYm91bmNlUmVuZGVyaW5nKSYmKChyPWwuZGVib3VuY2VSZW5kZXJpbmcpfHxvKShnKX1mdW5jdGlvbiBnKCl7Zm9yKHZhciBuO2cuX19yPXQubGVuZ3RoOyluPXQuc29ydChmdW5jdGlvbihuLGwpe3JldHVybiBuLl9fdi5fX2ItbC5fX3YuX19ifSksdD1bXSxuLnNvbWUoZnVuY3Rpb24obil7dmFyIGwsdSxpLHQsbyxyO24uX19kJiYobz0odD0obD1uKS5fX3YpLl9fZSwocj1sLl9fUCkmJih1PVtdLChpPWEoe30sdCkpLl9fdj10Ll9fdisxLGoocix0LGksbC5fX24sdm9pZCAwIT09ci5vd25lclNWR0VsZW1lbnQsbnVsbCE9dC5fX2g/W29dOm51bGwsdSxudWxsPT1vP2sodCk6byx0Ll9faCkseih1LHQpLHQuX19lIT1vJiZiKHQpKSl9KX1mdW5jdGlvbiB3KG4sbCx1LGksdCxvLHIsZixzLGEpe3ZhciBoLHYscCxfLGIsbSxnLHc9aSYmaS5fX2t8fGMsQT13Lmxlbmd0aDtmb3IodS5fX2s9W10saD0wO2g8bC5sZW5ndGg7aCsrKWlmKG51bGwhPShfPXUuX19rW2hdPW51bGw9PShfPWxbaF0pfHxcImJvb2xlYW5cIj09dHlwZW9mIF8/bnVsbDpcInN0cmluZ1wiPT10eXBlb2YgX3x8XCJudW1iZXJcIj09dHlwZW9mIF98fFwiYmlnaW50XCI9PXR5cGVvZiBfP3kobnVsbCxfLG51bGwsbnVsbCxfKTpBcnJheS5pc0FycmF5KF8pP3koZCx7Y2hpbGRyZW46X30sbnVsbCxudWxsLG51bGwpOl8uX19iPjA/eShfLnR5cGUsXy5wcm9wcyxfLmtleSxudWxsLF8uX192KTpfKSl7aWYoXy5fXz11LF8uX19iPXUuX19iKzEsbnVsbD09PShwPXdbaF0pfHxwJiZfLmtleT09cC5rZXkmJl8udHlwZT09PXAudHlwZSl3W2hdPXZvaWQgMDtlbHNlIGZvcih2PTA7djxBO3YrKyl7aWYoKHA9d1t2XSkmJl8ua2V5PT1wLmtleSYmXy50eXBlPT09cC50eXBlKXt3W3ZdPXZvaWQgMDticmVha31wPW51bGx9aihuLF8scD1wfHxlLHQsbyxyLGYscyxhKSxiPV8uX19lLCh2PV8ucmVmKSYmcC5yZWYhPXYmJihnfHwoZz1bXSkscC5yZWYmJmcucHVzaChwLnJlZixudWxsLF8pLGcucHVzaCh2LF8uX19jfHxiLF8pKSxudWxsIT1iPyhudWxsPT1tJiYobT1iKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBfLnR5cGUmJm51bGwhPV8uX19rJiZfLl9faz09PXAuX19rP18uX19kPXM9eChfLHMsbik6cz1QKG4sXyxwLHcsYixzKSxhfHxcIm9wdGlvblwiIT09dS50eXBlP1wiZnVuY3Rpb25cIj09dHlwZW9mIHUudHlwZSYmKHUuX19kPXMpOm4udmFsdWU9XCJcIik6cyYmcC5fX2U9PXMmJnMucGFyZW50Tm9kZSE9biYmKHM9ayhwKSl9Zm9yKHUuX19lPW0saD1BO2gtLTspbnVsbCE9d1toXSYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHUudHlwZSYmbnVsbCE9d1toXS5fX2UmJndbaF0uX19lPT11Ll9fZCYmKHUuX19kPWsoaSxoKzEpKSxOKHdbaF0sd1toXSkpO2lmKGcpZm9yKGg9MDtoPGcubGVuZ3RoO2grKylNKGdbaF0sZ1srK2hdLGdbKytoXSl9ZnVuY3Rpb24geChuLGwsdSl7dmFyIGksdDtmb3IoaT0wO2k8bi5fX2subGVuZ3RoO2krKykodD1uLl9fa1tpXSkmJih0Ll9fPW4sbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnR5cGU/eCh0LGwsdSk6UCh1LHQsdCxuLl9fayx0Ll9fZSxsKSk7cmV0dXJuIGx9ZnVuY3Rpb24gQShuLGwpe3JldHVybiBsPWx8fFtdLG51bGw9PW58fFwiYm9vbGVhblwiPT10eXBlb2Ygbnx8KEFycmF5LmlzQXJyYXkobik/bi5zb21lKGZ1bmN0aW9uKG4pe0EobixsKX0pOmwucHVzaChuKSksbH1mdW5jdGlvbiBQKG4sbCx1LGksdCxvKXt2YXIgcixmLGU7aWYodm9pZCAwIT09bC5fX2Qpcj1sLl9fZCxsLl9fZD12b2lkIDA7ZWxzZSBpZihudWxsPT11fHx0IT1vfHxudWxsPT10LnBhcmVudE5vZGUpbjppZihudWxsPT1vfHxvLnBhcmVudE5vZGUhPT1uKW4uYXBwZW5kQ2hpbGQodCkscj1udWxsO2Vsc2V7Zm9yKGY9byxlPTA7KGY9Zi5uZXh0U2libGluZykmJmU8aS5sZW5ndGg7ZSs9MilpZihmPT10KWJyZWFrIG47bi5pbnNlcnRCZWZvcmUodCxvKSxyPW99cmV0dXJuIHZvaWQgMCE9PXI/cjp0Lm5leHRTaWJsaW5nfWZ1bmN0aW9uIEMobixsLHUsaSx0KXt2YXIgbztmb3IobyBpbiB1KVwiY2hpbGRyZW5cIj09PW98fFwia2V5XCI9PT1vfHxvIGluIGx8fEgobixvLG51bGwsdVtvXSxpKTtmb3IobyBpbiBsKXQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGxbb118fFwiY2hpbGRyZW5cIj09PW98fFwia2V5XCI9PT1vfHxcInZhbHVlXCI9PT1vfHxcImNoZWNrZWRcIj09PW98fHVbb109PT1sW29dfHxIKG4sbyxsW29dLHVbb10saSl9ZnVuY3Rpb24gJChuLGwsdSl7XCItXCI9PT1sWzBdP24uc2V0UHJvcGVydHkobCx1KTpuW2xdPW51bGw9PXU/XCJcIjpcIm51bWJlclwiIT10eXBlb2YgdXx8cy50ZXN0KGwpP3U6dStcInB4XCJ9ZnVuY3Rpb24gSChuLGwsdSxpLHQpe3ZhciBvO246aWYoXCJzdHlsZVwiPT09bClpZihcInN0cmluZ1wiPT10eXBlb2YgdSluLnN0eWxlLmNzc1RleHQ9dTtlbHNle2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpJiYobi5zdHlsZS5jc3NUZXh0PWk9XCJcIiksaSlmb3IobCBpbiBpKXUmJmwgaW4gdXx8JChuLnN0eWxlLGwsXCJcIik7aWYodSlmb3IobCBpbiB1KWkmJnVbbF09PT1pW2xdfHwkKG4uc3R5bGUsbCx1W2xdKX1lbHNlIGlmKFwib1wiPT09bFswXSYmXCJuXCI9PT1sWzFdKW89bCE9PShsPWwucmVwbGFjZSgvQ2FwdHVyZSQvLFwiXCIpKSxsPWwudG9Mb3dlckNhc2UoKWluIG4/bC50b0xvd2VyQ2FzZSgpLnNsaWNlKDIpOmwuc2xpY2UoMiksbi5sfHwobi5sPXt9KSxuLmxbbCtvXT11LHU/aXx8bi5hZGRFdmVudExpc3RlbmVyKGwsbz9UOkksbyk6bi5yZW1vdmVFdmVudExpc3RlbmVyKGwsbz9UOkksbyk7ZWxzZSBpZihcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1sKXtpZih0KWw9bC5yZXBsYWNlKC94bGlua1tIOmhdLyxcImhcIikucmVwbGFjZSgvc05hbWUkLyxcInNcIik7ZWxzZSBpZihcImhyZWZcIiE9PWwmJlwibGlzdFwiIT09bCYmXCJmb3JtXCIhPT1sJiZcInRhYkluZGV4XCIhPT1sJiZcImRvd25sb2FkXCIhPT1sJiZsIGluIG4pdHJ5e25bbF09bnVsbD09dT9cIlwiOnU7YnJlYWsgbn1jYXRjaChuKXt9XCJmdW5jdGlvblwiPT10eXBlb2YgdXx8KG51bGwhPXUmJighMSE9PXV8fFwiYVwiPT09bFswXSYmXCJyXCI9PT1sWzFdKT9uLnNldEF0dHJpYnV0ZShsLHUpOm4ucmVtb3ZlQXR0cmlidXRlKGwpKX19ZnVuY3Rpb24gSShuKXt0aGlzLmxbbi50eXBlKyExXShsLmV2ZW50P2wuZXZlbnQobik6bil9ZnVuY3Rpb24gVChuKXt0aGlzLmxbbi50eXBlKyEwXShsLmV2ZW50P2wuZXZlbnQobik6bil9ZnVuY3Rpb24gaihuLHUsaSx0LG8scixmLGUsYyl7dmFyIHMsaCx2LHkscCxrLGIsbSxnLHgsQSxQPXUudHlwZTtpZih2b2lkIDAhPT11LmNvbnN0cnVjdG9yKXJldHVybiBudWxsO251bGwhPWkuX19oJiYoYz1pLl9faCxlPXUuX19lPWkuX19lLHUuX19oPW51bGwscj1bZV0pLChzPWwuX19iKSYmcyh1KTt0cnl7bjppZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQKXtpZihtPXUucHJvcHMsZz0ocz1QLmNvbnRleHRUeXBlKSYmdFtzLl9fY10seD1zP2c/Zy5wcm9wcy52YWx1ZTpzLl9fOnQsaS5fX2M/Yj0oaD11Ll9fYz1pLl9fYykuX189aC5fX0U6KFwicHJvdG90eXBlXCJpbiBQJiZQLnByb3RvdHlwZS5yZW5kZXI/dS5fX2M9aD1uZXcgUChtLHgpOih1Ll9fYz1oPW5ldyBfKG0seCksaC5jb25zdHJ1Y3Rvcj1QLGgucmVuZGVyPU8pLGcmJmcuc3ViKGgpLGgucHJvcHM9bSxoLnN0YXRlfHwoaC5zdGF0ZT17fSksaC5jb250ZXh0PXgsaC5fX249dCx2PWguX19kPSEwLGguX19oPVtdKSxudWxsPT1oLl9fcyYmKGguX19zPWguc3RhdGUpLG51bGwhPVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiYoaC5fX3M9PWguc3RhdGUmJihoLl9fcz1hKHt9LGguX19zKSksYShoLl9fcyxQLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhtLGguX19zKSkpLHk9aC5wcm9wcyxwPWguc3RhdGUsdiludWxsPT1QLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmbnVsbCE9aC5jb21wb25lbnRXaWxsTW91bnQmJmguY29tcG9uZW50V2lsbE1vdW50KCksbnVsbCE9aC5jb21wb25lbnREaWRNb3VudCYmaC5fX2gucHVzaChoLmNvbXBvbmVudERpZE1vdW50KTtlbHNle2lmKG51bGw9PVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiZtIT09eSYmbnVsbCE9aC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZoLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobSx4KSwhaC5fX2UmJm51bGwhPWguc2hvdWxkQ29tcG9uZW50VXBkYXRlJiYhMT09PWguc2hvdWxkQ29tcG9uZW50VXBkYXRlKG0saC5fX3MseCl8fHUuX192PT09aS5fX3Ype2gucHJvcHM9bSxoLnN0YXRlPWguX19zLHUuX192IT09aS5fX3YmJihoLl9fZD0hMSksaC5fX3Y9dSx1Ll9fZT1pLl9fZSx1Ll9faz1pLl9fayx1Ll9fay5mb3JFYWNoKGZ1bmN0aW9uKG4pe24mJihuLl9fPXUpfSksaC5fX2gubGVuZ3RoJiZmLnB1c2goaCk7YnJlYWsgbn1udWxsIT1oLmNvbXBvbmVudFdpbGxVcGRhdGUmJmguY29tcG9uZW50V2lsbFVwZGF0ZShtLGguX19zLHgpLG51bGwhPWguY29tcG9uZW50RGlkVXBkYXRlJiZoLl9faC5wdXNoKGZ1bmN0aW9uKCl7aC5jb21wb25lbnREaWRVcGRhdGUoeSxwLGspfSl9aC5jb250ZXh0PXgsaC5wcm9wcz1tLGguc3RhdGU9aC5fX3MsKHM9bC5fX3IpJiZzKHUpLGguX19kPSExLGguX192PXUsaC5fX1A9bixzPWgucmVuZGVyKGgucHJvcHMsaC5zdGF0ZSxoLmNvbnRleHQpLGguc3RhdGU9aC5fX3MsbnVsbCE9aC5nZXRDaGlsZENvbnRleHQmJih0PWEoYSh7fSx0KSxoLmdldENoaWxkQ29udGV4dCgpKSksdnx8bnVsbD09aC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8KGs9aC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSh5LHApKSxBPW51bGwhPXMmJnMudHlwZT09PWQmJm51bGw9PXMua2V5P3MucHJvcHMuY2hpbGRyZW46cyx3KG4sQXJyYXkuaXNBcnJheShBKT9BOltBXSx1LGksdCxvLHIsZixlLGMpLGguYmFzZT11Ll9fZSx1Ll9faD1udWxsLGguX19oLmxlbmd0aCYmZi5wdXNoKGgpLGImJihoLl9fRT1oLl9fPW51bGwpLGguX19lPSExfWVsc2UgbnVsbD09ciYmdS5fX3Y9PT1pLl9fdj8odS5fX2s9aS5fX2ssdS5fX2U9aS5fX2UpOnUuX19lPUwoaS5fX2UsdSxpLHQsbyxyLGYsYyk7KHM9bC5kaWZmZWQpJiZzKHUpfWNhdGNoKG4pe3UuX192PW51bGwsKGN8fG51bGwhPXIpJiYodS5fX2U9ZSx1Ll9faD0hIWMscltyLmluZGV4T2YoZSldPW51bGwpLGwuX19lKG4sdSxpKX19ZnVuY3Rpb24geihuLHUpe2wuX19jJiZsLl9fYyh1LG4pLG4uc29tZShmdW5jdGlvbih1KXt0cnl7bj11Ll9faCx1Ll9faD1bXSxuLnNvbWUoZnVuY3Rpb24obil7bi5jYWxsKHUpfSl9Y2F0Y2gobil7bC5fX2Uobix1Ll9fdil9fSl9ZnVuY3Rpb24gTChsLHUsaSx0LG8scixmLGMpe3ZhciBzLGEsdix5PWkucHJvcHMscD11LnByb3BzLGQ9dS50eXBlLF89MDtpZihcInN2Z1wiPT09ZCYmKG89ITApLG51bGwhPXIpZm9yKDtfPHIubGVuZ3RoO18rKylpZigocz1yW19dKSYmKHM9PT1sfHwoZD9zLmxvY2FsTmFtZT09ZDozPT1zLm5vZGVUeXBlKSkpe2w9cyxyW19dPW51bGw7YnJlYWt9aWYobnVsbD09bCl7aWYobnVsbD09PWQpcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHApO2w9bz9kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLGQpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZCxwLmlzJiZwKSxyPW51bGwsYz0hMX1pZihudWxsPT09ZCl5PT09cHx8YyYmbC5kYXRhPT09cHx8KGwuZGF0YT1wKTtlbHNle2lmKHI9ciYmbi5jYWxsKGwuY2hpbGROb2RlcyksYT0oeT1pLnByb3BzfHxlKS5kYW5nZXJvdXNseVNldElubmVySFRNTCx2PXAuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIWMpe2lmKG51bGwhPXIpZm9yKHk9e30sXz0wO188bC5hdHRyaWJ1dGVzLmxlbmd0aDtfKyspeVtsLmF0dHJpYnV0ZXNbX10ubmFtZV09bC5hdHRyaWJ1dGVzW19dLnZhbHVlOyh2fHxhKSYmKHYmJihhJiZ2Ll9faHRtbD09YS5fX2h0bWx8fHYuX19odG1sPT09bC5pbm5lckhUTUwpfHwobC5pbm5lckhUTUw9diYmdi5fX2h0bWx8fFwiXCIpKX1pZihDKGwscCx5LG8sYyksdil1Ll9faz1bXTtlbHNlIGlmKF89dS5wcm9wcy5jaGlsZHJlbix3KGwsQXJyYXkuaXNBcnJheShfKT9fOltfXSx1LGksdCxvJiZcImZvcmVpZ25PYmplY3RcIiE9PWQscixmLHI/clswXTppLl9fayYmayhpLDApLGMpLG51bGwhPXIpZm9yKF89ci5sZW5ndGg7Xy0tOyludWxsIT1yW19dJiZoKHJbX10pO2N8fChcInZhbHVlXCJpbiBwJiZ2b2lkIDAhPT0oXz1wLnZhbHVlKSYmKF8hPT1sLnZhbHVlfHxcInByb2dyZXNzXCI9PT1kJiYhXykmJkgobCxcInZhbHVlXCIsXyx5LnZhbHVlLCExKSxcImNoZWNrZWRcImluIHAmJnZvaWQgMCE9PShfPXAuY2hlY2tlZCkmJl8hPT1sLmNoZWNrZWQmJkgobCxcImNoZWNrZWRcIixfLHkuY2hlY2tlZCwhMSkpfXJldHVybiBsfWZ1bmN0aW9uIE0obix1LGkpe3RyeXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP24odSk6bi5jdXJyZW50PXV9Y2F0Y2gobil7bC5fX2UobixpKX19ZnVuY3Rpb24gTihuLHUsaSl7dmFyIHQsbztpZihsLnVubW91bnQmJmwudW5tb3VudChuKSwodD1uLnJlZikmJih0LmN1cnJlbnQmJnQuY3VycmVudCE9PW4uX19lfHxNKHQsbnVsbCx1KSksbnVsbCE9KHQ9bi5fX2MpKXtpZih0LmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXt0LmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2gobil7bC5fX2Uobix1KX10LmJhc2U9dC5fX1A9bnVsbH1pZih0PW4uX19rKWZvcihvPTA7bzx0Lmxlbmd0aDtvKyspdFtvXSYmTih0W29dLHUsXCJmdW5jdGlvblwiIT10eXBlb2Ygbi50eXBlKTtpfHxudWxsPT1uLl9fZXx8aChuLl9fZSksbi5fX2U9bi5fX2Q9dm9pZCAwfWZ1bmN0aW9uIE8obixsLHUpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yKG4sdSl9ZnVuY3Rpb24gUyh1LGksdCl7dmFyIG8scixmO2wuX18mJmwuX18odSxpKSxyPShvPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQpP251bGw6dCYmdC5fX2t8fGkuX19rLGY9W10saihpLHU9KCFvJiZ0fHxpKS5fX2s9dihkLG51bGwsW3VdKSxyfHxlLGUsdm9pZCAwIT09aS5vd25lclNWR0VsZW1lbnQsIW8mJnQ/W3RdOnI/bnVsbDppLmZpcnN0Q2hpbGQ/bi5jYWxsKGkuY2hpbGROb2Rlcyk6bnVsbCxmLCFvJiZ0P3Q6cj9yLl9fZTppLmZpcnN0Q2hpbGQsbykseihmLHUpfWZ1bmN0aW9uIHEobixsKXtTKG4sbCxxKX1mdW5jdGlvbiBCKGwsdSxpKXt2YXIgdCxvLHIsZj1hKHt9LGwucHJvcHMpO2ZvcihyIGluIHUpXCJrZXlcIj09cj90PXVbcl06XCJyZWZcIj09cj9vPXVbcl06ZltyXT11W3JdO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPjImJihmLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOmkpLHkobC50eXBlLGYsdHx8bC5rZXksb3x8bC5yZWYsbnVsbCl9ZnVuY3Rpb24gRChuLGwpe3ZhciB1PXtfX2M6bD1cIl9fY0NcIitmKyssX186bixDb25zdW1lcjpmdW5jdGlvbihuLGwpe3JldHVybiBuLmNoaWxkcmVuKGwpfSxQcm92aWRlcjpmdW5jdGlvbihuKXt2YXIgdSxpO3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dHx8KHU9W10sKGk9e30pW2xdPXRoaXMsdGhpcy5nZXRDaGlsZENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gaX0sdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5wcm9wcy52YWx1ZSE9PW4udmFsdWUmJnUuc29tZShtKX0sdGhpcy5zdWI9ZnVuY3Rpb24obil7dS5wdXNoKG4pO3ZhciBsPW4uY29tcG9uZW50V2lsbFVubW91bnQ7bi5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3Uuc3BsaWNlKHUuaW5kZXhPZihuKSwxKSxsJiZsLmNhbGwobil9fSksbi5jaGlsZHJlbn19O3JldHVybiB1LlByb3ZpZGVyLl9fPXUuQ29uc3VtZXIuY29udGV4dFR5cGU9dX1uPWMuc2xpY2UsbD17X19lOmZ1bmN0aW9uKG4sbCl7Zm9yKHZhciB1LGksdDtsPWwuX187KWlmKCh1PWwuX19jKSYmIXUuX18pdHJ5e2lmKChpPXUuY29uc3RydWN0b3IpJiZudWxsIT1pLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciYmKHUuc2V0U3RhdGUoaS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IobikpLHQ9dS5fX2QpLG51bGwhPXUuY29tcG9uZW50RGlkQ2F0Y2gmJih1LmNvbXBvbmVudERpZENhdGNoKG4pLHQ9dS5fX2QpLHQpcmV0dXJuIHUuX19FPXV9Y2F0Y2gobCl7bj1sfXRocm93IG59fSx1PTAsaT1mdW5jdGlvbihuKXtyZXR1cm4gbnVsbCE9biYmdm9pZCAwPT09bi5jb25zdHJ1Y3Rvcn0sXy5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24obixsKXt2YXIgdTt1PW51bGwhPXRoaXMuX19zJiZ0aGlzLl9fcyE9PXRoaXMuc3RhdGU/dGhpcy5fX3M6dGhpcy5fX3M9YSh7fSx0aGlzLnN0YXRlKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiYobj1uKGEoe30sdSksdGhpcy5wcm9wcykpLG4mJmEodSxuKSxudWxsIT1uJiZ0aGlzLl9fdiYmKGwmJnRoaXMuX19oLnB1c2gobCksbSh0aGlzKSl9LF8ucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKG4pe3RoaXMuX192JiYodGhpcy5fX2U9ITAsbiYmdGhpcy5fX2gucHVzaChuKSxtKHRoaXMpKX0sXy5wcm90b3R5cGUucmVuZGVyPWQsdD1bXSxvPVwiZnVuY3Rpb25cIj09dHlwZW9mIFByb21pc2U/UHJvbWlzZS5wcm90b3R5cGUudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKTpzZXRUaW1lb3V0LGcuX19yPTAsZj0wO2V4cG9ydHtTIGFzIHJlbmRlcixxIGFzIGh5ZHJhdGUsdiBhcyBjcmVhdGVFbGVtZW50LHYgYXMgaCxkIGFzIEZyYWdtZW50LHAgYXMgY3JlYXRlUmVmLGkgYXMgaXNWYWxpZEVsZW1lbnQsXyBhcyBDb21wb25lbnQsQiBhcyBjbG9uZUVsZW1lbnQsRCBhcyBjcmVhdGVDb250ZXh0LEEgYXMgdG9DaGlsZEFycmF5LGwgYXMgb3B0aW9uc307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhY3QubW9kdWxlLmpzLm1hcFxuIiwiaW1wb3J0e29wdGlvbnMgYXMgbn1mcm9tXCJwcmVhY3RcIjt2YXIgdCx1LHIsbz0wLGk9W10sYz1uLl9fYixmPW4uX19yLGU9bi5kaWZmZWQsYT1uLl9fYyx2PW4udW5tb3VudDtmdW5jdGlvbiBtKHQscil7bi5fX2gmJm4uX19oKHUsdCxvfHxyKSxvPTA7dmFyIGk9dS5fX0h8fCh1Ll9fSD17X186W10sX19oOltdfSk7cmV0dXJuIHQ+PWkuX18ubGVuZ3RoJiZpLl9fLnB1c2goe30pLGkuX19bdF19ZnVuY3Rpb24gbChuKXtyZXR1cm4gbz0xLHAodyxuKX1mdW5jdGlvbiBwKG4scixvKXt2YXIgaT1tKHQrKywyKTtyZXR1cm4gaS50PW4saS5fX2N8fChpLl9fPVtvP28ocik6dyh2b2lkIDAsciksZnVuY3Rpb24obil7dmFyIHQ9aS50KGkuX19bMF0sbik7aS5fX1swXSE9PXQmJihpLl9fPVt0LGkuX19bMV1dLGkuX19jLnNldFN0YXRlKHt9KSl9XSxpLl9fYz11KSxpLl9ffWZ1bmN0aW9uIHkocixvKXt2YXIgaT1tKHQrKywzKTshbi5fX3MmJmsoaS5fX0gsbykmJihpLl9fPXIsaS5fX0g9byx1Ll9fSC5fX2gucHVzaChpKSl9ZnVuY3Rpb24gaChyLG8pe3ZhciBpPW0odCsrLDQpOyFuLl9fcyYmayhpLl9fSCxvKSYmKGkuX189cixpLl9fSD1vLHUuX19oLnB1c2goaSkpfWZ1bmN0aW9uIHMobil7cmV0dXJuIG89NSxkKGZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bn19LFtdKX1mdW5jdGlvbiBfKG4sdCx1KXtvPTYsaChmdW5jdGlvbigpe1wiZnVuY3Rpb25cIj09dHlwZW9mIG4/bih0KCkpOm4mJihuLmN1cnJlbnQ9dCgpKX0sbnVsbD09dT91OnUuY29uY2F0KG4pKX1mdW5jdGlvbiBkKG4sdSl7dmFyIHI9bSh0KyssNyk7cmV0dXJuIGsoci5fX0gsdSkmJihyLl9fPW4oKSxyLl9fSD11LHIuX19oPW4pLHIuX199ZnVuY3Rpb24gQShuLHQpe3JldHVybiBvPTgsZChmdW5jdGlvbigpe3JldHVybiBufSx0KX1mdW5jdGlvbiBGKG4pe3ZhciByPXUuY29udGV4dFtuLl9fY10sbz1tKHQrKyw5KTtyZXR1cm4gby5jPW4scj8obnVsbD09by5fXyYmKG8uX189ITAsci5zdWIodSkpLHIucHJvcHMudmFsdWUpOm4uX199ZnVuY3Rpb24gVCh0LHUpe24udXNlRGVidWdWYWx1ZSYmbi51c2VEZWJ1Z1ZhbHVlKHU/dSh0KTp0KX1mdW5jdGlvbiBxKG4pe3ZhciByPW0odCsrLDEwKSxvPWwoKTtyZXR1cm4gci5fXz1uLHUuY29tcG9uZW50RGlkQ2F0Y2h8fCh1LmNvbXBvbmVudERpZENhdGNoPWZ1bmN0aW9uKG4pe3IuX18mJnIuX18obiksb1sxXShuKX0pLFtvWzBdLGZ1bmN0aW9uKCl7b1sxXSh2b2lkIDApfV19ZnVuY3Rpb24geCgpe2kuZm9yRWFjaChmdW5jdGlvbih0KXtpZih0Ll9fUCl0cnl7dC5fX0guX19oLmZvckVhY2goZyksdC5fX0guX19oLmZvckVhY2goaiksdC5fX0guX19oPVtdfWNhdGNoKHUpe3QuX19ILl9faD1bXSxuLl9fZSh1LHQuX192KX19KSxpPVtdfW4uX19iPWZ1bmN0aW9uKG4pe3U9bnVsbCxjJiZjKG4pfSxuLl9fcj1mdW5jdGlvbihuKXtmJiZmKG4pLHQ9MDt2YXIgcj0odT1uLl9fYykuX19IO3ImJihyLl9faC5mb3JFYWNoKGcpLHIuX19oLmZvckVhY2goaiksci5fX2g9W10pfSxuLmRpZmZlZD1mdW5jdGlvbih0KXtlJiZlKHQpO3ZhciBvPXQuX19jO28mJm8uX19IJiZvLl9fSC5fX2gubGVuZ3RoJiYoMSE9PWkucHVzaChvKSYmcj09PW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHwoKHI9bi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpfHxmdW5jdGlvbihuKXt2YXIgdCx1PWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHIpLGImJmNhbmNlbEFuaW1hdGlvbkZyYW1lKHQpLHNldFRpbWVvdXQobil9LHI9c2V0VGltZW91dCh1LDEwMCk7YiYmKHQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHUpKX0pKHgpKSx1PXZvaWQgMH0sbi5fX2M9ZnVuY3Rpb24odCx1KXt1LnNvbWUoZnVuY3Rpb24odCl7dHJ5e3QuX19oLmZvckVhY2goZyksdC5fX2g9dC5fX2guZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiFuLl9ffHxqKG4pfSl9Y2F0Y2gocil7dS5zb21lKGZ1bmN0aW9uKG4pe24uX19oJiYobi5fX2g9W10pfSksdT1bXSxuLl9fZShyLHQuX192KX19KSxhJiZhKHQsdSl9LG4udW5tb3VudD1mdW5jdGlvbih0KXt2JiZ2KHQpO3ZhciB1PXQuX19jO2lmKHUmJnUuX19IKXRyeXt1Ll9fSC5fXy5mb3JFYWNoKGcpfWNhdGNoKHQpe24uX19lKHQsdS5fX3YpfX07dmFyIGI9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO2Z1bmN0aW9uIGcobil7dmFyIHQ9dTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLl9fYyYmbi5fX2MoKSx1PXR9ZnVuY3Rpb24gaihuKXt2YXIgdD11O24uX19jPW4uX18oKSx1PXR9ZnVuY3Rpb24gayhuLHQpe3JldHVybiFufHxuLmxlbmd0aCE9PXQubGVuZ3RofHx0LnNvbWUoZnVuY3Rpb24odCx1KXtyZXR1cm4gdCE9PW5bdV19KX1mdW5jdGlvbiB3KG4sdCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD90KG4pOnR9ZXhwb3J0e2wgYXMgdXNlU3RhdGUscCBhcyB1c2VSZWR1Y2VyLHkgYXMgdXNlRWZmZWN0LGggYXMgdXNlTGF5b3V0RWZmZWN0LHMgYXMgdXNlUmVmLF8gYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZSxkIGFzIHVzZU1lbW8sQSBhcyB1c2VDYWxsYmFjayxGIGFzIHVzZUNvbnRleHQsVCBhcyB1c2VEZWJ1Z1ZhbHVlLHEgYXMgdXNlRXJyb3JCb3VuZGFyeX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rcy5tb2R1bGUuanMubWFwXG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZVAgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG4vKipcbiAqIFNsaWdodGx5IGVuaGFuY2VkIHZlcnNpb24gb2YgYHVzZVN0YXRlYCB0aGF0IGluY2x1ZGVzIGEgZ2V0dGVyIHRoYXQgcmVtYWlucyBjb25zdGFudFxuICogKGkuZS4geW91IGNhbiB1c2UgaXQgaW4gYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpdCBiZWluZyBhIGRlcGVuZGVuY3kpLlxuICpcbiAqIEBwYXJhbSBpbml0aWFsU3RhdGVcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgICAvLyBXZSBrZWVwIGJvdGhcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlUChpbml0aWFsU3RhdGUpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihzdGF0ZSk7XG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldCA9IHVzZUNhbGxiYWNrKCh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxldCBjYWxsYmFjayA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGUocHJldlZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGdldCA9ICgpID0+IHsgcmV0dXJuIHJlZi5jdXJyZW50OyB9O1xuICAgIGNvbnNvbGUuYXNzZXJ0KHJlZi5jdXJyZW50ID09PSBzdGF0ZSk7XG4gICAgcmV0dXJuIFtzdGF0ZSwgc2V0LCBnZXRdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXN0YXRlLmpzLm1hcCIsImltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG4vKipcbiAqXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCBkaWZmZXJlbnQgd2F5cyB0aGF0IGEgZm9jdXMgZXZlbnQgY2FuIGhhcHBlbi4gIEFzc3VtZVxuICogdGhlIGZvbGxvd2luZyBzdGVwcyBoYXBwZW4gaW4gb3JkZXI6XG4gKlxuICogMS4gVGhlIHBhZ2UgbG9hZHMuXG4gKiAgICAqIE5vdGhpbmcgaXMgZm9jdXNlZCwgYnV0IGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBgYm9keWAuXG4gKiAgICAqIE5vIGZvY3VzIGV2ZW50cyBhcmUgZmlyZWQuXG4gKiAyLiBUaGUgd2luZG93IGlzIGZvY3VzZWQsIGFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIHJlbWFpbnMgYXMgYGJvZHlgLlxuICogICAgKiBBIGBmb2N1c2AvYGZvY3VzaW5gIGV2ZW50ICpNSUdIVCogYmUgZmlyZWQgZm9yIGBib2R5YC4gRGVwZW5kaW5nIG9uXG4gKiAgICAgIHRoZSBicm93c2VyLCB0aGlzIGRlcGVuZHMgb24gd2hldGhlciB0aGUgaGFuZGxlciB3YXMgYXR0YWNoZWQgdG8gYHdpbmRvd2Agb3IgYGRvY3VtZW50YC5cbiAqICAgICAgUHJvYmFibHkganVzdCBiZXN0IHRvIG5vdCByZWx5IG9uIGl0LCBvciBsaXN0ZW4gdG8gYHdpbmRvd2AgZm9jdXMgZXZlbnRzIGRpcmVjdGx5LlxuICogMy4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBuZXcgZWxlbWVudCBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXG4gKiAgICAqIGBmb2N1c291dGAgYW5kIGBibHVyYCBhcmUgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxuICogICAgKiBgZm9jdXNgIGFuZCBgZm9jdXNpbmAgYXJlIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwuXG4gKiA0LiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cbiAqICAgICogKipUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgYGJvZHlgKiogYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxuICogICAgKiBgYmx1cmAgYW5kIGBmb2N1c291dGAgYXJlIGZpcmVkIG9uIHRoZSBvbGQgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBuZXcgZWxlbWVudC5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBub3cgc2V0IHRvIHRoZSBuZXcgZWxlbWVudC5cbiAqICAgICogYGZvY3VzaW5gIGlzIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBvbGQgZWxlbWVudC5cbiAqIDUuIEFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byBgYm9keWAuXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cbiAqICAgICogYGZvY3VzaW5gIGlzICpub3QqIGZpcmVkIG9uIGBib2R5YC5cbiAqXG4gKlxuICogSW4gc3VtbWFyeTpcbiAqIDEuIEZvY3VzIGV2ZW50cyAqZG8qIG5vdGlmeSB1cyBvZiBhbGwgY2hhbmdlcyBpbiBmb2N1cywgYnV0IHRoZXJlIGlzIG5vIG9uZSBzaW5nbGUgY29tcHJlaGVuc2l2ZSBldmVudCB0aGF0IHByb3ZpZGVzIHVzIHdpdGggYWxsIGF2YWlsYWJsZSBpbmZvcm1hdGlvbi5cbiAqIDIuIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCAqaXMgbm90KiBhbHdheXMgdGhlIHNhbWUgYXMgd2hhdCdzIGJlaW5nIHJlZmVyZW5jZWQgYnkgYSBmb2N1cyBldmVudC4gSW4gcGFydGljdWxhciwgaXQgbWF5IGJlY29tZSBgYm9keWAgYXQgYW55IGFyYml0cmFyeSB0aW1lLlxuICogMy4gQSBgYmx1cmAgd2l0aG91dCBhIGBmb2N1c2AgY2FuIGFuZCB3aWxsIG9jY3VyLiBUaGlzIG1lYW5zIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBzb2xlbHkgdXNlIGBmb2N1c2AgdG8gZGV0ZWN0IGFsbCBjaGFuZ2VzLlxuICogNC4gQSBgYmx1cmAgZXZlbnQgd2hvc2UgYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwgaW5kaWNhdGVzIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBmb2xsb3dpbmcgYGZvY3VzYCBldmVudC5cbiAqXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrXG4gKiBAcmV0dXJuc1xuICovXG5sZXQgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQgPSBudWxsO1xubGV0IGxhc3RGb2N1c2VkRWxlbWVudCA9IG51bGw7XG5mdW5jdGlvbiBnZXRMYXN0Rm9jdXNlZEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGxhc3RGb2N1c2VkRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRseUZvY3VzZWRFbGVtZW50KCkge1xuICAgIHJldHVybiBjdXJyZW50bHlGb2N1c2VkRWxlbWVudDtcbn1cbmNvbnN0IHVwZGF0ZXJzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gZm9jdXNvdXQoZSkge1xuICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGYgb2YgdXBkYXRlcnMpIHtcbiAgICAgICAgICAgIGYoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSnVzdCB3YWl0IGZvciB0aGUgZm9jdXNpbiBldmVudC5cbiAgICB9XG59XG5mdW5jdGlvbiBmb2N1c2luKGUpIHtcbiAgICBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCA9IGxhc3RGb2N1c2VkRWxlbWVudCA9IGUudGFyZ2V0O1xuICAgIGZvciAobGV0IGYgb2YgdXBkYXRlcnMpIHtcbiAgICAgICAgZigpO1xuICAgIH1cbn1cbmxldCB3aW5kb3dGb2N1c2VkID0gdHJ1ZTtcbmZ1bmN0aW9uIHdpbmRvd0ZvY3VzKCkge1xuICAgIHdpbmRvd0ZvY3VzZWQgPSB0cnVlO1xuICAgIGZvciAobGV0IGYgb2YgdXBkYXRlcnMpIHtcbiAgICAgICAgZigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdpbmRvd0JsdXIoKSB7XG4gICAgd2luZG93Rm9jdXNlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGYgb2YgdXBkYXRlcnMpIHtcbiAgICAgICAgZigpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3RpdmVFbGVtZW50KCkge1xuICAgIC8vIFRPRE86IElzIHRoaXMgYWN0dWFsbHkgYmV0dGVyIHRoYW4gdXNpbmcgcHJvcGVyIHN0YXRlIG1hbmFnZW1lbnQ/XG4gICAgY29uc3QgW2ksIHNldEldID0gdXNlU3RhdGUoMCk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgRiA9ICgpID0+IHNldEkoaSA9PiArK2kpO1xuICAgICAgICBpZiAodXBkYXRlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbiwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1ciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZXJzLmFkZChGKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZXJzLmRlbGV0ZShGKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbik7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0KTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQ6IGN1cnJlbnRseUZvY3VzZWRFbGVtZW50LFxuICAgICAgICBsYXN0QWN0aXZlRWxlbWVudDogbGFzdEZvY3VzZWRFbGVtZW50LFxuICAgICAgICBnZXRBY3RpdmVFbGVtZW50OiBnZXRDdXJyZW50bHlGb2N1c2VkRWxlbWVudCxcbiAgICAgICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQ6IGdldExhc3RGb2N1c2VkRWxlbWVudCxcbiAgICAgICAgd2luZG93Rm9jdXNlZFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtYWN0aXZlLWVsZW1lbnQuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tIFwicHJlYWN0XCI7XG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkQ2hpbGRyZW4obGhzUHJvcHMsIHJoc1Byb3BzKSB7XG4gICAgY29uc3QgbGhzID0gbGhzUHJvcHM/LmNoaWxkcmVuO1xuICAgIGNvbnN0IHJocyA9IHJoc1Byb3BzPy5jaGlsZHJlbjtcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJocztcbiAgICB9XG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxocztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCByZXQgPSBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgbGhzLCByaHMpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1tZXJnZWQtY2hpbGRyZW4uanMubWFwIiwiZnVuY3Rpb24gdG9WYWwobWl4KSB7XG5cdHZhciBrLCB5LCBzdHI9Jyc7XG5cblx0aWYgKHR5cGVvZiBtaXggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBtaXggPT09ICdudW1iZXInKSB7XG5cdFx0c3RyICs9IG1peDtcblx0fSBlbHNlIGlmICh0eXBlb2YgbWl4ID09PSAnb2JqZWN0Jykge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KG1peCkpIHtcblx0XHRcdGZvciAoaz0wOyBrIDwgbWl4Lmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdGlmIChtaXhba10pIHtcblx0XHRcdFx0XHRpZiAoeSA9IHRvVmFsKG1peFtrXSkpIHtcblx0XHRcdFx0XHRcdHN0ciAmJiAoc3RyICs9ICcgJyk7XG5cdFx0XHRcdFx0XHRzdHIgKz0geTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChrIGluIG1peCkge1xuXHRcdFx0XHRpZiAobWl4W2tdKSB7XG5cdFx0XHRcdFx0c3RyICYmIChzdHIgKz0gJyAnKTtcblx0XHRcdFx0XHRzdHIgKz0gaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcblx0dmFyIGk9MCwgdG1wLCB4LCBzdHI9Jyc7XG5cdHdoaWxlIChpIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGlmICh0bXAgPSBhcmd1bWVudHNbaSsrXSkge1xuXHRcdFx0aWYgKHggPSB0b1ZhbCh0bXApKSB7XG5cdFx0XHRcdHN0ciAmJiAoc3RyICs9ICcgJyk7XG5cdFx0XHRcdHN0ciArPSB4XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdHI7XG59XG4iLCJpbXBvcnQgeyBkZWZhdWx0IGFzIGNsc3ggfSBmcm9tIFwiY2xzeFwiO1xuLyoqXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXG4gKiBEdXBsaWNhdGUgY2xhc3NlcyBhcmUgcmVtb3ZlZCAob3JkZXIgZG9lc24ndCBtYXR0ZXIgYW55d2F5KS5cbiAqXG4gKiBAcGFyYW0gbGhzIENsYXNzZXMgb2YgdGhlIGZpcnN0IGNvbXBvbmVudFxuICogQHBhcmFtIHJocyBDbGFzc2VzIG9mIHRoZSBzZWNvbmQgY29tcG9uZW50XG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIGNvbWJpbmVkIGNsYXNzZXMgZnJvbSBib3RoIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENsYXNzZXMobGhzLCByaHMpIHtcbiAgICAvLyBOb3RlOiBGb3IgdGhlIHNha2Ugb2YgZm9yd2FyZCBjb21wYXRpYmlsaXR5LCB0aGlzIGZ1bmN0aW9uIGlzIGxhYmVsbGVkIGFzXG4gICAgLy8gYSBob29rLCBidXQgYXMgaXQgdXNlcyBubyBvdGhlciBob29rcyBpdCB0ZWNobmljYWxseSBpc24ndCBvbmUuXG4gICAgcmV0dXJuIG1lcmdlQ2xhc3NlcyhsaHMsIHJocyk7XG59XG5mdW5jdGlvbiBtZXJnZUNsYXNzZXMobGhzLCByaHMpIHtcbiAgICBjb25zdCBsaHNDbGFzcyA9IGxocz8uY2xhc3M7XG4gICAgY29uc3QgbGhzQ2xhc3NOYW1lID0gbGhzPy5jbGFzc05hbWU7XG4gICAgY29uc3QgcmhzQ2xhc3MgPSByaHM/LmNsYXNzO1xuICAgIGNvbnN0IHJoc0NsYXNzTmFtZSA9IHJocz8uY2xhc3NOYW1lO1xuICAgIGlmIChsaHNDbGFzcyB8fCByaHNDbGFzcyB8fCBsaHNDbGFzc05hbWUgfHwgcmhzQ2xhc3NOYW1lKSB7XG4gICAgICAgIGxldCBsaHNDbGFzc2VzID0gY2xzeChsaHNDbGFzcywgbGhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGxldCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGxldCBhbGxDbGFzc2VzID0gbmV3IFNldChbLi4uQXJyYXkuZnJvbShsaHNDbGFzc2VzKSwgLi4uQXJyYXkuZnJvbShyaHNDbGFzc2VzKV0pO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gdHlwZXRlc3QoKSB7XG4gICAgY29uc3QgYyA9IFtcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh1bmRlZmluZWQsIHVuZGVmaW5lZCksXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoe30sIHVuZGVmaW5lZCksXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXModW5kZWZpbmVkLCB7fSksXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoe30sIHt9KSxcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh7IGNsYXNzOiBcInN0cmluZ1wiIH0sIHt9KSxcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh7IGNsYXNzOiBcInN0cmluZ1wiIH0sIHsgY2xhc3M6IHVuZGVmaW5lZCB9KSxcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh7IGNsYXNzOiB1bmRlZmluZWQgfSwgeyBjbGFzczogXCJzdHJpbmdcIiB9KSxcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh7IGNsYXNzTmFtZTogXCJzdHJpbmdcIiB9LCB7IGNsYXNzTmFtZTogdW5kZWZpbmVkIH0pLFxuICAgICAgICB1c2VNZXJnZWRDbGFzc2VzKHsgY2xhc3NOYW1lOiB1bmRlZmluZWQgfSwgeyBjbGFzc05hbWU6IFwic3RyaW5nXCIgfSksXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoeyBjbGFzczogXCJzdHJpbmdcIiB9LCB7IGNsYXNzTmFtZTogdW5kZWZpbmVkIH0pLFxuICAgICAgICB1c2VNZXJnZWRDbGFzc2VzKHsgY2xhc3NOYW1lOiB1bmRlZmluZWQgfSwgeyBjbGFzczogXCJzdHJpbmdcIiB9KSxcbiAgICAgICAgdXNlTWVyZ2VkQ2xhc3Nlcyh7IGNsYXNzTmFtZTogXCJzdHJpbmdcIiB9LCB7IGNsYXNzOiB1bmRlZmluZWQgfSksXG4gICAgICAgIHVzZU1lcmdlZENsYXNzZXMoeyBjbGFzczogdW5kZWZpbmVkIH0sIHsgY2xhc3NOYW1lOiBcInN0cmluZ1wiIH0pLFxuICAgIF07XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjWzBdLmNvbmNhdChcIlwiKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNbMV0uY29uY2F0KFwiXCIpO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY1syXS5jb25jYXQoXCJcIik7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjWzNdLmNvbmNhdChcIlwiKTtcbiAgICBjWzRdLmNvbmNhdChcIlwiKTtcbiAgICBjWzVdLmNvbmNhdChcIlwiKTtcbiAgICBjWzZdLmNvbmNhdChcIlwiKTtcbiAgICBjWzddLmNvbmNhdChcIlwiKTtcbiAgICBjWzhdLmNvbmNhdChcIlwiKTtcbiAgICBjWzldLmNvbmNhdChcIlwiKTtcbiAgICBjWzEwXS5jb25jYXQoXCJcIik7XG4gICAgY1sxMV0uY29uY2F0KFwiXCIpO1xuICAgIGNbMTJdLmNvbmNhdChcIlwiKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNbMTNdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW1lcmdlZC1jbGFzc2VzLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuZnVuY3Rpb24gcHJvY2Vzc1JlZihpbnN0YW5jZSwgcmVmKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZWYoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICByZWYuY3VycmVudCA9IGluc3RhbmNlO1xuICAgIH1cbn1cbi8qKlxuICogQ29tYmluZXMgdHdvIHJlZnMgaW50byBvbmUuIFRoaXMgYWxsb3dzIGEgY29tcG9uZW50IHRvIGJvdGggdXNlIGl0cyBvd24gcmVmICphbmQqIGZvcndhcmQgYSByZWYgdGhhdCB3YXMgZ2l2ZW4gdG8gaXQuXG4gKiBAcGFyYW0gbGhzXG4gKiBAcGFyYW0gcmhzXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmcygpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGxoc1Byb3BzLCByaHNQcm9wcykge1xuICAgICAgICBjb25zdCBsaHMgPSBsaHNQcm9wcz8ucmVmO1xuICAgICAgICBjb25zdCByaHMgPSByaHNQcm9wcz8ucmVmO1xuICAgICAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsaHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmV0ID0gdXNlQ2FsbGJhY2soKGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIGxocyk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCByaHMpO1xuICAgICAgICAgICAgfSwgW2xocywgcmhzXSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qXG5mdW5jdGlvbiB0eXBldGVzdDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SFRNTElucHV0RWxlbWVudD4+KHByb3BzOiBQKSB7XG5cbiAgICBjb25zdCByZWY6IFJlZk9iamVjdDxIVE1MSW5wdXRFbGVtZW50PiA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsKTtcblxuICAgIGZ1bmN0aW9uIGFjY2VwdHNSZWYocmVmOiBSZWY8YW55PikgeyB9XG4gICAgZnVuY3Rpb24gYWNjZXB0c09wdGlvbmFsUmVmKHJlZjogUmVmPGFueT4gfCB1bmRlZmluZWQpIHsgfVxuXG4gICAgY29uc3QgYyA9IFtcbiAgICAgICAgdXNlTWVyZ2VkUmVmczxIVE1MSW5wdXRFbGVtZW50PigpKHVuZGVmaW5lZCwgdW5kZWZpbmVkKSxcbiAgICAgICAgdXNlTWVyZ2VkUmVmczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB1bmRlZmluZWQpLFxuICAgICAgICB1c2VNZXJnZWRSZWZzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHVuZGVmaW5lZCksXG4gICAgICAgIHVzZU1lcmdlZFJlZnM8SFRNTElucHV0RWxlbWVudD4oKSh1bmRlZmluZWQsIHByb3BzKSxcbiAgICAgICAgdXNlTWVyZ2VkUmVmczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwcm9wcyksXG4gICAgICAgIHVzZU1lcmdlZFJlZnM8SFRNTElucHV0RWxlbWVudD4oKSh7IHJlZiB9LCBwcm9wcyksXG4gICAgICAgIHVzZU1lcmdlZFJlZnM8SFRNTElucHV0RWxlbWVudD4oKSh7IHJlZiB9LCB7IHJlZjogdW5kZWZpbmVkIH0pLFxuICAgICAgICB1c2VNZXJnZWRSZWZzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoeyByZWY6IHVuZGVmaW5lZCB9LCB7IHJlZiB9KSxcbiAgICAgICAgdXNlTWVyZ2VkUmVmczxIVE1MSW5wdXRFbGVtZW50PigpKHsgcmVmIH0sIHsgcmVmIH0pLFxuICAgIF0gYXMgY29uc3Q7XG5cbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGFjY2VwdHNSZWYoY1swXSk7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBhY2NlcHRzUmVmKGNbMV0pO1xuXG4gICAgYWNjZXB0c09wdGlvbmFsUmVmKGNbMl0pO1xuICAgIGFjY2VwdHNPcHRpb25hbFJlZihjWzNdKTtcbiAgICBhY2NlcHRzT3B0aW9uYWxSZWYoY1s0XSk7XG5cbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPXG4gICAgYWNjZXB0c1JlZihjWzVdKTtcbiAgICBhY2NlcHRzUmVmKGNbNl0pO1xuICAgIGFjY2VwdHNSZWYoY1s3XSk7XG4gICAgYWNjZXB0c1JlZihjWzhdKTtcbn1cbiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbWVyZ2VkLXJlZnMuanMubWFwIiwiLyoqXG4gKiBNZXJnZXMgdHdvIHN0eWxlIG9iamVjdHMsIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSBzdHlsZSBUaGUgdXNlci1naXZlbiBzdHlsZSBwcm9wIGZvciB0aGlzIGNvbXBvbmVudFxuICogQHBhcmFtIG9iaiBUaGUgQ1NTIHByb3BlcnRpZXMgeW91IHdhbnQgYWRkZWQgdG8gdGhlIHVzZXItZ2l2ZW4gc3R5bGVcbiAqIEByZXR1cm5zIEEgQ1NTIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIGJvdGggb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFN0eWxlcyhsaHMsIHJocykge1xuICAgIC8vIEVhc3kgY2FzZSwgd2hlbiB0aGVyZSBhcmUgbm8gc3R5bGVzIHRvIG1lcmdlIHJldHVybiBub3RoaW5nLlxuICAgIGlmICghbGhzICYmICFyaHMpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiBsaHMgIT0gdHlwZW9mIHJocykge1xuICAgICAgICAvLyBFYXN5IGNhc2VzLCB3aGVuIG9uZSBpcyBudWxsIGFuZCB0aGUgb3RoZXIgaXNuJ3QuXG4gICAgICAgIGlmIChsaHMgJiYgIXJocylcbiAgICAgICAgICAgIHJldHVybiBsaHM7XG4gICAgICAgIGlmICghbGhzICYmIHJocylcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgIC8vIFRoZXkncmUgYm90aCBub24tbnVsbCBidXQgZGlmZmVyZW50IHR5cGVzLlxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgdHlwZSB0byBhbiBvYmplY3QgYmFnIHR5cGUgYW5kIHJ1biBpdCBhZ2Fpbi5cbiAgICAgICAgaWYgKGxocyAmJiByaHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGhzID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyh7IHN0eWxlOiBPYmplY3QuZnJvbUVudHJpZXMobGhzLnNwbGl0KFwiO1wiKS5tYXAoc3RhdGVtZW50ID0+IHN0YXRlbWVudC5zcGxpdChcIjpcIikpKSB9LCByaHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgeyBzdHlsZTogT2JqZWN0LmZyb21FbnRyaWVzKGxocy5zcGxpdChcIjtcIikubWFwKHN0YXRlbWVudCA9PiBzdGF0ZW1lbnQuc3BsaXQoXCI6XCIpKSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9naWM/Pz9cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gVGhleSdyZSBib3RoIHN0cmluZ3MsIGp1c3QgY29uY2F0ZW5hdGUgdGhlbS5cbiAgICBpZiAodHlwZW9mIGxocyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBgJHtsaHN9OyR7cmhzfWA7IC8vIFRPRE86IEltcHJvdmUgdGhlIHR5cGluZyB0byBtYWtlIHRoaXMgcG9zc2libGVcbiAgICB9XG4gICAgLy8gVGhleSdyZSBib3RoIG9iamVjdHMsIGp1c3QgbWVyZ2UgdGhlbS5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4obGhzPy5zdHlsZSA/PyB7fSksXG4gICAgICAgIC4uLihyaHM/LnN0eWxlID8/IHt9KVxuICAgIH07XG59XG5mdW5jdGlvbiBhY2NlcHRzU3RyaW5nT3JDc3NPclVuZGVmaW5lZCh1KSB7IH1cbmZ1bmN0aW9uIGFjY2VwdHNTdHJpbmdPckNzcyhzdHIpIHsgfVxuZnVuY3Rpb24gYWNjZXB0c0Nzcyhwcm9wKSB7IH1cbmZ1bmN0aW9uIHR5cGV0ZXN0KHByb3BzKSB7XG4gICAgY29uc3Qgc3R5bGUgPSB7fTtcbiAgICBjb25zdCBjID0gW1xuICAgICAgICB1c2VNZXJnZWRTdHlsZXModW5kZWZpbmVkLCB1bmRlZmluZWQpLFxuICAgICAgICB1c2VNZXJnZWRTdHlsZXMoe30sIHVuZGVmaW5lZCksXG4gICAgICAgIHVzZU1lcmdlZFN0eWxlcyh1bmRlZmluZWQsIHt9KSxcbiAgICAgICAgdXNlTWVyZ2VkU3R5bGVzKHt9LCB7fSksXG4gICAgICAgIHVzZU1lcmdlZFN0eWxlcyhwcm9wcywgdW5kZWZpbmVkKSxcbiAgICAgICAgdXNlTWVyZ2VkU3R5bGVzKHVuZGVmaW5lZCwgcHJvcHMpLFxuICAgICAgICB1c2VNZXJnZWRTdHlsZXMocHJvcHMsIHByb3BzKSxcbiAgICAgICAgdXNlTWVyZ2VkU3R5bGVzKHsgc3R5bGUgfSwge30pLFxuICAgICAgICB1c2VNZXJnZWRTdHlsZXMoeyBzdHlsZSB9LCBwcm9wcyksXG4gICAgICAgIHVzZU1lcmdlZFN0eWxlcyhwcm9wcywgeyBzdHlsZSB9KSxcbiAgICAgICAgdXNlTWVyZ2VkU3R5bGVzKHsgc3R5bGUgfSwgeyBzdHlsZSB9KSxcbiAgICBdO1xuICAgIC8vIFNhbml0eSBjaGVja3NcbiAgICBjWzBdID09PSB1bmRlZmluZWQ7XG4gICAgY1sxXSA9PT0gdW5kZWZpbmVkO1xuICAgIGNbMl0gPT09IHVuZGVmaW5lZDtcbiAgICBjWzNdID09PSB1bmRlZmluZWQ7XG4gICAgY1s0XSA9PT0gdW5kZWZpbmVkO1xuICAgIGNbNV0gPT09IHVuZGVmaW5lZDtcbiAgICBjWzZdID09PSB1bmRlZmluZWQ7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgQmVjYXVzZSBib3RoIHdlcmUgdW5kZWZpbmVkXG4gICAgY1swXT8uYmFja2dyb3VuZENvbG9yO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yIEJlY2F1c2UgXCJzdHlsZVwiIHdhcyBub3QgcHJvdmlkZWQgYXMgYSBwcm9wXG4gICAgY1sxXT8uYmFja2dyb3VuQ29sb3I7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgQmVjYXVzZSBcInN0eWxlXCIgd2FzIG5vdCBwcm92aWRlZCBhcyBhIHByb3BcbiAgICBjWzJdPy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgQmVjYXVzZSBcInN0eWxlXCIgd2FzIG5vdCBwcm92aWRlZCBhcyBhIHByb3BcbiAgICBjWzNdPy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgQmVjYXVzZSBcInN0eWxlXCIgbWF5IGJlIHVuZGVmaW5lZCBkZXBlbmRpbmcgb24gaG93IFAgZXh0ZW5kcyBIVE1MQXR0cmlidXRlc1xuICAgIGFjY2VwdHNTdHJpbmdPckNzcyhjWzRdKTtcbiAgICBhY2NlcHRzU3RyaW5nT3JDc3NPclVuZGVmaW5lZChjWzRdKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciBCZWNhdXNlIFwic3R5bGVcIiBtYXkgYmUgdW5kZWZpbmVkIGRlcGVuZGluZyBvbiBob3cgUCBleHRlbmRzIEhUTUxBdHRyaWJ1dGVzXG4gICAgYWNjZXB0c1N0cmluZ09yQ3NzKGNbNV0pO1xuICAgIGFjY2VwdHNTdHJpbmdPckNzc09yVW5kZWZpbmVkKGNbNV0pO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yIEJlY2F1c2UgXCJzdHlsZVwiIG1heSBiZSB1bmRlZmluZWQgZGVwZW5kaW5nIG9uIGhvdyBQIGV4dGVuZHMgSFRNTEF0dHJpYnV0ZXNcbiAgICBhY2NlcHRzU3RyaW5nT3JDc3MoY1s2XSk7XG4gICAgYWNjZXB0c1N0cmluZ09yQ3NzT3JVbmRlZmluZWQoY1s2XSk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBUaGlzIHNob3VsZCBiZSBhbGxvd2VkXG4gICAgYWNjZXB0c1N0cmluZ09yQ3NzKGNbN10pO1xuICAgIGFjY2VwdHNTdHJpbmdPckNzc09yVW5kZWZpbmVkKGNbN10pO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogVGhpcyBzaG91bGQgYmUgYWxsb3dlZFxuICAgIGFjY2VwdHNTdHJpbmdPckNzcyhjWzhdKTtcbiAgICBhY2NlcHRzU3RyaW5nT3JDc3NPclVuZGVmaW5lZChjWzhdKTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IFRoaXMgc2hvdWxkIGJlIGFsbG93ZWRcbiAgICBhY2NlcHRzU3RyaW5nT3JDc3MoY1s5XSk7XG4gICAgYWNjZXB0c1N0cmluZ09yQ3NzT3JVbmRlZmluZWQoY1s5XSk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBUaGlzIHNob3VsZCBiZSBhbGxvd2VkXG4gICAgYWNjZXB0c1N0cmluZ09yQ3NzKGNbMTBdKTtcbiAgICBhY2NlcHRzU3RyaW5nT3JDc3NPclVuZGVmaW5lZChjWzEwXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbWVyZ2VkLXN0eWxlcy5qcy5tYXAiLCJpbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW5cIjtcbmltcG9ydCB7IHVzZU1lcmdlZENsYXNzZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNsYXNzZXNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFJlZnMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXJlZnNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzXCI7XG5sZXQgbG9nID0gKHN0cikgPT4geyBkZWJ1Z2dlcjsgLyogSW50ZW50aW9uYWwgKi8gfTtcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVMb2dnaW5nUHJvcENvbmZsaWN0cyhsb2cyKSB7XG4gICAgbG9nID0gbG9nMjtcbn1cbi8qKlxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXG4gKlxuICogVGhlIGhvb2sgaXMgYXdhcmUgb2YgYW5kIGNhbiBpbnRlbGxpZ2VudGx5IG1lcmdlIGBjbGFzc05hbWVgLCBgY2xhc3NgLCBgc3R5bGVgLCBgcmVmYCwgYW5kIGFsbCBldmVudCBoYW5kbGVycy5cbiAqIEBwYXJhbSBsaHMyXG4gKiBAcGFyYW0gcmhzMlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobGhzMiwgcmhzMikge1xuICAgICAgICAvLyBGaXJzdCwgcHV0IGluIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IGFyZSBlYXN5IHRvIHJlYXNvbiBhYm91dFxuICAgICAgICAvLyBhbmQgYWxsIGxocyBwcm9wcy4gV2UncmUgZ29pbmcgdG8gbWVyZ2UgaW4gcmhzIGp1c3QgYWZ0ZXIuXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IGxoc0NoaWxkcmVuLCBjbGFzczogbGhzQ2xhc3MsIGNsYXNzTmFtZTogbGhzQ2xhc3NOYW1lLCBzdHlsZTogbGhzU3R5bGUsIHJlZjogbGhzUmVmLCAuLi5saHMgfSA9IGxoczI7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IHJoc0NoaWxkcmVuLCBjbGFzczogcmhzQ2xhc3MsIGNsYXNzTmFtZTogcmhzQ2xhc3NOYW1lLCBzdHlsZTogcmhzU3R5bGUsIHJlZjogcmhzUmVmLCAuLi5yaHMgfSA9IHJoczI7XG4gICAgICAgIGxldCByZXQgPSB7XG4gICAgICAgICAgICAuLi5saHMsXG4gICAgICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnMoKShsaHMyLCByaHMyKSxcbiAgICAgICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzMiwgcmhzMiksXG4gICAgICAgICAgICBjbGFzc05hbWU6IHVzZU1lcmdlZENsYXNzZXMobGhzMiwgcmhzMiksXG4gICAgICAgICAgICBjaGlsZHJlbjogdXNlTWVyZ2VkQ2hpbGRyZW4obGhzMiwgcmhzMilcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTm93LCBkbyAqZXZlcnl0aGluZyogZWxzZVxuICAgICAgICAvLyBNZXJnZSBldmVyeSByZW1haW5pbmcgZXhpc3RpbmcgZW50cnkgaW4gbGhzIHdpdGggd2hhdCB3ZSd2ZSBhbHJlYWR5IHB1dCBpbiByZXQuXG4gICAgICAgIC8vY29uc3QgbGhzRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGxocykgYXMgW2tleW9mIFQsIFRba2V5b2YgVF1dW107XG4gICAgICAgIGNvbnN0IHJoc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhyaHMpO1xuICAgICAgICBmb3IgKGNvbnN0IFtyaHNLZXksIHJoc1ZhbHVlXSBvZiByaHNFbnRyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBsaHNWYWx1ZSA9IGxoc1tyaHNLZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhleSdyZSBib3RoIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBtZXJnZWQgKG9yIG9uZSdzIGEgZnVuY3Rpb24gYW5kIHRoZSBvdGhlcidzIG51bGwpLlxuICAgICAgICAgICAgICAgIC8vIE5vdCBhbiAqZWFzeSogY2FzZSwgYnV0IGEgd2VsbC1kZWZpbmVkIG9uZS5cbiAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZUZ1bmN0aW9ucyhsaHNWYWx1ZSwgcmhzVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gbWVyZ2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVWguLi53ZSdyZSBoZXJlIGJlY2F1c2Ugb25lIG9mIHRoZW0ncyBudWxsLCByaWdodD9cbiAgICAgICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbCAmJiByaHNWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxoc1ZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmhzVmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyaHNWYWx1ZSA9PSBsaHNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJIG1lYW4sIHRoZXkncmUgdGhlIHNhbWUgdmFsdWUgYXQgbGVhc3RcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBVZ2guXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGdvb2Qgc3RyYXRlZ2llcyBoZXJlLCBqdXN0IGxvZyBpdCBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICAgICAgICAgICAgbG9nPy4oYENvdWxkIG5vdCBtZXJnZSBpbmNvbXBhdGlibGUgcHJvcCBcIiR7cmhzS2V5fVwiICh0eXBlOiAke3R5cGVvZiByaHNWYWx1ZX0sIHZhbHVlczogWyR7bGhzVmFsdWV9LCAke3Joc1ZhbHVlfV0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlRnVuY3Rpb25zKGxocywgcmhzKSB7XG4gICAgaWYgKCFsaHMpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgaWYgKCFyaHMpXG4gICAgICAgIHJldHVybiBsaHM7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGxldCBsdiA9IGxocz8uKC4uLmFyZ3MpO1xuICAgICAgICBsZXQgcnYgPSByaHM/LiguLi5hcmdzKTtcbiAgICAgICAgaWYgKGx2IGluc3RhbmNlb2YgUHJvbWlzZSB8fCBydiBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2x2LCBydl0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBnZW5lcmljR2V0VGVzdCgpIHtcbiAgICBjb25zdCB0MSA9IG51bGw7XG4gICAgY29uc3QgdDIgPSBudWxsO1xuICAgIGNvbnN0IHQzID0gbnVsbDtcbiAgICBpZiAodDMuaWQgPT0gbnVsbCkge1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdDMuaWQuY29uY2F0KFwiXCIpO1xuICAgIH1cbn1cbi8qXG5mdW5jdGlvbiB0ZXN0PFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxIVE1MSW5wdXRFbGVtZW50Pj4ocHJvcHM6IFApIHtcblxuICAgIGNvbnN0IGlkMDogR2VuZXJpY0dldDx7fSwgXCJpZFwiLCBzdHJpbmc+ID0gXCJcIjtcbiAgICBjb25zdCBpZDM6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpZDQ6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpZDU6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpZDY6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcbiAgICAvL2NvbnN0IGlkMjogWmlwU2luZ2xlPHN0cmluZyB8IHVuZGVmaW5lZCwgc3RyaW5nIHwgdW5kZWZpbmVkPiA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpZDE6IFppcE9iamVjdDx7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0geyBpZDogdW5kZWZpbmVkIH07XG5cbiAgICB0eXBlIE0xID0gR2VuZXJpY0dldDxQLCBcInN0eWxlXCIsIHN0cmluZz47XG4gICAgdHlwZSBNMiA9IEdlbmVyaWNHZXQ8e30sIFwic3R5bGVcIiwgc3RyaW5nPjtcbiAgICBjb25zdCBtMTogTTEgPSBcIlwiO1xuICAgIGNvbnN0IG0yOiBNMSA9IHVuZGVmaW5lZDtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xuICAgIGNvbnN0IG0zOiBNMSA9IDA7XG5cbiAgICBjb25zdCBtNDogTTIgPSBcIlwiO1xuICAgIGNvbnN0IG01OiBNMiA9IHVuZGVmaW5lZDtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xuICAgIGNvbnN0IG02OiBNMiA9IDA7XG5cbiAgICBjb25zdCBwMTogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHsgaWQ6IHN0cmluZyB9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHsgaWQ6IFwic3RyaW5nXCIgfSk7XG4gICAgY29uc3QgcDI6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xuICAgIGNvbnN0IHAzOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogdW5kZWZpbmVkIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogdW5kZWZpbmVkIH0pO1xuICAgIGNvbnN0IHA0OiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7fSwge30+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwge30pO1xuICAgIGNvbnN0IHA1ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywge30pO1xuICAgIGNvbnN0IHA2ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgeyBpZDogdW5kZWZpbmVkIH0pO1xuICAgIGNvbnN0IHA3ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgeyBpZDogXCJzdHJpbmdcIiB9KTtcblxuXG4gICAgcDEuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICBwMi5pZD8uY29uY2F0KFwiXCIpO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcbiAgICBwMy5pZD8uY29uY2F0KFwiXCIpO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcbiAgICBwNC5pZD8uY29uY2F0KFwiXCIpO1xuXG5cbiAgICBwNS5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHA2LmlkPy5jb25jYXQoXCJcIik7XG4gICAgcDcuaWQ/LmNvbmNhdChcIlwiKTtcblxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcbiAgICBwNS5pZC5jb25jYXQoXCJcIik7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxuICAgIHA2LmlkLmNvbmNhdChcIlwiKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXG4gICAgcDcuaWQuY29uY2F0KFwiXCIpO1xuXG5cbiAgICBpZiAocDUuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XG4gICAgZWxzZSBpZiAocDUuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjY2VwdHNOZXZlcihwNS5hbGxvd0Z1bGxTY3JlZW4pO1xuICAgIH1cblxuXG4gICAgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxuICAgIGVsc2Uge1xuICAgICAgICBhY2NlcHRzTmV2ZXIocDYuYWxsb3dGdWxsU2NyZWVuKTtcbiAgICB9XG5cblxuICAgIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxuICAgIGVsc2UgaWYgKHA3LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjZXB0c05ldmVyKHA3LmFsbG93RnVsbFNjcmVlbik7XG4gICAgfVxuXG5cbiAgICAvLyBNYWtlIHN1cmUgaXQgd29ya3MgcmVjdXJzaXZlbHlcbiAgICBjb25zdCByMWEgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwMSk7XG4gICAgY29uc3QgcjFiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDEpO1xuICAgIGNvbnN0IHIyYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAyKTtcbiAgICBjb25zdCByMmIgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwMik7XG4gICAgY29uc3QgcjNhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDMpO1xuICAgIGNvbnN0IHIzYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAzKTtcbiAgICBjb25zdCByNGEgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwNCk7XG4gICAgY29uc3QgcjRiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDQpO1xuICAgIGNvbnN0IHI1YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA1KTtcbiAgICBjb25zdCByNWIgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwNSk7XG4gICAgY29uc3QgcjZhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDYpO1xuICAgIGNvbnN0IHI2YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA2KTtcbiAgICBjb25zdCByN2EgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwNyk7XG4gICAgY29uc3QgcjdiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDcpO1xuXG5cbiAgICByMWEuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICByMWIuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICByMmEuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICByMmIuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcbiAgICByM2EuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICByM2IuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXG4gICAgcjRhLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcjRiLmlkPy5jb25jYXQoXCJcIik7XG5cblxuICAgIHI1YS5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHI1Yi5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHI2YS5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHI2Yi5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHI3YS5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHI3Yi5pZD8uY29uY2F0KFwiXCIpO1xuXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxuICAgIHI1YS5pZC5jb25jYXQoXCJcIik7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxuICAgIHI1Yi5pZC5jb25jYXQoXCJcIik7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxuICAgIHI2YS5pZC5jb25jYXQoXCJcIik7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxuICAgIHI2Yi5pZC5jb25jYXQoXCJcIik7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxuICAgIHI3YS5pZC5jb25jYXQoXCJcIik7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxuICAgIHI3Yi5pZC5jb25jYXQoXCJcIik7XG5cblxuICAgIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XG4gICAgZWxzZSBpZiAocjVhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XG4gICAgZWxzZSBpZiAocjVhLmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjZXB0c05ldmVyKHI1YS5hbGxvd0Z1bGxTY3JlZW4pO1xuICAgIH1cblxuXG4gICAgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxuICAgIGVsc2Uge1xuICAgICAgICBhY2NlcHRzTmV2ZXIocjViLmFsbG93RnVsbFNjcmVlbik7XG4gICAgfVxuXG5cbiAgICBpZiAocjZhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjY2VwdHNOZXZlcihyNmEuYWxsb3dGdWxsU2NyZWVuKTtcbiAgICB9XG5cblxuICAgIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XG4gICAgZWxzZSBpZiAocjZiLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XG4gICAgZWxzZSBpZiAocjZiLmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjZXB0c05ldmVyKHI2Yi5hbGxvd0Z1bGxTY3JlZW4pO1xuICAgIH1cblxuXG4gICAgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxuICAgIGVsc2Uge1xuICAgICAgICBhY2NlcHRzTmV2ZXIocjdhLmFsbG93RnVsbFNjcmVlbik7XG4gICAgfVxuXG5cbiAgICBpZiAocjdiLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjY2VwdHNOZXZlcihyN2IuYWxsb3dGdWxsU2NyZWVuKTtcbiAgICB9XG5cbn1cbmZ1bmN0aW9uIGFjY2VwdHNOZXZlcihuOiBuZXZlcikge31cbiovIFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW1lcmdlZC1wcm9wcy5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcbi8qKlxuICogQWxsb3dzIGFjY2Vzc2luZyB0aGUgZWxlbWVudCBhIHJlZiByZWZlcmVuY2VzIGFzIHNvb24gYXMgaXQgZG9lcyBzby5cbiAqICpUaGlzIGhvb2sgaXRzZWxmIHJldHVybnMgYSBob29rKi0tdXNlUmVmRWxlbWVudFByb3BzIG1vZGlmaWVzIHRoZSBwcm9wcyB0aGF0IHlvdSB3ZXJlIGdvaW5nIHRvIHBhc3MgdG8gYW4gSFRNTEVsZW1lbnQsXG4gKiBhZGRpbmcgYSBSZWZDYWxsYmFjayBhbmQgbWVyZ2luZyBpdCB3aXRoIGFueSBleGlzdGluZyByZWYgdGhhdCBleGlzdGVkIG9uIHRoZSBwcm9wcy5cbiAqXG4gKiBEb24ndCBmb3JnZXQgdG8gcHJvdmlkZSB0aGUgRWxlbWVudCBhcyB0aGUgdHlwZSBhcmd1bWVudCFcbiAqXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudCwgYW5kIHRoZSBzdWItaG9vayB0aGF0IG1ha2VzIGl0IHJldHJpZXZhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmRWxlbWVudCgpIHtcbiAgICAvLyBMZXQgdXMgc3RvcmUgdGhlIGFjdHVhbCAocmVmZXJlbmNlIHRvKSB0aGUgZWxlbWVudCB3ZSBjYXB0dXJlXG4gICAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnQsIGdldEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgLy8gQ3JlYXRlIGEgUmVmQ2FsbGJhY2sgdGhhdCdzIGZpcmVkIHdoZW4gbW91bnRlZCBcbiAgICAvLyBhbmQgdGhhdCBub3RpZmllcyB1cyBvZiBvdXIgZWxlbWVudCB3aGVuIHdlIGhhdmUgaXRcbiAgICBjb25zdCBteVJlZiA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgICAgIGlmIChlKVxuICAgICAgICAgICAgc2V0RWxlbWVudCgoKSA9PiBlKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgdXNlUmVmRWxlbWVudFByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzKSA9PiB1c2VNZXJnZWRQcm9wcygpKHsgcmVmOiBteVJlZiB9LCBwcm9wcyksIFtdKTtcbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcbiAgICAvLyB0aGUgcHJvcHMgYW5kIGFsbG93cyB1cyB0byBhY3R1YWxseSBmaW5kIHRoZSBlbGVtZW50XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlUmVmRWxlbWVudFByb3BzLFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICBnZXRFbGVtZW50XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgZnVuY3Rpb24gZm9vKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XG4gICAgICAgIGNvbnN0IHAxID0gdXNlUmVmRWxlbWVudFByb3BzKHByb3BzKTtcbiAgICAgICAgaWYgKHAxLnN0eWxlID09IHVuZGVmaW5lZCkge1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwMS5zdHlsZSA9PT0gXCJzdHJpbmdcIikgeyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcDEuc3R5bGU/LmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1yZWYtZWxlbWVudC5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQgfSBmcm9tIFwiLi91c2UtYWN0aXZlLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VIYXNGb2N1cyh7fSA9IHt9KSB7XG4gICAgLy9jb25zdCBbZm9jdXNlZEVsZW1lbnQsIHNldEZvY3VzZWRFbGVtZW50LCBnZXRGb2N1c2VkRWxlbWVudF0gPSB1c2VTdGF0ZTxFdmVudFRhcmdldCB8IG51bGw+KG51bGwpO1xuICAgIC8vY29uc3QgW2ZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vY29uc3QgW2ZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCB7IGVsZW1lbnQsIGdldEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xuICAgIGNvbnN0IHsgYWN0aXZlRWxlbWVudCwgbGFzdEFjdGl2ZUVsZW1lbnQgfSA9IHVzZUFjdGl2ZUVsZW1lbnQoKTtcbiAgICBjb25zdCB1c2VIYXNGb2N1c1Byb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzKSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBmb2N1c2VkID0gdXNlTWVtbygoKSA9PiB7IHJldHVybiBlbGVtZW50ID09IGFjdGl2ZUVsZW1lbnQ7IH0sIFtlbGVtZW50LCBhY3RpdmVFbGVtZW50XSk7XG4gICAgY29uc3QgZm9jdXNlZElubmVyID0gdXNlTWVtbygoKSA9PiB7IHJldHVybiBlbGVtZW50Py5jb250YWlucyhhY3RpdmVFbGVtZW50KSA/PyBmYWxzZTsgfSwgW2VsZW1lbnQsIGFjdGl2ZUVsZW1lbnRdKTtcbiAgICBjb25zdCBsYXN0Rm9jdXNlZCA9IHVzZU1lbW8oKCkgPT4geyByZXR1cm4gZWxlbWVudCA9PSBsYXN0QWN0aXZlRWxlbWVudDsgfSwgW2VsZW1lbnQsIGxhc3RBY3RpdmVFbGVtZW50XSk7XG4gICAgY29uc3QgbGFzdEZvY3VzZWRJbm5lciA9IHVzZU1lbW8oKCkgPT4geyByZXR1cm4gZWxlbWVudD8uY29udGFpbnMobGFzdEFjdGl2ZUVsZW1lbnQpID8/IGZhbHNlOyB9LCBbZWxlbWVudCwgbGFzdEFjdGl2ZUVsZW1lbnRdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VIYXNGb2N1c1Byb3BzLFxuICAgICAgICBmb2N1c2VkRWxlbWVudDogYWN0aXZlRWxlbWVudCxcbiAgICAgICAgbGFzdEZvY3VzZWRFbGVtZW50OiBsYXN0QWN0aXZlRWxlbWVudCxcbiAgICAgICAgZm9jdXNlZCxcbiAgICAgICAgZm9jdXNlZElubmVyLFxuICAgICAgICBsYXN0Rm9jdXNlZCxcbiAgICAgICAgbGFzdEZvY3VzZWRJbm5lclxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtaGFzLWZvY3VzLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5jb25zdCBUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLVwiO1xuZnVuY3Rpb24gYmFzZTY0KHZhbHVlKSB7XG4gICAgcmV0dXJuIFRhYmxlW3ZhbHVlXTtcbn1cbmZ1bmN0aW9uIHJhbmRvbTZCaXRzKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAwYjEwMDAwMDApO1xufVxuZnVuY3Rpb24gcmFuZG9tNjRCaXRzKCkge1xuICAgIHJldHVybiBbcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKV07XG59XG4vKipcbiAqIFJldHVybnMgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgd2l0aCBhbiBvcHRpb25hbCBwcmVmaXguXG4gKiBOb3RlIHRoYXQgaWYgdGhlIHByZWZpeCBpcyAqZXhwbGljaXRseSogc2V0IHRvIFwiXCIsIHRoZW5cbiAqIElEcyB0aGF0IGFyZSBub3QgdmFsaWQgdW5kZXIgSFRNTDQgbWF5IGJlIGdlbmVyYXRlZC4gT2ggbm8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeCkge1xuICAgIHJldHVybiBgJHtwcmVmaXggPz8gXCJpZC1cIn0ke3JhbmRvbTY0Qml0cygpLm1hcChuID0+IGJhc2U2NChuKSkuam9pbihcIlwiKX1gO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgaG9vayB0aGF0IG1vZGlmaWVzIGEgc2V0IG9mIHByb3BzIHRvIHByb3ZpZGUgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKlxuICogSWYgeW91J2QgbGlrZSB0byB1c2UgdGhlIElEIGluIGEgcHJvcGVydHkgdGhhdCdzICpub3QqIG5hbWVkIGBpZGAgKGxpa2UgYGZvcmAgb3IgYGFyaWEtbGFiZWxsZWRieWAgb3Igd2hhdG5vdCksIGB1c2VSZWZlcmVuY2VkSWRQcm9wc2AgaXMgYWxzbyBwcm92aWRlZC5cbiAqXG4gKiBBbmQgdGhlIHJhbmRvbWx5LWdlbmVyYXRlZCBpZCBpdHNlbGYgaXMgYWxzbyBwcm92aWRlZCBpbiBjYXNlIHlvdSB3YW50IHRvIGhhbmRsZSB0aGUgbG9naWMgeW91cnNlbGYgd2l0aG91dCBgdXNlTWVyZ2VkUHJvcHNgLlxuICpcbiAqIFVubGlrZSBtb3N0IG90aGVyIGB1c2UqUHJvcHNgIGhvb2tzLCB0aGVzZSBhcmUgbW9zdGx5IHN0YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJhbmRvbUlkKHsgcHJlZml4IH0gPSB7fSkge1xuICAgIGNvbnN0IFtyYW5kb21JZCwgc2V0UmFuZG9tSWRdID0gdXNlU3RhdGUoKCkgPT4gZ2VuZXJhdGVSYW5kb21JZChwcmVmaXgpKTtcbiAgICBjb25zdCBbd2F0Y2hQcmVmaXhVcGRhdGVzLCBzZXRXYXRjaFByZWZpeFVwZGF0ZXMsIGdldFdhdGNoUHJlZml4VXBkYXRlc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3Qgd2F0Y2hQcmVmaXhVcGRhdGVzID0gZ2V0V2F0Y2hQcmVmaXhVcGRhdGVzKCk7XG4gICAgICAgIGlmICh3YXRjaFByZWZpeFVwZGF0ZXMpXG4gICAgICAgICAgICBzZXRSYW5kb21JZCgoKSA9PiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeCkpO1xuICAgICAgICBzZXRXYXRjaFByZWZpeFVwZGF0ZXModHJ1ZSk7XG4gICAgfSwgW3ByZWZpeF0pO1xuICAgIC8vIFdoYXRldmVyIElEIHdhcyBtb3N0IHJlY2VudGx5IHVzZWQgYnkgdGhlIGFjdHVhbCBcImlkXCIgcHJvcC5cbiAgICAvLyBVc2VkIHNvIHRoYXQgYW55IElELXJlZmVyZW5jaW5nIHByb3BzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZS5cbiAgICAvL1xuICAgIC8vIFRPRE86IFRoaXMgZG9lcyBtZWFuIHRoYXQgb24gdGhlIGZpcnN0IHJlbmRlciwgaWYganVzdCB0aGUgSUQgaXMgcHJvdmlkZWQsXG4gICAgLy8gdGhlcmUgd2lsbCBiZSBhIHRlbXBvcmFyeSBtaXNtYXRjaCwgYnV0IGl0J3MgY29ycmVjdGVkIGJlZm9yZSByZW5kZXJpbmcgZmluaXNoZXMuXG4gICAgLy8gSXMgdGhpcyBva2F5P1xuICAgIGNvbnN0IFt1c2VkSWQsIHNldFVzZWRJZCwgZ2V0VXNlZElkXSA9IHVzZVN0YXRlKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgdXNlUmVmZXJlbmNlZElkUHJvcHMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VSZWZlcmVuY2VkSWRQcm9wcyhpZFByb3BOYW1lKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGZ1bmN0aW9uICh7IFtpZFByb3BOYW1lXTogZ2l2ZW5JZCwgLi4ucHJvcHMgfSkge1xuICAgICAgICAgICAgY29uc3QgdXNlZElkMiA9IChnaXZlbklkID8/IHVzZWRJZCA/PyByYW5kb21JZCA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgaWYgKGlkUHJvcE5hbWUgPT09IFwiaWRcIilcbiAgICAgICAgICAgICAgICBzZXRVc2VkSWQodXNlZElkMik7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IFtpZFByb3BOYW1lXTogdXNlZElkMiB9LCBwcm9wcyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSwgW3VzZWRJZCwgcmFuZG9tSWRdKTtcbiAgICBjb25zdCB1c2VSYW5kb21JZFByb3BzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlUmFuZG9tSWRQcm9wcyhwKSB7XG4gICAgICAgIHJldHVybiB1c2VSZWZlcmVuY2VkSWRQcm9wcyhcImlkXCIpKHApO1xuICAgIH0sIFt1c2VSZWZlcmVuY2VkSWRQcm9wc10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJhbmRvbUlkLFxuICAgICAgICBpZDogdXNlZElkLFxuICAgICAgICBnZXRJZDogZ2V0VXNlZElkLFxuICAgICAgICB1c2VSYW5kb21JZFByb3BzLFxuICAgICAgICB1c2VSZWZlcmVuY2VkSWRQcm9wc1xuICAgIH07XG59XG5mdW5jdGlvbiBhY2NlcHRzU3RyaW5nT3JDc3NPclVuZGVmaW5lZCh1KSB7IH1cbmZ1bmN0aW9uIGFjY2VwdHNTdHJpbmdPckNzcyhzdHIpIHsgfVxuZnVuY3Rpb24gYWNjZXB0c0Nzcyhwcm9wKSB7IH1cbmZ1bmN0aW9uIHRlc3QocHJvcHMpIHtcbiAgICBjb25zdCB7IGlkLCByYW5kb21JZCwgdXNlUmFuZG9tSWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHMgfSA9IHVzZVJhbmRvbUlkKCk7XG4gICAgLy9jb25zdCBwMWE6IE1lcmdlZFByb3BzPHsgaWQ6IHN0cmluZyB9LCB7ICB9PiA9IHVzZVJhbmRvbUlkUHJvcHMoeyBpZDogdW5kZWZpbmVkIH0pXG4gICAgY29uc3QgcDFiID0gdXNlUmFuZG9tSWRQcm9wcyh7IC4uLnByb3BzLCBpZDogdW5kZWZpbmVkIH0pO1xuICAgIGNvbnN0IHAyYSA9IHVzZVJlZmVyZW5jZWRJZFByb3BzKFwiZm9yXCIpKHsgaWQ6IHVuZGVmaW5lZCB9KTtcbiAgICBjb25zdCBwMmIgPSB1c2VSZWZlcmVuY2VkSWRQcm9wcyhcImZvclwiKSh7IC4uLnByb3BzLCBpZDogdW5kZWZpbmVkIH0pO1xuICAgIGNvbnN0IHAyYyA9IHVzZVJlZmVyZW5jZWRJZFByb3BzKFwiZm9yXCIpKHByb3BzKTtcbiAgICBjb25zdCBwM2EgPSB1c2VSYW5kb21JZFByb3BzKHVzZVJlZmVyZW5jZWRJZFByb3BzKFwiZm9yXCIpKHsgaWQ6IHVuZGVmaW5lZCB9KSk7XG4gICAgY29uc3QgcDNiID0gdXNlUmFuZG9tSWRQcm9wcyh1c2VSZWZlcmVuY2VkSWRQcm9wcyhcImZvclwiKSh7IC4uLnByb3BzLCBpZDogdW5kZWZpbmVkIH0pKTtcbiAgICBjb25zdCBwNGEgPSB1c2VSZWZlcmVuY2VkSWRQcm9wcyhcImZvclwiKSh1c2VSYW5kb21JZFByb3BzKHsgaWQ6IHVuZGVmaW5lZCB9KSk7XG4gICAgY29uc3QgcDRiID0gdXNlUmVmZXJlbmNlZElkUHJvcHMoXCJmb3JcIikocDFiKTtcbiAgICAvL3AxYS5pZDtcbiAgICBwMWIuaWQ7XG4gICAgcDJhW1wiZm9yXCJdO1xuICAgIHAyYltcImZvclwiXTtcbiAgICBwMmNbXCJmb3JcIl07XG4gICAgcDNhLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcDNiLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcDNhW1wiZm9yXCJdPy5jb25jYXQoXCJcIik7XG4gICAgcDNiW1wiZm9yXCJdPy5jb25jYXQoXCJcIik7XG4gICAgcDRhW1wiZm9yXCJdPy5jb25jYXQoXCJcIik7XG4gICAgcDRiW1wiZm9yXCJdPy5jb25jYXQoXCJcIik7XG4gICAgcDRhLmlkPy5jb25jYXQoXCJcIik7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogSXQncyBiZWNhdXNlIGl0IHJlc29sdmVzIHRvIFwiaWQ6IHVuZGVmaW5lZCAmIHN0cmluZ1wiIC0tIHRoaXMgc2hvdWxkbid0IGhhcHBlblxuICAgIHA0Yi5pZD8uY29uY2F0KFwiXCIpO1xuICAgIGFjY2VwdHNTdHJpbmdPckNzc09yVW5kZWZpbmVkKHAxYi5zdHlsZSk7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBhY2NlcHRzU3RyaW5nT3JDc3MocDFiLnN0eWxlKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHAyYS5zdHlsZT8uYmFja2dyb3VuZENvbG9yO1xuICAgIGFjY2VwdHNTdHJpbmdPckNzc09yVW5kZWZpbmVkKHAyYi5zdHlsZSk7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBhY2NlcHRzU3RyaW5nT3JDc3MocDJiLnN0eWxlKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHAzYS5zdHlsZT8uYmFja2dyb3VuZENvbG9yO1xuICAgIGFjY2VwdHNTdHJpbmdPckNzc09yVW5kZWZpbmVkKHAzYi5zdHlsZSk7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBwNGEuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuICAgIGFjY2VwdHNTdHJpbmdPckNzc09yVW5kZWZpbmVkKHA0Yi5zdHlsZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtcmFuZG9tLWlkLmpzLm1hcCIsImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5leHBvcnQgZnVuY3Rpb24gdXNlRWxlbWVudFNpemUoeyBvYnNlcnZlQm94IH0gPSB7fSkge1xuICAgIGNvbnN0IHsgZWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XG4gICAgY29uc3QgW3NpemUsIHNldFNpemUsIGdldFNpemVdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBzY3JvbGxXaWR0aCwgb2Zmc2V0V2lkdGgsIGNsaWVudEhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBvZmZzZXRIZWlnaHQsIGNsaWVudExlZnQsIHNjcm9sbExlZnQsIG9mZnNldExlZnQsIGNsaWVudFRvcCwgc2Nyb2xsVG9wLCBvZmZzZXRUb3AgfSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgc2V0U2l6ZSh7IGNsaWVudFdpZHRoLCBzY3JvbGxXaWR0aCwgb2Zmc2V0V2lkdGgsIGNsaWVudEhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBvZmZzZXRIZWlnaHQsIGNsaWVudExlZnQsIHNjcm9sbExlZnQsIG9mZnNldExlZnQsIGNsaWVudFRvcCwgc2Nyb2xsVG9wLCBvZmZzZXRUb3AgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCEoXCJSZXNpemVPYnNlcnZlclwiIGluIHdpbmRvdykpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVVwZGF0ZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4geyBoYW5kbGVVcGRhdGUoKTsgfSk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGJveDogb2JzZXJ2ZUJveCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2VsZW1lbnQsIG9ic2VydmVCb3hdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBlbGVtZW50U2l6ZTogc2l6ZSxcbiAgICAgICAgZ2V0RWxlbWVudFNpemU6IGdldFNpemUsXG4gICAgICAgIHVzZUVsZW1lbnRTaXplUHJvcHM6IHVzZVJlZkVsZW1lbnRQcm9wc1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtZWxlbWVudC1zaXplLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICAgIHJldHVybiAoc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyKDEpKTtcbn1cbi8qKlxuICogSW5zcGVjdHMgdGhlIGVsZW1lbnQncyBzdHlsZSBhbmQgZGV0ZXJtaW5lcyB0aGUgbG9naWNhbCBkaXJlY3Rpb24gdGhhdCB0ZXh0IGZsb3dzLlxuICpcbiAqIENlcnRhaW4gQ1NTIHByb3BlcnRpZXMsIGxpa2UgYGJsb2NrLXNpemVgLCByZXNwZWN0IHRoZSBjdXJyZW50IHdyaXRpbmcgbW9kZSBhbmQgdGV4dCBkaXJlY3Rpb24uXG4gKiBCdXQgYHRyYW5zZm9ybWAsIGBjbGlwYCwgZXRjLiBkb24ndC5cbiAqXG4gKiBUaGlzIGlzIHByb3ZpZGVkIHNvIHRoYXQgQ1NTIHByb3BlcnRpZXMgY2FuIGNvbnNpc3RlbnRseSB1c2UgdGhvc2UgbG9naWNhbCBwcm9wZXJ0aWVzLlxuICpcbiAqIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXdyaXRpbmctbW9kZXMvI2xvZ2ljYWwtdG8tcGh5c2ljYWxcbiAqXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAqICogYGdldExvZ2ljYWxEaXJlY3Rpb25gOiByZXRyaWV2ZXMgYSBgTG9naWNhbERpcmVjdGlvbkluZm9gIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudC4gKEZ1bmN0aW9uIGlzIGNvbnN0YW50IGJldHdlZW4gcmVuZGVycylcbiAqICogYGNvbnZlcnRFbGVtZW50U2l6ZWA6IFdoZW4gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGB1c2VFbGVtZW50U2l6ZWAsIGFsbG93cyB5b3UgdG8gcmV0cmlldmUgdGhlIGxvZ2ljYWwgc2l6ZSBvZiBhbiBlbGVtZW50IGluc3RlYWQgb2YgdGhlIHBoeXNpY2FsIHNpemUuXG4gKiAqIGBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb25gOiBCYXNlZCBvbiB0aGUgY3VycmVudCBkaXJlY3Rpb24sIGNvbnZlcnRzIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIiB0byBcImlubGluZVwiIG9yIFwiYmxvY2tcIi5cbiAqICogYGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb25gOiAgQmFzZWQgb24gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBjb252ZXJ0cyBcImlubGluZVwiIG9yIFwiYmxvY2tcIiB0byBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2dpY2FsRGlyZWN0aW9uKGVsZW1lbnQpIHtcbiAgICBjb25zdCBbd3JpdGluZ01vZGUsIHNldFdyaXRpbmdNb2RlXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtkaXJlY3Rpb24sIHNldERpcmVjdGlvbl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbdGV4dE9yaWVudGF0aW9uLCBzZXRUZXh0T3JpZW50YXRpb25dID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3Qgd3JpdGluZ01vZGVSZWYgPSB1c2VSZWYod3JpdGluZ01vZGUpO1xuICAgIGNvbnN0IGRpcmVjdGlvblJlZiA9IHVzZVJlZihkaXJlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRPcmllbnRhdGlvblJlZiA9IHVzZVJlZih0ZXh0T3JpZW50YXRpb24pO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHdyaXRpbmdNb2RlUmVmLmN1cnJlbnQgPSB3cml0aW5nTW9kZTsgfSwgW3dyaXRpbmdNb2RlXSk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgZGlyZWN0aW9uUmVmLmN1cnJlbnQgPSBkaXJlY3Rpb247IH0sIFtkaXJlY3Rpb25dKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyB0ZXh0T3JpZW50YXRpb25SZWYuY3VycmVudCA9IHRleHRPcmllbnRhdGlvbjsgfSwgW3RleHRPcmllbnRhdGlvbl0pO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgdyA9IGNvbXB1dGVkU3R5bGVzLndyaXRpbmdNb2RlO1xuICAgICAgICAgICAgY29uc3QgdCA9IGNvbXB1dGVkU3R5bGVzLnRleHRPcmllbnRhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBjb21wdXRlZFN0eWxlcy5kaXJlY3Rpb247XG4gICAgICAgICAgICBzZXRXcml0aW5nTW9kZSh3IHx8IFwiaG9yaXpvbnRhbC10YlwiKTtcbiAgICAgICAgICAgIHNldERpcmVjdGlvbihkIHx8IFwicnRsXCIpO1xuICAgICAgICAgICAgc2V0VGV4dE9yaWVudGF0aW9uKHQgfHwgXCJtaXhlZFwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdldExvZ2ljYWxEaXJlY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGxldCB3cml0aW5nTW9kZSA9IHdyaXRpbmdNb2RlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSBkaXJlY3Rpb25SZWYuY3VycmVudDtcbiAgICAgICAgbGV0IHRleHRPcmllbnRhdGlvbiA9IHRleHRPcmllbnRhdGlvblJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXdyaXRpbmdNb2RlIHx8ICFkaXJlY3Rpb24gfHwgIXRleHRPcmllbnRhdGlvbilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGV4dE9yaWVudGF0aW9uID09IFwidXByaWdodFwiKVxuICAgICAgICAgICAgZGlyZWN0aW9uID0gXCJsdHJcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLldyaXRpbmdNb2Rlc1t3cml0aW5nTW9kZSA/PyBcImhvcml6b250YWwtdGJcIl1bZGlyZWN0aW9uID8/IFwibHRyXCJdXG4gICAgICAgIH07XG4gICAgfSwgW3dyaXRpbmdNb2RlUmVmLCBkaXJlY3Rpb25SZWYsIHRleHRPcmllbnRhdGlvblJlZl0pO1xuICAgIGNvbnN0IGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbiA9IHVzZUNhbGxiYWNrKChlbGVtZW50T3JpZW50YXRpb24sIGRpcmVjdGlvbikgPT4ge1xuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT09IGVsZW1lbnRPcmllbnRhdGlvbilcbiAgICAgICAgICAgIHJldHVybiBcImlubGluZVwiO1xuICAgICAgICByZXR1cm4gXCJibG9ja1wiO1xuICAgIH0sIFtnZXRMb2dpY2FsRGlyZWN0aW9uXSk7XG4gICAgY29uc3QgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbiA9IHVzZUNhbGxiYWNrKChlbGVtZW50T3JpZW50YXRpb24sIGRpcmVjdGlvbikgPT4ge1xuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKGVsZW1lbnRPcmllbnRhdGlvbiA9PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PSBcImhvcml6b250YWxcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbj8uYmxvY2tPcmllbnRhdGlvbiA9PSBcInZlcnRpY2FsXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcbiAgICAgICAgICAgIHJldHVybiBcImhvcml6b250YWxcIjtcbiAgICAgICAgfVxuICAgIH0sIFtnZXRMb2dpY2FsRGlyZWN0aW9uXSk7XG4gICAgY29uc3QgY29udmVydEVsZW1lbnRTaXplID0gdXNlQ2FsbGJhY2soKGVsZW1lbnRTaXplLCBkaXJlY3Rpb24pID0+IHtcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uKCk7XG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5saW5lU2l6ZSwgYmxvY2tTaXplLCBpbmxpbmVEaXJlY3Rpb24sIGJsb2NrRGlyZWN0aW9uIH0gPSBkaXJlY3Rpb247XG4gICAgICAgICAgICAvLyBTaXplIGlzIHJlbGF0aXZlbHkgc2ltcGxlXG4gICAgICAgICAgICBsZXQgY2xpZW50SW5saW5lU2l6ZSA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoaW5saW5lU2l6ZSl9YF07XG4gICAgICAgICAgICBsZXQgY2xpZW50QmxvY2tTaXplID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShibG9ja1NpemUpfWBdO1xuICAgICAgICAgICAgbGV0IG9mZnNldElubGluZVNpemUgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGlubGluZVNpemUpfWBdO1xuICAgICAgICAgICAgbGV0IG9mZnNldEJsb2NrU2l6ZSA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoYmxvY2tTaXplKX1gXTtcbiAgICAgICAgICAgIGxldCBzY3JvbGxJbmxpbmVTaXplID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShpbmxpbmVTaXplKX1gXTtcbiAgICAgICAgICAgIGxldCBzY3JvbGxCbG9ja1NpemUgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGJsb2NrU2l6ZSl9YF07XG4gICAgICAgICAgICAvLyBQb3NpdGlvbiByZXF1aXJlcyB1cyB0byBzb21ldGltZXMgdXNlIG9uZSBwcm9wZXJ0eSAobGlrZSBgbGVmdGApXG4gICAgICAgICAgICAvLyBvciBzb21ldGltZXMgdHdvIChsaWtlIGBsZWZ0YCArIGB3aWR0aGApXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRQaHlzaWNhbExlZnRUb3AoZGlyKSB7IGlmIChkaXIgPT09IFwibHRyXCIgfHwgZGlyID09IFwicnRsXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibGVmdFwiOyByZXR1cm4gXCJ0b3BcIjsgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShkaXIpIHsgaWYgKGRpciA9PT0gXCJydGxcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ3aWR0aFwiOyBpZiAoZGlyID09PSBcImJ0dFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImhlaWdodFwiOyByZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgY29uc3QgZjEgPSBnZXRQaHlzaWNhbExlZnRUb3AoaW5saW5lRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGYyID0gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShpbmxpbmVEaXJlY3Rpb24pO1xuICAgICAgICAgICAgY29uc3QgZjMgPSBnZXRQaHlzaWNhbExlZnRUb3AoYmxvY2tEaXJlY3Rpb24pO1xuICAgICAgICAgICAgY29uc3QgZjQgPSBnZXRQaHlzaWNhbFJpZ2h0Qm90dG9tKGJsb2NrRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGxldCBjbGllbnRJbmxpbmVJbnNldCA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjEpfWBdICsgKCFmMiA/IDAgOiBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGYyKX1gXSk7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsSW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGYxKX1gXSArICghZjIgPyAwIDogZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMil9YF0pO1xuICAgICAgICAgICAgbGV0IG9mZnNldElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMSl9YF0gKyAoIWYyID8gMCA6IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjIpfWBdKTtcbiAgICAgICAgICAgIGxldCBjbGllbnRCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmMyl9YF0gKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjQpfWBdKTtcbiAgICAgICAgICAgIGxldCBzY3JvbGxCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMyl9YF0gKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjQpfWBdKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMyl9YF0gKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjQpfWBdKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2xpZW50SW5saW5lU2l6ZSxcbiAgICAgICAgICAgICAgICBzY3JvbGxJbmxpbmVTaXplLFxuICAgICAgICAgICAgICAgIG9mZnNldElubGluZVNpemUsXG4gICAgICAgICAgICAgICAgY2xpZW50QmxvY2tTaXplLFxuICAgICAgICAgICAgICAgIHNjcm9sbEJsb2NrU2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRCbG9ja1NpemUsXG4gICAgICAgICAgICAgICAgY2xpZW50SW5saW5lSW5zZXQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW5saW5lSW5zZXQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0SW5saW5lSW5zZXQsXG4gICAgICAgICAgICAgICAgY2xpZW50QmxvY2tJbnNldCxcbiAgICAgICAgICAgICAgICBzY3JvbGxCbG9ja0luc2V0LFxuICAgICAgICAgICAgICAgIG9mZnNldEJsb2NrSW5zZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIFtnZXRMb2dpY2FsRGlyZWN0aW9uXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0TG9naWNhbERpcmVjdGlvbixcbiAgICAgICAgY29udmVydEVsZW1lbnRTaXplLFxuICAgICAgICBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb24sXG4gICAgICAgIGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb25cbiAgICB9O1xufVxuO1xuY29uc3QgSG9yaXpvbnRhbFRiTHRyID0ge1xuICAgIGlubGluZURpcmVjdGlvbjogXCJsdHJcIixcbiAgICBibG9ja0RpcmVjdGlvbjogXCJ0dGJcIixcbiAgICBpbmxpbmVPcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG4gICAgYmxvY2tPcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLFxuICAgIGlubGluZVNpemU6IFwid2lkdGhcIixcbiAgICBibG9ja1NpemU6IFwiaGVpZ2h0XCIsXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcImx0clwiLFxuICAgIG92ZXJVbmRlckRpcmVjdGlvbjogXCJ0dGJcIlxufTtcbmNvbnN0IEhvcml6b250YWxUYlJ0bCA9IHtcbiAgICAuLi5Ib3Jpem9udGFsVGJMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInJ0bFwiLFxufTtcbmNvbnN0IFZlcnRpY2FsUmxMdHIgPSB7XG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiLFxuICAgIGJsb2NrRGlyZWN0aW9uOiBcInJ0bFwiLFxuICAgIGlubGluZU9yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXG4gICAgYmxvY2tPcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG4gICAgaW5saW5lU2l6ZTogXCJoZWlnaHRcIixcbiAgICBibG9ja1NpemU6IFwid2lkdGhcIixcbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwidHRiXCIsXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcInJ0bFwiXG59O1xuY29uc3QgVmVydGljYWxSbFJ0bCA9IHtcbiAgICAuLi5WZXJ0aWNhbFJsTHRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIlxufTtcbmNvbnN0IFNpZGV3YXlzUmxMdHIgPSB7IC4uLlZlcnRpY2FsUmxMdHIgfTtcbmNvbnN0IFNpZGV3YXlzUmxSdGwgPSB7IC4uLlZlcnRpY2FsUmxSdGwgfTtcbmNvbnN0IFZlcnRpY2FsTHJMdHIgPSB7XG4gICAgLi4uVmVydGljYWxSbEx0cixcbiAgICBibG9ja0RpcmVjdGlvbjogXCJsdHJcIixcbn07XG5jb25zdCBWZXJ0aWNhbExyUnRsID0ge1xuICAgIC4uLlZlcnRpY2FsUmxSdGwsXG4gICAgYmxvY2tEaXJlY3Rpb246IFwibHRyXCIsXG59O1xuY29uc3QgU2lkZXdheXNMdEx0ciA9IHtcbiAgICAuLi5WZXJ0aWNhbExyTHRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIixcbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwiYnR0XCIsXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcImx0clwiXG59O1xuY29uc3QgU2lkZXdheXNMdFJ0bCA9IHtcbiAgICAuLi5TaWRld2F5c0x0THRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJ0dGJcIlxufTtcbmNvbnN0IEhvcml6b250YWxUYiA9IHtcbiAgICBsdHI6IEhvcml6b250YWxUYkx0cixcbiAgICBydGw6IEhvcml6b250YWxUYlJ0bFxufTtcbmNvbnN0IFZlcnRpY2FsUmwgPSB7XG4gICAgbHRyOiBWZXJ0aWNhbFJsTHRyLFxuICAgIHJ0bDogVmVydGljYWxSbFJ0bFxufTtcbmNvbnN0IFZlcnRpY2FsTHIgPSB7XG4gICAgbHRyOiBWZXJ0aWNhbExyTHRyLFxuICAgIHJ0bDogVmVydGljYWxMclJ0bFxufTtcbmNvbnN0IFNpZGV3YXlzUmwgPSB7XG4gICAgbHRyOiBTaWRld2F5c1JsTHRyLFxuICAgIHJ0bDogU2lkZXdheXNSbFJ0bFxufTtcbmNvbnN0IFNpZGV3YXlzTHIgPSB7XG4gICAgbHRyOiBTaWRld2F5c0x0THRyLFxuICAgIHJ0bDogU2lkZXdheXNMdFJ0bFxufTtcbmNvbnN0IFdyaXRpbmdNb2RlcyA9IHtcbiAgICBcImhvcml6b250YWwtdGJcIjogSG9yaXpvbnRhbFRiLFxuICAgIFwidmVydGljYWwtbHJcIjogVmVydGljYWxMcixcbiAgICBcInZlcnRpY2FsLXJsXCI6IFZlcnRpY2FsUmwsXG4gICAgXCJzaWRld2F5cy1sclwiOiBTaWRld2F5c0xyLFxuICAgIFwic2lkZXdheXMtcmxcIjogU2lkZXdheXNSbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1sb2dpY2FsLWRpcmVjdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyB1c2VSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCB2YWx1ZSwgcmV0dXJucyBhIGNvbnN0YW50IGdldHRlciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gKlxuICogVXNlIHdpdGggY2F1dGlvbiwgYW5kICoqZG8gbm90IHVzZSB0aGUgZ2V0dGVyIGluIHVzZUxheW91dEVmZmVjdCEhKipcbiAqIGBzZXRTdGF0ZWAncyBnZXR0ZXIgZG9lcyBub3QgaGF2ZSB0aGlzIHByb2JsZW0sIGJ1dCB0aGVuIHlvdSdyZSB1c2luZyB5b3VyIG93biBzdGF0ZVxuICogaW5zdGVhZCBvZiBhbiBleGlzdGluZyB2YWx1ZSwgd2hpY2ggbWlnaHQgbm90IGFsd2F5cyBiZSBmZWFzaWJsZS5cbiAqXG4gKiBXZWlnaCB5b3VyIG9wdGlvbnMsIGFuZCBob3BlZnVsbHkgb25lIG9mIHRoZW0gZ2V0cyB0aGUgam9iIGRvbmUuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlR2V0dGVyKHZhbHVlKSB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKHZhbHVlKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gdmFsdWUpO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiByZWYuY3VycmVudDsgfSwgW10pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXN0YWJsZS1nZXR0ZXIuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuLyoqXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXG4gKiBzbyB0aGF0IGl0IGNhbiBiZSBleGNsdWRlZCBmcm9tIHRoZSBkZXBlbmRlbmN5IGFycmF5cyBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcy5cbiAqXG4gKiBETyBOT1QgVVNFIFRIRSBSRVNVTFQgSU4gdXNlTGF5b3V0RWZmZWN0ISFcbiAqXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSBvcHRpb25zLmRpZmZlZCBpZiB0aGUgdXNlTGF5b3V0RWZmZWN0IGxpbWl0YXRpb24gYmVjb21lcyBsaW1pdGxlc3NseSBsaW1pdGluZy5cbiAqXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQwOTkjaXNzdWVjb21tZW50LTY1OTI5ODQyMlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlQ2FsbGJhY2soZm4pIHtcbiAgICBjb25zdCBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIgPSB1c2VTdGFibGVHZXR0ZXIoZm4pO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50RnVuYyA9IGN1cnJlbnRDYWxsYmFja0dldHRlcigpO1xuICAgICAgICBpZiAoIWN1cnJlbnRGdW5jKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrKCkgY2Fubm90IGJlIGNhbGxlZCBmcm9tIHVzZUxheW91dEVmZmVjdCgpLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50RnVuYyguLi5hcmdzKTtcbiAgICB9LCBbXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2Utc3RhYmxlLWNhbGxiYWNrLmpzLm1hcCIsImltcG9ydCB7IHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3ROYXRpdmUsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbi8qKlxuICogV3JhcCB0aGUgbmF0aXZlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGFkZCBhcmd1bWVudHNcbiAqIHRoYXQgYWxsb3cgYWNjZXNzaW5nIHRoZSBwcmV2aW91cyB2YWx1ZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhcyB3ZWxsIGFzIHRoZSBjaGFuZ2VzIHRoYXQgY2F1c2VkIHRoZSBob29rIHRvIGJlIGNhbGxlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSBlZmZlY3RcbiAqIEBwYXJhbSBpbnB1dHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChlZmZlY3QsIGlucHV0cykge1xuICAgIGNvbnN0IHByZXZJbnB1dHMgPSB1c2VSZWYoaW5wdXRzKTtcbiAgICBjb25zdCBlZmZlY3QyID0gKCkgPT4ge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHByZXZJbnB1dHMuY3VycmVudC5sZW5ndGgsIGlucHV0cy5sZW5ndGgpOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwcmV2SW5wdXRzLmN1cnJlbnRbaV0gIT0gaW5wdXRzW2ldKVxuICAgICAgICAgICAgICAgIGNoYW5nZXNbaV0gPSB7IGZyb206IHByZXZJbnB1dHMuY3VycmVudFtpXSwgdG86IGlucHV0c1tpXSB9O1xuICAgICAgICB9XG4gICAgICAgIGVmZmVjdChwcmV2SW5wdXRzLmN1cnJlbnQsIGNoYW5nZXMpO1xuICAgICAgICBwcmV2SW5wdXRzLmN1cnJlbnQgPSBpbnB1dHM7XG4gICAgfTtcbiAgICB1c2VMYXlvdXRFZmZlY3ROYXRpdmUoZWZmZWN0MiwgaW5wdXRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1sYXlvdXQtZWZmZWN0LmpzLm1hcCIsImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VUaW1lb3V0KHsgdGltZW91dCwgY2FsbGJhY2ssIHRyaWdnZXJJbmRleCB9KSB7XG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgY29uc3QgZ2V0VGltZW91dCA9IHVzZVN0YWJsZUdldHRlcih0aW1lb3V0KTtcbiAgICBjb25zdCB0aW1lb3V0SXNOdWxsID0gKHRpbWVvdXQgPT0gbnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGltZW91dElzTnVsbCA9PSAodGltZW91dCA9PSBudWxsKSk7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KHN0YWJsZUNhbGxiYWNrLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH0sIFt0cmlnZ2VySW5kZXgsIHRpbWVvdXRJc051bGxdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS10aW1lb3V0LmpzLm1hcCIsImltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VUaW1lb3V0IH0gZnJvbSBcIi4vdXNlLXRpbWVvdXRcIjtcbi8qKlxuICogR2l2ZW4gYW4gYXN5bmNyb25vdXMgZXZlbnQgaGFuZGxlciwgcmV0dXJucyBhIHN5bmNyb25vdXMgb25lIHRoYXQgd29ya3Mgb24gdGhlIERPTSxcbiAqIGFsb25nIHdpdGggc29tZSBvdGhlciBpbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoZSBjdXJyZW50IHN0YXRlLlxuICogRG9lcyBub3QgbW9kaWZ5IGFueSBwcm9wcy5cbiAqXG4gKiBUaGUgaGFuZGxlciBpcyBhdXRvbWF0aWNhbGx5IHRocm90dGxlZCB0byBvbmx5IHJ1biBvbmUgYXQgYSB0aW1lLlxuICogSWYgdGhlIGhhbmRsZXIgaXMgY2FsbGVkLCBhbmQgdGhlbiBiZWZvcmUgaXQgZmluaXNoZXMsIGlzIGNhbGxlZCBhZ2FpbixcbiAqIGl0IHdpbGwgYmUgcHV0IG9uIGhvbGQgdW50aWwgdGhlIGN1cnJlbnQgb25lIGZpbmlzaGVzLCBhdCB3aGljaCBwb2ludFxuICogdGhlIHNlY29uZCBvbmUgd2lsbCBydW4uICBJZiB0aGUgaGFuZGxlciBpcyBjYWxsZWQgYSB0aGlyZCB0aW1lIGJlZm9yZVxuICogdGhlIGZpcnN0IGhhcyBmaW5pc2hlZCwgaXQgd2lsbCAqcmVwbGFjZSogdGhlIHNlY29uZCwgc28gb25seSB0aGUgbW9zdFxuICogcmVjZW50bHkgY2FsbGVkIGl0ZXJhdGlvbiBvZiB0aGUgaGFuZGxlciB3aWxsIHJ1bi5cbiAqXG4gKiBZb3UgbWF5IG9wdGlvbmFsbHkgKmFsc28qIHNwZWNpZnkgYSBkZWJvdW5jZSBwYXJhbWV0ZXIgdGhhdCB3YWl0cyB1bnRpbCB0aGVcbiAqIHN5bmNyb25vdXMgaGFuZGxlciBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciB0aGUgc3BlY2lmaWVkIG51bWJlciBvZlxuICogbWlsbGlzZWNvbmRzLCBhdCB3aGljaCBwb2ludCB3ZSAqYWN0dWFsbHkqIHJ1biB0aGUgYXN5bmNyb25vdXMgaGFuZGxlclxuICogYWNjb3JkaW5nIHRvIHRoZSBsb2dpYyBpbiB0aGUgcHJldmlvdXMgcGFyYWdyYXBoLiBUaGlzIGlzIGluXG4gKiAqYWRkaXRpb24qIHRvIHRocm90dGxpbmcgdGhlIGhhbmRsZXIsIGFuZCBkb2VzIG5vdCByZXBsYWNlIHRoYXQgYmVoYXZpb3IuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBwYXJhbWV0ZXJzIHRvIHRoZSBhc3luYyBoYW5kbGVyIGFyZSBzbGlnaHRseSBkaWZmZXJlbnQgdGhhblxuICogdGhlIHN5bmMgaGFuZGxlciAmbmRhc2g7IHRoZSBmaXJzdCBhcmd1bWVudCwgYXMgZGVjaWRlZCBieSB5b3Ugd2l0aCB0aGVcbiAqIGBjYXB0dXJlYCBwYXJhbWV0ZXIgZm9yIHRoaXMgaG9vaywgaXMgdGhlIFwic2F2ZWRcIiBpbmZvcm1hdGlvbiBmcm9tIHRoZVxuICogZXZlbnQuICBGb3IgZXhhbXBsZSwgdGhlIGV2ZW50J3MgY3VycmVudFRhcmdldCdzIGB2YWx1ZWAsIHdoaWNoIG1heSBoYXZlXG4gKiBjaGFuZ2VkIGJ5IHRoZSB0aW1lIHRoZSBoYW5kbGVyIGlzICphY3R1YWxseSogY2FsbGVkLiAgVGhlIHNlY29uZCBhcmd1bWVudFxuICogaXMgdGhlIG9yaWdpbmFsIGV2ZW50LCB3aGljaCBtaWdodCBzdGlsbCBoYXZlIHNvbWUgdXNlZnVsIGZpZWxkcyBvbiBpdFxuICogbGlrZSBgbW91c2VYYCBvciBzb21ldGhpbmcsIGJ1dCBpcyBzdGFsZSBhdCBsZWFzdCBpbiByZWdhcmRzIHRvIHRoZVxuICogZWxlbWVudCBpdCByZWZlcmVuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmNIYW5kbGVyKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeyBjYXB0dXJlLCBkZWJvdW5jZSB9KSB7XG4gICAgICAgIC8vIEFsd2F5cyByZXByZXNlbnRzIHdoYXRldmVyIHByb21pc2UgaXMgY3VycmVudGx5IGJlaW5nIHdhaXRlZCBvbiwgb3IgbnVsbCBpZiBub25lLlxuICAgICAgICBjb25zdCBbcHJvbWlzZSwgc2V0UHJvbWlzZSwgZ2V0UHJvbWlzZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBob3cgbWFueSB0aW1lcyB3ZSd2ZSBhY3R1YWxseSBjYWxsZWQgdGhlIGFzeW5jIGhhbmRsZXJcbiAgICAgICAgY29uc3QgW3J1bkNvdW50LCBzZXRSdW5Db3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAgICAgICAgY29uc3QgW3Jlc29sdmVDb3VudCwgc2V0UmVzb2x2ZUNvdW50XSA9IHVzZVN0YXRlKDApO1xuICAgICAgICBjb25zdCBbcmVqZWN0Q291bnQsIHNldFJlamVjdENvdW50XSA9IHVzZVN0YXRlKDApO1xuICAgICAgICAvLyBJZiB3ZSdyZSBzZXQgdG8gdXNlIGEgZGVib3VuY2UsIHRoZW4gd2hlbiB0aGUgdGltZW91dCBmaW5pc2hlcyxcbiAgICAgICAgLy8gdGhlIHByb21pc2UgZnJvbSB0aGlzIHN0YXRlIG9iamVjdCBpcyB0cmFuc2ZlcnJlZCBvdmVyIHRvIGVpdGhlciBcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgcHJvbWlzZSBvciB0aGUgcGVuZGluZyBwcm9taXNlLlxuICAgICAgICBjb25zdCBbZGVib3VuY2VkUHJvbWlzZVN0YXJ0ZXIsIHNldERlYm91bmNlZFByb21pc2VTdGFydGVyLCBnZXREZWJvdW5jZWRQcm9taXNlU3RhcnRlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICAgICAgLy8gV2hlbiB3ZSB3YW50IHRvIHN0YXJ0IGEgbmV3IHByb21pc2UsIHdlIHdvbid0IGFsbG93IGl0IHRvIHN0YXJ0IGlmIG9uZSBpcyBzdGlsbCBydW5uaW5nLlxuICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIHN0b3JlIHRoZSBwcm9taXNlIChvciByYXRoZXIsIGEgd2F5IHRvIHN0YXJ0IHRoZSBwcm9taXNlKSBpbiBzdGF0ZS5cbiAgICAgICAgY29uc3QgW3BlbmRpbmdQcm9taXNlU3RhcnRlciwgc2V0UGVuZGluZ1Byb21pc2VTdGFydGVyLCBnZXRQZW5kaW5nUHJvbWlzZVN0YXJ0ZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGB1bmRlZmluZWRgIGFuZCBcIm5vIGVycm9yIGhhcyBiZWVuIHRocm93blwiLlxuICAgICAgICAvLyBXZSBjb3VsZCBhbHNvIGtlZXAgYSBzZXBhcmF0ZSBib29sZWFuIHN0YXRlIHRvIHRyYWNrIHRoYXQuXG4gICAgICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3IsIGdldEVycm9yXSA9IHVzZVN0YXRlKHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IFtoYXNFcnJvciwgc2V0SGFzRXJyb3IsIGdldEhhc0Vycm9yXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAgICAgY29uc3QgW2N1cnJlbnRDYXB0dXJlLCBzZXRDdXJyZW50Q2FwdHVyZSwgZ2V0Q3VycmVudENhcHR1cmVdID0gdXNlU3RhdGUodW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgW2hhc0NhcHR1cmUsIHNldEhhc0NhcHR1cmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgICAgICAvLyBIYW5kbGUgdGhlIGRlYm91bmNlLiBMb2dpY2FsbHkgdGhpcyBoYXBwZW5zIGJlZm9yZSB0aGUgbWFpbiBzdGVwIGFzIGEgc29ydCBvZiBzdGVwIDAuXG4gICAgICAgIC8vIFJlc2V0cyB0aGUgdGltZW91dCBhbnkgdGltZSB0aGUgaGFuZGxlciB3YXMgcmVxdWVzdGVkIHRvIGJlIGNhbGxlZCBhZ2FpblxuICAgICAgICAvLyBhbmQgd2hlbiBpdCBmaW5pc2hlcywgYWN0dWFsbHkgY2FsbCB0aGUgaGFuZGxlciAob3Igc2V0IGl0IGFzIHRoZSBwZW5kaW5nIHByb21pc2UpXG4gICAgICAgIHVzZVRpbWVvdXQoe1xuICAgICAgICAgICAgdGltZW91dDogZGVib3VuY2UgPz8gbnVsbCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRlYm91bmNlZFByb21pc2VTdGFydGVyKVxuICAgICAgICAgICAgICAgICAgICB3YW50VG9TdGFydEFOZXdQcm9taXNlKGRlYm91bmNlZFByb21pc2VTdGFydGVyKTtcbiAgICAgICAgICAgICAgICBzZXREZWJvdW5jZWRQcm9taXNlU3RhcnRlcihudWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmlnZ2VySW5kZXg6IGRlYm91bmNlZFByb21pc2VTdGFydGVyXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZWUgaWYgd2Ugc2hvdWxkIHNldCBvdXIgY3VycmVudCBwcm9taXNlIHRvIGJlIHdoYXRldmVyIHRoZSBwZW5kaW5nIHByb21pc2UgaXNcbiAgICAgICAgLy8gKHVzdWFsbHkgYmVjYXVzZSB0aGUgY3VycmVudCBwcm9taXNlIGZpbmlzaGVkIGFuZCBiZWNhbWUgbnVsbCkuXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBPdXIgY3VycmVudCBwcm9taXNlIGp1c3QgZmluaXNoZWQgYW5kIHRoZXJlJ3Mgb25lIHdhaXRpbmc/XG4gICAgICAgICAgICBpZiAocHJvbWlzZSA9PSBudWxsICYmIHBlbmRpbmdQcm9taXNlU3RhcnRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd2FudFRvU3RhcnRBTmV3UHJvbWlzZShwZW5kaW5nUHJvbWlzZVN0YXJ0ZXIpO1xuICAgICAgICAgICAgICAgIHNldFBlbmRpbmdQcm9taXNlU3RhcnRlcihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3Byb21pc2UsIHBlbmRpbmdQcm9taXNlU3RhcnRlcl0pO1xuICAgICAgICAvLyBDYWxsZWQgYW55IHRpbWUgdGhlIGFzeW5jIGhhbmRsZXIgaXMgYWJvdXQgdG8gYmUgY2FsbGVkIGZvciB3aGF0ZXZlciByZWFzb24sXG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgZGVib3VuY2UsIHdoaWNoIGNvbWVzIGZpcnN0LCBhcyBhIHNvcnQgb2YgXCJzdGVwIDBcIi5cbiAgICAgICAgLy8gSGFuZGxlcyBhbGwgdGhlIG5lY2Vzc2FyeSBib2lsZXJwbGF0ZSByZWxhdGVkIHRvIGNob29zaW5nIHdoZXRoZXIgdG9cbiAgICAgICAgLy8gcnVuIG9yIHNldCBhcyBwZW5kaW5nLCByZXNldHRpbmcgc3RhdGUgdmFyaWFibGVzLCBldGMuXG4gICAgICAgIGZ1bmN0aW9uIHdhbnRUb1N0YXJ0QU5ld1Byb21pc2Uoc3RhcnRQcm9taXNlKSB7XG4gICAgICAgICAgICBsZXQgYWxyZWFkeVJ1bm5pbmdQcm9taXNlID0gKGdldFByb21pc2UoKSAhPSBudWxsKTtcbiAgICAgICAgICAgIC8vIEJvaWxlcnBsYXRlIHdyYXBwZXIgYXJvdW5kIHRoZSBnaXZlbiBwcm9taXNlIHN0YXJ0ZXJcbiAgICAgICAgICAgIGxldCBQID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gaXQgc3RhcnRzLCBub3RpZnkgdGhlIGNhbGxlclxuICAgICAgICAgICAgICAgIHNldFJ1bkNvdW50KHIgPT4gKytyKTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGl0IGNvbXBsZXRlcywgbm90aWZ5IHRoZSBjYWxsZXJcbiAgICAgICAgICAgICAgICBjb25zdCBvblRoZW4gPSAoKSA9PiB7IHNldFJlc29sdmVDb3VudChjID0+ICsrYyk7IH07XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBpdCBmYWlscywgc2F2ZSB0aGUgZXJyb3IgYW5kIG5vdGlmeSB0aGUgY2FsbGVyXG4gICAgICAgICAgICAgICAgY29uc3Qgb25DYXRjaCA9IChleCkgPT4geyBzZXRFcnJvcihleCk7IHNldEhhc0Vycm9yKHRydWUpOyBzZXRSZWplY3RDb3VudChjID0+ICsrYyk7IH07XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBpdCBzZXR0bGVzLCByZXNldCBvdXIgc3RhdGUgc28gd2UgY2FuIFxuICAgICAgICAgICAgICAgIC8vIHJ1biBhIHBlbmRpbmcgcHJvbWlzZSBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICBjb25zdCBvbkZpbmFsbHkgPSAoKSA9PiB7IHNldFByb21pc2UobnVsbCk7IH07XG4gICAgICAgICAgICAgICAgbGV0IHN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGUgaGFuZGxlciBpcyBzeW5jaHJvbm91c1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc3RhcnRQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIHN5bmNocm9ub3VzIGFuZCByZXR1cm5lZCBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCYWlsIG91dCBlYXJseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVGhlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0J3Mgc3luY2hyb25vdXMgYW5kIHRocmV3IGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAvLyBCYWlsIG91dCBlYXJseS5cbiAgICAgICAgICAgICAgICAgICAgb25DYXRjaChleCk7XG4gICAgICAgICAgICAgICAgICAgIG9uRmluYWxseSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgaGFuZGxlciBpcyBhc3luY2hyb25vdXNcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFzeW5jICgpID0+IHsgYXdhaXQgcmVzdWx0OyB9KSgpLnRoZW4ob25UaGVuKS5jYXRjaChvbkNhdGNoKS5maW5hbGx5KG9uRmluYWxseSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFhbHJlYWR5UnVubmluZ1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCB0aGUgcHJvbWlzZSBpbW1lZGlhdGVseSwgYmVjYXVzZSB0aGVyZSB3YXNuJ3Qgb25lIHJ1bm5pbmcgYWxyZWFkeS5cbiAgICAgICAgICAgICAgICBsZXQgbmV4dFByb21pc2UgPSBQKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRQcm9taXNlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIb2xkIG9uISBUaGUgaGFuZGxlciB3YXMgYWN0dWFsbHkgc3luY2hyb25vdXMsIGFuZCBhbHJlYWR5IGZpbmlzaGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBCYWlsIG91dCBlYXJseS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEVycm9yKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIHNldEhhc0Vycm9yKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvbWlzZShuZXh0UHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc3RhcnQgdGhlIHByb21pc2UgeWV0LCBcbiAgICAgICAgICAgICAgICAvLyBhbmQgYWxsb3cgaXQgdG8gc3RhcnQgaW4gdGhlIGZ1dHVyZSBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIHNldFBlbmRpbmdQcm9taXNlU3RhcnRlcihfID0+IFApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXQgPSB7XG4gICAgICAgICAgICBnZXRTeW5jSGFuZGxlcixcbiAgICAgICAgICAgIGdldEN1cnJlbnRDYXB0dXJlLFxuICAgICAgICAgICAgY2FsbENvdW50OiBydW5Db3VudCxcbiAgICAgICAgICAgIGN1cnJlbnRDYXB0dXJlLFxuICAgICAgICAgICAgaGFzQ2FwdHVyZSxcbiAgICAgICAgICAgIHBlbmRpbmc6IChwcm9taXNlICE9IG51bGwpLFxuICAgICAgICAgICAgaGFzRXJyb3IsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHJlc29sdmVDb3VudCxcbiAgICAgICAgICAgIHJlamVjdENvdW50LFxuICAgICAgICAgICAgc2V0dGxlQ291bnQ6IHJlamVjdENvdW50ICsgcmVzb2x2ZUNvdW50XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIGZ1bmN0aW9uIGdldFN5bmNIYW5kbGVyKGFzeW5jSGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3Qgc3luY0hhbmRsZXIgPSB1c2VTdGFibGVDYWxsYmFjayhmdW5jdGlvbiBzeW5jSGFuZGxlcihldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChhc3luY0hhbmRsZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbW9zdCBzaWduaWZpY2FudCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBldmVudCBhdCB0aGlzIHRpbWUsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgbmVjZXNzYXJ5IHNpbmNlIHRoZSBwcm9taXNlIGNvdWxkIGFjdHVhbGx5IGJlIGNhbGxlZCBtdWNoIGxhdGVyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgZWxlbWVudCdzIHZhbHVlIChldGMuKSBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlZCA9IGNhcHR1cmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDYXB0dXJlKGNhcHR1cmVkKTtcbiAgICAgICAgICAgICAgICBzZXRIYXNDYXB0dXJlKHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9ICgpID0+IGFzeW5jSGFuZGxlcihjYXB0dXJlZCwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChkZWJvdW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbnRUb1N0YXJ0QU5ld1Byb21pc2Uoc3RhcnRQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERlYm91bmNlZFByb21pc2VTdGFydGVyKF8gPT4gc3RhcnRQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhc3luY0hhbmRsZXIgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHN5bmNIYW5kbGVyO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7IHJldHVybiAoc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyKDEpKTsgfVxuZnVuY3Rpb24gaXNWb2lkKHYpIHsgcmV0dXJuIHYgPT0gdW5kZWZpbmVkOyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtYXN5bmMtaGFuZGxlci5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbi8qKlxuICogQWxsb3dzIGF0dGFjaGluZyBhbiBldmVudCBoYW5kbGVyIHRvIGFueSAqbm9uLVByZWFjdCogZWxlbWVudCwgYW5kIHJlbW92aW5nIGl0IHdoZW4gdGhlIGNvbXBvbmVudCB1c2luZyB0aGUgaG9vayB1bm1vdW50cy4gVGhlIGNhbGxiYWNrIGRvZXMgbm90IG5lZWQgdG8gYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxuICpcbiAqIER1ZSB0byB0eXBpbmcgbGltaXRhdGlvbnMsIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgbGlrZSB0aGlzOlxuICpcbiAqIGB1c2VFdmVudEhhbmRsZXIoZWxlbWVudCwgXCJpbnB1dFwiKTxJbnB1dEV2ZW50PihlID0+IHt9KWBcbiAqXG4gKiBUaGUgdHlwZSBhcmd1bWVudCBpcyBvcHRpb25hbCwgYnV0IG5hcnJvd3MgZG93biB0aGUgdHlwZSBmcm9tIFwiYSB1bmlvbiBvZiBhbGwgZXZlbnRzXCIgdG8gd2hhdGV2ZXIgeW91IHNwZWNpZnksIGFuZCBlcnJvcnMgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAqXG4gKiBUaGVyZSBpcyBhIHNlcGFyYXRlIHZlcnNpb24gdGhhdCBhdHRhY2hlcyBldmVudCBoYW5kbGVycyB0byBhIHNldCBvZiBwcm9wcy5cbiAqIEl0IHRha2VzIGRpZmZlcmVudCBldmVudCBzdHJpbmcgdHlwZXMgKG9uRXZlbnQgdnMgb25ldmVudCkuXG4gKlxuICogQHBhcmFtIHRhcmdldCBBICpub24tUHJlYWN0KiBub2RlIHRvIGF0dGFjaCB0aGUgZXZlbnQgdG8uXG4gKiBAcmV0dXJuc1xuICogKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlcih0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAvLyBOb3RlIHRvIHNlbGY6IFRoZSB0eXBpbmcgZG9lc24ndCBpbXByb3ZlIGV2ZW4gaWYgdGhpcyBpcyBzcGxpdCB1cCBpbnRvIGEgc3ViLWZ1bmN0aW9uLlxuICAgIC8vIE5vIG1hdHRlciB3aGF0LCBpdCBzZWVtcyBpbXBvc3NpYmxlIHRvIGdldCB0aGUgaGFuZGxlcidzIGV2ZW50IG9iamVjdCB0eXBlZCBwZXJmZWN0bHkuXG4gICAgLy8gSXQgc2VlbXMgbGlrZSBpdCdzIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIGEgdW5pb24gb2YgYWxsIGF2YWlsYWJsZSB0dXBlcy5cbiAgICAvLyBBZ2Fpbiwgbm8gbWF0dGVyIHdoYXQgY29tYmluYXRpb24gb2Ygc3ViLSBvciBzdWItc3ViLWZ1bmN0aW9ucyB1c2VkLlxuICAgIGNvbnN0IHN0YWJsZUhhbmRsZXIgPSB1c2VTdGFibGVDYWxsYmFjayhoYW5kbGVyID8/ICgoKSA9PiB7IH0pKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcbn1cbi8qKlxuICogQW4gYWx0ZXJuYXRpdmUgd2F5IHRvIGFkZCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIGVsZW1lbnQuIFVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpbnRlZ3JhdGluZyAzcmQgcGFydHkgbGlicmFyaWVzIHRoYXQgZXhwZWN0IGEgZ2VuZXJpYyBcImFkZCBldmVudCBoYW5kbGVyXCIgZnVuY3Rpb24uXG4gKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHlvdSB0byBtb2RpZnkgYSBzZXQgb2YgcHJvcHMgdG8gYXBwbHkgdGhpcyBoYW5kbGVyLlxuICpcbiAqIEZvciB0eXBpbmcgcmVhc29ucywgdGhpcyBmdW5jdGlvbiBpcyBzcGxpdCBpbnRvIHR3by4gIFVzYWdlIGlzIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiBgYGBcbiAqIGNvbnN0IHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9ID0gdXNlTG9jYWxFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+KCkoXCJvbk1vdXNlRG93blwiLCBlID0+IHsgIH0pO1xuICogY29uc3QgZGl2UHJvcHMgPSB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzKHByb3BzKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYWxIYW5kbGVyKCkge1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICBjb25zdCBzdGFibGVIYW5kbGVyID0gdXNlU3RhYmxlQ2FsbGJhY2soaGFuZGxlcik7XG4gICAgICAgIGNvbnN0IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHsgW3R5cGVdOiBzdGFibGVIYW5kbGVyIH0sIHByb3BzKTtcbiAgICAgICAgfSwgW3R5cGVdKTtcbiAgICAgICAgcmV0dXJuIHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9O1xuICAgIH0sIFtdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1ldmVudC1oYW5kbGVyLmpzLm1hcCIsImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnRlcnZhbCh7IGludGVydmFsLCBjYWxsYmFjayB9KSB7XG4gICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIGdpdmVuIGNhbGxiYWNrIHRoYXQncyBzdGFibGVcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICBjb25zdCBnZXRJbnRlcnZhbCA9IHVzZVN0YWJsZUdldHRlcihpbnRlcnZhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IGludGVydmFsID0gZ2V0SW50ZXJ2YWwoKTtcbiAgICAgICAgbGV0IGxhc3REZWxheVVzZWQgPSBpbnRlcnZhbDtcbiAgICAgICAgaWYgKGludGVydmFsID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgLy8gdGhhdCBjbGVhcnMgYW5kIHJlc2V0cyB0aGUgaW50ZXJ2YWwgaWYgaXQgY2hhbmdlcy5cbiAgICAgICAgY29uc3QgYWRqdXN0YWJsZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhYmxlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbnRlcnZhbCA9IGdldEludGVydmFsKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEludGVydmFsICE9IGxhc3REZWxheVVzZWQpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbnRlcnZhbCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSBzZXRJbnRlcnZhbChhZGp1c3RhYmxlQ2FsbGJhY2ssIGxhc3REZWxheVVzZWQgPSBjdXJyZW50SW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgaGFuZGxlID0gc2V0SW50ZXJ2YWwoYWRqdXN0YWJsZUNhbGxiYWNrLCBpbnRlcnZhbCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGhhbmRsZSk7XG4gICAgfSwgW10pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWludGVydmFsLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtbGF5b3V0LWVmZmVjdFwiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcbi8qKlxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxuICogY2hpbGQgY29tcG9uZW50cyBvbmNlIHRoZXkgaGF2ZSByZW5kZXJlZC5cbiAqXG4gKiBUaGlzIGhvb2sgaXMgc2xpZ2h0bHkgbW9yZSBjb21wbGljYXRlZCBpbiB0aGF0IGl0IHJldHVybnMgYm90aCBhXG4gKiBwcm9wLW1vZGlmeWluZyBob29rLCBidXQgYWxzbyBhIGhvb2sgdGhhdCBlYWNoIGNoaWxkIHdpbGwgbmVlZFxuICogdG8gdXNlOiBgdXNlTWFuYWdlZENoaWxkYC4gIEl0J3Mgc3RhYmxlIGFjcm9zcyByZW5kZXJzLCBzbyBqdXN0XG4gKiB0b3NzIGl0IGludG8gYSBgQ29udGV4dGAgc28gdGhlIGNoaWxkcmVuIGNhbiBoYXZlIGFjY2VzcyB0byBpdC5cbiAqIFRoaXMgZnVuY3Rpb24gcmVnaXN0ZXJzIHRoZSBjaGlsZCB3aXRoIHRoZSBwYXJlbnQgYW5kIHByb3ZpZGVzXG4gKiBpdCB3aXRoIGFueSByZXF1ZXN0ZWQgaW5mb3JtYXRpb24sIGJ1dCBkb2Vzbid0IGRvIGFueXRoaW5nIGVsc2VcbiAqIHVudGlsIGl0IHVubW91bnRzIGFuZCByZXRyYWN0cyB0aGF0IGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hpbGRNYW5hZ2VyKCkge1xuICAgIC8vIFRoaXMgaXMgYmxpbmRseSB1cGRhdGVkIGFueSB0aW1lIGEgY2hpbGQgbW91bnRzIG9yIHVubW91bnRzIGl0c2VsZi5cbiAgICAvLyBVc2VkIHRvIG1ha2Ugc3VyZSB0aGF0IGFueSB0aW1lIHRoZSBhcnJheSBvZiBtYW5hZ2VkIGNoaWxkcmVuIHVwZGF0ZXMsXG4gICAgLy8gd2UgYWxzbyByZS1yZW5kZXIuXG4gICAgY29uc3QgW2NoaWxkVXBkYXRlSW5kZXgsIHNldENoaWxkVXBkYXRlSW5kZXhdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW3RvdGFsQ2hpbGRyZW5Nb3VudGVkLCBzZXRUb3RhbENoaWxkcmVuTW91bnRlZCwgZ2V0VG90YWxDaGlsZHJlbk1vdW50ZWRdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW3RvdGFsQ2hpbGRyZW5Vbm91bnRlZCwgc2V0VG90YWxDaGlsZHJlblVub3VudGVkLCBnZXRUb3RhbENoaWxkcmVuVW5vdW50ZWRdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgY2hpbGRyZW5DdXJyZW50bHlNb3VudGVkID0gdG90YWxDaGlsZHJlbk1vdW50ZWQgLSB0b3RhbENoaWxkcmVuVW5vdW50ZWQ7XG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuID0gdXNlUmVmKFtdIC8qKiBUT0RPOiBBbnkgcHJvYmxlbXMgY2F1c2VkIGJ5IHVzaW5nIGFuIGFycmF5IHdoZW4gaXQgc2hvdWxkIGJlIGFuIG9iamVjdD8gKi8pO1xuICAgIGNvbnN0IG1vdW50ZWRDaGlsZHJlbiA9IHVzZVJlZihbXSk7XG4gICAgY29uc3QgbW91bnRPcmRlciA9IHVzZVJlZihuZXcgTWFwKCkpO1xuICAgIGNvbnN0IGluZGljZXNCeUVsZW1lbnQgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgICBjb25zdCBnZXRNb3VudEluZGV4ID0gdXNlQ2FsbGJhY2soKGluZGV4KSA9PiB7IHJldHVybiBtb3VudE9yZGVyLmN1cnJlbnQuZ2V0KGluZGV4KTsgfSwgW10pO1xuICAgIGNvbnN0IHVzZU1hbmFnZWRDaGlsZCA9IHVzZUNhbGxiYWNrKChpbmZvKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBnZXRUb3RhbENoaWxkcmVuTW91bnRlZCgpO1xuICAgICAgICAgICAgbW91bnRPcmRlci5jdXJyZW50LnNldChpbmZvLmluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICBtb3VudGVkQ2hpbGRyZW4uY3VycmVudFtpbmRleF0gPSBpbmZvO1xuICAgICAgICAgICAgc2V0VG90YWxDaGlsZHJlbk1vdW50ZWQodCA9PiArK3QpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgbW91bnRPcmRlci5jdXJyZW50LmRlbGV0ZShpbmZvLmluZGV4KTsgbW91bnRlZENoaWxkcmVuLmN1cnJlbnRbaW5kZXhdID0gbnVsbDsgc2V0VG90YWxDaGlsZHJlblVub3VudGVkKHQgPT4gKyt0KTsgfTtcbiAgICAgICAgfSwgW2luZm8uaW5kZXhdKTtcbiAgICAgICAgLy8gQXMgc29vbiBhcyB0aGUgY29tcG9uZW50IG1vdW50cywgbm90aWZ5IHRoZSBwYXJlbnQgYW5kIHJlcXVlc3QgYSByZXJlbmRlci5cbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KChbcHJldkVsZW1lbnQsIHByZXZJbmRleF0sIGNoYW5nZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlc0J5RWxlbWVudC5jdXJyZW50LnNldChlbGVtZW50LCBpbmZvLmluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAobWFuYWdlZENoaWxkcmVuLmN1cnJlbnRbaW5mby5pbmRleF0gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGluZm8uaW5kZXggPT0gdW5kZWZpbmVkLCBcIlR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGluZGV4IHdlcmUgYWRkZWQsIHdoaWNoIG1heSByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvci5cIik7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyOyAvLyBJbnRlbnRpb25hbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRDaGlsZFVwZGF0ZUluZGV4KGMgPT4gKytjKTtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4uY3VycmVudFtpbmZvLmluZGV4XSA9IHsgLi4uaW5mbyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldENoaWxkVXBkYXRlSW5kZXgoYyA9PiArK2MpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuLmN1cnJlbnRbaW5mby5pbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGluZGljZXNCeUVsZW1lbnQuY3VycmVudC5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW2VsZW1lbnQsIGluZm8uaW5kZXhdKTtcbiAgICAgICAgLy8gQW55IHRpbWUgb3VyIGNoaWxkIHByb3BzIGNoYW5nZSwgbWFrZSB0aGF0IGluZm9ybWF0aW9uIGF2YWlsYWJsZSBnZW5lcmFsbHkuXG4gICAgICAgIC8vICpEb24ndCByZS1yZW5kZXIqLCBvdGhlcndpc2Ugd2UnZCBiZSBzdHVjayBpbiBhblxuICAgICAgICAvLyBpbmZpbml0ZSBsb29wIGV2ZXJ5IHRpbWUgYW4gYW5vbnltb3VzIGZ1bmN0aW9uIGlzIHBhc3NlZC5cbiAgICAgICAgLy8gSXQgY29tZXMgaW4gZnJvbSB0aGUgcHJvcHMgc28gdGhlIGNoaWxkIHdhcyBhbHJlYWR5IHVwZGF0ZWQgYnkgaXQgLS1cbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgcGFyZW50IHRvIHJlLXJlbmRlciBldmVyeSBzaW5nbGUgY2hpbGQgYW55IHRpbWVcbiAgICAgICAgLy8gXCJvbkNsaWNrXCIgdXBkYXRlcyBvciB3aGF0ZXZlci4gIFRoZSByZWxldmFudCBjaGlsZCBhbHJlYWR5IGtub3dzLFxuICAgICAgICAvLyBhbmQgdGhhdCdzIHdoYXQgbWF0dGVycy5cbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChtYW5hZ2VkQ2hpbGRyZW4uY3VycmVudFtpbmZvLmluZGV4XSAhPSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuLmN1cnJlbnRbaW5mby5pbmRleF0gPSB7IC4uLmluZm8gfTtcbiAgICAgICAgfSwgWy4uLk9iamVjdC5lbnRyaWVzKGluZm8pLmZsYXQoKV0pO1xuICAgICAgICByZXR1cm4geyBlbGVtZW50LCBnZXRFbGVtZW50LCB1c2VNYW5hZ2VkQ2hpbGRQcm9wczogdXNlUmVmRWxlbWVudFByb3BzIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVzZU1hbmFnZWRDaGlsZCxcbiAgICAgICAgY2hpbGRDb3VudDogY2hpbGRyZW5DdXJyZW50bHlNb3VudGVkLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRDaGlsZHJlbi5jdXJyZW50LFxuICAgICAgICBtb3VudGVkQ2hpbGRyZW46IG1vdW50ZWRDaGlsZHJlbi5jdXJyZW50LFxuICAgICAgICBpbmRpY2VzQnlFbGVtZW50OiBpbmRpY2VzQnlFbGVtZW50LmN1cnJlbnQsXG4gICAgICAgIHRvdGFsQ2hpbGRyZW5Nb3VudGVkLFxuICAgICAgICB0b3RhbENoaWxkcmVuVW5vdW50ZWQsXG4gICAgICAgIGdldE1vdW50SW5kZXhcbiAgICB9O1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGxldHRpbmcgY2hpbGRyZW4ga25vdyB3aGVuIHRoZXkgYXJlIG9yIGFyZSBub3QgdGhlXG4gKiBjdXJyZW50IHNlbGVjdGVkL2V4cGFuZGVkL2ZvY3VzZWQvd2hhdGV2ZXIgY2hpbGQuXG4gKlxuICogQXV0b21hdGljYWxseSBoYW5kbGVzIHdoZW4gY2hpbGRyZW4gYXJlIG1vdW50ZWQgJiB1bm1vdW50ZWQgYW5kIHN1Y2guXG4gKlxuICogQHBhcmFtIGFjdGl2YXRlZEluZGV4IFdoYXQgaW5kZXggdGhlIGN1cnJlbnQgc2VsZWN0ZWQgKGV0Yy4pIGNoaWxkIGlzXG4gKiBAcGFyYW0gbGVuZ3RoIEhvdyBtYW55IGNoaWxkcmVuIGV4aXN0IChhcyBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoKVxuICogQHBhcmFtIHNldEZsYWcgQSBmdW5jdGlvbiB0aGF0IHByb2JhYmx5IGxvb2tzIGxpa2UgKGksIGZsYWcpID0+IG1hbmFnZWRDaGlsZHJlbltpXS5zZXRBY3RpdmUoZmxhZylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkRmxhZyhhY3RpdmF0ZWRJbmRleCwgbGVuZ3RoLCBzZXRGbGFnKSB7XG4gICAgY29uc3QgW3ByZXZBY3RpdmF0ZWRJbmRleCwgc2V0UHJldkFjdGl2YXRlZEluZGV4LCBnZXRQcmV2QWN0aXZhdGVkSW5kZXhdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW3ByZXZDaGlsZENvdW50LCBzZXRQcmV2Q2hpbGRDb3VudCwgZ2V0UHJldkNoaWxkQ291bnRdID0gdXNlU3RhdGUobGVuZ3RoKTtcbiAgICAvLyBBbnkgdGltZSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgY2hhbmdlcyxcbiAgICAvLyByZXNldCBhbnkgaW5pdGlhbCwgcG9zc2libHkgaW5jb3JyZWN0IHN0YXRlIHRoZXkgbWlnaHQgaGF2ZSBoYWQsIGp1c3QgaW4gY2FzZS5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBNYXRoLnNpZ24obGVuZ3RoIC0gZ2V0UHJldkNoaWxkQ291bnQoKSk7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gIT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBnZXRQcmV2Q2hpbGRDb3VudCgpID8/IDA7IGkgIT0gbGVuZ3RoOyBpICs9IGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHNldEZsYWcoaSwgaSA9PT0gYWN0aXZhdGVkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UHJldkNoaWxkQ291bnQobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH0sIFtzZXRGbGFnLCBhY3RpdmF0ZWRJbmRleCwgbGVuZ3RoXSk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gRGVhY3RpdmF0ZSB0aGUgcHJldmlvdXNseSBhY3RpdmF0ZWQgY29tcG9uZW50XG4gICAgICAgIGNvbnN0IHByZXZBY3RpdmF0ZWRJbmRleCA9IGdldFByZXZBY3RpdmF0ZWRJbmRleCgpO1xuICAgICAgICBpZiAocHJldkFjdGl2YXRlZEluZGV4ICE9IGFjdGl2YXRlZEluZGV4KSB7XG4gICAgICAgICAgICBpZiAocHJldkFjdGl2YXRlZEluZGV4ICE9IG51bGwgJiYgcHJldkFjdGl2YXRlZEluZGV4ID49IDAgJiYgcHJldkFjdGl2YXRlZEluZGV4IDwgbGVuZ3RoKVxuICAgICAgICAgICAgICAgIHNldEZsYWcocHJldkFjdGl2YXRlZEluZGV4LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWN0aXZhdGUgdGhlIGN1cnJlbnQgY29tcG9uZW50XG4gICAgICAgIGlmIChhY3RpdmF0ZWRJbmRleCAhPSBudWxsICYmIGFjdGl2YXRlZEluZGV4ID49IDAgJiYgYWN0aXZhdGVkSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHNldEZsYWcoYWN0aXZhdGVkSW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgc2V0UHJldkFjdGl2YXRlZEluZGV4KGFjdGl2YXRlZEluZGV4KTtcbiAgICAgICAgfVxuICAgIH0sIFtzZXRGbGFnLCBhY3RpdmF0ZWRJbmRleCwgbGVuZ3RoXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtY2hpbGQtbWFuYWdlci5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcbmltcG9ydCB7IHVzZUNoaWxkTWFuYWdlciwgdXNlQ2hpbGRGbGFnIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG4vKipcbiAqIEltcGxlbWVudHMgYSByb3ZpbmcgdGFiaW5kZXggc3lzdGVtIHdoZXJlIG9ubHkgb25lIFwiZm9jdXNhYmxlXCJcbiAqIGNvbXBvbmVudCBpbiBhIHNldCBpcyBhYmxlIHRvIHJlY2VpdmUgYSB0YWIgZm9jdXMuICpXaGljaCpcbiAqIG9mIHRob3NlIGVsZW1lbnRzIHJlY2VpdmVzIGZvY3VzIGlzIGRldGVybWluZWQgYnkgeW91LCBidXQgaXQnc1xuICogcmVjb21tZW5kZWQgdG8gb2ZmbG9hZCB0aGF0IGxvZ2ljIHRoZW4gdG8gYW5vdGhlciBob29rLCBsaWtlXG4gKiBgdXNlTGluZWFyTmF2aWdhdGlvbmAsIHdoaWNoIGxldHMgeW91IGNoYW5nZSB0aGUgdGFiYmFibGVcbiAqIGVsZW1lbnQgd2l0aCB0aGUgYXJyb3cga2V5cywgYHVzZVR5cGVhaGVhZE5hdmlnYXRpb25gLCB3aGljaFxuICogbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZSBpbmRleCB3aXRoIHR5cGVhaGVhZCwgb3JcbiAqIGB1c2VMaXN0TmF2aWdhdGlvbmAgaWYgeW91IGp1c3Qgd2FudCBldmVyeXRoaW5nIGJ1bmRsZWQgdG9nZXRoZXIuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBjaGlsZCBob29rIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkXG4gKiBieSBldmVyeSBjaGlsZCB0aGF0IHVzZXMgdGhpcyByb3ZpbmcgdGFiaW5kZXggbG9naWMuICBUaGVcbiAqIHByb3AtbW9kaWZ5aW5nIGhvb2sgKnRoYXQqIGhvb2sgcmV0dXJucyBzaG91bGQgdGhlbiBiZSB1c2VkXG4gKiBvbiB0aGUgY2hpbGQncyBlbGVtZW50LCBhcyB3ZWxsIGFzIGFueSBvdGhlciBlbGVtZW50cyB5b3UnZCBsaWtlXG4gKiB0byBiZSBleHBsaWNpdGx5IG1hZGUgdW50YWJiYWJsZSB0b28uXG4gKlxuICogYGZvY3VzT25DaGFuZ2VgIHNob3VsZCBiZSBzZXQgdG8gdHJ1ZSBpZiBmb2N1cyBpc1xuICogY29udGFpbmVkIHdpdGhpbiB3aGF0ZXZlciBlbGVtZW50IGNvbnRhaW5zIHRoZSByb3ZpbmcgdGFiIGluZGV4LlxuICogR2VuZXJhbGx5IGFzIHNpbXBsZSBhcyB0aGUgZm9sbG93aW5nOlxuICogYGBgXG4gKiBjb25zdCB7IGZvY3VzZWQsIGZvY3VzZWRJbm5lciwgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8UGFyZW50RWxlbWVudD4oKTtcbiAqIGNvbnN0IGZvY3VzT25DaGFuZ2UgPSAoZm9jdXNlZElubmVyICE9IGZhbHNlKTtcbiAqIGBgYFxuICogSXQncyBub3QgaW5jbHVkZWQgaGVyZSBiZWNhdXNlIGB1c2VSb3ZpbmdUYWJJbmRleGAgZG9lc24ndCBrbm93XG4gKiBhbnl0aGluZyBhYm91dCB0aGUgY29udGFpbmVyIGVsZW1lbnQsIG9ubHkgY2hpbGRyZW4gZWxlbWVudHMuXG4gKiBBbmQganVzdCBhcyB3ZWxsISBDaGlsZHJlbiBzaG91bGQgYmUgYWxsb3dlZCBhdCB0aGUgcm9vdCxcbiAqIHJlZ2FyZGxlc3Mgb2YgaWYgaXQncyB0aGUgd2hvbGUgYXBwIG9yIGp1c3QgYSBnaXZlbiBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleCh7IGZvY3VzT25DaGFuZ2UsIHRhYmJhYmxlSW5kZXggfSkge1xuICAgIGNvbnN0IGdldFRhYmJhYmxlSW5kZXggPSB1c2VTdGFibGVHZXR0ZXIodGFiYmFibGVJbmRleCk7XG4gICAgY29uc3QgcHJldlRhYmJhYmxlID0gdXNlUmVmKC1JbmZpbml0eSk7XG4gICAgLy8gQ2FsbCB0aGUgaG9vayB0aGF0IGFsbG93cyB1cyB0byBjb2xsZWN0IGluZm9ybWF0aW9uIGZyb20gY2hpbGRyZW4gd2hvIHByb3ZpZGUgaXRcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbiwgY2hpbGRDb3VudCwgdXNlTWFuYWdlZENoaWxkLCBpbmRpY2VzQnlFbGVtZW50LCAuLi5yZXN0IH0gPSB1c2VDaGlsZE1hbmFnZXIoKTtcbiAgICAvLyBBbnkgdGltZSB0aGUgdGFiYmFibGUgaW5kZXggY2hhbmdlcyxcbiAgICAvLyBub3RpZnkgdGhlIHByZXZpb3VzIGNoaWxkIHRoYXQgaXQncyBubyBsb25nZXIgdGFiYmFibGUsXG4gICAgLy8gYW5kIG5vdGlmeSB0aGUgbmV4dCBjaGlsZCB0aGF0IGlzIGFsbG93ZWQgdG8gYmUgdGFiYmVkIHRvLlxuICAgIHVzZUNoaWxkRmxhZyh0YWJiYWJsZUluZGV4LCBjaGlsZENvdW50LCAoaW5kZXgsIHRhYmJhYmxlKSA9PiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbltpbmRleF0/LnNldFRhYmJhYmxlKHRhYmJhYmxlLCB0YWJiYWJsZSAmJiBmb2N1c09uQ2hhbmdlID8gXCJmb2N1c1wiIDogdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblt0YWJiYWJsZUluZGV4XS5zZXRUYWJiYWJsZSh0cnVlLCBcImZvY3VzXCIpO1xuICAgIH0sIFt0YWJiYWJsZUluZGV4XSk7XG4gICAgY29uc3QgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCA9IHVzZUNhbGxiYWNrKChpbmZvKSA9PiB7XG4gICAgICAgIGNvbnN0IHNldFRhYmJhYmxlID0gdXNlQ2FsbGJhY2soKHRhYmJhYmxlLCBzaG91bGRGb2N1cykgPT4ge1xuICAgICAgICAgICAgc2V0VGFiYmFibGUyKHRhYmJhYmxlKTtcbiAgICAgICAgICAgIGlmICh0YWJiYWJsZSAmJiBzaG91bGRGb2N1cylcbiAgICAgICAgICAgICAgICBzZXRTaG91bGRGb2N1cyghIXNob3VsZEZvY3VzKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICBsZXQgbmV3SW5mbyA9IHtcbiAgICAgICAgICAgIC4uLmluZm8sXG4gICAgICAgICAgICBzZXRUYWJiYWJsZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIGdldEVsZW1lbnQsIHVzZU1hbmFnZWRDaGlsZFByb3BzIH0gPSB1c2VNYW5hZ2VkQ2hpbGQobmV3SW5mbyk7XG4gICAgICAgIGNvbnN0IFt0YWJiYWJsZSwgc2V0VGFiYmFibGUyXSA9IHVzZVN0YXRlKGdldFRhYmJhYmxlSW5kZXgoKSA9PSBpbmZvLmluZGV4KTtcbiAgICAgICAgY29uc3QgW3Nob3VsZEZvY3VzLCBzZXRTaG91bGRGb2N1c10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgICAgIGZ1bmN0aW9uIHVzZVJvdmluZ1RhYkluZGV4U2libGluZ1Byb3BzKHsgdGFiSW5kZXgsIC4uLnByb3BzIH0pIHtcbiAgICAgICAgICAgIGlmICh0YWJJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhYmJhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoeyB0YWJJbmRleCB9LCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzKHsgdGFiSW5kZXgsIC4uLnByb3BzIH0pIHtcbiAgICAgICAgICAgIC8vY29uc3QgeyBlbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8Q2hpbGRFbGVtZW50PigpO1xuICAgICAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBzaG91bGRGb2N1cyAmJiBcImZvY3VzXCIgaW4gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2hvdWxkRm9jdXMoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtlbGVtZW50LCBzaG91bGRGb2N1c10pO1xuICAgICAgICAgICAgaWYgKHRhYkluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFiYmFibGUpXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh1c2VNYW5hZ2VkQ2hpbGRQcm9wcyh7IHRhYkluZGV4IH0pLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzLFxuICAgICAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhTaWJsaW5nUHJvcHMsXG4gICAgICAgICAgICB0YWJiYWJsZVxuICAgICAgICB9O1xuICAgIH0sIFt1c2VNYW5hZ2VkQ2hpbGRdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLFxuICAgICAgICBjaGlsZENvdW50LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIGluZGljZXNCeUVsZW1lbnQsXG4gICAgICAgIGZvY3VzU2VsZixcbiAgICAgICAgLi4ucmVzdFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2Utcm92aW5nLXRhYmluZGV4LmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VUaW1lb3V0IH0gZnJvbSBcIi4vdXNlLXRpbWVvdXRcIjtcbmltcG9ydCB7IHVzZUxvZ2ljYWxEaXJlY3Rpb24gfSBmcm9tIFwiLi91c2UtbG9naWNhbC1kaXJlY3Rpb25cIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuLyoqXG4gKiBXaGVuIHVzZWQgaW4gdGFuZGVtIHdpdGggYHVzZVJvdmluZ1RhYkluZGV4YCwgYWxsb3dzIGNvbnRyb2wgb2ZcbiAqIHRoZSB0YWJiYWJsZSBpbmRleCB3aXRoIHRoZSBhcnJvdyBrZXlzLlxuICpcbiAqIEBzZWUgdXNlTGlzdE5hdmlnYXRpb24sIHdoaWNoIHBhY2thZ2VzIGV2ZXJ5dGhpbmcgdXAgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaW5lYXJOYXZpZ2F0aW9uKHsgZ2V0SW5kZXgsIHNldEluZGV4LCBtYW5hZ2VkQ2hpbGRyZW4sIG5hdmlnYXRpb25EaXJlY3Rpb24gfSkge1xuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24gPz89IFwiZWl0aGVyXCI7XG4gICAgY29uc3QgaW5kZXggPSBnZXRJbmRleCgpO1xuICAgIGNvbnN0IGNoaWxkQ291bnQgPSBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgdGFiYmFibGUgaW5kZXggbmV2ZXIgZXNjYXBlcyB0aGUgYm91bmRzIG9mIGFsbCBhdmFpbGFibGUgY2hpbGRyZW5cbiAgICAvLyBUT0RPOiBLZWVwIHRyYWNrIG9mIHRoZSBvcmlnaW5hbCBpbmRleCBhbmQga2VlcCBpdCwgYXQgbGVhc3QgdW50aWwga2V5Ym9hcmQgbmF2aWdhdGlvbi5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBzZXRJbmRleCgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZENvdW50ID4gMCAmJiBpbmRleCA+PSBjaGlsZENvdW50KSB7XG4gICAgICAgICAgICBzZXRJbmRleChjaGlsZENvdW50IC0gMSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5kZXgsIGNoaWxkQ291bnRdKTtcbiAgICAvLyBUaGVzZSBhbGxvdyB1cyB0byBtYW5pcHVsYXRlIHdoYXQgb3VyIGN1cnJlbnQgdGFiYmFibGUgY2hpbGQgaXMuXG4gICAgY29uc3QgbmF2aWdhdGVUb0luZGV4ID0gdXNlQ2FsbGJhY2soKGluZGV4KSA9PiB7IHNldEluZGV4KGluZGV4IDwgMCA/IChtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoICsgaW5kZXgpIDogaW5kZXgpOyB9LCBbXSk7XG4gICAgY29uc3QgbmF2aWdhdGVUb05leHQgPSB1c2VDYWxsYmFjaygoKSA9PiB7IHNldEluZGV4KGkgPT4gKytpKTsgfSwgW10pO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9QcmV2ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBzZXRJbmRleChpID0+IC0taSk7IH0sIFtdKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvU3RhcnQgPSB1c2VDYWxsYmFjaygoKSA9PiB7IG5hdmlnYXRlVG9JbmRleCgwKTsgfSwgW25hdmlnYXRlVG9JbmRleF0pO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9FbmQgPSB1c2VDYWxsYmFjaygoKSA9PiB7IG5hdmlnYXRlVG9JbmRleCgtMSk7IH0sIFtuYXZpZ2F0ZVRvSW5kZXhdKTtcbiAgICBjb25zdCB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBlbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50KCk7XG4gICAgICAgIC8vIFByZWZlciB0aGUgcGFyZW50IGVsZW1lbnQncyBkaXJlY3Rpb24gc28gdGhhdCB3ZSdyZSBub3QgY2FsbGluZyBnZXRDb21wdXRlZFN0eWxlXG4gICAgICAgIC8vIG9uIGV2ZXJ5IHNpbmdsZSBpbmRpdmlkdWFsIGNoaWxkLCB3aGljaCBpcyBsaWtlbHkgcmVkdW5kYW50LlxuICAgICAgICAvLyBUT0RPOiBEb2VzIHVzZUxvZ2ljYWxEaXJlY3Rpb24gbmVlZCB0byBob2xkIGEgcGVyLXJlbmRlciAmIHBlci1lbGVtZW50IGNhY2hlIHRvIG1ha2UgdGhpcyB3b3JrP1xuICAgICAgICAvLyBPciBkb2VzIHRoZSBicm93c2VyIGF1dG9tYXRpY2FsbHkgY2FjaGUgdGhlIGNvbXB1dGF0aW9ucyB1bnRpbCBzb21ldGhpbmcgY2hhbmdlcz9cbiAgICAgICAgLy8gR2l2ZW4gdGhhdCB0aGUgdmFsdWVzIGFyZSBsaXZlLCBpdCBzZWVtcyBsaWtlIGl0IHNob3VsZCBiZSB0aGUgbGF0dGVyLi4uXG4gICAgICAgIGNvbnN0IHsgY29udmVydEVsZW1lbnRTaXplLCBnZXRMb2dpY2FsRGlyZWN0aW9uIH0gPSB1c2VMb2dpY2FsRGlyZWN0aW9uKGVsZW1lbnQ/LnBhcmVudEVsZW1lbnQgPz8gZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZFByb3BzID0gKHByb3BzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbktleURvd24gPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxuICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IGdldExvZ2ljYWxEaXJlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBsZXQgYWxsb3dzQmxvY2tOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJibG9ja1wiIHx8IG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJlaXRoZXJcIik7XG4gICAgICAgICAgICAgICAgbGV0IGFsbG93c0lubGluZU5hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImlubGluZVwiIHx8IG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJlaXRoZXJcIik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcImJsb2NrRGlyZWN0aW9uXCIgOiBcImlubGluZURpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gYWxsb3dzQmxvY2tOYXZpZ2F0aW9uIDogYWxsb3dzSW5saW5lTmF2aWdhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcImJ0dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IGFsbG93c0Jsb2NrTmF2aWdhdGlvbiA6IGFsbG93c0lubGluZU5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJidHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwiaW5saW5lRGlyZWN0aW9uXCIgOiBcImJsb2NrRGlyZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uIDogYWxsb3dzQmxvY2tOYXZpZ2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwicnRsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJpbmxpbmVEaXJlY3Rpb25cIiA6IFwiYmxvY2tEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IGFsbG93c0lubGluZU5hdmlnYXRpb24gOiBhbGxvd3NCbG9ja05hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJydGxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9TdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IG9uS2V5RG93biB9LCBwcm9wcykpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkUHJvcHNcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgsXG4gICAgICAgIG5hdmlnYXRlVG9OZXh0LFxuICAgICAgICBuYXZpZ2F0ZVRvUHJldixcbiAgICAgICAgbmF2aWdhdGVUb1N0YXJ0LFxuICAgICAgICBuYXZpZ2F0ZVRvRW5kLFxuICAgIH07XG59XG4vKipcbiAqIEFsbG93cyBmb3IgdGhlIHNlbGVjdGlvbiBvZiBhIG1hbmFnZWQgY2hpbGQgYnkgdHlwaW5nIHRoZSBnaXZlbiB0ZXh0IGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAqXG4gKiBAc2VlIHVzZUxpc3ROYXZpZ2F0aW9uLCB3aGljaCBwYWNrYWdlcyBldmVyeXRoaW5nIHVwIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbih7IGNvbGxhdG9yLCBnZXRJbmRleCwgdHlwZWFoZWFkVGltZW91dCwgc2V0SW5kZXggfSkge1xuICAgIC8vIEZvciB0eXBlYWhlYWQsIGtlZXAgdHJhY2sgb2Ygd2hhdCBvdXIgY3VycmVudCBcInNlYXJjaFwiIHN0cmluZyBpcyAoaWYgd2UgaGF2ZSBvbmUpXG4gICAgLy8gYW5kIGFsc28gY2xlYXIgaXQgZXZlcnkgMTAwMCBtcyBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IGNoYW5nZWQuXG4gICAgLy8gTmV4dCwga2VlcCBhIG1hcHBpbmcgb2YgdHlwZWFoZWFkIHZhbHVlcyB0byBpbmRpY2VzIGZvciBmYXN0ZXIgc2VhcmNoaW5nLlxuICAgIC8vIEFuZCwgZm9yIHRoZSB1c2VyJ3Mgc2FrZSwgbGV0IHRoZW0ga25vdyB3aGVuIHRoZWlyIHR5cGVhaGVhZCBjYW4ndCBtYXRjaCBhbnl0aGluZyBhbnltb3JlXG4gICAgY29uc3QgW2N1cnJlbnRUeXBlYWhlYWQsIHNldEN1cnJlbnRUeXBlYWhlYWQsIGdldEN1cnJlbnRUeXBlYWhlYWRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlVGltZW91dCh7IHRpbWVvdXQ6IHR5cGVhaGVhZFRpbWVvdXQgPz8gMTAwMCwgY2FsbGJhY2s6ICgpID0+IHsgc2V0Q3VycmVudFR5cGVhaGVhZChudWxsKTsgc2V0SW52YWxpZFR5cGVhaGVhZChudWxsKTsgfSwgdHJpZ2dlckluZGV4OiBjdXJyZW50VHlwZWFoZWFkIH0pO1xuICAgIGNvbnN0IHNvcnRlZFR5cGVhaGVhZEluZm8gPSB1c2VSZWYoW10pO1xuICAgIGNvbnN0IFtpbnZhbGlkVHlwZWFoZWFkLCBzZXRJbnZhbGlkVHlwZWFoZWFkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvLyBIYW5kbGUgdHlwZWFoZWFkIGZvciBpbnB1dCBtZXRob2QgZWRpdG9ycyBhcyB3ZWxsXG4gICAgLy8gRXNzZW50aWFsbHksIHdoZW4gYWN0aXZlLCBpZ25vcmUgZnVydGhlciBrZXlzIFxuICAgIC8vIGJlY2F1c2Ugd2UncmUgd2FpdGluZyBmb3IgYSBDb21wb3NpdGlvbkVuZCBldmVudFxuICAgIGNvbnN0IFtpbWVBY3RpdmUsIHNldEltZUFjdGl2ZSwgZ2V0SW1lQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvLyBCZWNhdXNlIGNvbXBvc2l0aW9uIGV2ZW50cyBmaXJlICphZnRlcioga2V5ZG93biBldmVudHMgXG4gICAgLy8gKGJ1dCB3aXRoaW4gdGhlIHNhbWUgdGFzaywgd2hpY2gsIFRPRE8sIGNvdWxkIGJlIGJyb3dzZXItZGVwZW5kZW50KSxcbiAgICAvLyB3ZSBjYW4gdXNlIHRoaXMgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBldmVudCB3ZSdyZSBsaXN0ZW5pbmcgZm9yIG9uIHRoZSBmaXJzdCBrZXlkb3duLlxuICAgIGNvbnN0IFtuZXh0VHlwZWFoZWFkQ2hhciwgc2V0TmV4dFR5cGVhaGVhZENoYXJdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG5leHRUeXBlYWhlYWRDaGFyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHR5cGVhaGVhZCA9PiAoKHR5cGVhaGVhZCA/PyBcIlwiKSArIG5leHRUeXBlYWhlYWRDaGFyKSk7XG4gICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihudWxsKTtcbiAgICAgICAgfVxuICAgIH0sIFtuZXh0VHlwZWFoZWFkQ2hhcl0pO1xuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSB1c2VTdGFibGVDYWxsYmFjaygobGhzLCByaHMpID0+IHtcbiAgICAgICAgbGV0IGNvbXBhcmU7XG4gICAgICAgIC8vIEZvciB0aGUgcHVycG9zZXMgb2YgdHlwZWFoZWFkLCBvbmx5IGNvbXBhcmUgYSBzdHJpbmcgb2YgdGhlIHNhbWUgc2l6ZSBhcyBvdXIgY3VycmVudGx5IHR5cGVkIHN0cmluZy5cbiAgICAgICAgLy8gQnkgbm9ybWFsaXppbmcgdGhlbSBmaXJzdCwgd2UgZW5zdXJlIHRoaXMgYnl0ZS1ieS1ieXRlIGhhbmRsaW5nIG9mIHJhdyBjaGFyYWN0ZXIgZGF0YSB3b3JrcyBvdXQgb2theS5cbiAgICAgICAgbGV0IHNhZmVMaHMgPSBsaHMubm9ybWFsaXplKFwiTkZEXCIpO1xuICAgICAgICBsZXQgc2FmZVJocyA9IHJocy50ZXh0Lm5vcm1hbGl6ZShcIk5GRFwiKS5zdWJzdHIoMCwgc2FmZUxocy5sZW5ndGgpO1xuICAgICAgICBpZiAoY29sbGF0b3IpXG4gICAgICAgICAgICBjb21wYXJlID0gY29sbGF0b3IuY29tcGFyZShzYWZlTGhzLCBzYWZlUmhzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGFyZSA9IHNhZmVMaHMudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKHNhZmVSaHMudG9Mb3dlckNhc2UoKSA/PyBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgfSk7XG4gICAgLy8gSGFuZGxlIGNoYW5nZXMgaW4gdHlwZWFoZWFkIHRoYXQgY2F1c2UgY2hhbmdlcyB0byB0aGUgdGFiYmFibGUgaW5kZXhcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY3VycmVudFR5cGVhaGVhZCAmJiBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgc29ydGVkVHlwZWFoZWFkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCBjdXJyZW50VHlwZWFoZWFkLCBjb21wYXJhdG9yKTtcbiAgICAgICAgICAgIGlmIChzb3J0ZWRUeXBlYWhlYWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBoYXMgdHlwZWQgYW4gZW50cnkgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgLy8gKG9yIG1vcmUgc3BlY2lmaWNhbGx5IFwiZm9yIHdoaWNoIHRoZXJlIGlzIG5vIGVudHJ5IHRoYXQgc3RhcnRzIHdpdGggdGhhdCBpbnB1dFwiKVxuICAgICAgICAgICAgICAgIHNldEludmFsaWRUeXBlYWhlYWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgV2Uga25vdyByb3VnaGx5IHdoZXJlLCBpbiB0aGUgc29ydGVkIGFycmF5IG9mIHN0cmluZ3MsIG91ciBuZXh0IHR5cGVhaGVhZCBsb2NhdGlvbiBpcy5cbiAgICAgICAgICAgICAgICAgIEJ1dCByb3VnaGx5IGlzbid0IGdvb2QgZW5vdWdoIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzLlxuICAgICAgICAgICAgICAgICAgVG8gY29udmVydCBvdXIgc29ydGVkIGluZGV4IHRvIHRoZSB1bnNvcnRlZCBpbmRleCB3ZSBuZWVkLCB3ZSBoYXZlIHRvIGZpbmQgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICBlbGVtZW50IHRoYXQgbWF0Y2hlcyB1cyAqYW5kKiAoaWYgYW55IHN1Y2ggZXhpc3QpIGlzICphZnRlciogb3VyIGN1cnJlbnQgc2VsZWN0aW9uLlxuXG4gICAgICAgICAgICAgICAgICBJbiBvdGhlciB3b3JkcywgdGhlIG9ubHkgd2F5IHR5cGVhaGVhZCBtb3ZlcyBiYWNrd2FyZHMgcmVsYXRpdmUgdG8gb3VyIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIGlzIGlmIHRoZSBvbmx5IG90aGVyIG9wdGlvbiBpcyBiZWhpbmQgdXMuXG5cbiAgICAgICAgICAgICAgICAgIEl0J3Mgbm90IHNwZWNpZmllZCBpbiBXQUktQVJJQSB3aGF0IHRvIGRvIGluIHRoYXQgY2FzZS4gIEkgc3VwcG9zZSB3cmFwIGJhY2sgdG8gdGhlIHN0YXJ0P1xuICAgICAgICAgICAgICAgICAgVGhvdWdoIHRoZXJlJ3MgYWxzbyBhIGNhc2UgZm9yIGp1c3QgZ29pbmcgdXB3YXJkcyB0byB0aGUgbmVhcmVzdCB0byBwcmV2ZW50IGp1bXBpbmVzcy5cbiAgICAgICAgICAgICAgICAgIEJ1dCBpZiB5b3UncmUgYWxyZWFkeSBkb2luZyB0eXBlYWhlYWQgb24gYW4gdW5zb3J0ZWQgbGlzdCwgbGlrZSwganVtcGluZXNzIGNhbid0IGJlIGF2b2lkZWQuXG4gICAgICAgICAgICAgICAgICBJIGR1bm5vLiBHb2luZyBiYWNrIHRvIHRoZSBzdGFydCBpcyB0aGUgc2ltcGxpc3QgdGhvdWdoLlxuXG4gICAgICAgICAgICAgICAgICBCYXNpY2FsbHkgd2hhdCB0aGlzIGRvZXM6IFN0YXJ0aW5nIGZyb20gd2hlcmUgd2UgZm91bmQgb3Vyc2VsdmVzIGFmdGVyIG91ciBiaW5hcnkgc2VhcmNoLFxuICAgICAgICAgICAgICAgICAgc2NhbiBiYWNrd2FyZHMgYW5kIGZvcndhcmRzIHRocm91Z2ggYWxsIGFkamFjZW50IGVudHJpZXMgdGhhdCBhbHNvIGNvbXBhcmUgZXF1YWxseSBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICB3ZSBjYW4gZmluZCB0aGUgb25lIHdob3NlIGB1bnNvcnRlZEluZGV4YCBpcyB0aGUgbG93ZXN0IGFtb25nc3QgYWxsIG90aGVyIGVxdWFsIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgIChhbmQgYWxzbyB0aGUgbG93ZXN0IGB1bnNvcnRlZEluZGV4YCB5YWRkYSB5YWRkYSBleGNlcHQgdGhhdCBpdCBjb21lcyBhZnRlciB1cykuXG5cbiAgICAgICAgICAgICAgICAgIFRPRE86IFRoZSBiaW5hcnkgc2VhcmNoIHN0YXJ0cyB0aGlzIG9mZiB3aXRoIGEgc29saWQgTyhsb2cgbiksIGJ1dCBvbmUtY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICBzZWFyY2hlcyBhcmUsIHRoYW5rcyB0byBwaWdlb25ob2xlIHByaW5jaXBhbCwgZXZlbnR1YWxseSBndWFyYW50ZWVkIHRvIGJlY29tZVxuICAgICAgICAgICAgICAgICAgTyhuKmxvZyBuKS4gVGhpcyBpcyBhbm5veWluZyBidXQgcHJvYmFibHkgbm90IGVhc2lseSBzb2x2YWJsZT8gVGhlcmUgY291bGQgYmUgYW5cbiAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiBmb3Igb25lLWNoYXJhY3RlciBzdHJpbmdzLCBidXQgdGhhdCdzIGp1c3Qga2lja2luZyB0aGUgY2FuIGRvd25cbiAgICAgICAgICAgICAgICAgIHRoZSByb2FkLiBNYXliZSBvbmUgb3IgdHdvIGNoYXJhY3RlcnMgd291bGQgYmUgZ29vZCBlbm91Z2ggdGhvdWdoLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY2FuZGlkYXRlcycgcG9zaXRpb25zIGluIGJvdGggb3VyIHNvcnRlZCBhcnJheSBhbmQgdGhlIHVuc29ydGVkIERPTS5cbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4QWxsID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgdHdvIGFyZSBvbmx5IHNldCBmb3IgZWxlbWVudHMgdGhhdCBhcmUgYWhlYWQgb2YgdXMsIGJ1dCB0aGUgcHJpbmNpcGxlJ3MgdGhlIHNhbWUgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0U29ydGVkSW5kZXhOZXh0ID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlQmVzdEZpdCA9ICh1KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U29ydGVkSW5kZXhBbGwgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPT0gbnVsbCB8fCB1IDwgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQpICYmIHUgPiBnZXRJbmRleCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9IHU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgY29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQmVzdEZpdChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50Lmxlbmd0aCAmJiBjb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleE5leHRdLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleEFsbF0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbY3VycmVudFR5cGVhaGVhZF0pO1xuICAgIGNvbnN0IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCA9IHVzZUNhbGxiYWNrKCh7IHRleHQsIC4uLmkgfSkgPT4ge1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHdoZXJlIHRvIGluc2VydCB0aGlzIGl0ZW0uXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBhbGwgaW5kZXggdmFsdWVzIHNob3VsZCBiZSB1bmlxdWUsIHRoZSByZXR1cm5lZCBzb3J0ZWRJbmRleFxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBhbHdheXMgcmVmZXIgdG8gYSBuZXcgbG9jYXRpb24gKGkuZS4gYmUgbmVnYXRpdmUpICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIHRleHQsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKC1zb3J0ZWRJbmRleCAtIDEsIDAsIHsgdGV4dCwgdW5zb3J0ZWRJbmRleDogaS5pbmRleCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1bm1vdW50aW5nLCBmaW5kIHdoZXJlIHdlIHdlcmUgYW5kIHJlbW92ZSBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFnYWluLCB3ZSBzaG91bGQgYWx3YXlzIGZpbmQgb3Vyc2VsdmVzIGJlY2F1c2UgdGhlcmUgc2hvdWxkIGJlIG5vIGR1cGxpY2F0ZSB2YWx1ZXMgaWYgZWFjaCBpbmRleCBpcyB1bmlxdWUuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIHRleHQsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA+PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2Uoc29ydGVkSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3RleHRdKTtcbiAgICAgICAgY29uc3QgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUHJvcHMgPSBmdW5jdGlvbiAoeyAuLi5wcm9wcyB9KSB7XG4gICAgICAgICAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcywgZWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudCgpO1xuICAgICAgICAgICAgY29uc3Qgb25Db21wb3NpdGlvblN0YXJ0ID0gKGUpID0+IHsgc2V0SW1lQWN0aXZlKHRydWUpOyB9O1xuICAgICAgICAgICAgY29uc3Qgb25Db21wb3NpdGlvbkVuZCA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoZS5kYXRhKTtcbiAgICAgICAgICAgICAgICBzZXRJbWVBY3RpdmUoZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW1lQWN0aXZlID0gZ2V0SW1lQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IGUua2V5O1xuICAgICAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxuICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUgJiYgZS5rZXkgPT09IFwiQmFja3NwYWNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsYXN0IGNoYXJhY3RlciBpbiBhIHdheSB0aGF0IGRvZXNuJ3Qgc3BsaXQgVVRGLTE2IHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlYWhlYWQodCA9PiB0ID09PSBudWxsID8gbnVsbCA6IFsuLi50XS5yZXZlcnNlKCkuc2xpY2UoMSkucmV2ZXJzZSgpLmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIGtleSBwcm9wZXJ0eSByZXByZXNlbnRzIHRoZSB0eXBlZCBjaGFyYWN0ZXIgT1IgdGhlIFwibmFtZWQga2V5IGF0dHJpYnV0ZVwiIG9mIHRoZSBrZXkgcHJlc3NlZC5cbiAgICAgICAgICAgICAgICAvLyBUaGVyZSdzIG5vIGRlZmluaXRlIHdheSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlLCBidXQgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3Nlc1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBvbmUtY2hhcmFjdGVyIG5hbWVzLCBhbmQgdGhlcmUgYXJlIG5vIG5vbi1BU0NJSS1hbHBoYSBuYW1lcy5cbiAgICAgICAgICAgICAgICAvLyBUaHVzLCBhbnkgb25lLWNoYXJhY3RlciBvciBub24tQVNDSUkgdmFsdWUgZm9yIGBrZXlgIGlzICphbG1vc3QgY2VydGFpbmx5KiBhIHR5cGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICBjb25zdCBpc0NoYXJhY3RlcktleSA9IChrZXkubGVuZ3RoID09PSAxIHx8ICEvXltBLVphLXpdLy50ZXN0KGtleSkpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlcktleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwiIFwiICYmIChnZXRDdXJyZW50VHlwZWFoZWFkKCkgPz8gXCJcIikudHJpbSgpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBiZWNhdXNlIGEgc3BhY2ViYXIgY2FuJ3QgZXZlciBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIGEgdHlwZWFoZWFkLCBvbmx5IGNvbnRpbnVlIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChTcGVjaWZpY2FsbHksIGxldCB0aGUgZXZlbnQgY29udGludWUgcHJvcGFnYXRpb24gaW4gdGhpcyBjYXNlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdvbid0IGJlIHRydWUgZm9yIHRoZSBmaXJzdCBrZXlkb3duXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWZvcmUgdXNlTGF5b3V0RWZmZWN0IGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYWN0dWFsbHkgYXBwbHkgdGhlIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh1c2VSZWZFbGVtZW50UHJvcHMoeyBvbktleURvd24sIG9uQ29tcG9zaXRpb25TdGFydCwgb25Db21wb3NpdGlvbkVuZCwgfSksIHByb3BzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFByb3BzXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZCxcbiAgICB9O1xufVxuLyoqXG4gKiBZb3VyIHVzdWFsIGJpbmFyeSBzZWFyY2ggaW1wbGVtZW50YXRpb24uXG4gKlxuICogSXQncyB1c2VkIGhlcmUgdG8gcXVpY2tseSBmaW5kIGEgZ29vZCBzcG90IHRvIHN0YXJ0IHNlYXJjaGluZyBmb3Igb3VyIG5leHQgdHlwZWFoZWFkIGNhbmRpZGF0ZS5cbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoIHRocm91Z2hcbiAqIEBwYXJhbSB3YW50ZWQgVGhlIHZhbHVlIHlvdSdkIGxpa2UgdG8gZmluZFxuICogQHBhcmFtIGNvbXBhcmF0b3IgQ29tcGFyZXMgYHdhbnRlZGAgd2l0aCB0aGUgY3VycmVudCB2YWx1ZSBpbiBgYXJyYXlgXG4gKiBAcmV0dXJucyBBIG5vbi1uZWdhdGl2ZSB2YWx1ZSBpZiBgd2FudGVkYCB3YXMgZm91bmQsIGFuZCBhIG5lZ2F0aXZlIG51bWJlciBpZiBub3QuXG4gKiBUaGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBudW1iZXIsIG1pbnVzIG9uZSwgaXMgd2hlcmUgYHdhbnRlZGAgKndvdWxkKiBiZSBmb3VuZCBpZiBpdCAqd2FzKiBpbiBgYXJyYXlgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2goYXJyYXksIHdhbnRlZCwgY29tcGFyYXRvcikge1xuICAgIHZhciBmaXJzdEluZGV4ID0gMDtcbiAgICB2YXIgbGFzdEluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoZmlyc3RJbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgdmFyIHRlc3RJbmRleCA9IChsYXN0SW5kZXggKyBmaXJzdEluZGV4KSA+PiAxO1xuICAgICAgICB2YXIgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmF0b3Iod2FudGVkLCBhcnJheVt0ZXN0SW5kZXhdKTtcbiAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgICAgICBmaXJzdEluZGV4ID0gdGVzdEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gdGVzdEluZGV4IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC1maXJzdEluZGV4IC0gMTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1rZXlib2FyZC1uYXZpZ2F0aW9uLmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlUm92aW5nVGFiSW5kZXggfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XG5pbXBvcnQgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcbi8qKlxuICpcbiAqIFRPRE86IFRoaXMgdGFibGUgd2FzIHNjcmFwcGVkIHdoZW4gdGhpcyB3YXMgY2hhbmdlZCB0byBqdXN0IGFjY2VwdCBhIGNvbGxhdG9yIGRpcmVjdGx5LFxuICogYnV0IGl0J3Mgbm90IGJhZCBmb3IgYSBjb2xsYXRpb24gY3Jhc2ggY291cnNlIGFuZCBJIG1pZ2h0IHVzZSBpdCBhZ2Fpbi5cbiAqIEV2ZW4ganVzdCBhcyBhIFwidGhpcyBpcyB3aHkgaXQncyBpbXBvcnRhbnQgYW5kIGdvb2QgdG8gdXNlIHRoZXNlIHRoaW5nc1wiIHRoaW5nLlxuICpcbiAqIHxMYW5nLnxUYXJnZXR8VXNlciBpbnB1dHxgYmFzZWB8YGFjY2VudGB8YGNhc2VgfGB2YXJpYW50YHxcbiAqIHwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfFxuICogfEVOfEhpfEhpfOKchXzinIV84pyFfOKchXxcbiAqIHxFTnxIaXzvvKjvvYl84pyFfOKchXzinIV84p2MfFxuICogfEVOfEhpfGhpfOKchXzinIV84p2MfOKdjHxcbiAqIHxFTnxIaXxIw6984pyFfOKdjHzinYx84p2MfFxuICogfEVOfEhpfEJ5ZXzinYx84p2MfOKdjHzinYx8XG4gKiB8REF8w6V8YWF84pyFfOKchXzinIV84p2MfFxuICogfERBfMOlfEFBfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxBYXzinIV84pyFfOKdjHzinYx8XG4gKiB8RU58w6V8YWF84p2MfOKdjHzinYx84p2MfFxuICogfERBfMOlfGFBfOKdjHzinYx84p2MfOKdjHxcbiAqIHxFTnzDpXxhfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxhfOKchXzinIV84p2MfOKdjHxcbiAqIHxKUHzvqqp8552AfOKchXzinIV84pyFfOKchXxcbiAqIHxKUHzjgqt87722fOKchXzinIV84pyFfOKchXxcbiAqIHxKUHzjgqt844GLfOKchXzinIV84pyFfOKdjHxcbiAqIHxKUHzjgqt844O1fOKchXzinIV84pyFfOKdjHxcbiAqIHxKUHzjgqt844uVfOKchXzinIV84p2MfOKdjHxcbiAqIHxKUHzjgqt844KsfOKchXzinYx84p2MfOKdjHxcbiAqIHxKUHzjgqt85YqbfOKdjHzinYx84p2MfOKdjHxcbiAqIHxaSHzntIV857qifOKdjHzinYx84p2MfOKdjHxcbiAqXG4gKlxuICogKE5vdGUgdG8gc2VsZjogQXQgc29tZSBwb2ludCwgdGhpcyBmaWxlIHdpbGwgcHJvYmFibHkgYmUgbm9ybWFsaXplZFxuICogYnkgc29tZWJvZHkgYW5kIO+qqiB3aWxsIHR1cm4gYmFjayBpbnRvIOedgC4pXG4gKlxuICovXG5jb25zdCBkdW1teSA9IG51bGw7XG4vKipcbiAqIEltcGxlbWVudHMgcHJvcGVyIGtleWJvYXJkIG5hdmlnYXRpb24gZm9yIGNvbXBvbmVudHMgbGlrZSBsaXN0Ym94ZXMsIGJ1dHRvbiBncm91cHMsIG1lbnVzLCBldGMuXG4gKlxuICogSW4gdGhlIGRvY3VtZW50IG9yZGVyLCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIFwiZm9jdXNlZFwiIG9yIFwidGFiYmFibGVcIiBlbGVtZW50LCBtYWtpbmcgaXQgYWN0IG1vcmUgbGlrZSBvbmUgY29tcGxldGUgdW5pdCBpbiBjb21wYXJpc29uIHRvIGV2ZXJ5dGhpbmcgYXJvdW5kIGl0LlxuICogTmF2aWdhdGluZyBmb3J3YXJkcy9iYWNrd2FyZHMgY2FuIGJlIGRvbmUgd2l0aCB0aGUgYXJyb3cga2V5cywgSG9tZS9FbmQga2V5cywgb3IgYW55IGFueSB0ZXh0IGZvciB0eXBlYWhlYWQgdG8gZm9jdXMgdGhlIG5leHQgaXRlbSB0aGF0IG1hdGNoZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbih7IGZvY3VzT25DaGFuZ2UsIGNvbGxhdG9yLCBrZXlOYXZpZ2F0aW9uIH0pIHtcbiAgICBrZXlOYXZpZ2F0aW9uID8/PSBcImVpdGhlclwiO1xuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhyZWUgdGhpbmdzIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnRseSB0YWJiYWJsZSBlbGVtZW50J3MgaW5kZXg6XG4gICAgLy8gV2hhdCBpdCBpcywgYW5kIHdoZXRoZXIsIHdoZW4gd2UgcmVuZGVyIHRoaXMgY29tcG9uZW50IGFuZCBpdCdzIGNoYW5nZWQsIHRvIGFsc28gZm9jdXMgdGhlIGVsZW1lbnQgdGhhdCB3YXMgbWFkZSB0YWJiYWJsZS5cbiAgICBjb25zdCBbdGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleCwgZ2V0VGFiYmFibGVJbmRleF0gPSB1c2VTdGF0ZSgwKTtcbiAgICBjb25zdCBzZXRJbmRleCA9IHVzZUNhbGxiYWNrKChpbmRleCkgPT4ge1xuICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGluZGV4KTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW4sIGluZGljZXNCeUVsZW1lbnQsIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIGZvY3VzU2VsZiwgLi4ucmVzdCB9ID0gdXNlUm92aW5nVGFiSW5kZXgoeyBmb2N1c09uQ2hhbmdlLCB0YWJiYWJsZUluZGV4OiB0YWJiYWJsZUluZGV4IH0pO1xuICAgIGNvbnN0IHsgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCwgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uKHsgY29sbGF0b3IsIGdldEluZGV4OiBnZXRUYWJiYWJsZUluZGV4LCBzZXRJbmRleCwgdHlwZWFoZWFkVGltZW91dDogMTAwMCB9KTtcbiAgICBjb25zdCB7IG5hdmlnYXRlVG9FbmQsIG5hdmlnYXRlVG9JbmRleCwgbmF2aWdhdGVUb05leHQsIG5hdmlnYXRlVG9QcmV2LCBuYXZpZ2F0ZVRvU3RhcnQsIHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZCB9ID0gdXNlTGluZWFyTmF2aWdhdGlvbih7IGdldEluZGV4OiBnZXRUYWJiYWJsZUluZGV4LCBzZXRJbmRleCwgbWFuYWdlZENoaWxkcmVuIH0pO1xuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjaygoaW5mbykgPT4ge1xuICAgICAgICBjb25zdCB7IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFByb3BzIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQoaW5mbyk7XG4gICAgICAgIGNvbnN0IHsgdXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkUHJvcHMgfSA9IHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZCgpO1xuICAgICAgICBjb25zdCB7IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcywgdXNlUm92aW5nVGFiSW5kZXhTaWJsaW5nUHJvcHMsIHRhYmJhYmxlIH0gPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkKGluZm8pO1xuICAgICAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMgPSBmdW5jdGlvbiAoeyAuLi5wcm9wcyB9KSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHModXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUHJvcHModXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkUHJvcHMoeyBvbkNsaWNrOiByb3ZlVG9TZWxmIH0pKSksIHByb3BzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgcm92ZVRvU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHsgbmF2aWdhdGVUb0luZGV4KGluZm8uaW5kZXgpOyB9LCBbXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsXG4gICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpYmxpbmdQcm9wczogdXNlUm92aW5nVGFiSW5kZXhTaWJsaW5nUHJvcHMsXG4gICAgICAgICAgICB0YWJiYWJsZSxcbiAgICAgICAgICAgIC8vcm92ZVRvU2VsZixcbiAgICAgICAgICAgIC8vZWxlbWVudFxuICAgICAgICB9O1xuICAgIH0sIFt1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsIHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZCwgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgbmF2aWdhdGVUb0luZGV4XSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZCxcbiAgICAgICAgdGFiYmFibGVJbmRleCxcbiAgICAgICAgc2V0VGFiYmFibGVJbmRleCxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxuICAgICAgICBpbmRpY2VzQnlFbGVtZW50LFxuICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgsXG4gICAgICAgIG5hdmlnYXRlVG9OZXh0LFxuICAgICAgICBuYXZpZ2F0ZVRvUHJldixcbiAgICAgICAgbmF2aWdhdGVUb1N0YXJ0LFxuICAgICAgICBuYXZpZ2F0ZVRvRW5kLFxuICAgICAgICBmb2N1c1NlbGYsXG4gICAgICAgIC4uLnJlc3RcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWxpc3QtbmF2aWdhdGlvbi5qcy5tYXAiLCIvKiFcbiogdGFiYmFibGUgNS4yLjBcbiogQGxpY2Vuc2UgTUlULCBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC90YWJiYWJsZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xudmFyIGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFsnaW5wdXQnLCAnc2VsZWN0JywgJ3RleHRhcmVhJywgJ2FbaHJlZl0nLCAnYnV0dG9uJywgJ1t0YWJpbmRleF0nLCAnYXVkaW9bY29udHJvbHNdJywgJ3ZpZGVvW2NvbnRyb2xzXScsICdbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdKScsICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScsICdkZXRhaWxzJ107XG52YXIgY2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi9jYW5kaWRhdGVTZWxlY3RvcnMuam9pbignLCcpO1xudmFyIG1hdGNoZXMgPSB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgPyBmdW5jdGlvbiAoKSB7fSA6IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG52YXIgZ2V0Q2FuZGlkYXRlcyA9IGZ1bmN0aW9uIGdldENhbmRpZGF0ZXMoZWwsIGluY2x1ZGVDb250YWluZXIsIGZpbHRlcikge1xuICB2YXIgY2FuZGlkYXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9yKSk7XG5cbiAgaWYgKGluY2x1ZGVDb250YWluZXIgJiYgbWF0Y2hlcy5jYWxsKGVsLCBjYW5kaWRhdGVTZWxlY3RvcikpIHtcbiAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICB9XG5cbiAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxudmFyIGlzQ29udGVudEVkaXRhYmxlID0gZnVuY3Rpb24gaXNDb250ZW50RWRpdGFibGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJztcbn07XG5cbnZhciBnZXRUYWJpbmRleCA9IGZ1bmN0aW9uIGdldFRhYmluZGV4KG5vZGUpIHtcbiAgdmFyIHRhYmluZGV4QXR0ciA9IHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG5cbiAgaWYgKCFpc05hTih0YWJpbmRleEF0dHIpKSB7XG4gICAgcmV0dXJuIHRhYmluZGV4QXR0cjtcbiAgfSAvLyBCcm93c2VycyBkbyBub3QgcmV0dXJuIGB0YWJJbmRleGAgY29ycmVjdGx5IGZvciBjb250ZW50RWRpdGFibGUgbm9kZXM7XG4gIC8vIHNvIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHRhYmluZGV4IGF0dHJpYnV0ZSBzcGVjaWZpY2FsbHkgc2V0LCBhc3N1bWUgaXQncyAwLlxuXG5cbiAgaWYgKGlzQ29udGVudEVkaXRhYmxlKG5vZGUpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gaW4gQ2hyb21lLCA8ZGV0YWlscy8+LCA8YXVkaW8gY29udHJvbHMvPiBhbmQgPHZpZGVvIGNvbnRyb2xzLz4gZWxlbWVudHMgZ2V0IGEgZGVmYXVsdFxuICAvLyAgYHRhYkluZGV4YCBvZiAtMSB3aGVuIHRoZSAndGFiaW5kZXgnIGF0dHJpYnV0ZSBpc24ndCBzcGVjaWZpZWQgaW4gdGhlIERPTSxcbiAgLy8gIHlldCB0aGV5IGFyZSBzdGlsbCBwYXJ0IG9mIHRoZSByZWd1bGFyIHRhYiBvcmRlcjsgaW4gRkYsIHRoZXkgZ2V0IGEgZGVmYXVsdFxuICAvLyAgYHRhYkluZGV4YCBvZiAwOyBzaW5jZSBDaHJvbWUgc3RpbGwgcHV0cyB0aG9zZSBlbGVtZW50cyBpbiB0aGUgcmVndWxhciB0YWJcbiAgLy8gIG9yZGVyLCBjb25zaWRlciB0aGVpciB0YWIgaW5kZXggdG8gYmUgMC5cblxuXG4gIGlmICgobm9kZS5ub2RlTmFtZSA9PT0gJ0FVRElPJyB8fCBub2RlLm5vZGVOYW1lID09PSAnVklERU8nIHx8IG5vZGUubm9kZU5hbWUgPT09ICdERVRBSUxTJykgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBub2RlLnRhYkluZGV4O1xufTtcblxudmFyIHNvcnRPcmRlcmVkVGFiYmFibGVzID0gZnVuY3Rpb24gc29ydE9yZGVyZWRUYWJiYWJsZXMoYSwgYikge1xuICByZXR1cm4gYS50YWJJbmRleCA9PT0gYi50YWJJbmRleCA/IGEuZG9jdW1lbnRPcmRlciAtIGIuZG9jdW1lbnRPcmRlciA6IGEudGFiSW5kZXggLSBiLnRhYkluZGV4O1xufTtcblxudmFyIGlzSW5wdXQgPSBmdW5jdGlvbiBpc0lucHV0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0lOUFVUJztcbn07XG5cbnZhciBpc0hpZGRlbklucHV0ID0gZnVuY3Rpb24gaXNIaWRkZW5JbnB1dChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ2hpZGRlbic7XG59O1xuXG52YXIgaXNEZXRhaWxzV2l0aFN1bW1hcnkgPSBmdW5jdGlvbiBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB7XG4gIHZhciByID0gbm9kZS50YWdOYW1lID09PSAnREVUQUlMUycgJiYgQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG5vZGUuY2hpbGRyZW4pLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLnRhZ05hbWUgPT09ICdTVU1NQVJZJztcbiAgfSk7XG4gIHJldHVybiByO1xufTtcblxudmFyIGdldENoZWNrZWRSYWRpbyA9IGZ1bmN0aW9uIGdldENoZWNrZWRSYWRpbyhub2RlcywgZm9ybSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldLmNoZWNrZWQgJiYgbm9kZXNbaV0uZm9ybSA9PT0gZm9ybSkge1xuICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGlzVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIGlzVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIGlmICghbm9kZS5uYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgcmFkaW9TY29wZSA9IG5vZGUuZm9ybSB8fCBub2RlLm93bmVyRG9jdW1lbnQ7XG5cbiAgdmFyIHF1ZXJ5UmFkaW9zID0gZnVuY3Rpb24gcXVlcnlSYWRpb3MobmFtZSkge1xuICAgIHJldHVybiByYWRpb1Njb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJyk7XG4gIH07XG5cbiAgdmFyIHJhZGlvU2V0O1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkNTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLCBlcnIubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoZWNrZWQgPSBnZXRDaGVja2VkUmFkaW8ocmFkaW9TZXQsIG5vZGUuZm9ybSk7XG4gIHJldHVybiAhY2hlY2tlZCB8fCBjaGVja2VkID09PSBub2RlO1xufTtcblxudmFyIGlzUmFkaW8gPSBmdW5jdGlvbiBpc1JhZGlvKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAncmFkaW8nO1xufTtcblxudmFyIGlzTm9uVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIHJldHVybiBpc1JhZGlvKG5vZGUpICYmICFpc1RhYmJhYmxlUmFkaW8obm9kZSk7XG59O1xuXG52YXIgaXNIaWRkZW4gPSBmdW5jdGlvbiBpc0hpZGRlbihub2RlLCBkaXNwbGF5Q2hlY2spIHtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUobm9kZSkudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpc0RpcmVjdFN1bW1hcnkgPSBtYXRjaGVzLmNhbGwobm9kZSwgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyk7XG4gIHZhciBub2RlVW5kZXJEZXRhaWxzID0gaXNEaXJlY3RTdW1tYXJ5ID8gbm9kZS5wYXJlbnRFbGVtZW50IDogbm9kZTtcblxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGVVbmRlckRldGFpbHMsICdkZXRhaWxzOm5vdChbb3Blbl0pIConKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCFkaXNwbGF5Q2hlY2sgfHwgZGlzcGxheUNoZWNrID09PSAnZnVsbCcpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUobm9kZSkuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwbGF5Q2hlY2sgPT09ICdub24temVyby1hcmVhJykge1xuICAgIHZhciBfbm9kZSRnZXRCb3VuZGluZ0NsaWUgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICB3aWR0aCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLmhlaWdodDtcblxuICAgIHJldHVybiB3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDA7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSA9IGZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSkge1xuICBpZiAobm9kZS5kaXNhYmxlZCB8fCBpc0hpZGRlbklucHV0KG5vZGUpIHx8IGlzSGlkZGVuKG5vZGUsIG9wdGlvbnMuZGlzcGxheUNoZWNrKSB8fFxuICAvKiBGb3IgYSBkZXRhaWxzIGVsZW1lbnQgd2l0aCBhIHN1bW1hcnksIHRoZSBzdW1tYXJ5IGVsZW1lbnQgZ2V0cyB0aGUgZm9jdXNlZCAgKi9cbiAgaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUgPSBmdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSkge1xuICBpZiAoIWlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSkgfHwgaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHx8IGdldFRhYmluZGV4KG5vZGUpIDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHRhYmJhYmxlID0gZnVuY3Rpb24gdGFiYmFibGUoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciByZWd1bGFyVGFiYmFibGVzID0gW107XG4gIHZhciBvcmRlcmVkVGFiYmFibGVzID0gW107XG4gIHZhciBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhlbCwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKSk7XG4gIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoY2FuZGlkYXRlLCBpKSB7XG4gICAgdmFyIGNhbmRpZGF0ZVRhYmluZGV4ID0gZ2V0VGFiaW5kZXgoY2FuZGlkYXRlKTtcblxuICAgIGlmIChjYW5kaWRhdGVUYWJpbmRleCA9PT0gMCkge1xuICAgICAgcmVndWxhclRhYmJhYmxlcy5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yZGVyZWRUYWJiYWJsZXMucHVzaCh7XG4gICAgICAgIGRvY3VtZW50T3JkZXI6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVUYWJpbmRleCxcbiAgICAgICAgbm9kZTogY2FuZGlkYXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICB2YXIgdGFiYmFibGVOb2RlcyA9IG9yZGVyZWRUYWJiYWJsZXMuc29ydChzb3J0T3JkZXJlZFRhYmJhYmxlcykubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGEubm9kZTtcbiAgfSkuY29uY2F0KHJlZ3VsYXJUYWJiYWJsZXMpO1xuICByZXR1cm4gdGFiYmFibGVOb2Rlcztcbn07XG5cbnZhciBmb2N1c2FibGUgPSBmdW5jdGlvbiBmb2N1c2FibGUoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhlbCwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbnZhciBpc1RhYmJhYmxlID0gZnVuY3Rpb24gaXNUYWJiYWJsZShub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICB9XG5cbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBjYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbnZhciBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqL2NhbmRpZGF0ZVNlbGVjdG9ycy5jb25jYXQoJ2lmcmFtZScpLmpvaW4oJywnKTtcblxudmFyIGlzRm9jdXNhYmxlID0gZnVuY3Rpb24gaXNGb2N1c2FibGUobm9kZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuXG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpO1xufTtcblxuZXhwb3J0IHsgZm9jdXNhYmxlLCBpc0ZvY3VzYWJsZSwgaXNUYWJiYWJsZSwgdGFiYmFibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4oKCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgcHJvcGVydGllcyAqL1xuICAgIGNvbnN0IF9ibG9ja2luZ0VsZW1lbnRzID0gU3ltYm9sKCk7XG4gICAgY29uc3QgX2FscmVhZHlJbmVydEVsZW1lbnRzID0gU3ltYm9sKCk7XG4gICAgY29uc3QgX3RvcEVsUGFyZW50cyA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IF9zaWJsaW5nc1RvUmVzdG9yZSA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IF9wYXJlbnRNTyA9IFN5bWJvbCgpO1xuICAgIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgc3RhdGljIG1ldGhvZHMgKi9cbiAgICBjb25zdCBfdG9wQ2hhbmdlZCA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IF9zd2FwSW5lcnRlZFNpYmxpbmcgPSBTeW1ib2woKTtcbiAgICBjb25zdCBfaW5lcnRTaWJsaW5ncyA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IF9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gICAgY29uc3QgX2dldFBhcmVudHMgPSBTeW1ib2woKTtcbiAgICBjb25zdCBfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbiA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IF9pc0luZXJ0YWJsZSA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IF9oYW5kbGVNdXRhdGlvbnMgPSBTeW1ib2woKTtcbiAgICBjbGFzcyBCbG9ja2luZ0VsZW1lbnRzSW1wbCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXNbX2FdID0gW107XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcGFyZW50cyBvZiB0aGUgdG9wIGVsZW1lbnQsIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAqIGl0c2VsZiB1cCB0byBib2R5LiBXaGVuIHRvcCBjaGFuZ2VzLCB0aGUgb2xkIHRvcCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgICogZnJvbSB0aGUgZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gbWVtb2l6ZSB0aGUgaW5lcnRlZCBwYXJlbnRzJyBzaWJsaW5nc1xuICAgICAgICAgICAgICogaW4gb3JkZXIgdG8gcmVzdG9yZSB0aGVpciBpbmVydGVuZXNzIHdoZW4gdG9wIGNoYW5nZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXNbX2JdID0gW107XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVsZW1lbnRzIHRoYXQgYXJlIGFscmVhZHkgaW5lcnQgYmVmb3JlIHRoZSBmaXJzdCBibG9ja2luZyBlbGVtZW50IGlzXG4gICAgICAgICAgICAgKiBwdXNoZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXNbX2NdID0gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGluZXJ0bmVzcy5cbiAgICAgICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKHRoaXNbX3RvcEVsUGFyZW50c10pO1xuICAgICAgICAgICAgLy8gTm90ZSB3ZSBkb24ndCB3YW50IHRvIG1ha2UgdGhlc2UgcHJvcGVydGllcyBudWxsYWJsZSBvbiB0aGUgY2xhc3MsXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGVuIHdlJ2QgbmVlZCBub24tbnVsbCBjYXN0cyBpbiBtYW55IHBsYWNlcy4gQ2FsbGluZyBhIG1ldGhvZCBvblxuICAgICAgICAgICAgLy8gYSBCbG9ja2luZ0VsZW1lbnRzIGluc3RhbmNlIGFmdGVyIGNhbGxpbmcgZGVzdHJ1Y3RvciB3aWxsIHJlc3VsdCBpbiBhblxuICAgICAgICAgICAgLy8gZXhjZXB0aW9uLlxuICAgICAgICAgICAgY29uc3QgbnVsbGFibGUgPSB0aGlzO1xuICAgICAgICAgICAgbnVsbGFibGVbX2Jsb2NraW5nRWxlbWVudHNdID0gbnVsbDtcbiAgICAgICAgICAgIG51bGxhYmxlW190b3BFbFBhcmVudHNdID0gbnVsbDtcbiAgICAgICAgICAgIG51bGxhYmxlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGdldCB0b3AoKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtcyA9IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1zW2VsZW1zLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy50b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIHdlJ2xsIGJyaW5nIGl0IHRvIHRoZSB0b3AuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXNbX3RvcENoYW5nZWRdKGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmUoZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgaSA9IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAvLyBUb3AgY2hhbmdlZCBvbmx5IGlmIHRoZSByZW1vdmVkIGVsZW1lbnQgd2FzIHRoZSB0b3AgZWxlbWVudC5cbiAgICAgICAgICAgIGlmIChpID09PSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzW190b3BDaGFuZ2VkXSh0aGlzLnRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwb3AoKSB7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgIHRvcCAmJiB0aGlzLnJlbW92ZSh0b3ApO1xuICAgICAgICAgICAgcmV0dXJuIHRvcDtcbiAgICAgICAgfVxuICAgICAgICBoYXMoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmluZGV4T2YoZWxlbWVudCkgIT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGBpbmVydGAgdG8gYWxsIGRvY3VtZW50IGVsZW1lbnRzIGV4Y2VwdCB0aGUgbmV3IHRvcCBlbGVtZW50LCBpdHNcbiAgICAgICAgICogcGFyZW50cywgYW5kIGl0cyBkaXN0cmlidXRlZCBjb250ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgWyhfYSA9IF9ibG9ja2luZ0VsZW1lbnRzLCBfYiA9IF90b3BFbFBhcmVudHMsIF9jID0gX2FscmVhZHlJbmVydEVsZW1lbnRzLCBfdG9wQ2hhbmdlZCldKG5ld1RvcCkge1xuICAgICAgICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICAgICAgICBjb25zdCBvbGRQYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgICAgICAgIC8vIE5vIG5ldyB0b3AsIHJlc2V0IG9sZCB0b3AgaWYgYW55LlxuICAgICAgICAgICAgaWYgKCFuZXdUb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzKTtcbiAgICAgICAgICAgICAgICB0b0tlZXBJbmVydC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdQYXJlbnRzID0gdGhpc1tfZ2V0UGFyZW50c10obmV3VG9wKTtcbiAgICAgICAgICAgIC8vIE5ldyB0b3AgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgbWFpbiBkb2N1bWVudCFcbiAgICAgICAgICAgIGlmIChuZXdQYXJlbnRzW25ld1BhcmVudHMubGVuZ3RoIC0gMV0ucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdOb24tY29ubmVjdGVkIGVsZW1lbnQgY2Fubm90IGJlIGEgYmxvY2tpbmcgZWxlbWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FzdCBoZXJlIGJlY2F1c2Ugd2Uga25vdyB3ZSdsbCBjYWxsIF9pbmVydFNpYmxpbmdzIG9uIG5ld1BhcmVudHNcbiAgICAgICAgICAgIC8vIGJlbG93LlxuICAgICAgICAgICAgdGhpc1tfdG9wRWxQYXJlbnRzXSA9IG5ld1BhcmVudHM7XG4gICAgICAgICAgICBjb25zdCB0b1NraXAgPSB0aGlzW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShuZXdUb3ApO1xuICAgICAgICAgICAgLy8gTm8gcHJldmlvdXMgdG9wIGVsZW1lbnQuXG4gICAgICAgICAgICBpZiAoIW9sZFBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cywgdG9Ta2lwLCB0b0tlZXBJbmVydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGkgPSBvbGRQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgaiA9IG5ld1BhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIC8vIEZpbmQgY29tbW9uIHBhcmVudC4gSW5kZXggMCBpcyB0aGUgZWxlbWVudCBpdHNlbGYgKHNvIHN0b3AgYmVmb3JlIGl0KS5cbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBqID4gMCAmJiBvbGRQYXJlbnRzW2ldID09PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHVwIHRoZSBwYXJlbnRzIHRyZWUgdGhlcmUgYXJlIDIgZWxlbWVudHMgdGhhdCBhcmUgc2libGluZ3MsIHN3YXBcbiAgICAgICAgICAgIC8vIHRoZSBpbmVydGVkIHNpYmxpbmcuXG4gICAgICAgICAgICBpZiAob2xkUGFyZW50c1tpXSAhPT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbX3N3YXBJbmVydGVkU2libGluZ10ob2xkUGFyZW50c1tpXSwgbmV3UGFyZW50c1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0bmVzcy5cbiAgICAgICAgICAgIGkgPiAwICYmIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMuc2xpY2UoMCwgaSkpO1xuICAgICAgICAgICAgLy8gTWFrZSBuZXcgcGFyZW50cyBzaWJsaW5ncyBpbmVydC5cbiAgICAgICAgICAgIGogPiAwICYmIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMuc2xpY2UoMCwgaiksIHRvU2tpcCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN3YXBzIGluZXJ0bmVzcyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzLlxuICAgICAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAgICAgKi9cbiAgICAgICAgW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZEluZXJ0LCBuZXdJbmVydCkge1xuICAgICAgICAgICAgY29uc3Qgc2libGluZ3NUb1Jlc3RvcmUgPSBvbGRJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgICAgICAgLy8gb2xkSW5lcnQgaXMgbm90IGNvbnRhaW5lZCBpbiBzaWJsaW5ncyB0byByZXN0b3JlLCBzbyB3ZSBoYXZlIHRvIGNoZWNrXG4gICAgICAgICAgICAvLyBpZiBpdCdzIGluZXJ0YWJsZSBhbmQgaWYgYWxyZWFkeSBpbmVydC5cbiAgICAgICAgICAgIGlmICh0aGlzW19pc0luZXJ0YWJsZV0ob2xkSW5lcnQpICYmICFvbGRJbmVydC5pbmVydCkge1xuICAgICAgICAgICAgICAgIG9sZEluZXJ0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5hZGQob2xkSW5lcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbmV3SW5lcnQgd2FzIGFscmVhZHkgYmV0d2VlbiB0aGUgc2libGluZ3MgdG8gcmVzdG9yZSwgaXQgbWVhbnMgaXQgaXNcbiAgICAgICAgICAgIC8vIGluZXJ0YWJsZSBhbmQgbXVzdCBiZSByZXN0b3JlZC5cbiAgICAgICAgICAgIGlmIChzaWJsaW5nc1RvUmVzdG9yZS5oYXMobmV3SW5lcnQpKSB7XG4gICAgICAgICAgICAgICAgbmV3SW5lcnQuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5kZWxldGUobmV3SW5lcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3SW5lcnRbX3BhcmVudE1PXSA9IG9sZEluZXJ0W19wYXJlbnRNT107XG4gICAgICAgICAgICBuZXdJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gc2libGluZ3NUb1Jlc3RvcmU7XG4gICAgICAgICAgICBvbGRJbmVydFtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgb2xkSW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzdG9yZXMgb3JpZ2luYWwgaW5lcnRuZXNzIHRvIHRoZSBzaWJsaW5ncyBvZiB0aGUgZWxlbWVudHMuXG4gICAgICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICAgICAqL1xuICAgICAgICBbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtbyA9IGVsZW1lbnRbX3BhcmVudE1PXTtcbiAgICAgICAgICAgICAgICBtby5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudFtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdzID0gZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2libGluZyBvZiBzaWJsaW5ncykge1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW5lcnRzIHRoZSBzaWJsaW5ncyBvZiB0aGUgZWxlbWVudHMgZXhjZXB0IHRoZSBlbGVtZW50cyB0byBza2lwLiBTdG9yZXNcbiAgICAgICAgICogdGhlIGluZXJ0ZWQgc2libGluZ3MgaW50byB0aGUgZWxlbWVudCdzIHN5bWJvbCBgX3NpYmxpbmdzVG9SZXN0b3JlYC5cbiAgICAgICAgICogUGFzcyBgdG9LZWVwSW5lcnRgIHRvIGNvbGxlY3QgdGhlIGFscmVhZHkgaW5lcnQgZWxlbWVudHMuXG4gICAgICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICAgICAqL1xuICAgICAgICBbX2luZXJ0U2libGluZ3NdKGVsZW1lbnRzLCB0b1NraXAsIHRvS2VlcEluZXJ0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAvLyBBc3N1bWUgZWxlbWVudCBpcyBub3QgYSBEb2N1bWVudCwgc28gaXQgbXVzdCBoYXZlIGEgcGFyZW50Tm9kZS5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IGNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBpbnB1dCBlbGVtZW50LCBpZiBub3QgaW5lcnRhYmxlIG9yIHRvIGJlIHNraXBwZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nID09PSBlbGVtZW50IHx8ICF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0b1NraXAgJiYgdG9Ta2lwLmhhcyhzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSBjb2xsZWN0ZWQgc2luY2UgYWxyZWFkeSBpbmVydGVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBzaWJsaW5ncyB0aGF0IHdlcmUgaW5lcnRlZC5cbiAgICAgICAgICAgICAgICBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBpbmVydGVkU2libGluZ3M7XG4gICAgICAgICAgICAgICAgLy8gT2JzZXJ2ZSBvbmx5IGltbWVkaWF0ZSBjaGlsZHJlbiBtdXRhdGlvbnMgb24gdGhlIHBhcmVudC5cbiAgICAgICAgICAgICAgICBjb25zdCBtbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXNbX2hhbmRsZU11dGF0aW9uc10uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudFtfcGFyZW50TU9dID0gbW87XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudFRvT2JzZXJ2ZSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgU2hhZHlET00gcG9seWZpbGwsIHRoZW4gb3VyIHBhcmVudCBjb3VsZCBiZSBhXG4gICAgICAgICAgICAgICAgLy8gc2hhZHkgcm9vdCwgd2hpY2ggaXMgYW4gb2JqZWN0IHRoYXQgYWN0cyBsaWtlIGEgU2hhZG93Um9vdCwgYnV0IGlzbid0XG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgYSBub2RlIGluIHRoZSByZWFsIERPTS4gT2JzZXJ2ZSB0aGUgcmVhbCBET00gcGFyZW50IGluc3RlYWQuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF5YmVTaGFkeVJvb3QgPSBwYXJlbnRUb09ic2VydmU7XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlU2hhZHlSb290Ll9fc2hhZHkgJiYgbWF5YmVTaGFkeVJvb3QuaG9zdCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRUb09ic2VydmUgPSBtYXliZVNoYWR5Um9vdC5ob3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtby5vYnNlcnZlKHBhcmVudFRvT2JzZXJ2ZSwge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgbmV3bHkgYWRkZWQvcmVtb3ZlZCBub2RlcyBieSB0b2dnbGluZyB0aGVpciBpbmVydG5lc3MuXG4gICAgICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBjdXJyZW50IHRvcCBCbG9ja2luZyBFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICAgICAqIG5vdGlmeWluZyBhbmQgcmVtb3ZpbmcgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBbX2hhbmRsZU11dGF0aW9uc10obXV0YXRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgICAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgc2hhZG93Um9vdCwgZ2V0IGl0cyBob3N0IGFzIHdlIHNraXAgc2hhZG93Um9vdHMgd2hlblxuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGluZyBfdG9wRWxQYXJlbnRzLlxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG11dGF0aW9uLnRhcmdldC5ob3N0IHx8IG11dGF0aW9uLnRhcmdldDtcbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgP1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHMuaW5kZXhPZih0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZXJ0ZWRDaGlsZCA9IHBhcmVudHNbaWR4IC0gMV07XG4gICAgICAgICAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gaW5lcnRlZENoaWxkW19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAgICAgICAgICAgLy8gVG8gcmVzdG9yZS5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZyA9PT0gaW5lcnRlZENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RldGVjdGVkIHJlbW92YWwgb2YgdGhlIHRvcCBCbG9ja2luZyBFbGVtZW50LicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5lcnRlZFNpYmxpbmdzLmhhcyhzaWJsaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmRlbGV0ZShzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUbyBpbmVydC5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLmFkZGVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGluZXJ0YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIFtfaXNJbmVydGFibGVdKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZSA9PT0gL14oc3R5bGV8dGVtcGxhdGV8c2NyaXB0KSQvLnRlc3QoZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIG5ld1BhcmVudHMgb2YgYW4gZWxlbWVudCwgc3RhcnRpbmcgZnJvbSBlbGVtZW50XG4gICAgICAgICAqIChpbmNsdWRlZCkgdXAgdG8gYGRvY3VtZW50LmJvZHlgIChleGNsdWRlZCkuXG4gICAgICAgICAqL1xuICAgICAgICBbX2dldFBhcmVudHNdKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIC8vIFN0b3AgdG8gYm9keS5cbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHNoYWRvdyByb290cy5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaGFkb3dEb20gdjFcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCBzbG90cyBmcm9tIGRlZXBlc3Qgc2xvdCB0byB0b3AuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZSB0aGUgc2VhcmNoIG9uIHRoZSB0b3Agc2xvdC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIHx8XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBkaXN0cmlidXRlZCBjaGlsZHJlbiBvZiB0aGUgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgc2hhZG93IHJvb3QuXG4gICAgICAgICAqL1xuICAgICAgICBbX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW5dKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBlbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICAgICAgICBpZiAoIXNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IGo7XG4gICAgICAgICAgICBsZXQgbm9kZXM7XG4gICAgICAgICAgICBjb25zdCBzbG90cyA9IHNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgICAgICAgICAgaWYgKHNsb3RzLmxlbmd0aCAmJiBzbG90c1swXS5hc3NpZ25lZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzID0gc2xvdHNbaV0uYXNzaWduZWROb2Rlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXNbal0ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChub2Rlc1tqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBzZWFyY2ggZm9yIDxjb250ZW50Pi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9jdW1lbnQuJGJsb2NraW5nRWxlbWVudHMgPVxuICAgICAgICBuZXcgQmxvY2tpbmdFbGVtZW50c0ltcGwoKTtcbn0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9ja2luZy1lbGVtZW50cy5qcy5tYXAiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ2luZXJ0JywgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICAvKipcbiAgICogVGhpcyB3b3JrIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBXM0MgU29mdHdhcmUgYW5kIERvY3VtZW50IExpY2Vuc2VcbiAgICogKGh0dHA6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvMjAxNS9jb3B5cmlnaHQtc29mdHdhcmUtYW5kLWRvY3VtZW50KS5cbiAgICovXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZXR1cm4gZWFybHkgaWYgd2UncmUgbm90IHJ1bm5pbmcgaW5zaWRlIG9mIHRoZSBicm93c2VyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgICAvKiogQHR5cGUge3R5cGVvZiBBcnJheS5wcm90b3R5cGUuc2xpY2V9ICovXG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgLyoqXG4gICAgICogSUUgaGFzIGEgbm9uLXN0YW5kYXJkIG5hbWUgZm9yIFwibWF0Y2hlc1wiLlxuICAgICAqIEB0eXBlIHt0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc31cbiAgICAgKi9cbiAgICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XG5cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgICAvKipcbiAgICAgKiBgSW5lcnRSb290YCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IHN1YnRyZWUsIGkuZS4gYSBET00gc3VidHJlZSB3aG9zZSByb290IGVsZW1lbnQgaGFzIGFuIGBpbmVydGBcbiAgICAgKiBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBJdHMgbWFpbiBmdW5jdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogLSB0byBjcmVhdGUgYW5kIG1haW50YWluIGEgc2V0IG9mIG1hbmFnZWQgYEluZXJ0Tm9kZWBzLCBpbmNsdWRpbmcgd2hlbiBtdXRhdGlvbnMgb2NjdXIgaW4gdGhlXG4gICAgICogICBzdWJ0cmVlLiBUaGUgYG1ha2VTdWJ0cmVlVW5mb2N1c2FibGUoKWAgbWV0aG9kIGhhbmRsZXMgY29sbGVjdGluZyBgSW5lcnROb2RlYHMgdmlhIHJlZ2lzdGVyaW5nXG4gICAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgICAqICAgZm9jdXNhYmxlIG5vZGVzIHdpdGhpbiBpbmVydCBzdWJ0cmVlcy4gYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgXG4gICAgICogICBpbnN0YW5jZSBleGlzdHMgZm9yIGVhY2ggZm9jdXNhYmxlIG5vZGUgd2hpY2ggaGFzIGF0IGxlYXN0IG9uZSBpbmVydCByb290IGFzIGFuIGFuY2VzdG9yLlxuICAgICAqXG4gICAgICogLSB0byBub3RpZnkgYWxsIG1hbmFnZWQgYEluZXJ0Tm9kZWBzIHdoZW4gdGhpcyBzdWJ0cmVlIHN0b3BzIGJlaW5nIGluZXJ0IChpLmUuIHdoZW4gdGhlIGBpbmVydGBcbiAgICAgKiAgIGF0dHJpYnV0ZSBpcyByZW1vdmVkIGZyb20gdGhlIHJvb3Qgbm9kZSkuIFRoaXMgaXMgaGFuZGxlZCBpbiB0aGUgZGVzdHJ1Y3Rvciwgd2hpY2ggY2FsbHMgdGhlXG4gICAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICAgKi9cblxuICAgIHZhciBJbmVydFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RFbGVtZW50IFRoZSBFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRNYW5hZ2VyfSBpbmVydE1hbmFnZXIgVGhlIGdsb2JhbCBzaW5nbGV0b24gSW5lcnRNYW5hZ2VyIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Um9vdCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshRWxlbWVudH0gKi9cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Tm9kZT59XG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHs/c3RyaW5nfSAqL1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIC8vIE1ha2UgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0aGUgc3VidHJlZSB1bmZvY3VzYWJsZSBhbmQgYWRkIHRoZW0gdG8gX21hbmFnZWROb2Rlc1xuICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgICAvLyBXYXRjaCBmb3I6XG4gICAgICAgIC8vIC0gYW55IGFkZGl0aW9ucyBpbiB0aGUgc3VidHJlZTogbWFrZSB0aGVtIHVuZm9jdXNhYmxlIHRvb1xuICAgICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgICAgLy8gLSBhdHRyaWJ1dGUgY2hhbmdlczogaWYgYHRhYmluZGV4YCBpcyBhZGRlZCwgb3IgcmVtb3ZlZCBmcm9tIGFuIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlXG4gICAgICAgIC8vICAgZWxlbWVudCwgbWFrZSB0aGF0IG5vZGUgYSBtYW5hZ2VkIG5vZGUuXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9yb290RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS4gIFRoaXMgdW53aW5kcyBhbGwgb2YgdGhlIHN0YXRlXG4gICAgICAgKiBzdG9yZWQgaW4gdGhpcyBvYmplY3QgYW5kIHVwZGF0ZXMgdGhlIHN0YXRlIG9mIGFsbCBvZiB0aGUgbWFuYWdlZCBub2Rlcy5cbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydFJvb3QsIFt7XG4gICAgICAgIGtleTogJ2Rlc3RydWN0b3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRoaXMuX3NhdmVkQXJpYUhpZGRlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5tYW5hZ2VOb2RlKGluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgICAvLyAxKSBXZSB3YW50IHRoZSBjbGFzcyBwcm9wZXJ0aWVzIHRvIGJlIGRlY2xhcmVkIGFzIG5vbi1udWxsLCBvciBlbHNlIHdlXG4gICAgICAgICAgLy8gICAgbmVlZCBldmVuIG1vcmUgY2FzdHMgdGhyb3VnaG91dCB0aGlzIGNvZGUuIEFsbCBiZXRzIGFyZSBvZmYgaWYgYW5cbiAgICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgICAvLyAyKSBXZSBkb24ndCB3YW50IHRvIGNhc3QgXCJ0aGlzXCIsIGJlY2F1c2Ugd2Ugd2FudCB0eXBlLWF3YXJlIG9wdGltaXphdGlvbnNcbiAgICAgICAgICAvLyAgICB0byBrbm93IHdoaWNoIHByb3BlcnRpZXMgd2UncmUgc2V0dGluZy5cbiAgICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5fdmlzaXROb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0Tm9kZSBtYXkgYmUgaW4gc2hhZG93IERPTSwgc28gZmluZCBpdHMgbmVhcmVzdCBzaGFkb3dSb290IHRvIGdldCB0aGUgYWN0aXZlRWxlbWVudC5cbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHshU2hhZG93Um9vdHx1bmRlZmluZWR9ICovXG4gICAgICAgICAgICB2YXIgcm9vdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICByb290ID0gLyoqIEB0eXBlIHshU2hhZG93Um9vdH0gKi9ub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gcm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnROb2RlLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAgIC8vIEluIElFMTEsIGlmIGFuIGVsZW1lbnQgaXMgYWxyZWFkeSBmb2N1c2VkLCBhbmQgdGhlbiBzZXQgdG8gdGFiaW5kZXg9LTFcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgYmx1cigpIHdpbGwgbm90IGFjdHVhbGx5IG1vdmUgdGhlIGZvY3VzLlxuICAgICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdmlzaXROb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF92aXNpdE5vZGUobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovbm9kZTtcblxuICAgICAgICAgIC8vIElmIGEgZGVzY2VuZGFudCBpbmVydCByb290IGJlY29tZXMgdW4taW5lcnQsIGl0cyBkZXNjZW5kYW50cyB3aWxsIHN0aWxsIGJlIGluZXJ0IGJlY2F1c2Ugb2ZcbiAgICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdChlbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19tYW5hZ2VOb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5hZGQoaW5lcnROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlciB0aGUgZW50aXJlIHN1YnRyZWUgc3RhcnRpbmcgYXQgYHN0YXJ0Tm9kZWAuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdW5tYW5hZ2VTdWJ0cmVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhIGRlc2NlbmRhbnQgbm9kZSBpcyBmb3VuZCB3aXRoIGFuIGBpbmVydGAgYXR0cmlidXRlLCBhZG9wdCBpdHMgbWFuYWdlZCBub2Rlcy5cbiAgICAgICAgICogQHBhcmFtIHshRWxlbWVudH0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fkb3B0SW5lcnRSb290KG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcblxuICAgICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgICAgLy8gc28gcmVnaXN0ZXIgaXQgbm93IGlmIG5lZWQgYmUuXG4gICAgICAgICAgaWYgKCFpbmVydFN1YnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShzYXZlZEluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBzdWJ0cmVlIGFkZGl0aW9ucywgcmVtb3ZhbHMsIG9yIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uTXV0YXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uTXV0YXRpb24ocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi9yZWNvcmQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgICAvLyBNYW5hZ2UgYWRkZWQgbm9kZXNcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgIC8vIFVuLW1hbmFnZSByZW1vdmVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlU3VidHJlZShub2RlKTtcbiAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAndGFiaW5kZXgnKSB7XG4gICAgICAgICAgICAgICAgLy8gUmUtaW5pdGlhbGlzZSBpbmVydCBub2RlIGlmIHRhYmluZGV4IGNoYW5nZXNcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiByZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ2luZXJ0JyAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBuZXcgaW5lcnQgcm9vdCBpcyBhZGRlZCwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMgYW5kIG1ha2Ugc3VyZSBpdCBrbm93cyBhYm91dCB0aGVcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5jb250YWlucyhtYW5hZ2VkTm9kZS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydFN1YnJvb3QuX21hbmFnZU5vZGUobWFuYWdlZE5vZGUubm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdtYW5hZ2VkTm9kZXMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcGFyYW0gez9zdHJpbmd9IGFyaWFIaWRkZW4gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhcmlhSGlkZGVuKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHs/c3RyaW5nfSAqL1xuICAgICAgICAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW47XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Um9vdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBgSW5lcnROb2RlYCBpbml0aWFsaXNlcyBhbmQgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBub2RlLlxuICAgICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIE9uIGNvbnN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgc2F2ZXMgdGhlIGV4aXN0aW5nIGB0YWJpbmRleGAgdmFsdWUgZm9yIHRoZSBub2RlLCBpZiBhbnksIGFuZFxuICAgICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAgICogaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUgb3Igbm90LlxuICAgICAqXG4gICAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgICAqIGBJbmVydFJvb3RgIGlzIGRlc3Ryb3llZCwgYW5kIGNhbGxzIGBJbmVydE1hbmFnZXIuZGVyZWdpc3RlcigpYCwgdGhlIGBJbmVydE1hbmFnZXJgIG5vdGlmaWVzIHRoZVxuICAgICAqIGBJbmVydE5vZGVgIHZpYSBgcmVtb3ZlSW5lcnRSb290KClgLCB3aGljaCBpbiB0dXJuIGRlc3Ryb3lzIHRoZSBgSW5lcnROb2RlYCBpZiBubyBgSW5lcnRSb290YHNcbiAgICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAgICogb3IgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgaWYgdGhlIGVsZW1lbnQgaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUuXG4gICAgICovXG5cblxuICAgIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgQSBmb2N1c2FibGUgZWxlbWVudCB0byBiZSBtYWRlIGluZXJ0LlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IU5vZGV9ICovXG4gICAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiAgICBJZiBhbmQgb25seSBpZiB0aGlzIHNldCBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IG51bGw7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBTYXZlIGFueSBwcmlvciB0YWJpbmRleCBpbmZvIGFuZCBtYWtlIHRoaXMgbm9kZSB1bnRhYmJhYmxlXG4gICAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICAgKiBUaGlzIG1ha2VzIHRoZSBtYW5hZ2VkIG5vZGUgZm9jdXNhYmxlIGFnYWluIGFuZCBkZWxldGVzIGFsbCBvZiB0aGUgcHJldmlvdXNseSBzdG9yZWQgc3RhdGUuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX25vZGUgJiYgdGhpcy5fbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGhpcy5fc2F2ZWRUYWJJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50LmZvY3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNlZSBub3RlIGluIEluZXJ0Um9vdC5kZXN0cnVjdG9yIGZvciB3aHkgd2UgY2FzdCB0aGVzZSBudWxscyB0byBBTlkuXG4gICAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9ic29sZXRlIGJlY2F1c2UgdGhlIG1hbmFnZWQgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaHJvdyBpZiB1c2VyIHRyaWVzIHRvIGFjY2VzcyBkZXN0cm95ZWQgSW5lcnROb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90aHJvd0lmRGVzdHJveWVkKCkge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdlbnN1cmVVbnRhYmJhYmxlJyxcblxuXG4gICAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlVW50YWJiYWJsZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5ub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSkge1xuICAgICAgICAgICAgaWYgKCAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4ID09PSAtMSAmJiB0aGlzLmhhc1NhdmVkVGFiSW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbm90aGVyIGluZXJ0IHJvb3QgdG8gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdhZGRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLmFkZChpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBmcm9tIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICAgKiBzbyB0aGUgb2JqZWN0IHNob3VsZCBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3llZCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHshSW5lcnROb2RlfSAqL3RoaXMuX2Rlc3Ryb3llZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ25vZGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/bnVtYmVyfSB0YWJJbmRleCAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YWJJbmRleCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P251bWJlcn0gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBXaGVuIGFuIGVsZW1lbnQgYmVjb21lcyBhbiBpbmVydCByb290IGJ5IGhhdmluZyBhbiBgaW5lcnRgIGF0dHJpYnV0ZSBzZXQgYW5kL29yIGl0cyBgaW5lcnRgXG4gICAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICAgKiBUaGUgYEluZXJ0Um9vdGAgaW4gdHVybiByZWdpc3RlcnMgaXRzZWxmIGFzIG1hbmFnaW5nIGFsbCBvZiB0aGUgZWxlbWVudCdzIGZvY3VzYWJsZSBkZXNjZW5kYW50XG4gICAgICogbm9kZXMgdmlhIHRoZSBgcmVnaXN0ZXIoKWAgbWV0aG9kLiBUaGUgYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgIGluc3RhbmNlXG4gICAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshRG9jdW1lbnR9IGRvY3VtZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRNYW5hZ2VyKTtcblxuICAgICAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHshRG9jdW1lbnR9ICovXG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIG5vZGVzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIGluZXJ0IHJvb3RzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnRSb290Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICAgKiBAdHlwZSB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gQWRkIGluZXJ0IHN0eWxlLlxuICAgICAgICBhZGRJbmVydFN0eWxlKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRvY3VtZW50TG9hZGVkLmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZCBiZSBhbiBpbmVydCByb290IG9yIG5vdC5cbiAgICAgICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5lcnRcbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydE1hbmFnZXIsIFt7XG4gICAgICAgIGtleTogJ3NldEluZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgICAgaWYgKGluZXJ0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgICByb290LnNldEF0dHJpYnV0ZSgnaW5lcnQnLCAnJyk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLnNldChyb290LCBpbmVydFJvb3QpO1xuICAgICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgICAgLy8gRW5zdXJlIGluZXJ0IHN0eWxlcyBhcmUgYWRkZWQgdGhlcmUuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RvY3VtZW50LmJvZHkuY29udGFpbnMocm9vdCkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IG5vbi1pbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfaW5lcnRSb290ID0gdGhpcy5faW5lcnRSb290cy5nZXQocm9vdCk7XG4gICAgICAgICAgICBfaW5lcnRSb290LmRlc3RydWN0b3IoKTtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgSW5lcnRSb290IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmVydCByb290IGVsZW1lbnQsIGlmIGFueS5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJuIHshSW5lcnRSb290fHVuZGVmaW5lZH1cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0SW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluZXJ0Um9vdChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgICAqIEluIHRoZSBjYXNlIHdoZXJlIHRoZSBub2RlIGhhcyBhIHByZXZpb3VzbHkgZXhpc3RpbmcgaW5lcnQgcm9vdCwgdGhpcyBpbmVydCByb290IHdpbGxcbiAgICAgICAgICogYmUgYWRkZWQgdG8gaXRzIHNldCBvZiBpbmVydCByb290cy5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKiBAcmV0dXJuIHshSW5lcnROb2RlfSBpbmVydE5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVnaXN0ZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICAgIGluZXJ0Tm9kZS5hZGRJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5zZXQobm9kZSwgaW5lcnROb2RlKTtcblxuICAgICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAgICogUmVtb3ZlcyB0aGUgaW5lcnQgcm9vdCBmcm9tIHRoZSBJbmVydE5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMsIGFuZCByZW1vdmUgdGhlIGluZXJ0XG4gICAgICAgICAqIG5vZGUgZnJvbSB0aGUgSW5lcnRNYW5hZ2VyJ3Mgc2V0IG9mIG1hbmFnZWQgbm9kZXMgaWYgaXQgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVyZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5fbWFuYWdlZE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXNbJ2RlbGV0ZSddKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIGRvY3VtZW50IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfb25Eb2N1bWVudExvYWRlZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Eb2N1bWVudExvYWRlZCgpIHtcbiAgICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbCh0aGlzLl9kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBDb21tZW50IHRoaXMgb3V0IHRvIHVzZSBwcm9ncmFtbWF0aWMgQVBJIG9ubHkuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gc2VsZlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfd2F0Y2hGb3JJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICdjaGlsZExpc3QnOlxuICAgICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCAnW2luZXJ0XScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMudW5zaGlmdChub2RlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSAhPT0gJ2luZXJ0Jykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi9yZWNvcmQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0SW5lcnQodGFyZ2V0LCBpbmVydCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0TWFuYWdlcjtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSB3YWxrIHRoZSBjb21wb3NlZCB0cmVlIGZyb20gfG5vZGV8LlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUVsZW1lbnQpKT19IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50IHRyYXZlcnNlZCxcbiAgICAgKiAgICAgYmVmb3JlIGRlc2NlbmRpbmcgaW50byBjaGlsZCBub2Rlcy5cbiAgICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY29tcG9zZWRUcmVlV2Fsayhub2RlLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovbm9kZTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgICAgLy8gSWYgaXQgaGFzIGEgU2hhZG93Um9vdCwgaWdub3JlIGFsbCBjaGlsZCBlbGVtZW50cyAtIHRoZXNlIHdpbGwgYmUgcGlja2VkXG4gICAgICAgIC8vIHVwIGJ5IHRoZSA8Y29udGVudD4gb3IgPHNoYWRvdz4gZWxlbWVudHMuIERlc2NlbmQgc3RyYWlnaHQgaW50byB0aGVcbiAgICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgICAgdmFyIHNoYWRvd1Jvb3QgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICAgIHZhciBjb250ZW50ID0gLyoqIEB0eXBlIHshSFRNTENvbnRlbnRFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZpZXMgaWYgU2hhZG93RG9tIHYwIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGRpc3RyaWJ1dGVkTm9kZXNbaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgdmFyIHNsb3QgPSAvKiogQHR5cGUgeyFIVE1MU2xvdEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgICAvLyBWZXJpZnkgaWYgU2hhZG93RG9tIHYxIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9kaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhfZGlzdHJpYnV0ZWROb2Rlc1tfaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgbmVpdGhlciB0aGUgcGFyZW50IG9mIGEgU2hhZG93Um9vdCwgYSA8Y29udGVudD4gZWxlbWVudCwgYSA8c2xvdD5cbiAgICAgIC8vIGVsZW1lbnQsIG5vciBhIDxzaGFkb3c+IGVsZW1lbnQgcmVjdXJzZSBub3JtYWxseS5cbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoY2hpbGQsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdHlsZSBlbGVtZW50IHRvIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIGluZXJ0IHNwZWNpZmljIHN0eWxlc1xuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRJbmVydFN0eWxlKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlI2luZXJ0LXN0eWxlLCBsaW5rI2luZXJ0LXN0eWxlJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gJ1xcbicgKyAnW2luZXJ0XSB7XFxuJyArICcgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbicgKyAnICBjdXJzb3I6IGRlZmF1bHQ7XFxuJyArICd9XFxuJyArICdcXG4nICsgJ1tpbmVydF0sIFtpbmVydF0gKiB7XFxuJyArICcgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICd9XFxuJztcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cblxuICAgIGlmICghRWxlbWVudC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2luZXJ0JykpIHtcbiAgICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICAgIHZhciBpbmVydE1hbmFnZXIgPSBuZXcgSW5lcnRNYW5hZ2VyKGRvY3VtZW50KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIC8qKiBAdGhpcyB7IUVsZW1lbnR9ICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEB0aGlzIHshRWxlbWVudH0gKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgICBpbmVydE1hbmFnZXIuc2V0SW5lcnQodGhpcywgaW5lcnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pKCk7XG5cbn0pKSk7XG4iLCJpbXBvcnQgXCJibG9ja2luZy1lbGVtZW50c1wiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IFwid2ljZy1pbmVydFwiO1xuY29uc3QgYmxvY2tpbmdFbGVtZW50cyA9IGRvY3VtZW50LiRibG9ja2luZ0VsZW1lbnRzO1xuLyoqXG4gKiBBbGxvd3MgYW4gZWxlbWVudCB0byB0cmFwIGZvY3VzIGJ5IGFwcGx5aW5nIHRoZSBcImluZXJ0XCIgYXR0cmlidXRlIHRvIGFsbCBzaWJsaW5nLCBhdW50LCBhbmQgdW5jbGUgbm9kZXMuXG4gKlxuICogQXV0b21hdGljYWxseSBoYW5kbGVzIGNvbnNlY3V0aXZlIGNhbGxzIHdpdGggYSBsb29zZWx5IGFwcGxpZWQgc3RhY2sgb3BlcmF0aW9uXG4gKiAoc3BlY2lmaWNhbGx5IHZpYSBgYmxvY2tpbmdFbGVtZW50c2AsIHdpdGggYSBzbWFsbCBwb2x5ZmlsbCBiZWNhdXNlIEknbSBub3Qgc3VyZSBob3cgbG9uZ1xuICogaXQnbGwgdGFrZSB0byBmaW5kIGl0cyB3YXkgaW50byB0aGUgc3BlYywgaWYgZXZlcilcbiAqIEBwYXJhbSB0YXJnZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJsb2NraW5nRWxlbWVudCh0YXJnZXQpIHtcbiAgICAvKipcbiAgICAgKiBQdXNoL3BvcCB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZ0VsZW1lbnRzIHN0YWNrLlxuICAgICAqL1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGJsb2NraW5nRWxlbWVudHMucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBibG9ja2luZ0VsZW1lbnRzLnJlbW92ZSh0YXJnZXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFt0YXJnZXRdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BFbGVtZW50KCkge1xuICAgIHJldHVybiBibG9ja2luZ0VsZW1lbnRzLnRvcDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1ibG9ja2luZy1lbGVtZW50LmpzLm1hcCIsImltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGlzRm9jdXNhYmxlIH0gZnJvbSBcInRhYmJhYmxlXCI7XG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50IH0gZnJvbSBcIi4vdXNlLWFjdGl2ZS1lbGVtZW50XCI7XG5pbXBvcnQgeyBnZXRUb3BFbGVtZW50LCB1c2VCbG9ja2luZ0VsZW1lbnQgfSBmcm9tIFwiLi91c2UtYmxvY2tpbmctZWxlbWVudFwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5jb25zdCBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8gPSBuZXcgTWFwKCk7XG5leHBvcnQgZnVuY3Rpb24gdXNlRm9jdXNUcmFwKHsgdHJhcEFjdGl2ZSB9KSB7XG4gICAgY29uc3QgeyBlbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQoKTtcbiAgICBjb25zdCB7IGdldExhc3RBY3RpdmVFbGVtZW50IH0gPSB1c2VBY3RpdmVFbGVtZW50KCk7XG4gICAgLy8gV2hlbiB0aGUgdHJhcCBiZWNvbWVzIGFjdGl2ZSwgYmVmb3JlIHdlIGxldCB0aGUgYmxvY2tpbmdFbGVtZW50cyBob29rIHJ1bixcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoYXRldmVyJ3MgY3VycmVudGx5IGZvY3VzZWQgYW5kIHNhdmUgaXQuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHRyYXBBY3RpdmUgJiYgZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAgICAgLy8gdG8gd2hhdGV2ZXIncyBjdXJyZW50bHkgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgICAgIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUby5zZXQoZ2V0VG9wRWxlbWVudCgpLCBnZXRMYXN0QWN0aXZlRWxlbWVudCgpID8/IGRvY3VtZW50LmJvZHkpO1xuICAgICAgICB9XG4gICAgfSwgW3RyYXBBY3RpdmUsIGVsZW1lbnRdKTtcbiAgICB1c2VCbG9ja2luZ0VsZW1lbnQodHJhcEFjdGl2ZSA/IGVsZW1lbnQgOiBudWxsKTtcbiAgICAvKipcbiAgICAgKiBBbnkgdGltZSB3ZSBhY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHRoZSB0cmFwLFxuICAgICAqIGNoYW5nZSBmb2N1cyB0byBzb21ldGhpbmcgZWxzZSAoc29tZXRoaW5nIGluXG4gICAgICogdGhlIHRyYXAgaWYgaXQncyBhY3RpdmUsIG9yIHdoYXRldmVyIHdlJ3ZlXG4gICAgICogdHJhY2tlZCBpbiBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8gaWYgbm90KVxuICAgICAqL1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0cmFwQWN0aXZlICYmIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCByYWZIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZXh0cmEgcXVldWVNaWNyb3Rhc2sgaXMgbmVlZGVkIGZvclxuICAgICAgICAgICAgICAgIC8vIC4uLnJlYXNvbnM/XG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmaW5kRmlyc3RGb2N1c2FibGUoZWxlbWVudCk/LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJhZkhhbmRsZSlcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSGFuZGxlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgZm9jdXMgdG8gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHRoYXQgaGFzIHJldHVybmVkIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICAgICAgICBsZXQgcmFmSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUby5nZXQoZ2V0VG9wRWxlbWVudCgpKT8uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFmSGFuZGxlID0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFt0cmFwQWN0aXZlLCBlbGVtZW50XSk7XG4gICAgY29uc3QgdXNlRm9jdXNUcmFwUHJvcHMgPSAoKHByb3BzKSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHsgXCJhcmlhLW1vZGFsXCI6IHRyYXBBY3RpdmUgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9LCB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VGb2N1c1RyYXBQcm9wcyxcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgZ2V0RWxlbWVudFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IGNvbnRhaW5lZCB3aXRoaW4gdGhlIGdpdmVuIG5vZGUsIG9yIG51bGwgaWYgbm9uZSBhcmUgZm91bmQuXG4gKiBAcGFyYW0gZWxlbWVudFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50KSB7XG4gICAgY29uc3QgdHJlZVdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWxlbWVudCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIHsgYWNjZXB0Tm9kZTogKG5vZGUpID0+IChub2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiBpc0ZvY3VzYWJsZShub2RlKSA/IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCA6IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVApIH0pO1xuICAgIGNvbnN0IGZpcnN0Rm9jdXNhYmxlID0gdHJlZVdhbGtlci5maXJzdENoaWxkKCk7XG4gICAgcmV0dXJuIGZpcnN0Rm9jdXNhYmxlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWZvY3VzLXRyYXAuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUhhc0ZvY3VzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWhhcy1mb2N1c1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VSYW5kb21JZCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1yYW5kb20taWRcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhVG9vbHRpcCh7IG1vdXNlb3ZlckRlbGF5IH0pIHtcbiAgICBtb3VzZW92ZXJEZWxheSA/Pz0gNDAwO1xuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuLCBnZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbaGFzQW55TW91c2VvdmVyLCBzZXRIYXNBbnlNb3VzZW92ZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vY29uc3QgW21vdXNlb3ZlcklzVmFsaWQsIHNldE1vdXNlb3ZlcklzVmFsaWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlVG9vbHRpcElkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzOiB1c2VUb29sdGlwSWRSZWZlcmVuY2luZ1Byb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLXRvb2x0aXAtXCIgfSk7XG4gICAgY29uc3QgeyBmb2N1c2VkSW5uZXI6IHRyaWdnZXJGb2N1c2VkLCB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1cygpO1xuICAgIGNvbnN0IFt0cmlnZ2VySGFzTW91c2VvdmVyLCBzZXRUcmlnZ2VySGFzTW91c2VvdmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbdG9vbHRpcEhhc01vdXNlb3Zlciwgc2V0VG9vbHRpcEhhc01vdXNlb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgdXNlVGltZW91dCh7XG4gICAgICAgIHRpbWVvdXQ6IG1vdXNlb3ZlckRlbGF5LFxuICAgICAgICB0cmlnZ2VySW5kZXg6ICgrdHJpZ2dlckhhc01vdXNlb3ZlciArICt0b29sdGlwSGFzTW91c2VvdmVyKSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VySGFzTW91c2VvdmVyIHx8IHRvb2x0aXBIYXNNb3VzZW92ZXIpXG4gICAgICAgICAgICAgICAgc2V0SGFzQW55TW91c2VvdmVyKHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdXNlVGltZW91dCh7XG4gICAgICAgIHRpbWVvdXQ6IDUwLFxuICAgICAgICB0cmlnZ2VySW5kZXg6ICgrdHJpZ2dlckhhc01vdXNlb3ZlciArICt0b29sdGlwSGFzTW91c2VvdmVyKSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdHJpZ2dlckhhc01vdXNlb3ZlciAmJiAhdG9vbHRpcEhhc01vdXNlb3ZlcilcbiAgICAgICAgICAgICAgICBzZXRIYXNBbnlNb3VzZW92ZXIoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0T3BlbihoYXNBbnlNb3VzZW92ZXIgfHwgdHJpZ2dlckZvY3VzZWQpO1xuICAgIH0sIFtoYXNBbnlNb3VzZW92ZXIsIHRyaWdnZXJGb2N1c2VkXSk7XG4gICAgY29uc3QgdXNlVG9vbHRpcFRyaWdnZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VUb29sdGlwVHJpZ2dlcigpIHtcbiAgICAgICAgZnVuY3Rpb24gb25Qb2ludGVyRW50ZXIoZSkge1xuICAgICAgICAgICAgc2V0VHJpZ2dlckhhc01vdXNlb3Zlcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblBvaW50ZXJMZWF2ZShlKSB7XG4gICAgICAgICAgICBzZXRUcmlnZ2VySGFzTW91c2VvdmVyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1c2VUb29sdGlwVHJpZ2dlclByb3BzKHsgLi4ucHJvcHMgfSkge1xuICAgICAgICAgICAgLy8gTm90ZTogVGhvdWdoIGl0J3MgaW1wb3J0YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGZvY3VzaW5nIGFjdGl2YXRlcyBhIHRvb2x0aXAsXG4gICAgICAgICAgICAvLyBpdCdzIHBlcmZlY3RseSByZWFzb25hYmxlIHRoYXQgYSBjaGlsZCBlbGVtZW50IHdpbGwgYmUgdGhlIG9uZSB0aGF0J3MgZm9jdXNlZCxcbiAgICAgICAgICAgIC8vIG5vdCB0aGlzIG9uZSwgc28gd2UgZG9uJ3Qgc2V0IHRhYkluZGV4PTBcbiAgICAgICAgICAgIHJldHVybiB1c2VUb29sdGlwSWRSZWZlcmVuY2luZ1Byb3BzKFwiYXJpYS1kZXNjcmliZWRieVwiKSh1c2VNZXJnZWRQcm9wcygpKHsgb25Qb2ludGVyRW50ZXIsIG9uUG9pbnRlckxlYXZlIH0sIHVzZUhhc0ZvY3VzUHJvcHMocHJvcHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyB9O1xuICAgIH0sIFt1c2VUb29sdGlwSWRSZWZlcmVuY2luZ1Byb3BzXSk7XG4gICAgY29uc3QgdXNlVG9vbHRpcCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVRvb2x0aXAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIG9uUG9pbnRlckVudGVyKGUpIHtcbiAgICAgICAgICAgIHNldFRvb2x0aXBIYXNNb3VzZW92ZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Qb2ludGVyTGVhdmUoZSkge1xuICAgICAgICAgICAgc2V0VG9vbHRpcEhhc01vdXNlb3ZlcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXNlVG9vbHRpcFByb3BzKHsgLi4ucHJvcHMgfSkge1xuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwidG9vbHRpcFwiO1xuICAgICAgICAgICAgcmV0dXJuIHVzZVRvb2x0aXBJZFByb3BzKHVzZU1lcmdlZFByb3BzKCkoeyBvblBvaW50ZXJFbnRlciwgb25Qb2ludGVyTGVhdmUgfSwgcHJvcHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1c2VUb29sdGlwUHJvcHMgfTtcbiAgICB9LCBbdXNlVG9vbHRpcElkUHJvcHNdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VUb29sdGlwLFxuICAgICAgICB1c2VUb29sdGlwVHJpZ2dlcixcbiAgICAgICAgaXNPcGVuOiBvcGVuLFxuICAgICAgICBnZXRJc09wZW46IGdldE9wZW5cbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXRvb2x0aXAuanMubWFwIiwiaW1wb3J0e3VzZVN0YXRlIGFzIG4sdXNlUmVkdWNlciBhcyB0LHVzZUVmZmVjdCBhcyBlLHVzZUxheW91dEVmZmVjdCBhcyByLHVzZVJlZiBhcyB1LHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgbyx1c2VNZW1vIGFzIGksdXNlQ2FsbGJhY2sgYXMgbCx1c2VDb250ZXh0IGFzIGYsdXNlRGVidWdWYWx1ZSBhcyBjfWZyb21cInByZWFjdC9ob29rc1wiO2V4cG9ydCpmcm9tXCJwcmVhY3QvaG9va3NcIjtpbXBvcnR7Q29tcG9uZW50IGFzIGEsY3JlYXRlRWxlbWVudCBhcyBzLG9wdGlvbnMgYXMgaCx0b0NoaWxkQXJyYXkgYXMgdixGcmFnbWVudCBhcyBkLHJlbmRlciBhcyBwLGh5ZHJhdGUgYXMgbSxjbG9uZUVsZW1lbnQgYXMgeSxjcmVhdGVSZWYgYXMgYixjcmVhdGVDb250ZXh0IGFzIF99ZnJvbVwicHJlYWN0XCI7ZXhwb3J0e2NyZWF0ZUVsZW1lbnQsY3JlYXRlQ29udGV4dCxjcmVhdGVSZWYsRnJhZ21lbnQsQ29tcG9uZW50fWZyb21cInByZWFjdFwiO2Z1bmN0aW9uIFMobix0KXtmb3IodmFyIGUgaW4gdCluW2VdPXRbZV07cmV0dXJuIG59ZnVuY3Rpb24gQyhuLHQpe2Zvcih2YXIgZSBpbiBuKWlmKFwiX19zb3VyY2VcIiE9PWUmJiEoZSBpbiB0KSlyZXR1cm4hMDtmb3IodmFyIHIgaW4gdClpZihcIl9fc291cmNlXCIhPT1yJiZuW3JdIT09dFtyXSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBFKG4pe3RoaXMucHJvcHM9bn1mdW5jdGlvbiBnKG4sdCl7ZnVuY3Rpb24gZShuKXt2YXIgZT10aGlzLnByb3BzLnJlZixyPWU9PW4ucmVmO3JldHVybiFyJiZlJiYoZS5jYWxsP2UobnVsbCk6ZS5jdXJyZW50PW51bGwpLHQ/IXQodGhpcy5wcm9wcyxuKXx8IXI6Qyh0aGlzLnByb3BzLG4pfWZ1bmN0aW9uIHIodCl7cmV0dXJuIHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWUscyhuLHQpfXJldHVybiByLmRpc3BsYXlOYW1lPVwiTWVtbyhcIisobi5kaXNwbGF5TmFtZXx8bi5uYW1lKStcIilcIixyLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PSEwLHIuX19mPSEwLHJ9KEUucHJvdG90eXBlPW5ldyBhKS5pc1B1cmVSZWFjdENvbXBvbmVudD0hMCxFLnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGU9ZnVuY3Rpb24obix0KXtyZXR1cm4gQyh0aGlzLnByb3BzLG4pfHxDKHRoaXMuc3RhdGUsdCl9O3ZhciB3PWguX19iO2guX19iPWZ1bmN0aW9uKG4pe24udHlwZSYmbi50eXBlLl9fZiYmbi5yZWYmJihuLnByb3BzLnJlZj1uLnJlZixuLnJlZj1udWxsKSx3JiZ3KG4pfTt2YXIgUj1cInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yJiZTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIil8fDM5MTE7ZnVuY3Rpb24geChuKXtmdW5jdGlvbiB0KHQsZSl7dmFyIHI9Uyh7fSx0KTtyZXR1cm4gZGVsZXRlIHIucmVmLG4ociwoZT10LnJlZnx8ZSkmJihcIm9iamVjdFwiIT10eXBlb2YgZXx8XCJjdXJyZW50XCJpbiBlKT9lOm51bGwpfXJldHVybiB0LiQkdHlwZW9mPVIsdC5yZW5kZXI9dCx0LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXQuX19mPSEwLHQuZGlzcGxheU5hbWU9XCJGb3J3YXJkUmVmKFwiKyhuLmRpc3BsYXlOYW1lfHxuLm5hbWUpK1wiKVwiLHR9dmFyIE49ZnVuY3Rpb24obix0KXtyZXR1cm4gbnVsbD09bj9udWxsOnYodihuKS5tYXAodCkpfSxrPXttYXA6Tixmb3JFYWNoOk4sY291bnQ6ZnVuY3Rpb24obil7cmV0dXJuIG4/dihuKS5sZW5ndGg6MH0sb25seTpmdW5jdGlvbihuKXt2YXIgdD12KG4pO2lmKDEhPT10Lmxlbmd0aCl0aHJvd1wiQ2hpbGRyZW4ub25seVwiO3JldHVybiB0WzBdfSx0b0FycmF5OnZ9LEE9aC5fX2U7aC5fX2U9ZnVuY3Rpb24obix0LGUpe2lmKG4udGhlbilmb3IodmFyIHIsdT10O3U9dS5fXzspaWYoKHI9dS5fX2MpJiZyLl9fYylyZXR1cm4gbnVsbD09dC5fX2UmJih0Ll9fZT1lLl9fZSx0Ll9faz1lLl9fayksci5fX2Mobix0KTtBKG4sdCxlKX07dmFyIE89aC51bm1vdW50O2Z1bmN0aW9uIEwoKXt0aGlzLl9fdT0wLHRoaXMudD1udWxsLHRoaXMuX19iPW51bGx9ZnVuY3Rpb24gVShuKXt2YXIgdD1uLl9fLl9fYztyZXR1cm4gdCYmdC5fX2UmJnQuX19lKG4pfWZ1bmN0aW9uIEYobil7dmFyIHQsZSxyO2Z1bmN0aW9uIHUodSl7aWYodHx8KHQ9bigpKS50aGVuKGZ1bmN0aW9uKG4pe2U9bi5kZWZhdWx0fHxufSxmdW5jdGlvbihuKXtyPW59KSxyKXRocm93IHI7aWYoIWUpdGhyb3cgdDtyZXR1cm4gcyhlLHUpfXJldHVybiB1LmRpc3BsYXlOYW1lPVwiTGF6eVwiLHUuX19mPSEwLHV9ZnVuY3Rpb24gTSgpe3RoaXMudT1udWxsLHRoaXMubz1udWxsfWgudW5tb3VudD1mdW5jdGlvbihuKXt2YXIgdD1uLl9fYzt0JiZ0Ll9fUiYmdC5fX1IoKSx0JiYhMD09PW4uX19oJiYobi50eXBlPW51bGwpLE8mJk8obil9LChMLnByb3RvdHlwZT1uZXcgYSkuX19jPWZ1bmN0aW9uKG4sdCl7dmFyIGU9dC5fX2Mscj10aGlzO251bGw9PXIudCYmKHIudD1bXSksci50LnB1c2goZSk7dmFyIHU9VShyLl9fdiksbz0hMSxpPWZ1bmN0aW9uKCl7b3x8KG89ITAsZS5fX1I9bnVsbCx1P3UobCk6bCgpKX07ZS5fX1I9aTt2YXIgbD1mdW5jdGlvbigpe2lmKCEtLXIuX191KXtpZihyLnN0YXRlLl9fZSl7dmFyIG49ci5zdGF0ZS5fX2U7ci5fX3YuX19rWzBdPWZ1bmN0aW9uIG4odCxlLHIpe3JldHVybiB0JiYodC5fX3Y9bnVsbCx0Ll9faz10Ll9fayYmdC5fX2subWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuKHQsZSxyKX0pLHQuX19jJiZ0Ll9fYy5fX1A9PT1lJiYodC5fX2UmJnIuaW5zZXJ0QmVmb3JlKHQuX19lLHQuX19kKSx0Ll9fYy5fX2U9ITAsdC5fX2MuX19QPXIpKSx0fShuLG4uX19jLl9fUCxuLl9fYy5fX08pfXZhciB0O2ZvcihyLnNldFN0YXRlKHtfX2U6ci5fX2I9bnVsbH0pO3Q9ci50LnBvcCgpOyl0LmZvcmNlVXBkYXRlKCl9fSxmPSEwPT09dC5fX2g7ci5fX3UrK3x8Znx8ci5zZXRTdGF0ZSh7X19lOnIuX19iPXIuX192Ll9fa1swXX0pLG4udGhlbihpLGkpfSxMLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3RoaXMudD1bXX0sTC5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKG4sdCl7aWYodGhpcy5fX2Ipe2lmKHRoaXMuX192Ll9fayl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxyPXRoaXMuX192Ll9fa1swXS5fX2M7dGhpcy5fX3YuX19rWzBdPWZ1bmN0aW9uIG4odCxlLHIpe3JldHVybiB0JiYodC5fX2MmJnQuX19jLl9fSCYmKHQuX19jLl9fSC5fXy5mb3JFYWNoKGZ1bmN0aW9uKG4pe1wiZnVuY3Rpb25cIj09dHlwZW9mIG4uX19jJiZuLl9fYygpfSksdC5fX2MuX19IPW51bGwpLG51bGwhPSh0PVMoe30sdCkpLl9fYyYmKHQuX19jLl9fUD09PXImJih0Ll9fYy5fX1A9ZSksdC5fX2M9bnVsbCksdC5fX2s9dC5fX2smJnQuX19rLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbih0LGUscil9KSksdH0odGhpcy5fX2IsZSxyLl9fTz1yLl9fUCl9dGhpcy5fX2I9bnVsbH12YXIgdT10Ll9fZSYmcyhkLG51bGwsbi5mYWxsYmFjayk7cmV0dXJuIHUmJih1Ll9faD1udWxsKSxbcyhkLG51bGwsdC5fX2U/bnVsbDpuLmNoaWxkcmVuKSx1XX07dmFyIFQ9ZnVuY3Rpb24obix0LGUpe2lmKCsrZVsxXT09PWVbMF0mJm4uby5kZWxldGUodCksbi5wcm9wcy5yZXZlYWxPcmRlciYmKFwidFwiIT09bi5wcm9wcy5yZXZlYWxPcmRlclswXXx8IW4uby5zaXplKSlmb3IoZT1uLnU7ZTspe2Zvcig7ZS5sZW5ndGg+MzspZS5wb3AoKSgpO2lmKGVbMV08ZVswXSlicmVhaztuLnU9ZT1lWzJdfX07ZnVuY3Rpb24gRChuKXtyZXR1cm4gdGhpcy5nZXRDaGlsZENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gbi5jb250ZXh0fSxuLmNoaWxkcmVufWZ1bmN0aW9uIEkobil7dmFyIHQ9dGhpcyxlPW4uaTt0LmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7cChudWxsLHQubCksdC5sPW51bGwsdC5pPW51bGx9LHQuaSYmdC5pIT09ZSYmdC5jb21wb25lbnRXaWxsVW5tb3VudCgpLG4uX192Pyh0Lmx8fCh0Lmk9ZSx0Lmw9e25vZGVUeXBlOjEscGFyZW50Tm9kZTplLGNoaWxkTm9kZXM6W10sYXBwZW5kQ2hpbGQ6ZnVuY3Rpb24obil7dGhpcy5jaGlsZE5vZGVzLnB1c2gobiksdC5pLmFwcGVuZENoaWxkKG4pfSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24obixlKXt0aGlzLmNoaWxkTm9kZXMucHVzaChuKSx0LmkuYXBwZW5kQ2hpbGQobil9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKG4pe3RoaXMuY2hpbGROb2Rlcy5zcGxpY2UodGhpcy5jaGlsZE5vZGVzLmluZGV4T2Yobik+Pj4xLDEpLHQuaS5yZW1vdmVDaGlsZChuKX19KSxwKHMoRCx7Y29udGV4dDp0LmNvbnRleHR9LG4uX192KSx0LmwpKTp0LmwmJnQuY29tcG9uZW50V2lsbFVubW91bnQoKX1mdW5jdGlvbiBXKG4sdCl7cmV0dXJuIHMoSSx7X192Om4saTp0fSl9KE0ucHJvdG90eXBlPW5ldyBhKS5fX2U9ZnVuY3Rpb24obil7dmFyIHQ9dGhpcyxlPVUodC5fX3YpLHI9dC5vLmdldChuKTtyZXR1cm4gclswXSsrLGZ1bmN0aW9uKHUpe3ZhciBvPWZ1bmN0aW9uKCl7dC5wcm9wcy5yZXZlYWxPcmRlcj8oci5wdXNoKHUpLFQodCxuLHIpKTp1KCl9O2U/ZShvKTpvKCl9fSxNLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24obil7dGhpcy51PW51bGwsdGhpcy5vPW5ldyBNYXA7dmFyIHQ9dihuLmNoaWxkcmVuKTtuLnJldmVhbE9yZGVyJiZcImJcIj09PW4ucmV2ZWFsT3JkZXJbMF0mJnQucmV2ZXJzZSgpO2Zvcih2YXIgZT10Lmxlbmd0aDtlLS07KXRoaXMuby5zZXQodFtlXSx0aGlzLnU9WzEsMCx0aGlzLnVdKTtyZXR1cm4gbi5jaGlsZHJlbn0sTS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlPU0ucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50PWZ1bmN0aW9uKCl7dmFyIG49dGhpczt0aGlzLm8uZm9yRWFjaChmdW5jdGlvbih0LGUpe1QobixlLHQpfSl9O3ZhciBqPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3ImJlN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpfHw2MDEwMyxQPS9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXAoPyFQYXRoVSl8Y29sb3J8ZmlsbHxmbG9vZHxmb250fGdseXBoKD8hUil8aG9yaXp8bWFya2VyKD8hSHxXfFUpfG92ZXJsaW5lfHBhaW50fHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dCg/IUwpfHVuZGVybGluZXx1bmljb2RlfHVuaXRzfHZ8dmVjdG9yfHZlcnR8d29yZHx3cml0aW5nfHgoPyFDKSlbQS1aXS8sVj1mdW5jdGlvbihuKXtyZXR1cm4oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbCgpPy9maWx8Y2hlfHJhZC9pOi9maWx8Y2hlfHJhL2kpLnRlc3Qobil9O2Z1bmN0aW9uIHoobix0LGUpe3JldHVybiBudWxsPT10Ll9fayYmKHQudGV4dENvbnRlbnQ9XCJcIikscChuLHQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUoKSxuP24uX19jOm51bGx9ZnVuY3Rpb24gQihuLHQsZSl7cmV0dXJuIG0obix0KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlKCksbj9uLl9fYzpudWxsfWEucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9e30sW1wiY29tcG9uZW50V2lsbE1vdW50XCIsXCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsXCJjb21wb25lbnRXaWxsVXBkYXRlXCJdLmZvckVhY2goZnVuY3Rpb24obil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLG4se2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tcIlVOU0FGRV9cIituXX0sc2V0OmZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLG4se2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSl9fSl9KTt2YXIgSD1oLmV2ZW50O2Z1bmN0aW9uIFooKXt9ZnVuY3Rpb24gWSgpe3JldHVybiB0aGlzLmNhbmNlbEJ1YmJsZX1mdW5jdGlvbiAkKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFByZXZlbnRlZH1oLmV2ZW50PWZ1bmN0aW9uKG4pe3JldHVybiBIJiYobj1IKG4pKSxuLnBlcnNpc3Q9WixuLmlzUHJvcGFnYXRpb25TdG9wcGVkPVksbi5pc0RlZmF1bHRQcmV2ZW50ZWQ9JCxuLm5hdGl2ZUV2ZW50PW59O3ZhciBxLEc9e2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbGFzc319LEo9aC52bm9kZTtoLnZub2RlPWZ1bmN0aW9uKG4pe3ZhciB0PW4udHlwZSxlPW4ucHJvcHMscj1lO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXtmb3IodmFyIHUgaW4gcj17fSxlKXt2YXIgbz1lW3VdO1widmFsdWVcIj09PXUmJlwiZGVmYXVsdFZhbHVlXCJpbiBlJiZudWxsPT1vfHwoXCJkZWZhdWx0VmFsdWVcIj09PXUmJlwidmFsdWVcImluIGUmJm51bGw9PWUudmFsdWU/dT1cInZhbHVlXCI6XCJkb3dubG9hZFwiPT09dSYmITA9PT1vP289XCJcIjovb25kb3VibGVjbGljay9pLnRlc3QodSk/dT1cIm9uZGJsY2xpY2tcIjovXm9uY2hhbmdlKHRleHRhcmVhfGlucHV0KS9pLnRlc3QodSt0KSYmIVYoZS50eXBlKT91PVwib25pbnB1dFwiOi9eb24oQW5pfFRyYXxUb3V8QmVmb3JlSW5wKS8udGVzdCh1KT91PXUudG9Mb3dlckNhc2UoKTpQLnRlc3QodSk/dT11LnJlcGxhY2UoL1tBLVowLTldLyxcIi0kJlwiKS50b0xvd2VyQ2FzZSgpOm51bGw9PT1vJiYobz12b2lkIDApLHJbdV09byl9XCJzZWxlY3RcIj09dCYmci5tdWx0aXBsZSYmQXJyYXkuaXNBcnJheShyLnZhbHVlKSYmKHIudmFsdWU9dihlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe24ucHJvcHMuc2VsZWN0ZWQ9LTEhPXIudmFsdWUuaW5kZXhPZihuLnByb3BzLnZhbHVlKX0pKSxcInNlbGVjdFwiPT10JiZudWxsIT1yLmRlZmF1bHRWYWx1ZSYmKHIudmFsdWU9dihlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe24ucHJvcHMuc2VsZWN0ZWQ9ci5tdWx0aXBsZT8tMSE9ci5kZWZhdWx0VmFsdWUuaW5kZXhPZihuLnByb3BzLnZhbHVlKTpyLmRlZmF1bHRWYWx1ZT09bi5wcm9wcy52YWx1ZX0pKSxuLnByb3BzPXJ9dCYmZS5jbGFzcyE9ZS5jbGFzc05hbWUmJihHLmVudW1lcmFibGU9XCJjbGFzc05hbWVcImluIGUsbnVsbCE9ZS5jbGFzc05hbWUmJihyLmNsYXNzPWUuY2xhc3NOYW1lKSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcImNsYXNzTmFtZVwiLEcpKSxuLiQkdHlwZW9mPWosSiYmSihuKX07dmFyIEs9aC5fX3I7aC5fX3I9ZnVuY3Rpb24obil7SyYmSyhuKSxxPW4uX19jfTt2YXIgUT17UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjp7Y3VycmVudDp7cmVhZENvbnRleHQ6ZnVuY3Rpb24obil7cmV0dXJuIHEuX19uW24uX19jXS5wcm9wcy52YWx1ZX19fX0sWD1cIjE3LjAuMlwiO2Z1bmN0aW9uIG5uKG4pe3JldHVybiBzLmJpbmQobnVsbCxuKX1mdW5jdGlvbiB0bihuKXtyZXR1cm4hIW4mJm4uJCR0eXBlb2Y9PT1qfWZ1bmN0aW9uIGVuKG4pe3JldHVybiB0bihuKT95LmFwcGx5KG51bGwsYXJndW1lbnRzKTpufWZ1bmN0aW9uIHJuKG4pe3JldHVybiEhbi5fX2smJihwKG51bGwsbiksITApfWZ1bmN0aW9uIHVuKG4pe3JldHVybiBuJiYobi5iYXNlfHwxPT09bi5ub2RlVHlwZSYmbil8fG51bGx9dmFyIG9uPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4odCl9LGxuPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4odCl9LGZuPWQ7ZXhwb3J0IGRlZmF1bHR7dXNlU3RhdGU6bix1c2VSZWR1Y2VyOnQsdXNlRWZmZWN0OmUsdXNlTGF5b3V0RWZmZWN0OnIsdXNlUmVmOnUsdXNlSW1wZXJhdGl2ZUhhbmRsZTpvLHVzZU1lbW86aSx1c2VDYWxsYmFjazpsLHVzZUNvbnRleHQ6Zix1c2VEZWJ1Z1ZhbHVlOmMsdmVyc2lvbjpcIjE3LjAuMlwiLENoaWxkcmVuOmsscmVuZGVyOnosaHlkcmF0ZTpCLHVubW91bnRDb21wb25lbnRBdE5vZGU6cm4sY3JlYXRlUG9ydGFsOlcsY3JlYXRlRWxlbWVudDpzLGNyZWF0ZUNvbnRleHQ6XyxjcmVhdGVGYWN0b3J5Om5uLGNsb25lRWxlbWVudDplbixjcmVhdGVSZWY6YixGcmFnbWVudDpkLGlzVmFsaWRFbGVtZW50OnRuLGZpbmRET01Ob2RlOnVuLENvbXBvbmVudDphLFB1cmVDb21wb25lbnQ6RSxtZW1vOmcsZm9yd2FyZFJlZjp4LGZsdXNoU3luYzpsbix1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczpvbixTdHJpY3RNb2RlOmQsU3VzcGVuc2U6TCxTdXNwZW5zZUxpc3Q6TSxsYXp5OkYsX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6UX07ZXhwb3J0e1ggYXMgdmVyc2lvbixrIGFzIENoaWxkcmVuLHogYXMgcmVuZGVyLEIgYXMgaHlkcmF0ZSxybiBhcyB1bm1vdW50Q29tcG9uZW50QXROb2RlLFcgYXMgY3JlYXRlUG9ydGFsLG5uIGFzIGNyZWF0ZUZhY3RvcnksZW4gYXMgY2xvbmVFbGVtZW50LHRuIGFzIGlzVmFsaWRFbGVtZW50LHVuIGFzIGZpbmRET01Ob2RlLEUgYXMgUHVyZUNvbXBvbmVudCxnIGFzIG1lbW8seCBhcyBmb3J3YXJkUmVmLGxuIGFzIGZsdXNoU3luYyxvbiBhcyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxmbiBhcyBTdHJpY3RNb2RlLEwgYXMgU3VzcGVuc2UsTSBhcyBTdXNwZW5zZUxpc3QsRiBhcyBsYXp5LFEgYXMgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGF0Lm1vZHVsZS5qcy5tYXBcbiIsImltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuLyoqXG4gKiBTaG9ydGN1dCBmb3IgcHJlYWN0L2NvbXBhdCdzIGBmb3J3YXJkUmVmYCB0aGF0IGF1dG8tYXNzdW1lcyBzb21lIHRoaW5ncyB0aGF0IGFyZSB1c2VmdWwgZm9yIGZvcndhcmRpbmcgcmVmcyB0byBgSFRNTEVsZW1lbnRzYCBzcGVjaWZpY2FsbHkuXG4gKiBOYW1lbHkgaXQgaW52b2x2ZXMgZGUtZ3Vua2luZyB0aGUgdHlwZSBzeXN0ZW0gYnkgbGV0dGluZyB1cyByZXR1cm4gKmdlbmVyaWMqIGZ1bmN0aW9uIGFuZCBwbGF5aW5nIG5pY2Ugd2l0aCBSZWFjdC4gSW4gYWxsIG90aGVyIHJlc3BlY3RzLCBpdCBhY3RzIGxpa2UgYGZvcndhcmRSZWZgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZEVsZW1lbnRSZWYoQ29tcG9uZW50KSB7XG4gICAgY29uc3QgRm9yd2FyZGVkQ29tcG9uZW50ID0gZm9yd2FyZFJlZihDb21wb25lbnQpO1xuICAgIHJldHVybiBGb3J3YXJkZWRDb21wb25lbnQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3J3YXJkLWVsZW1lbnQtcmVmLmpzLm1hcCIsImltcG9ydCB7IGRlZmF1bHQgYXMgY2xzeCB9IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyBjbG9uZUVsZW1lbnQgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VMb2dpY2FsRGlyZWN0aW9uIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxvZ2ljYWwtZGlyZWN0aW9uXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbi8vaW1wb3J0IHsgbWVyZ2VTdHlsZXMgfSBmcm9tIFwiLi9tZXJnZS1zdHlsZVwiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1yZWYtZWxlbWVudFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vZm9yd2FyZC1lbGVtZW50LXJlZlwiO1xuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKGNsYXNzQmFzZSwgb3BlbiwgcGhhc2UpIHtcbiAgICBpZiAocGhhc2UpXG4gICAgICAgIHJldHVybiBgJHtjbGFzc0Jhc2UgfHwgXCJ0cmFuc2l0aW9uXCJ9LSR7b3Blbn0tJHtwaGFzZX1gO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGAke2NsYXNzQmFzZSB8fCBcInRyYW5zaXRpb25cIn0tJHtvcGVufWA7XG59XG5sZXQgZHVtbXk7XG5mdW5jdGlvbiBmb3JjZVJlZmxvdyhlKSB7XG4gICAgLy8gVHJ5IHJlYWxseSBoYXJkIHRvIG1ha2Ugc3VyZSB0aGlzIGlzbid0IG9wdGltaXplZCBvdXQgYnkgYW55dGhpbmcuXG4gICAgLy8gV2UgbmVlZCBpdCBmb3IgaXRzIGRvY3VtZW50IHJlZmxvdyBzaWRlIGVmZmVjdC5cbiAgICBkdW1teSA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIGU7XG59XG4vKipcbiAqIEEgaG9vayB0aGF0IGFkZHMgJiByZW1vdmVzIGNsYXNzIG5hbWVzIGluIGEgd2F5IHRoYXQgZmFjaWxpdGF0ZXMgcHJvcGVyIHRyYW5zaXRpb25zLlxuICpcbiAqIFRoZSBmaXJzdCBhcmd1bWVudCBjb250YWlucyB0aGUgcHJvcHMgcmVsYXRlZCBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbi5cbiAqXG4gKiBUaGUgc2Vjb25kIGFyZ3VtZW50IGNvbnRhaW5zIGFueSBvdGhlciBwcm9wcyB5b3UgbWlnaHQgd2FudCBtZXJnZWQgaW50byB0aGUgZmluYWwgcHJvZHVjdCAodGhlc2UgYXJlIG5vdCByZWFkIG9yIG1hbmlwdWxhdGVkIG9yIGFueXRoaW5nIC0tIGl0J3MgcHVyZWx5IHNob3J0aGFuZCBhbmQgY2FuIGJlIG9taXR0ZWQgd2l0aCBge31gIGFuZCB0aGVuIHlvdXIgb3duIGB1c2VNZXJnZWRQcm9wc2ApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wcyh7IG1lYXN1cmUsIGFuaW1hdGVPbk1vdW50LCBjbGFzc0Jhc2UsIG9uVHJhbnNpdGlvblVwZGF0ZSwgZXhpdFZpc2liaWxpdHksIGR1cmF0aW9uLCBvcGVuLCByZWYgfSwgb3RoZXJQcm9wcykge1xuICAgIGNsYXNzQmFzZSA/Pz0gXCJ0cmFuc2l0aW9uXCI7XG4gICAgY29uc3QgeyBlbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcbiAgICBjb25zdCBbcGhhc2UsIHNldFBoYXNlXSA9IHVzZVN0YXRlKGFuaW1hdGVPbk1vdW50ID8gXCJpbml0XCIgOiBudWxsKTtcbiAgICBjb25zdCBbZGlyZWN0aW9uLCBzZXREaXJlY3Rpb25dID0gdXNlU3RhdGUob3BlbiA9PSBudWxsID8gbnVsbCA6IG9wZW4gPyBcImVudGVyXCIgOiBcImV4aXRcIik7XG4gICAgY29uc3QgW3N1cmZhY2VXaWR0aCwgc2V0U3VyZmFjZVdpZHRoXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtzdXJmYWNlSGVpZ2h0LCBzZXRTdXJmYWNlSGVpZ2h0XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtzdXJmYWNlWCwgc2V0U3VyZmFjZVhdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW3N1cmZhY2VZLCBzZXRTdXJmYWNlWV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbdHJhbnNpdGlvbmluZ1dpZHRoLCBzZXRUcmFuc2l0aW9uaW5nV2lkdGhdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW3RyYW5zaXRpb25pbmdIZWlnaHQsIHNldFRyYW5zaXRpb25pbmdIZWlnaHRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW3RyYW5zaXRpb25pbmdYLCBzZXRUcmFuc2l0aW9uaW5nWF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbdHJhbnNpdGlvbmluZ1ksIHNldFRyYW5zaXRpb25pbmdZXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHsgZ2V0TG9naWNhbERpcmVjdGlvbiB9ID0gdXNlTG9naWNhbERpcmVjdGlvbihlbGVtZW50KTtcbiAgICBjb25zdCBsb2dpY2FsRGlyZWN0aW9uID0gZ2V0TG9naWNhbERpcmVjdGlvbigpO1xuICAgIGNvbnN0IG9uVHJhbnNpdGlvblVwZGF0ZVJlZiA9IHVzZVJlZihvblRyYW5zaXRpb25VcGRhdGUpO1xuICAgIGNvbnN0IHBoYXNlUmVmID0gdXNlUmVmKHBoYXNlKTtcbiAgICBjb25zdCBkaXJlY3Rpb25SZWYgPSB1c2VSZWYoZGlyZWN0aW9uKTtcbiAgICBjb25zdCBkdXJhdGlvblJlZiA9IHVzZVJlZihkdXJhdGlvbik7XG4gICAgY29uc3QgdG9vRWFybHlUaW1lb3V0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHRvb0Vhcmx5VmFsdWVSZWYgPSB1c2VSZWYodHJ1ZSk7XG4gICAgY29uc3QgdG9vTGF0ZVRpbWVvdXRSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbGVtZW50ICYmIHRvb0Vhcmx5VmFsdWVSZWYuY3VycmVudCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgc2V0UGhhc2UoXCJmaW5hbGl6ZVwiKTtcbiAgICAgICAgfVxuICAgIH0sIFtlbGVtZW50XSk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgb25UcmFuc2l0aW9uVXBkYXRlUmVmLmN1cnJlbnQgPSBvblRyYW5zaXRpb25VcGRhdGU7IH0sIFtvblRyYW5zaXRpb25VcGRhdGVdKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBwaGFzZVJlZi5jdXJyZW50ID0gcGhhc2U7IH0sIFtwaGFzZV0pO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IGRpcmVjdGlvblJlZi5jdXJyZW50ID0gZGlyZWN0aW9uOyB9LCBbZGlyZWN0aW9uXSk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgZHVyYXRpb25SZWYuY3VycmVudCA9IGR1cmF0aW9uOyB9LCBbZHVyYXRpb25dKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGlyZWN0aW9uICYmIHBoYXNlKVxuICAgICAgICAgICAgb25UcmFuc2l0aW9uVXBkYXRlUmVmLmN1cnJlbnQ/LihkaXJlY3Rpb24sIHBoYXNlKTtcbiAgICB9LCBbZGlyZWN0aW9uLCBwaGFzZV0pO1xuICAgIC8vIEV2ZXJ5IHRpbWUgdGhlIHBoYXNlIGNoYW5nZXMgdG8gXCJ0cmFuc2l0aW9uXCIsIGFkZCBvdXIgdHJhbnNpdGlvbiB0aW1lb3V0IHRpbWVvdXRzXG4gICAgLy8gdG8gY2F0Y2ggYW55IHRpbWUgb25UcmFuc2l0aW9uRW5kIGZhaWxzIHRvIHJlcG9ydCBmb3Igd2hhdGV2ZXIgcmVhc29uIHRvIGJlIHNhZmVcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocGhhc2UgPT0gXCJ0cmFuc2l0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXREdXJhdGlvbiA9IGR1cmF0aW9uUmVmLmN1cnJlbnQgPz8gMTAwMDtcbiAgICAgICAgICAgIHRvb0Vhcmx5VGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRvb0Vhcmx5VmFsdWVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRvb0Vhcmx5VGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgIHRvb0xhdGVUaW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdG9vRWFybHlWYWx1ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0b29MYXRlVGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzZXRQaGFzZShcImZpbmFsaXplXCIpO1xuICAgICAgICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRvb0Vhcmx5VGltZW91dFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0b29FYXJseVRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBpZiAodG9vTGF0ZVRpbWVvdXRSZWYuY3VycmVudClcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodG9vTGF0ZVRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIH07XG4gICAgfSwgW3BoYXNlXSk7XG4gICAgLy8gQW55IHRpbWUgXCJvcGVuXCIgY2hhbmdlcywgdXBkYXRlIG91ciBkaXJlY3Rpb24gYW5kIHBoYXNlLlxuICAgIC8vIEluIGFkZGl0aW9uLCBtZWFzdXJlIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudCAmJiBvcGVuICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUGhhc2UgPSBwaGFzZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgLy8gU3dhcCBvdXIgZGlyZWN0aW9uXG4gICAgICAgICAgICBpZiAob3BlbilcbiAgICAgICAgICAgICAgICBzZXREaXJlY3Rpb24oXCJlbnRlclwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZXREaXJlY3Rpb24oXCJleGl0XCIpO1xuICAgICAgICAgICAgc2V0UGhhc2UocHJldmlvdXNQaGFzZSA9PT0gbnVsbCA/IFwiZmluYWxpemVcIiA6IFwiaW5pdFwiKTtcbiAgICAgICAgICAgIGlmIChtZWFzdXJlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTaXplV2l0aFRyYW5zaXRpb24gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSBjdXJyZW50U2l6ZVdpdGhUcmFuc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uaW5nWCh4ICsgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbmluZ1koeSArIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25pbmdXaWR0aCh3aWR0aCArIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25pbmdIZWlnaHQoaGVpZ2h0ICsgXCJweFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzUGhhc2UgPT09IFwiZmluYWxpemVcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBiZSBtZXNzaW5nIHdpdGggdGhlIGFjdHVhbCBlbGVtZW50J3MgY2xhc3MsIFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSdsbCB3YW50IGFuIGVhc3kgd2F5IHRvIHJlc3RvcmUgaXQgbGF0ZXIuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2t1cCA9IGVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoYCR7Y2xhc3NCYXNlfS1tZWFzdXJlYCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgJHtjbGFzc0Jhc2V9LWVudGVyYCwgYCR7Y2xhc3NCYXNlfS1lbnRlci1pbml0YCwgYCR7Y2xhc3NCYXNlfS1lbnRlci10cmFuc2l0aW9uYCwgYCR7Y2xhc3NCYXNlfS1lbnRlci1maW5hbGl6ZWAsIGAke2NsYXNzQmFzZX0tZXhpdGAsIGAke2NsYXNzQmFzZX0tZXhpdC1pbml0YCwgYCR7Y2xhc3NCYXNlfS1leGl0LXRyYW5zaXRpb25gLCBgJHtjbGFzc0Jhc2V9LWV4aXQtZmluYWxpemVgKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VSZWZsb3coZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemVXaXRob3V0VHJhbnNpdGlvbiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gc2l6ZVdpdGhvdXRUcmFuc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzZXRTdXJmYWNlWCh4ICsgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3VyZmFjZVkoeSArIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldFN1cmZhY2VXaWR0aCh3aWR0aCArIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldFN1cmZhY2VIZWlnaHQoaGVpZ2h0ICsgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBiYWNrdXA7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlUmVmbG93KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtvcGVuLCBlbGVtZW50LCBtZWFzdXJlLCBjbGFzc0Jhc2VdKTtcbiAgICAvLyBBbnkgdGltZSB0aGUgcGhhc2UgY2hhbmdlcyB0byBpbml0LCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIHNjcmVlbiBpcyBwYWludGVkLFxuICAgIC8vIGNoYW5nZSB0aGUgcGhhc2UgdG8gXCJ0cmFuc2l0aW9uXCIgYW5kIHJlLXJlbmRlciAoKS5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudCAmJiBkaXJlY3Rpb25SZWYuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGFzc0Jhc2UgPz89IFwidHJhbnNpdGlvblwiO1xuICAgICAgICAgICAgaWYgKHBoYXNlID09PSBcImluaXRcIikge1xuICAgICAgICAgICAgICAgIC8vIFByZWFjdCBqdXN0IGZpbmlzaGVkIHJlbmRlcmluZyBpbml0XG4gICAgICAgICAgICAgICAgLy8gTm93IHNldCBvdXIgdHJhbnNpdGlvbiBzdHlsZS5cbiAgICAgICAgICAgICAgICBzZXRQaGFzZShcInRyYW5zaXRpb25cIik7XG4gICAgICAgICAgICAgICAgaWYgKG1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VSZWZsb3coZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3BoYXNlLCBtZWFzdXJlLCBlbGVtZW50XSk7XG4gICAgY29uc3QgaW5saW5lRGlyZWN0aW9uID0gbG9naWNhbERpcmVjdGlvbj8uaW5saW5lRGlyZWN0aW9uO1xuICAgIGNvbnN0IGJsb2NrRGlyZWN0aW9uID0gbG9naWNhbERpcmVjdGlvbj8uYmxvY2tEaXJlY3Rpb247XG4gICAgY29uc3Qgd3JpdGluZ01vZGVJc0hvcml6b250YWwgPSAoaW5saW5lRGlyZWN0aW9uID09IFwicnRsXCIgfHwgaW5saW5lRGlyZWN0aW9uID09IFwibHRyXCIpO1xuICAgIGNvbnN0IHN1cmZhY2VJbmxpbmVJbnNldCA9IHdyaXRpbmdNb2RlSXNIb3Jpem9udGFsID8gc3VyZmFjZVggOiBzdXJmYWNlWTtcbiAgICBjb25zdCBzdXJmYWNlQmxvY2tJbnNldCA9IHdyaXRpbmdNb2RlSXNIb3Jpem9udGFsID8gc3VyZmFjZVkgOiBzdXJmYWNlWDtcbiAgICBjb25zdCBzdXJmYWNlSW5saW5lU2l6ZSA9IHdyaXRpbmdNb2RlSXNIb3Jpem9udGFsID8gc3VyZmFjZVdpZHRoIDogc3VyZmFjZUhlaWdodDtcbiAgICBjb25zdCBzdXJmYWNlQmxvY2tTaXplID0gd3JpdGluZ01vZGVJc0hvcml6b250YWwgPyBzdXJmYWNlSGVpZ2h0IDogc3VyZmFjZVdpZHRoO1xuICAgIGNvbnN0IHRyYW5zaXRpb25pbmdJbmxpbmVJbnNldCA9IHdyaXRpbmdNb2RlSXNIb3Jpem9udGFsID8gdHJhbnNpdGlvbmluZ1ggOiB0cmFuc2l0aW9uaW5nWTtcbiAgICBjb25zdCB0cmFuc2l0aW9uaW5nQmxvY2tJbnNldCA9IHdyaXRpbmdNb2RlSXNIb3Jpem9udGFsID8gdHJhbnNpdGlvbmluZ1kgOiB0cmFuc2l0aW9uaW5nWDtcbiAgICBjb25zdCB0cmFuc2l0aW9uaW5nSW5saW5lU2l6ZSA9IHdyaXRpbmdNb2RlSXNIb3Jpem9udGFsID8gdHJhbnNpdGlvbmluZ1dpZHRoIDogdHJhbnNpdGlvbmluZ0hlaWdodDtcbiAgICBjb25zdCB0cmFuc2l0aW9uaW5nQmxvY2tTaXplID0gd3JpdGluZ01vZGVJc0hvcml6b250YWwgPyB0cmFuc2l0aW9uaW5nSGVpZ2h0IDogdHJhbnNpdGlvbmluZ1dpZHRoO1xuICAgIGxldCBhbG1vc3REb25lID0gdXNlUmVmRWxlbWVudFByb3BzKHtcbiAgICAgICAgcmVmLFxuICAgICAgICBzdHlsZTogcmVtb3ZlRW1wdHkoe1xuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1kdXJhdGlvbmBdOiBkdXJhdGlvbixcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tc3VyZmFjZS14YF06IHN1cmZhY2VYLFxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1zdXJmYWNlLXlgXTogc3VyZmFjZVksXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXN1cmZhY2Utd2lkdGhgXTogc3VyZmFjZVdpZHRoLFxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1zdXJmYWNlLWhlaWdodGBdOiBzdXJmYWNlSGVpZ2h0LFxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1zdXJmYWNlLWlubGluZS1pbnNldGBdOiBzdXJmYWNlSW5saW5lSW5zZXQsXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXN1cmZhY2UtYmxvY2staW5zZXRgXTogc3VyZmFjZUJsb2NrSW5zZXQsXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXN1cmZhY2UtaW5saW5lLXNpemVgXTogc3VyZmFjZUlubGluZVNpemUsXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXN1cmZhY2UtYmxvY2stc2l6ZWBdOiBzdXJmYWNlQmxvY2tTaXplLFxuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS10cmFuc2l0aW9uaW5nLXhgXTogdHJhbnNpdGlvbmluZ1gsXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXRyYW5zaXRpb25pbmcteWBdOiB0cmFuc2l0aW9uaW5nWSxcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tdHJhbnNpdGlvbmluZy13aWR0aGBdOiB0cmFuc2l0aW9uaW5nV2lkdGgsXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXRyYW5zaXRpb25pbmctaGVpZ2h0YF06IHRyYW5zaXRpb25pbmdIZWlnaHQsXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXRyYW5zaXRpb25pbmctaW5saW5lLWluc2V0YF06IHRyYW5zaXRpb25pbmdJbmxpbmVJbnNldCxcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tdHJhbnNpdGlvbmluZy1ibG9jay1pbnNldGBdOiB0cmFuc2l0aW9uaW5nQmxvY2tJbnNldCxcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tdHJhbnNpdGlvbmluZy1pbmxpbmUtc2l6ZWBdOiB0cmFuc2l0aW9uaW5nSW5saW5lU2l6ZSxcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tdHJhbnNpdGlvbmluZy1ibG9jay1zaXplYF06IHRyYW5zaXRpb25pbmdCbG9ja1NpemVcbiAgICAgICAgfSksXG4gICAgICAgIG9uVHJhbnNpdGlvbkVuZCxcbiAgICAgICAgLi4uKHsgXCJhcmlhLWhpZGRlblwiOiBvcGVuID8gdW5kZWZpbmVkIDogXCJ0cnVlXCIgfSksXG4gICAgICAgIGNsYXNzTmFtZTogY2xzeChkaXJlY3Rpb24gJiYgZ2V0Q2xhc3NOYW1lKGNsYXNzQmFzZSwgZGlyZWN0aW9uKSwgZGlyZWN0aW9uICYmIHBoYXNlICYmIGdldENsYXNzTmFtZShjbGFzc0Jhc2UsIGRpcmVjdGlvbiwgcGhhc2UpLCBleGl0VmlzaWJpbGl0eSA9PSBcInJlbW92ZWRcIiAmJiBgJHtjbGFzc0Jhc2V9LXJlbW92ZWQtb24tZXhpdGAsIGV4aXRWaXNpYmlsaXR5ID09IFwidmlzaWJsZVwiICYmIGAke2NsYXNzQmFzZX0tdmlzaWJsZS1vbi1leGl0YCwgYCR7Y2xhc3NCYXNlfS1pbmxpbmUtZGlyZWN0aW9uLSR7aW5saW5lRGlyZWN0aW9uID8/IFwibHRyXCJ9YCwgYCR7Y2xhc3NCYXNlfS1ibG9jay1kaXJlY3Rpb24tJHtibG9ja0RpcmVjdGlvbiA/PyBcInR0YlwifWApLFxuICAgIH0pO1xuICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKGFsbW9zdERvbmUsIG90aGVyUHJvcHMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRW1wdHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvYmopLmZpbHRlcigoW18sIHZdKSA9PiB2ICE9IG51bGwpKTtcbn1cbi8qKlxuICogQSBjb21wb25lbnQgdGhhdCAqd3JhcHMgYW4gSFRNTEVsZW1lbnQgb3Igb3RoZXIgcmVmLWZvcndhcmRpbmcgY29tcG9uZW50KiBhbmQgYWxsb3dzIGl0IHRvIHVzZSBDU1MgdG8gdHJhbnNpdGlvbiBpbi9vdXQuXG4gKiBDb21iaW5lcyB0aGUgcHJvcHMgcGFzc2VkIHRvIGl0LCB0aGUgcHJvcHMgaXRzIGNoaWxkIGhhcywgYW5kIHRoZSBwcm9wcyBuZWVkZWQgZm9yIHRoZSBDU1MgdHJhbnNpdGlvbiwgYW5kIHBhc3NlcyB0aGVtXG4gKiBhbGwgdG8gdGhlIGNoaWxkIGVsZW1lbnQgeW91IHByb3ZpZGUuXG4gKlxuICogVGhpcyBpcyB0aGUgbW9zdCBnZW5lcmFsIGNvbXBvbmVudCB0aGF0IG90aGVycyB1c2UgYXMgYSBiYXNlLiBCeSBkZWZhdWx0LCB0aGlzIGNvbXBvbmVudCBieSBpdHNlbGYgZG9lc24ndCBhY3R1YWxseSBhZGQgYW55IENTUyBjbGFzc2VzIHRoYXQgYW5pbWF0ZSBhbnl0aGluZyAobGlrZSBvcGFjaXR5LCBmb3IgZXhhbXBsZSkuXG4gKiBJdCBhZGRzIGNsYXNzZXMgbGlrZSBgdHJhbnNpdGlvbi1lbnRlci1maW5hbGl6ZWAsIGJ1dCB5b3UgbmVlZCB0byBwcm92aWRlIHRoZSBhZGRpdGlvbmFsIGUuZy4gYGZhZGVgIGNsYXNzIHRoYXQgcmVhY3RzIHRvIGl0LlxuICpcbiAqIFVzZSB0aGlzIGlmIHRoZSBvdGhlciwgbW9yZSBzcGVjaWFsaXplZCBUcmFuc2l0aW9uIGNvbXBvbmVudHMgZG9uJ3QgZml0IHlvdXIgbmVlZHMuXG4gKlxuICogQGV4YW1wbGUgYDxUcmFuc2l0aW9uYWJsZSBvcGVuPXtvcGVufSB7Li4udXNlQ3JlYXRlRmFkZVByb3BzKC4uLil9PjxkaXY+e2NoaWxkcmVufTwvZGl2PjwvVHJhbnNpdGlvbmFibGU+YFxuICogQGV4YW1wbGUgYDxUcmFuc2l0aW9uYWJsZSBvcGVuPXtvcGVufT48ZGl2IHsuLi51c2VDcmVhdGVGYWRlUHJvcHMoLi4uKX0+e2NoaWxkcmVufTwvZGl2PjwvVHJhbnNpdGlvbmFibGU+YFxuICovXG5leHBvcnQgY29uc3QgVHJhbnNpdGlvbmFibGUgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBUcmFuc2l0aW9uKHsgY2hpbGRyZW46IGNoaWxkLCBkdXJhdGlvbiwgY2xhc3NCYXNlLCBtZWFzdXJlLCBleGl0VmlzaWJpbGl0eSwgb3Blbiwgb25UcmFuc2l0aW9uVXBkYXRlLCBhbmltYXRlT25Nb3VudCwgLi4ucHJvcHMgfSwgcikge1xuICAgIGlmICghY2hpbGRJc1ZOb2RlKGNoaWxkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIFRyYW5zaXRpb25hYmxlIGNvbXBvbmVudCBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY29tcG9uZW50IGNoaWxkIChlLmcuIGEgPGRpdj4sIGJ1dCBub3QgXFxcImEgc3RyaW5nXFxcIikuXCIpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2l0aW9uUHJvcHMgPSB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzKHsgY2xhc3NCYXNlLCBkdXJhdGlvbiwgbWVhc3VyZSwgb3BlbiwgYW5pbWF0ZU9uTW91bnQsIG9uVHJhbnNpdGlvblVwZGF0ZSwgcmVmOiByLCBleGl0VmlzaWJpbGl0eSB9LCBwcm9wcyk7XG4gICAgY29uc3QgbWVyZ2VkV2l0aENoaWxkcmVuID0gdXNlTWVyZ2VkUHJvcHMoKSh0cmFuc2l0aW9uUHJvcHMsIHsgLi4uY2hpbGQucHJvcHMsIHJlZjogY2hpbGQucmVmIH0pO1xuICAgIHJldHVybiBjbG9uZUVsZW1lbnQoY2hpbGQsIG1lcmdlZFdpdGhDaGlsZHJlbik7XG59KTtcbmZ1bmN0aW9uIGNoaWxkSXNWTm9kZShjaGlsZCkge1xuICAgIGlmICghY2hpbGQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKFwicHJvcHNcIiBpbiBjaGlsZCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2l0aW9uYWJsZS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IFRyYW5zaXRpb25hYmxlIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGVcIjtcbmltcG9ydCB7IGRlZmF1bHQgYXMgY2xzeCB9IGZyb20gXCJjbHN4XCI7XG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBDbGlwIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cbiAqIEJlIHN1cmUgdG8gbWVyZ2UgdGhlc2UgcmV0dXJuZWQgcHJvcHMgd2l0aCB3aGF0ZXZlciB0aGUgdXNlciBwYXNzZWQgaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDcmVhdGVDbGlwUHJvcHMoeyBjbGFzc0Jhc2UsIGNsaXBPcmlnaW4sIGNsaXBPcmlnaW5JbmxpbmUsIGNsaXBPcmlnaW5CbG9jaywgY2xpcE1pbiwgY2xpcE1pbklubGluZSwgY2xpcE1pbkJsb2NrIH0sIG90aGVyUHJvcHMpIHtcbiAgICBjbGFzc0Jhc2UgPz89IFwidHJhbnNpdGlvblwiO1xuICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbHN4KGAke2NsYXNzQmFzZX0tY2xpcGApLFxuICAgICAgICBjbGFzc0Jhc2UsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWNsaXAtb3JpZ2luLWlubGluZWBdOiAoY2xpcE9yaWdpbklubGluZSA/PyBjbGlwT3JpZ2luID8/IDAuNSksXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWNsaXAtb3JpZ2luLWJsb2NrYF06IChjbGlwT3JpZ2luQmxvY2sgPz8gY2xpcE9yaWdpbiA/PyAwKSxcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tY2xpcC1taW4taW5saW5lYF06IChjbGlwTWluSW5saW5lID8/IGNsaXBNaW4gPz8gMSksXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWNsaXAtbWluLWJsb2NrYF06IChjbGlwTWluQmxvY2sgPz8gY2xpcE1pbiA/PyAwKSxcbiAgICAgICAgfSxcbiAgICB9LCBvdGhlclByb3BzKTtcbn1cbjtcbmV4cG9ydCBjb25zdCBDbGlwID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2xpcCh7IGNsYXNzQmFzZSwgY2xpcE9yaWdpbiwgY2xpcE9yaWdpbklubGluZSwgY2xpcE9yaWdpbkJsb2NrLCBjbGlwTWluLCBjbGlwTWluSW5saW5lLCBjbGlwTWluQmxvY2ssIG9wZW4sIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgcmV0dXJuIGgoVHJhbnNpdGlvbmFibGUsIHsgb3Blbjogb3BlbiwgLi4udXNlQ3JlYXRlQ2xpcFByb3BzKHsgY2xhc3NCYXNlLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luSW5saW5lLCBjbGlwT3JpZ2luQmxvY2ssIGNsaXBNaW4sIGNsaXBNaW5JbmxpbmUsIGNsaXBNaW5CbG9jayB9LCB7IC4uLnJlc3QsIHJlZiB9KSB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpcC5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IFRyYW5zaXRpb25hYmxlIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGVcIjtcbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIEZhZGUgdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxuICogQmUgc3VyZSB0byBtZXJnZSB0aGVzZSByZXR1cm5lZCBwcm9wcyB3aXRoIHdoYXRldmVyIHRoZSB1c2VyIHBhc3NlZCBpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNyZWF0ZUZhZGVQcm9wcyh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCB9LCBvdGhlclByb3BzKSB7XG4gICAgY2xhc3NCYXNlID8/PSBcInRyYW5zaXRpb25cIjtcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7XG4gICAgICAgIGNsYXNzTmFtZTogYCR7Y2xhc3NCYXNlfS1mYWRlYCxcbiAgICAgICAgY2xhc3NCYXNlLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1mYWRlLW1pbmBdOiAoZmFkZU1pbiA/PyAwKSxcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tZmFkZS1tYXhgXTogKGZhZGVNYXggPz8gMSksXG4gICAgICAgIH1cbiAgICB9LCBvdGhlclByb3BzKTtcbn1cbjtcbi8qKlxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIEZhZGUgZWZmZWN0LlxuICpcbiAqIE5vdGUgdGhhdCB3aGlsZSBpdCBpcyBhYnNvbHV0ZWx5IHBvc3NpYmxlIHRvIHdyYXAgYW5vdGhlciB0cmFuc2l0aW9uIHdpdGggYDxGYWRlPmAsXG4gKiB0aGVyZSB3aWxsIGJlIHNvbWUgZHVwbGljYXRlIGNvZGUgcnVuIGFzIHR3byBgPFRyYW5zaXRpb25hYmxlPmAgY29tcG9uZW50cyBlbmQgdXAgb3BlcmF0aW5nIG9uIHRoZSBzYW1lIGVsZW1lbnQuXG4gKiBJdCdzIGdlbmVyYWxseSByZWNvbW1lbmRlZCB0byBlaXRoZXIgdXNlIHRoZSBjb21wb25lbnRzIHRoYXQgaW5jbHVkZSBhIGNvbWJpbmVkIGZhZGUgZWZmZWN0LFxuICogb3IganVzdCBkaXJlY3RseSBhIGA8VHJhbnNpdGlvbmFibGU+YCBvbiB5b3VyIG93bi5cbiAqXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcbiAqL1xuZXhwb3J0IGNvbnN0IEZhZGUgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBGYWRlKHsgY2xhc3NCYXNlLCBmYWRlTWluLCBmYWRlTWF4LCBvcGVuLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIHJldHVybiBoKFRyYW5zaXRpb25hYmxlLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZUZhZGVQcm9wcyh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCB9LCB7IC4uLnJlc3QsIHJlZiB9KSB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFkZS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgQ2xpcCB9IGZyb20gXCIuL2NsaXBcIjtcbmltcG9ydCB7IHVzZUNyZWF0ZUZhZGVQcm9wcyB9IGZyb20gXCIuL2ZhZGVcIjtcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vZm9yd2FyZC1lbGVtZW50LXJlZlwiO1xuO1xuZXhwb3J0IGNvbnN0IENsaXBGYWRlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2xpcEZhZGUoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXgsIG9wZW4sIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgcmV0dXJuIGgoQ2xpcCwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVGYWRlUHJvcHMoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXggfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaXAtZmFkZS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IFRyYW5zaXRpb25hYmxlIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGVcIjtcbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIFpvb20gdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxuICogQmUgc3VyZSB0byBtZXJnZSB0aGVzZSByZXR1cm5lZCBwcm9wcyB3aXRoIHdoYXRldmVyIHRoZSB1c2VyIHBhc3NlZCBpbi5cbiAqXG4gKiBJTVBPUlRBTlQ6IElmIHVzZWQgb3V0c2lkZSBvZiBhIGA8Q29sbGFwc2UgLz5gLCB5b3UgbXVzdCBpbmNsdWRlIHRoZSBgbWVhc3VyZWAgcHJvcCBvbiB0aGUgYDxUcmFuc2l0aW9uYWJsZT5gIHRoYXQgeW91IHVzZS5cbiAqXG4gKiBAZXhhbXBsZSA8VHJhbnNpdGlvbmFibGUgbWVhc3VyZSB7Li4udXNlQ3JlYXRlQ29sbGFwc2VQcm9wcyguLi4pfSAvPlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlQ29sbGFwc2VQcm9wcyh7IGNsYXNzQmFzZSwgbWluQmxvY2tTaXplIH0sIG90aGVyUHJvcHMpIHtcbiAgICBjbGFzc0Jhc2UgPz89IFwidHJhbnNpdGlvblwiO1xuICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHtcbiAgICAgICAgY2xhc3NCYXNlLFxuICAgICAgICBtZWFzdXJlOiB0cnVlLFxuICAgICAgICBjbGFzc05hbWU6IGAke2NsYXNzQmFzZX0tY29sbGFwc2VgLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgW2AtLSR7Y2xhc3NCYXNlfS1jb2xsYXBzZS1taW4tYmxvY2tgXTogbWluQmxvY2tTaXplID8/IDBcbiAgICAgICAgfVxuICAgIH0sIG90aGVyUHJvcHMpO1xufVxuO1xuLyoqXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgQ29sbGFwc2UgZWZmZWN0LlxuICpcbiAqICpJbXBvcnRhbnQqOiBUaGlzIGNvbXBvbmVudCBpcyAqbm90KiBlZmZpY2llbnQgZm9yIHRoZSBicm93c2VyIHRvIGFuaW1hdGUhXG4gKiBNYWtlIHN1cmUgeW91IGRvIHRlc3Rpbmcgb24gbG93ZXIgcG93ZXIgZGV2aWNlcywgb3IgcHJlZmVyIGEgbGlnaHRlclxuICogYWx0ZXJuYXRpdmUsIGxpa2UgYDxDbGlwPmAuXG4gKlxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgXG4gKi9cbmV4cG9ydCBjb25zdCBDb2xsYXBzZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENvbGxhcHNlKHsgY2xhc3NCYXNlLCBvcGVuLCBtaW5CbG9ja1NpemUsIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgcmV0dXJuIGgoVHJhbnNpdGlvbmFibGUsIHsgb3Blbjogb3BlbiwgLi4udXNlQ3JlYXRlQ29sbGFwc2VQcm9wcyh7IGNsYXNzQmFzZSwgbWluQmxvY2tTaXplIH0sIHsgLi4ucmVzdCwgcmVmIH0pIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsYXBzZS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgQ29sbGFwc2UgfSBmcm9tIFwiLi9jb2xsYXBzZVwiO1xuaW1wb3J0IHsgdXNlQ3JlYXRlRmFkZVByb3BzIH0gZnJvbSBcIi4vZmFkZVwiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XG47XG4vKipcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYm90aCBDb2xsYXBzZSBhbmQgRmFkZSBlZmZlY3RzLlxuICpcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYCBgQ29sbGFwc2VgIGBGYWRlYFxuICovXG5leHBvcnQgY29uc3QgQ29sbGFwc2VGYWRlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ29sbGFwc2VGYWRlKHsgY2xhc3NCYXNlLCBmYWRlTWluLCBmYWRlTWF4LCBvcGVuLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIHJldHVybiBoKENvbGxhcHNlLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZUZhZGVQcm9wcyh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCB9LCB7IC4uLnJlc3QsIHJlZiB9KSB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sbGFwc2UtZmFkZS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vZm9yd2FyZC1lbGVtZW50LXJlZlwiO1xuaW1wb3J0IHsgVHJhbnNpdGlvbmFibGUgfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZVwiO1xuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgU2xpZGUgdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlU2xpZGVQcm9wcyh7IGNsYXNzQmFzZSwgc2xpZGVUYXJnZXRJbmxpbmUsIHNsaWRlVGFyZ2V0QmxvY2sgfSwgb3RoZXJQcm9wcykge1xuICAgIGNsYXNzQmFzZSA/Pz0gXCJ0cmFuc2l0aW9uXCI7XG4gICAgY29uc3QgbGFzdFZhbGlkVGFyZ2V0SW5saW5lID0gdXNlUmVmKHNsaWRlVGFyZ2V0SW5saW5lID8/IDEpO1xuICAgIGNvbnN0IGxhc3RWYWxpZFRhcmdldEJsb2NrID0gdXNlUmVmKHNsaWRlVGFyZ2V0QmxvY2sgPz8gMCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHsgaWYgKHNsaWRlVGFyZ2V0SW5saW5lKVxuICAgICAgICBsYXN0VmFsaWRUYXJnZXRJbmxpbmUuY3VycmVudCA9IHNsaWRlVGFyZ2V0SW5saW5lOyB9LCBbc2xpZGVUYXJnZXRJbmxpbmVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4geyBpZiAoc2xpZGVUYXJnZXRCbG9jaylcbiAgICAgICAgbGFzdFZhbGlkVGFyZ2V0QmxvY2suY3VycmVudCA9IHNsaWRlVGFyZ2V0QmxvY2s7IH0sIFtzbGlkZVRhcmdldEJsb2NrXSk7XG4gICAgaWYgKHNsaWRlVGFyZ2V0SW5saW5lID09IDApXG4gICAgICAgIHNsaWRlVGFyZ2V0SW5saW5lID0gbGFzdFZhbGlkVGFyZ2V0SW5saW5lLmN1cnJlbnQ7XG4gICAgaWYgKHNsaWRlVGFyZ2V0QmxvY2sgPT0gMClcbiAgICAgICAgc2xpZGVUYXJnZXRCbG9jayA9IGxhc3RWYWxpZFRhcmdldEJsb2NrLmN1cnJlbnQ7XG4gICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoe1xuICAgICAgICBjbGFzc05hbWU6IGAke2NsYXNzQmFzZX0tc2xpZGVgLFxuICAgICAgICBjbGFzc0Jhc2UsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXNsaWRlLXRhcmdldC1pbmxpbmVgXTogYCR7KHNsaWRlVGFyZ2V0SW5saW5lID8/IDApfWAsXG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXNsaWRlLXRhcmdldC1ibG9ja2BdOiBgJHsoc2xpZGVUYXJnZXRCbG9jayA/PyAwKX1gXG4gICAgICAgIH1cbiAgICB9LCBvdGhlclByb3BzKTtcbn1cbjtcbi8qKlxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIFNsaWRlIGVmZmVjdC5cbiAqXG4gKiBQcm92aWRlIHRoZSBkaXJlY3Rpb24gdGhlIGVsZW1lbnQgd2lsbCB0cmF2ZWwgaW4gd2l0aCBgc2xpZGVJbmxpbmVgIGFuZCBgc2xpZGVCbG9ja2AsXG4gKiB3aXRoIGAxYCBiZWluZyBgMTAwJWAgb2YgdGhlIGVsZW1lbnQncyB3aWR0aCBvciBoZWlnaHQuXG4gKlxuICogQSB2YWx1ZSBvZiBgMGAgaXMgaGFuZGxlZCBzcGVjaWFsbHksIGVmZmVjdGl2ZWx5IG1lYW5pbmcgXCJ1c2UgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWVcIixcbiAqIHdoaWNoIGFsbG93cyBmb3IgY29udmVuaWVudCBzZXR1cHMgaW5zaWRlIG9mIGEgYFN3YXBDb250YWluZXJgXG4gKiAoYHNsaWRlSW5saW5lPXtpbmRleCAtIHNlbGVjdGVkSW5kZXh9YCBvciBzaW1pbGFyLilcbiAqXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcbiAqL1xuZXhwb3J0IGNvbnN0IFNsaWRlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGUoeyBjbGFzc0Jhc2UsIHNsaWRlVGFyZ2V0SW5saW5lLCBzbGlkZVRhcmdldEJsb2NrLCBvcGVuLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIHJldHVybiBoKFRyYW5zaXRpb25hYmxlLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZVNsaWRlUHJvcHMoeyBjbGFzc0Jhc2UsIHNsaWRlVGFyZ2V0SW5saW5lLCBzbGlkZVRhcmdldEJsb2NrIH0sIHsgLi4ucmVzdCwgcmVmIH0pIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGlkZS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ3JlYXRlRmFkZVByb3BzIH0gZnJvbSBcIi4vZmFkZVwiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XG5pbXBvcnQgeyBTbGlkZSB9IGZyb20gXCIuL3NsaWRlXCI7XG47XG4vKipcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYm90aCBTbGlkZSBhbmQgRmFkZSBlZmZlY3RzLlxuICpcbiAqIGBzbGlkZUlubGluZT17KGluZGV4IC0gc2VsZWN0ZWRJbmRleCkgLyAxMH1gIHdvdWxkIG1ha2UgdGhlIGVsZW1lbnQgbG9vayBsaWtlIGl0IGZhZGVzIG91dCBiZWZvcmUgaXQgdHJhdmVscyB0byBpdHMgdGFyZ2V0IGRlc3RpbmF0aW9uLlxuICpcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYCBgWm9vbWBcbiAqL1xuZXhwb3J0IGNvbnN0IFNsaWRlRmFkZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFNsaWRlRmFkZSh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCwgb3BlbiwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICByZXR1cm4gaChTbGlkZSwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVGYWRlUHJvcHMoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXggfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWRlLWZhZGUuanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XG5pbXBvcnQgeyBUcmFuc2l0aW9uYWJsZSB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBab29tIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNyZWF0ZVpvb21Qcm9wcyh7IGNsYXNzQmFzZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbklubGluZSwgem9vbU9yaWdpbkJsb2NrLCB6b29tTWluLCB6b29tTWluSW5saW5lLCB6b29tTWluQmxvY2sgfSwgb3RoZXJQcm9wcykge1xuICAgIGNsYXNzQmFzZSA/Pz0gXCJ0cmFuc2l0aW9uXCI7XG4gICAgcmV0dXJuICh1c2VNZXJnZWRQcm9wcygpKHtcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtjbGFzc0Jhc2V9LXpvb21gLFxuICAgICAgICBjbGFzc0Jhc2UsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LXpvb20tb3JpZ2luLWlubGluZWBdOiBgJHsoem9vbU9yaWdpbklubGluZSA/PyB6b29tT3JpZ2luID8/IDAuNSl9YCxcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tem9vbS1vcmlnaW4tYmxvY2tgXTogYCR7KHpvb21PcmlnaW5CbG9jayA/PyB6b29tT3JpZ2luID8/IDAuNSl9YCxcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tem9vbS1taW4taW5saW5lYF06IGAkeyh6b29tTWluSW5saW5lID8/IHpvb21NaW4gPz8gMCl9YCxcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tem9vbS1taW4tYmxvY2tgXTogYCR7KHpvb21NaW5CbG9jayA/PyB6b29tTWluID8/IDApfWAsXG4gICAgICAgIH0sXG4gICAgfSwgb3RoZXJQcm9wcykpO1xufVxuO1xuLyoqXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgWm9vbSBlZmZlY3QuXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWAgYFpvb21GYWRlYFxuICovXG5leHBvcnQgY29uc3QgWm9vbSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFpvb20oeyBjbGFzc0Jhc2UsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5JbmxpbmUsIHpvb21PcmlnaW5CbG9jaywgem9vbU1pbiwgem9vbU1pbklubGluZSwgem9vbU1pbkJsb2NrLCBvcGVuLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIHJldHVybiBoKFRyYW5zaXRpb25hYmxlLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZVpvb21Qcm9wcyh7IGNsYXNzQmFzZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbklubGluZSwgem9vbU9yaWdpbkJsb2NrLCB6b29tTWluLCB6b29tTWluSW5saW5lLCB6b29tTWluQmxvY2sgfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXpvb20uanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNyZWF0ZUZhZGVQcm9wcyB9IGZyb20gXCIuL2ZhZGVcIjtcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vZm9yd2FyZC1lbGVtZW50LXJlZlwiO1xuaW1wb3J0IHsgWm9vbSB9IGZyb20gXCIuL3pvb21cIjtcbjtcbi8qKlxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBib3RoIFpvb20gYW5kIEZhZGUgZWZmZWN0cy5cbiAqXG4gKiBUaGlzIGlzIGFuIGlkZWFsIHRpbWUgdG8gdXNlIHRoZSBtaW5pbXVtIHNpemUgWm9vbSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYCBgWm9vbWBcbiAqL1xuZXhwb3J0IGNvbnN0IFpvb21GYWRlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gWm9vbUZhZGUoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXgsIG9wZW4sIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgcmV0dXJuIGgoWm9vbSwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVGYWRlUHJvcHMoeyBjbGFzc0Jhc2UsIGZhZGVNaW4sIGZhZGVNYXggfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXpvb20tZmFkZS5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XG5pbXBvcnQgeyBTbGlkZSB9IGZyb20gXCIuL3NsaWRlXCI7XG5pbXBvcnQgeyB1c2VDcmVhdGVab29tUHJvcHMgfSBmcm9tIFwiLi96b29tXCI7XG47XG4vKipcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYm90aCBTbGlkZSBhbmQgWm9vbSBlZmZlY3RzLlxuICpcbiAqIFByb2JhYmx5IGJlc3QgY29tYmluZWQgd2l0aCBgdXNlQ3JlYXRlRmFkZVByb3BzYCAob3IganVzdCB1c2luZyBhIGBTbGlkZVpvb21GYWRlYD8pLlxuICpcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYCBgU2xpZGVGYWRlWm9vbWAgYFpvb21gIGBGYWRlYFxuICovXG5leHBvcnQgY29uc3QgU2xpZGVab29tID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGVab29tKHsgY2xhc3NCYXNlLCB6b29tTWluLCB6b29tTWluSW5saW5lLCB6b29tTWluQmxvY2ssIHpvb21PcmlnaW4sIHpvb21PcmlnaW5JbmxpbmUsIHpvb21PcmlnaW5CbG9jaywgb3BlbiwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICByZXR1cm4gaChTbGlkZSwgeyBvcGVuOiBvcGVuLCAuLi51c2VDcmVhdGVab29tUHJvcHMoeyBjbGFzc0Jhc2UsIHpvb21NaW4sIHpvb21NaW5JbmxpbmUsIHpvb21NaW5CbG9jaywgem9vbU9yaWdpbiwgem9vbU9yaWdpbklubGluZSwgem9vbU9yaWdpbkJsb2NrIH0sIHsgLi4ucmVzdCwgcmVmIH0pIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGlkZS16b29tLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDcmVhdGVGYWRlUHJvcHMgfSBmcm9tIFwiLi9mYWRlXCI7XG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL2ZvcndhcmQtZWxlbWVudC1yZWZcIjtcbmltcG9ydCB7IFNsaWRlWm9vbSB9IGZyb20gXCIuL3NsaWRlLXpvb21cIjtcbjtcbi8qKlxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBab29tLCBTbGlkZSwgYW5kIEZhZGUgZWZmZWN0cy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBpcyBiYXNpY2FsbHkganVzdCBzaG9ydGhhbmQgZm9yIHNvbWUgcHJvcCBjcmVhdGlvbiBhbmQgcHJvcCBtZXJnaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWAgYFNsaWRlYCBgWm9vbWAgYEZhZGVgXG4gKi9cbmV4cG9ydCBjb25zdCBTbGlkZVpvb21GYWRlID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGVab29tRmFkZSh7IGNsYXNzQmFzZSwgZmFkZU1pbiwgZmFkZU1heCwgb3BlbiwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICByZXR1cm4gaChTbGlkZVpvb20sIHsgb3Blbjogb3BlbiwgLi4udXNlQ3JlYXRlRmFkZVByb3BzKHsgY2xhc3NCYXNlLCBmYWRlTWluLCBmYWRlTWF4IH0sIHsgLi4ucmVzdCwgcmVmIH0pIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGlkZS16b29tLWZhZGUuanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IFRyYW5zaXRpb25hYmxlIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGVcIjtcbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIEZsaXAgdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlRmxpcFByb3BzKHsgY2xhc3NCYXNlLCBmbGlwQW5nbGVJbmxpbmUsIGZsaXBBbmdsZUJsb2NrLCBwZXJzcGVjdGl2ZSB9LCBvdGhlclByb3BzKSB7XG4gICAgY2xhc3NCYXNlID8/PSBcInRyYW5zaXRpb25cIjtcbiAgICBjb25zdCBsYXN0VmFsaWRUYXJnZXRJbmxpbmUgPSB1c2VSZWYoZmxpcEFuZ2xlSW5saW5lID8/IDE4MCk7XG4gICAgY29uc3QgbGFzdFZhbGlkVGFyZ2V0QmxvY2sgPSB1c2VSZWYoZmxpcEFuZ2xlQmxvY2sgPz8gMCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHsgaWYgKGZsaXBBbmdsZUlubGluZSlcbiAgICAgICAgbGFzdFZhbGlkVGFyZ2V0SW5saW5lLmN1cnJlbnQgPSBmbGlwQW5nbGVJbmxpbmU7IH0sIFtmbGlwQW5nbGVJbmxpbmVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4geyBpZiAoZmxpcEFuZ2xlQmxvY2spXG4gICAgICAgIGxhc3RWYWxpZFRhcmdldEJsb2NrLmN1cnJlbnQgPSBmbGlwQW5nbGVCbG9jazsgfSwgW2ZsaXBBbmdsZUJsb2NrXSk7XG4gICAgaWYgKGZsaXBBbmdsZUlubGluZSA9PSAwKVxuICAgICAgICBmbGlwQW5nbGVJbmxpbmUgPSBsYXN0VmFsaWRUYXJnZXRJbmxpbmUuY3VycmVudDtcbiAgICBpZiAoZmxpcEFuZ2xlQmxvY2sgPT0gMClcbiAgICAgICAgZmxpcEFuZ2xlQmxvY2sgPSBsYXN0VmFsaWRUYXJnZXRCbG9jay5jdXJyZW50O1xuICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHtcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtjbGFzc0Jhc2V9LWZsaXBgLFxuICAgICAgICBjbGFzc0Jhc2UsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBbYC0tJHtjbGFzc0Jhc2V9LWZsaXAtYW5nbGUtaW5saW5lYF06IGAkeyhmbGlwQW5nbGVJbmxpbmUgPz8gMCl9ZGVnYCxcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tZmxpcC1hbmdsZS1ibG9ja2BdOiBgJHsoZmxpcEFuZ2xlQmxvY2sgPz8gMCl9ZGVnYCxcbiAgICAgICAgICAgIFtgLS0ke2NsYXNzQmFzZX0tcGVyc3BlY3RpdmVgXTogYCR7KHBlcnNwZWN0aXZlID8/IDgwMCl9cHhgXG4gICAgICAgIH1cbiAgICB9LCBvdGhlclByb3BzKTtcbn1cbjtcbi8qKlxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIEZsaXAgZWZmZWN0LlxuICpcbiAqIFByb3ZpZGUgdGhlIGRpcmVjdGlvbiB0aGUgZWxlbWVudCB3aWxsIHRyYXZlbCBpbiB3aXRoIGBmbGlwSW5saW5lYCBhbmQgYGZsaXBCbG9ja2AsXG4gKiB3aXRoIGAxYCBiZWluZyBgMTAwJWAgb2YgdGhlIGVsZW1lbnQncyB3aWR0aCBvciBoZWlnaHQuXG4gKlxuICogQSB2YWx1ZSBvZiBgMGAgaXMgaGFuZGxlZCBzcGVjaWFsbHksIGVmZmVjdGl2ZWx5IG1lYW5pbmcgXCJ1c2UgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWVcIixcbiAqIHdoaWNoIGFsbG93cyBmb3IgY29udmVuaWVudCBzZXR1cHMgaW5zaWRlIG9mIGEgYFN3YXBDb250YWluZXJgXG4gKiAoYGZsaXBJbmxpbmU9e2luZGV4IC0gc2VsZWN0ZWRJbmRleH1gIG9yIHNpbWlsYXIuKVxuICpcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYFxuICovXG5leHBvcnQgY29uc3QgRmxpcCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEZsaXAoeyBjbGFzc0Jhc2UsIGZsaXBBbmdsZUlubGluZSwgZmxpcEFuZ2xlQmxvY2ssIHBlcnNwZWN0aXZlLCBvcGVuLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIHJldHVybiBoKFRyYW5zaXRpb25hYmxlLCB7IG9wZW46IG9wZW4sIC4uLnVzZUNyZWF0ZUZsaXBQcm9wcyh7IGNsYXNzQmFzZSwgZmxpcEFuZ2xlSW5saW5lLCBmbGlwQW5nbGVCbG9jaywgcGVyc3BlY3RpdmUgfSwgeyAuLi5yZXN0LCByZWYgfSkgfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZsaXAuanMubWFwIiwiaW1wb3J0IHsgZGVmYXVsdCBhcyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IGNsb25lRWxlbWVudCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi9mb3J3YXJkLWVsZW1lbnQtcmVmXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBzd2FwIGNvbnRhaW5lci5cbiAqIEJlIHN1cmUgdG8gbWVyZ2UgdGhlc2UgcmV0dXJuZWQgcHJvcHMgd2l0aCB3aGF0ZXZlciB0aGUgdXNlciBwYXNzZWQgaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDcmVhdGVTd2FwcGFibGVQcm9wcyh7IGlubGluZSwgY2xhc3NCYXNlIH0sIG90aGVyUHJvcHMpIHtcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7XG4gICAgICAgIGNsYXNzTmFtZTogY2xzeChgJHtjbGFzc0Jhc2UgPz8gXCJ0cmFuc2l0aW9uXCJ9LXN3YXAtY29udGFpbmVyYCwgaW5saW5lICYmIGAke2NsYXNzQmFzZSA/PyBcInRyYW5zaXRpb25cIn0tc3dhcC1jb250YWluZXItaW5saW5lYClcbiAgICB9LCBvdGhlclByb3BzKTtcbn1cbi8qKlxuICogQWxsb3dzIGEgc2V0IG9mIGNoaWxkIDxUcmFuc2l0aW9uYWJsZT4gY29tcG9uZW50cyB0byBhbmltYXRlIGluICYgb3V0IGluLXBsYWNlLiBWZXJ5IHVzZWZ1bCBmb3IsIGUuZy4sIHRhYiBwYW5lbHMuXG4gKlxuICogWW91IG11c3QgbWFuYWdlIGVhY2ggY2hpbGQgYDxUcmFuc2l0aW9uYWJsZT5gIGNvbXBvbmVudCdzIGBvcGVuYCBwcm9wIC0tIHRoaXMgY29tcG9uZW50ICpkb2VzIG5vdCogbWFuYWdlIGFueSBzb3J0IG9mIHN0YXRlIGluIHRoYXQgcmVnYXJkLlxuICpcbiAqIExpa2UgYDxUcmFuc2l0aW9uYWJsZT5gLCAqdGhpcyB3cmFwcyBhbiBIVE1MRWxlbWVudCAob3Igb3RoZXIgcmVmLWZvcndhcmRpbmcgY29tcG9uZW50KSouIFRoaXMgd2lsbCBiZSB5b3VyIGNvbnRhaW5lciB0aGF0IGhvbGRzIGVhY2ggYDxUcmFuc2l0aW9uYWJsZT5gIChvciBjb21wb25lbnQgdGhhdCB1c2VzIGl0KS4gU3RyaWN0bHkgc3BlYWtpbmcgaXQgY291bGQgYmUgYW55dGhpbmcsIG5vdCBhIGA8VHJhbnNpdGlvbmFibGU+YCwgYnV0IGlmIGl0IGRvZXNudCd0IHRyYW5zaXRpb24gb3V0IHRoZW4gaXQncyBqdXN0IGdvaW5nIHRvIGJlIGhhbmdpbmcgYXJvdW5kIDEwMCUgb2YgdGhlIHRpbWUuXG4gKlxuICogTG9uZyB3YXkgb2Ygc2F5aW5nLCBpZiB5b3UgZ2V0IGEgY3J5cHRpYyBlcnJvciB3aXRoIHRoaXMgY29tcG9uZW50LCBtYWtlIHN1cmUgaXQgaGFzIGEgc2luZ2xlIGA8ZGl2PmAgY2hpbGQgb3Igc29tZXRoaW5nLlxuICogQHBhcmFtIHBhcmFtMFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGNvbnN0IFN3YXBwYWJsZSA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFN3YXBwYWJsZSh7IGNoaWxkcmVuLCBjbGFzc0Jhc2UsIGlubGluZSwgLi4ucCB9LCByZWYpIHtcbiAgICBpbmxpbmUgPz89IHR5cGVvZiBjaGlsZHJlbi50eXBlID09PSBcInN0cmluZ1wiICYmIGlubGluZUVsZW1lbnRzLmhhcyhjaGlsZHJlbi50eXBlKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uUHJvcHMgPSB1c2VDcmVhdGVTd2FwcGFibGVQcm9wcyh7IGNsYXNzQmFzZSwgaW5saW5lIH0sIHsgLi4ucCwgcmVmIH0pO1xuICAgIGNvbnN0IG1lcmdlZFdpdGhDaGlsZHJlbiA9IHVzZU1lcmdlZFByb3BzKCkodHJhbnNpdGlvblByb3BzLCBjaGlsZHJlbi5wcm9wcyk7XG4gICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZHJlbiwgbWVyZ2VkV2l0aENoaWxkcmVuKTtcbn0pO1xuLy8gSWYgXCJpbmxpbmVcIiBpc24ndCBleHBsaWNpdGx5IHByb3ZpZGVkLCB3ZSB0cnkgdG8gaW1wbGljaXRseSBkbyBpdCBiYXNlZCBvbiB0aGUgY2hpbGQncyB0YWcuXG4vLyBOb3QgcGVyZmVjdCwgYnV0IGl0J3Mgbm90IHN1cHBvc2VkIHRvIGJlLiBgaW5saW5lYCBpcyBmb3IgcGVyZmVjdC5cbmNvbnN0IGlubGluZUVsZW1lbnRzID0gbmV3IFNldChbXG4gICAgXCJhXCIsXG4gICAgXCJhYmJyXCIsXG4gICAgXCJhY3JvbnltXCIsXG4gICAgXCJhdWRpb1wiLFxuICAgIFwiYlwiLFxuICAgIFwiYmRpXCIsXG4gICAgXCJiZG9cIixcbiAgICBcImJpZ1wiLFxuICAgIFwiYnJcIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwiY2FudmFzXCIsXG4gICAgXCJjaXRlXCIsXG4gICAgXCJjb2RlXCIsXG4gICAgXCJkYXRhXCIsXG4gICAgXCJkYXRhbGlzdFwiLFxuICAgIFwiZGVsXCIsXG4gICAgXCJkZm5cIixcbiAgICBcImVtXCIsXG4gICAgXCJlbWJlZFwiLFxuICAgIFwiaVwiLFxuICAgIFwiaWZyYW1lXCIsXG4gICAgXCJpbWdcIixcbiAgICBcImlucHV0XCIsXG4gICAgXCJpbnNcIixcbiAgICBcImtiZFwiLFxuICAgIFwibGFiZWxcIixcbiAgICBcIm1hcFwiLFxuICAgIFwibWFya1wiLFxuICAgIFwibWV0ZXJcIixcbiAgICBcIm5vc2NyaXB0XCIsXG4gICAgXCJvYmplY3RcIixcbiAgICBcIm91dHB1dFwiLFxuICAgIFwicGljdHVyZVwiLFxuICAgIFwicHJvZ3Jlc3NcIixcbiAgICBcInFcIixcbiAgICBcInJ1YnlcIixcbiAgICBcInNcIixcbiAgICBcInNhbXBcIixcbiAgICBcInNjcmlwdFwiLFxuICAgIFwic2VsZWN0XCIsXG4gICAgXCJzbG90XCIsXG4gICAgXCJzbWFsbFwiLFxuICAgIFwic3BhblwiLFxuICAgIFwic3Ryb25nXCIsXG4gICAgXCJzdWJcIixcbiAgICBcInN1cFwiLFxuICAgIFwic3ZnXCIsXG4gICAgXCJ0ZW1wbGF0ZVwiLFxuICAgIFwidGV4dGFyZWFcIixcbiAgICBcInRpbWVcIixcbiAgICBcInVcIixcbiAgICBcInR0XCIsXG4gICAgXCJ2YXJcIixcbiAgICBcInZpZGVvXCIsXG4gICAgXCJ3YnJcIlxuXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2FwcGFibGUuanMubWFwIiwiZXhwb3J0IGNvbnN0IEV2ZW50RGV0YWlsID0gU3ltYm9sKFwiZXZlbnQtZGV0YWlsXCIpO1xuZXhwb3J0IGZ1bmN0aW9uIGVuaGFuY2VFdmVudChlLCBkZXRhaWwpIHtcbiAgICBsZXQgZXZlbnQgPSBlO1xuICAgIGV2ZW50W0V2ZW50RGV0YWlsXSA9IGRldGFpbDtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wcy5qcy5tYXAiLCJpbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXN0YXRlXCI7XG5pbXBvcnQgeyBFdmVudERldGFpbCwgZW5oYW5jZUV2ZW50IH0gZnJvbSBcIi4vcHJvcHNcIjtcbmxldCBwdWxzZSA9IChcInZpYnJhdGVcIiBpbiBuYXZpZ2F0b3IpID8gKCgpID0+IG5hdmlnYXRvci52aWJyYXRlKDEwKSkgOiAoKCkgPT4geyB9KTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBlbmFibGUvZGlzYWJsZSBidXR0b24gdmlicmF0aW9uIHB1bHNlcyBvbiBhbiBhcHAtd2lkZSBzY2FsZS5cbiAqXG4gKlxuICogQHBhcmFtIGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGEgYnV0dG9uIGlzIHRhcHBlZC5cbiAqIChEZWZhdWx0IGlzIGAoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMClgIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdCwgYSBub29wIG90aGVyd2lzZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEJ1dHRvblZpYnJhdGUoZnVuYykge1xuICAgIHB1bHNlID0gZnVuYztcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVzKHRhZywgdGFyZ2V0LCBleGNsdWRlKSB7XG4gICAgaWYgKGV4Y2x1ZGU/Llt0YXJnZXRdKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGFyZ2V0ID09PSBcInNwYWNlXCIgfHwgdGFyZ2V0ID09PSBcImVudGVyXCIpXG4gICAgICAgIHJldHVybiB0YWcgPT0gXCJidXR0b25cIjtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEVhc3kgd2F5IHRvIFwicG9seWZpbGxcIiBidXR0b24tbGlrZSBpbnRlcmFjdGlvbnMgb250bywgZS5nLiwgYSBkaXYuXG4gKlxuICogQWRkcyBjbGljaywgc3BhY2Ugb24ga2V5RG93biwgYW5kIGVudGVyIG9uIGtleVVwLCBhcyB3ZWxsIGFzIGhhcHRpY1xuICogZmVlZGJhY2sgdmlhIGEgbW9tZW50YXJ5IHZpYnJhdGlvbiBwdWxzZSB3aGVuIHRoZXJlJ3MgYW4gb25DbGljayBoYW5kbGVyIHByb3ZpZGVkXG4gKiAodGhpcyBjYW4gYmUgZGlzYWJsZWQgYXBwLXdpZGUgd2l0aCBgc2V0QnV0dG9uVmlicmF0ZWApLlxuICpcbiAqIEluIGFkZGl0aW9uLCB3aGVuIHRoZSBDU1MgYDphY3RpdmVgIHBzZXVkby1jbGFzcyB3b3VsZCBhcHBseSB0byBhIG5vcm1hbCBidXR0b25cbiAqIChpLmUuIHdoZW4gaG9sZGluZyB0aGUgc3BhY2ViYXIgb3IgZHVyaW5nIG1vdXNlZG93biksIGB7IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IFwidHJ1ZVwiIH1gXG4gKiBpcyBhZGRlZCB0byB0aGUgcHJvcHMuICBZb3UgY2FuIGVpdGhlciBsZXQgaXQgcGFzcyB0aHJvdWdoIGFuZCBzdHlsZSBpdCB0aHJvdWdoIG5ldyBDU1MsXG4gKiBvciBpbnNwZWN0IHRoZSByZXR1cm5lZCBwcm9wcyBmb3IgaXQgYW5kIGFkZCBlLmcuIGFuIGAuYWN0aXZlYCBjbGFzcyBmb3IgZXhpc3RpbmcgQ1NTXG4gKlxuICogQHBhcmFtIG9uQ2xpY2tcbiAqIEBwYXJhbSBleGNsdWRlIFdoZXRoZXIgdGhlIHBvbHlmaWxsIHNob3VsZCBhcHBseSAoY2FuIHNwZWNpZnkgZm9yIHNwZWNpZmljIGludGVyYWN0aW9ucylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzKHRhZywgb25DbGlja1N5bmMsIGV4Y2x1ZGUpIHtcbiAgICAvL3R5cGUgRSA9IEV2IGV4dGVuZHMgaC5KU1guVGFyZ2V0ZWRFdmVudDxpbmZlciBFLCBhbnk+PyBFIDogRXZlbnRUYXJnZXQ7XG4gICAgY29uc3QgW2FjdGl2ZSwgc2V0QWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBvbktleVVwID0gZXhjbHVkZXModGFnLCBcInNwYWNlXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGUpID0+IHtcbiAgICAgICAgaWYgKGUua2V5ID09IFwiIFwiICYmIG9uQ2xpY2tTeW5jKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBvbkNsaWNrU3luYyhlKTtcbiAgICAgICAgICAgIHNldEFjdGl2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uTW91c2VEb3duID0gZXhjbHVkZXModGFnLCBcImNsaWNrXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGUpID0+IHtcbiAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKVxuICAgICAgICAgICAgc2V0QWN0aXZlKHRydWUpO1xuICAgIH07XG4gICAgY29uc3Qgb25CbHVyID0gKGUpID0+IHtcbiAgICAgICAgc2V0QWN0aXZlKGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTW91c2VVcCA9IGV4Y2x1ZGVzKHRhZywgXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IG9uQmx1cjtcbiAgICBjb25zdCBvbk1vdXNlT3V0ID0gZXhjbHVkZXModGFnLCBcImNsaWNrXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogb25CbHVyO1xuICAgIGNvbnN0IG9uS2V5RG93biA9IGV4Y2x1ZGVzKHRhZywgXCJzcGFjZVwiLCBleGNsdWRlKSAmJiBleGNsdWRlcyh0YWcsIFwiZW50ZXJcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5rZXkgPT0gXCIgXCIgJiYgb25DbGlja1N5bmMgJiYgIWV4Y2x1ZGVzKHRhZywgXCJzcGFjZVwiLCBleGNsdWRlKSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgYWN0aXZhdGUgaXQgb24gYSBzcGFjZSBrZXlkb3duXG4gICAgICAgICAgICAvLyBidXQgd2UgZG8gcHJldmVudERlZmF1bHQgdG8gc3RvcCB0aGUgcGFnZSBmcm9tIHNjcm9sbGluZy5cbiAgICAgICAgICAgIHNldEFjdGl2ZSh0cnVlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXkgPT0gXCJFbnRlclwiICYmIG9uQ2xpY2tTeW5jICYmICFleGNsdWRlcyh0YWcsIFwiZW50ZXJcIiwgZXhjbHVkZSkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG9uQ2xpY2tTeW5jKGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkNsaWNrMiA9IGV4Y2x1ZGVzKHRhZywgXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6ICgoZSkgPT4ge1xuICAgICAgICBpZiAob25DbGlja1N5bmMgJiYgIWV4Y2x1ZGVzKHRhZywgXCJjbGlja1wiLCBleGNsdWRlKSkge1xuICAgICAgICAgICAgcHVsc2UoKTtcbiAgICAgICAgICAgIG9uQ2xpY2tTeW5jKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIChwcm9wcykgPT4gdXNlTWVyZ2VkUHJvcHMoKSh7IG9uS2V5RG93biwgb25LZXlVcCwgb25DbGljazogb25DbGljazIsIG9uQmx1ciwgb25Nb3VzZURvd24sIG9uTW91c2VVcCwgb25Nb3VzZU91dCwgLi4ueyBcImRhdGEtcHNldWRvLWFjdGl2ZVwiOiBhY3RpdmUgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9IH0sIHByb3BzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhQnV0dG9uKHsgdGFnLCBwcmVzc2VkLCBvbkNsaWNrIH0pIHtcbiAgICBmdW5jdGlvbiB1c2VBcmlhQnV0dG9uUHJvcHMoeyBcImFyaWEtcHJlc3NlZFwiOiBhcmlhUHJlc3NlZCwgdGFiSW5kZXgsIHJvbGUsIC4uLnAgfSkge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzKHRhZywgKGUpID0+IG9uQ2xpY2s/LihlbmhhbmNlRXZlbnQoZSwgeyBwcmVzc2VkOiBwcmVzc2VkID09IG51bGwgPyBudWxsIDogIXByZXNzZWQgfSkpLCB1bmRlZmluZWQpKHApO1xuICAgICAgICBjb25zdCBidXR0b25Qcm9wcyA9IHsgcm9sZSwgdGFiSW5kZXgsIFwiYXJpYS1wcmVzc2VkXCI6IGFyaWFQcmVzc2VkID8/IChwcmVzc2VkID09PSB0cnVlID8gXCJ0cnVlXCIgOiBwcmVzc2VkID09PSBmYWxzZSA/IFwiZmFsc2VcIiA6IHVuZGVmaW5lZCkgfTtcbiAgICAgICAgY29uc3QgZGl2UHJvcHMgPSB7IC4uLmJ1dHRvblByb3BzLCB0YWJJbmRleDogdGFiSW5kZXggPz8gMCwgcm9sZTogcm9sZSA/PyBcImJ1dHRvblwiIH07XG4gICAgICAgIGNvbnN0IGFuY2hvclByb3BzID0geyAuLi5kaXZQcm9wcyB9O1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgY2FzZSBcImJ1dHRvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKGJ1dHRvblByb3BzLCBwcm9wcyk7XG4gICAgICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKGFuY2hvclByb3BzLCBwcm9wcyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKGRpdlByb3BzLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlQXJpYUJ1dHRvblByb3BzXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1idXR0b24uanMubWFwIiwiaW1wb3J0IHsgdXNlQ2hpbGRNYW5hZ2VyIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZUxpbmVhck5hdmlnYXRpb24gfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlUmFuZG9tSWQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtcmFuZG9tLWlkXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzIH0gZnJvbSBcIi4vdXNlLWJ1dHRvblwiO1xuaW1wb3J0IHsgdXNlQ2hpbGRGbGFnIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhQWNjb3JkaW9uKHsgZXhwYW5kZWRJbmRleCwgc2V0RXhwYW5kZWRJbmRleCB9KSB7XG4gICAgY29uc3QgW2xhc3RGb2N1c2VkSW5kZXgsIHNldExhc3RGb2N1c2VkSW5kZXgsIGdldExhc3RGb2N1c2VkSW5kZXhdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3Qgc3RhYmxlU2V0RXhwYW5kZWRJbmRleCA9IHVzZVN0YWJsZUNhbGxiYWNrKHNldEV4cGFuZGVkSW5kZXggPz8gKCgpID0+IHsgfSkpO1xuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkQWNjb3JkaW9uU2VjdGlvbnMsIHVzZU1hbmFnZWRDaGlsZDogdXNlTWFuYWdlZENoaWxkU2VjdGlvbiB9ID0gdXNlQ2hpbGRNYW5hZ2VyKCk7XG4gICAgY29uc3QgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGQgfSA9IHVzZUxpbmVhck5hdmlnYXRpb24oeyBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRBY2NvcmRpb25TZWN0aW9ucywgbmF2aWdhdGlvbkRpcmVjdGlvbjogXCJibG9ja1wiLCBnZXRJbmRleDogZ2V0TGFzdEZvY3VzZWRJbmRleCwgc2V0SW5kZXg6IHNldExhc3RGb2N1c2VkSW5kZXggfSk7XG4gICAgLy8gQW55IHRpbWUgbGlzdCBtYW5hZ2VtZW50IGNoYW5nZXMgdGhlIGZvY3VzZWQgaW5kZXgsIG1hbnVhbGx5IGZvY3VzIHRoZSBjaGlsZFxuICAgIC8vIFRPRE86IENhbiB0aGlzIGJlIGN1dD9cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobGFzdEZvY3VzZWRJbmRleCAhPSBudWxsICYmIGxhc3RGb2N1c2VkSW5kZXggPj0gMClcbiAgICAgICAgICAgIG1hbmFnZWRBY2NvcmRpb25TZWN0aW9uc1tsYXN0Rm9jdXNlZEluZGV4XT8uZm9jdXMoKTtcbiAgICB9LCBbbGFzdEZvY3VzZWRJbmRleF0pO1xuICAgIHVzZUNoaWxkRmxhZyhleHBhbmRlZEluZGV4LCBtYW5hZ2VkQWNjb3JkaW9uU2VjdGlvbnMubGVuZ3RoLCAoaSwgb3BlbikgPT4gbWFuYWdlZEFjY29yZGlvblNlY3Rpb25zW2ldPy5zZXRPcGVuRnJvbVBhcmVudChvcGVuKSk7XG4gICAgY29uc3QgdXNlQXJpYUFjY29yZGlvblNlY3Rpb24gPSB1c2VDYWxsYmFjaygoYXJncykgPT4ge1xuICAgICAgICBjb25zdCBbb3BlbkZyb21QYXJlbnQsIHNldE9wZW5Gcm9tUGFyZW50LCBnZXRPcGVuRnJvbVBhcmVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICAgICAgY29uc3QgeyByYW5kb21JZDogYm9keVJhbmRvbUlkLCB1c2VSYW5kb21JZFByb3BzOiB1c2VCb2R5UmFuZG9tSWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRCb2R5SWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1hY2NvcmRpb24tc2VjdGlvbi1ib2R5LVwiIH0pO1xuICAgICAgICBjb25zdCB7IHJhbmRvbUlkOiBoZWFkUmFuZG9tSWQsIHVzZVJhbmRvbUlkUHJvcHM6IHVzZUhlYWRSYW5kb21JZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlUmVmZXJlbmNlZEhlYWRJZFByb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLWFjY29yZGlvbi1zZWN0aW9uLWhlYWRlci1cIiB9KTtcbiAgICAgICAgbGV0IG9wZW4gPSAoKGFyZ3Mub3BlbiA/PyBvcGVuRnJvbVBhcmVudCkgPz8gbnVsbCk7XG4gICAgICAgIC8vIFRPRE86IENvbnZlcnQgdG8gdXNlIHVzZU1hbmFnZWRDaGlsZCBzbyB0aGF0IHRoaXMgaG9vayBcbiAgICAgICAgLy8gaXMgc3RhYmxlIHdpdGhvdXQgKGRpcmVjdGx5KSBkZXBlbmRpbmcgb24gdGhlIG9wZW4gc3RhdGUuXG4gICAgICAgIGNvbnN0IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXIoeyB0YWcgfSkge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4geyBlbGVtZW50Py5mb2N1cygpOyB9LCBbZWxlbWVudF0pO1xuICAgICAgICAgICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGRQcm9wcyB9ID0gdXNlTWFuYWdlZENoaWxkU2VjdGlvbih7IGluZGV4OiBhcmdzLmluZGV4LCBvcGVuOiBvcGVuLCBzZXRPcGVuRnJvbVBhcmVudCwgZm9jdXMgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZFByb3BzIH0gPSB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGQoKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHMoeyBbXCJhcmlhLWV4cGFuZGVkXCJdOiBhcmlhRXhwYW5kZWQsIFtcImFyaWEtZGlzYWJsZWRcIl06IGFyaWFEaXNhYmxlZCwgLi4ucHJvcHMgfSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uRm9jdXMgPSAoKSA9PiB7IHNldExhc3RGb2N1c2VkSW5kZXgoYXJncy5pbmRleCk7IH07XG4gICAgICAgICAgICAgICAgbGV0IG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRPcGVuRnJvbVBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhYmxlU2V0RXhwYW5kZWRJbmRleChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhYmxlU2V0RXhwYW5kZWRJbmRleChhcmdzLmluZGV4KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCByZXRCID0gdXNlTWVyZ2VkUHJvcHMoKSh7IHRhYkluZGV4OiAwIH0sIHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzKHRhZywgb25DbGljaywgdW5kZWZpbmVkKShwcm9wcykpO1xuICAgICAgICAgICAgICAgIGxldCByZXQzID0gdXNlTWVyZ2VkUHJvcHMoKSh1c2VIZWFkUmFuZG9tSWRQcm9wcyh1c2VSZWZlcmVuY2VkQm9keUlkUHJvcHMoXCJhcmlhLWNvbnRyb2xzXCIpKHtcbiAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IChhcmlhRXhwYW5kZWQgPz8gKCEhb3BlbikudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiAoYXJpYURpc2FibGVkID8/IChvcGVuID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQpKSxcbiAgICAgICAgICAgICAgICAgICAgLi4udXNlUmVmRWxlbWVudFByb3BzKHVzZU1hbmFnZWRDaGlsZFByb3BzKHJldEIpKVxuICAgICAgICAgICAgICAgIH0pKSwgeyBvbkZvY3VzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRQcm9wcyhyZXQzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJldHVybiB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHMgfTtcbiAgICAgICAgfSwgW29wZW5dKTtcbiAgICAgICAgY29uc3QgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5KCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHMoeyByb2xlLCAuLi5wcm9wcyB9KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJldDEgPSB1c2VSZWZlcmVuY2VkSGVhZElkUHJvcHMoXCJhcmlhLWxhYmVsbGVkYnlcIikoeyByb2xlOiByb2xlID8/IFwicmVnaW9uXCIsIC4uLnByb3BzIH0pO1xuICAgICAgICAgICAgICAgIGxldCByZXQyID0gdXNlQm9keVJhbmRvbUlkUHJvcHMocmV0MSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBleHBhbmRlZDogb3BlbixcbiAgICAgICAgICAgIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyLFxuICAgICAgICAgICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5LFxuICAgICAgICB9O1xuICAgIH0sIFt1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvblxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtYWNjb3JkaW9uLmpzLm1hcCIsImltcG9ydCB7IHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VSYW5kb21JZCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1yYW5kb20taWRcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XG4vKipcbiAqIEFkZHMgYW4gSUQgYW5kIFwiYXJpYS1sYWJlbGxlZGJ5XCIgZm9yIHR3byBlbGVtZW50cywgYW4gXCJpbnB1dFwiIGVsZW1lbnQgYW5kIGEgXCJsYWJlbFwiIGVsZW1lbnQuXG4gKlxuICogUmV0dXJucyB0aGUgYHVzZVJlZmVyZW5jZWRJZFByb3BzYCBob29rcyBpZiB5b3UgbmVlZCB0byBhbHNvIGFkZCBvdGhlciBJRC1yZWZlcmVuY2luZyBhdHRyaWJ1dGVzLCBsaWtlIGBmb3JgXG4gKlxuICogQHNlZSB1c2VJbnB1dExhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VHZW5lcmljTGFiZWwoeyBsYWJlbFByZWZpeCwgaW5wdXRQcmVmaXgsIGJhY2t1cFRleHQgfSA9IHsgbGFiZWxQcmVmaXg6IFwibGFiZWwtXCIsIGlucHV0UHJlZml4OiBcImlucHV0LVwiIH0pIHtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGxhYmVsRWxlbWVudCwgZ2V0RWxlbWVudDogZ2V0TGFiZWxFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUxhYmVsUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XG4gICAgY29uc3QgeyBlbGVtZW50OiBpbnB1dEVsZW1lbnQsIGdldEVsZW1lbnQ6IGdldElucHV0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VJbnB1dFJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlTGFiZWxSYW5kb21JZFByb3BzLCBpZDogbGFiZWxJZCwgcmFuZG9tSWQ6IGxhYmVsUmFuZG9tSWQsIHVzZVJlZmVyZW5jZWRJZFByb3BzOiB1c2VSZWZlcmVuY2VkTGFiZWxJZFByb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogbGFiZWxQcmVmaXggfSk7XG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VJbnB1dFJhbmRvbUlkUHJvcHMsIGlkOiBpbnB1dElkLCByYW5kb21JZDogaW5wdXRSYW5kb21JZCwgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBpbnB1dFByZWZpeCB9KTtcbiAgICBjb25zdCBsYWJlbEhhc01vdW50ZWQgPSAhIShsYWJlbEVsZW1lbnQpO1xuICAgIGNvbnN0IGlucHV0SGFzTW91bnRlZCA9ICEhKGlucHV0RWxlbWVudCk7XG4gICAgY29uc3QgdXNlR2VuZXJpY0xhYmVsTGFiZWwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VHZW5lcmljTGFiZWxMYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHM6IChwcm9wcykgPT4geyByZXR1cm4gdXNlTGFiZWxSYW5kb21JZFByb3BzKHVzZUxhYmVsUmVmRWxlbWVudFByb3BzKHByb3BzKSk7IH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgdXNlR2VuZXJpY0xhYmVsSW5wdXQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VHZW5lcmljTGFiZWxJbnB1dCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZUdlbmVyaWNMYWJlbElucHV0UHJvcHM6ICh7IFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZGJ5LCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh1c2VJbnB1dFJhbmRvbUlkUHJvcHModXNlUmVmZXJlbmNlZExhYmVsSWRQcm9wcyhcImFyaWEtbGFiZWxsZWRieVwiKSh1c2VJbnB1dFJlZkVsZW1lbnRQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHsgXCJhcmlhLWxhYmVsXCI6ICghbGFiZWxIYXNNb3VudGVkID8gYmFja3VwVGV4dCA6IGFyaWFMYWJlbCkgPz8gYXJpYUxhYmVsIH0sIHByb3BzKSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW2xhYmVsSGFzTW91bnRlZF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUdlbmVyaWNMYWJlbElucHV0LFxuICAgICAgICB1c2VHZW5lcmljTGFiZWxMYWJlbCxcbiAgICAgICAgdXNlUmVmZXJlbmNlZExhYmVsSWRQcm9wcyxcbiAgICAgICAgdXNlUmVmZXJlbmNlZElucHV0SWRQcm9wcyxcbiAgICAgICAgbGFiZWxJZCxcbiAgICAgICAgaW5wdXRJZCxcbiAgICAgICAgbGFiZWxFbGVtZW50LFxuICAgICAgICBpbnB1dEVsZW1lbnQsXG4gICAgICAgIGdldExhYmVsRWxlbWVudCxcbiAgICAgICAgZ2V0SW5wdXRFbGVtZW50LFxuICAgIH07XG59XG4vKipcbiAqIEhhbmRsZXMgdGhlIGF0dHJpYnV0ZXMgYGlkYCwgYGZvcmAsIGFuZCBgYXJpYS1sYWJlbGxlZGJ5YCBmb3IgdG8gcmVsYXRlZCBlbGVtZW50cy5cbiAqXG4gKiBJdCdzIGFzc3VtZWQgdGhhdCB0aGUgbGFiZWwgaXMgYW4gYEhUTUxMYWJlbEVsZW1lbnRgLCBhbmQgdGhlIGlucHV0IGlzIHNvbWV0aGluZyBmb3Igd2hpY2hcbiAqIHRoZSBgZm9yYCBhdHRyaWJ1dGUgY2FuIHJlZmVyZW5jZS5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnB1dExhYmVsKHsgbGFiZWxQcmVmaXgsIGlucHV0UHJlZml4IH0gPSB7IGxhYmVsUHJlZml4OiBcImxhYmVsLVwiLCBpbnB1dFByZWZpeDogXCJpbnB1dC1cIiB9KSB7XG4gICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxJbnB1dCwgdXNlR2VuZXJpY0xhYmVsTGFiZWwsIHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMsIHVzZVJlZmVyZW5jZWRMYWJlbElkUHJvcHMsIGlucHV0SWQsIGxhYmVsSWQsIGlucHV0RWxlbWVudCwgZ2V0SW5wdXRFbGVtZW50LCBsYWJlbEVsZW1lbnQsIGdldExhYmVsRWxlbWVudCB9ID0gdXNlR2VuZXJpY0xhYmVsKHsgbGFiZWxQcmVmaXgsIGlucHV0UHJlZml4IH0pO1xuICAgIGNvbnN0IHVzZUlucHV0TGFiZWxMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUlucHV0TGFiZWxMYWJlbCh7IHRhZyB9KSB7XG4gICAgICAgIGNvbnN0IHsgdXNlR2VuZXJpY0xhYmVsTGFiZWxQcm9wcyB9ID0gdXNlR2VuZXJpY0xhYmVsTGFiZWwoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZUlucHV0TGFiZWxMYWJlbFByb3BzKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aEZvciA9IHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMoXCJmb3JcIikocHJvcHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpdGhvdXRGb3IgPSBwcm9wcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlR2VuZXJpY0xhYmVsTGFiZWxQcm9wcyh0YWcgPT0gXCJsYWJlbFwiID8gd2l0aEZvciA6IHdpdGhvdXRGb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFt1c2VHZW5lcmljTGFiZWxJbnB1dF0pO1xuICAgIGNvbnN0IHVzZUlucHV0TGFiZWxJbnB1dCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUlucHV0TGFiZWxJbnB1dCgpIHtcbiAgICAgICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VHZW5lcmljTGFiZWxJbnB1dCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlSW5wdXRMYWJlbElucHV0UHJvcHMocHJvcHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlR2VuZXJpY0xhYmVsSW5wdXRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW3VzZUdlbmVyaWNMYWJlbExhYmVsXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlSW5wdXRMYWJlbExhYmVsLFxuICAgICAgICB1c2VJbnB1dExhYmVsSW5wdXQsXG4gICAgICAgIGxhYmVsSWQsXG4gICAgICAgIGlucHV0SWQsXG4gICAgICAgIGlucHV0RWxlbWVudCxcbiAgICAgICAgbGFiZWxFbGVtZW50LFxuICAgICAgICBnZXRJbnB1dEVsZW1lbnQsXG4gICAgICAgIGdldExhYmVsRWxlbWVudFxuICAgIH07XG59XG5jb25zdCBoYW5kbGVzSW5wdXQgPSAodGFnLCBsYWJlbFBvc2l0aW9uLCB3aGljaCkgPT4ge1xuICAgIGlmIChsYWJlbFBvc2l0aW9uID09PSBcInNlcGFyYXRlXCIpIHtcbiAgICAgICAgaWYgKHdoaWNoID09PSBcImlucHV0LWVsZW1lbnRcIilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBlbHNlIGlmICh3aGljaCA9PT0gXCJsYWJlbC1lbGVtZW50XCIpXG4gICAgICAgICAgICByZXR1cm4gdGFnICE9IFwiaW5wdXRcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobGFiZWxQb3NpdGlvbiA9PT0gXCJ3cmFwcGluZ1wiKSB7XG4gICAgICAgIGlmICh3aGljaCA9PT0gXCJpbnB1dC1lbGVtZW50XCIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh3aGljaCA9PSBcImxhYmVsLWVsZW1lbnRcIilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG4vKipcbiAqIEhhbmRsZXMgbGFiZWwgdHlwZSAod3JhcHBpbmcgb3Igc2VwYXJhdGUpIGZvciBjaGVja2JveGVzLCByYWRpb3MsIHN3aXRjaGVzLCBldGMuXG4gKiBAcGFyYW0gcGFyYW0wXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlKHsgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24sIG9uSW5wdXQsIHJvbGUgfSkge1xuICAgIGNvbnN0IHN0YWJsZU9uSW5wdXQgPSB1c2VTdGFibGVDYWxsYmFjaygoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCk7IG9uSW5wdXQ/LihlKTsgfSk7XG4gICAgY29uc3QgeyBpbnB1dElkLCBsYWJlbElkLCB1c2VJbnB1dExhYmVsSW5wdXQ6IHVzZUlMSW5wdXQsIHVzZUlucHV0TGFiZWxMYWJlbDogdXNlSUxMYWJlbCwgZ2V0TGFiZWxFbGVtZW50LCBnZXRJbnB1dEVsZW1lbnQgfSA9IHVzZUlucHV0TGFiZWwoeyBsYWJlbFByZWZpeDogXCJhcmlhLWNoZWNrYm94LWxhYmVsLVwiLCBpbnB1dFByZWZpeDogXCJhcmlhLWNoZWNrYm94LWlucHV0LVwiIH0pO1xuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KHsgdGFnIH0pIHtcbiAgICAgICAgY29uc3QgeyB1c2VJbnB1dExhYmVsSW5wdXRQcm9wczogdXNlSUxJbnB1dFByb3BzIH0gPSB1c2VJTElucHV0KCk7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XG4gICAgICAgIHJldHVybiB7IGlucHV0RWxlbWVudDogZWxlbWVudCwgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMgfTtcbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMoeyAuLi5wMCB9KSB7XG4gICAgICAgICAgICAvLyBGb3Igc29tZSByZWFzb24sIENocm9tZSB3b24ndCBmaXJlIG9uSW5wdXQgZXZlbnRzIGZvciByYWRpbyBidXR0b25zIHRoYXQgYXJlIHRhYkluZGV4PS0xPz9cbiAgICAgICAgICAgIC8vIE5lZWRzIGludmVzdGlnYXRpbmcsIGJ1dCBvbklucHV0IHdvcmtzIGZpbmUgaW4gRmlyZWZveFxuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgbGV0IHByb3BzID0gdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnModGFnLCBkaXNhYmxlZCB8fCAhaGFuZGxlc0lucHV0KHRhZywgbGFiZWxQb3NpdGlvbiwgXCJpbnB1dC1lbGVtZW50XCIpID8gdW5kZWZpbmVkIDogc3RhYmxlT25JbnB1dCwgdW5kZWZpbmVkKSh7fSk7XG4gICAgICAgICAgICBpZiAodGFnID09IFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICBwcm9wcy5vbklucHV0ID0gKGUpID0+IGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHByb3BzID0gdXNlUmVmRWxlbWVudFByb3BzKHVzZUlMSW5wdXRQcm9wcyhwcm9wcykpO1xuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgd3JhcHBlZCBsYWJlbCBoYW5kbGVzIGFsbCBpbnRlcmFjdGlvbnMsXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhpcyBlbGVtZW50IGNhbid0IGJlIGludGVyYWN0ZWQgd2l0aFxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgaXQncyBhbiBpbnB1dCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIHByb3BzLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9wcy50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIHByb3BzLm9uRm9jdXMgPSBlID0+IGdldExhYmVsRWxlbWVudCgpLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnICE9IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5yb2xlID0gcm9sZTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBkaXNhYmxlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkocDAsIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH0sIFt1c2VJTElucHV0LCByb2xlLCBsYWJlbFBvc2l0aW9uLCBkaXNhYmxlZF0pO1xuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KHsgdGFnIH0pIHtcbiAgICAgICAgY29uc3QgeyB1c2VJbnB1dExhYmVsTGFiZWxQcm9wczogdXNlSUxMYWJlbFByb3BzIH0gPSB1c2VJTExhYmVsKHsgdGFnIH0pO1xuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyh7IC4uLnAwIH0pIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IHVzZUJ1dHRvbkxpa2VFdmVudEhhbmRsZXJzKFwiZGl2XCIsIGRpc2FibGVkIHx8ICFoYW5kbGVzSW5wdXQodGFnLCBsYWJlbFBvc2l0aW9uLCBcImxhYmVsLWVsZW1lbnRcIikgPyB1bmRlZmluZWQgOiBzdGFibGVPbklucHV0LCB1bmRlZmluZWQpKHt9KTtcbiAgICAgICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIikge1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBuZXdQcm9wcy5yb2xlID0gcm9sZTtcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBkaXNhYmxlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9uZSBjYXNlIHdoZXJlIHRoZXJlJ3MgYWxtb3N0IG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBub3JtYWwgY2FzZSB3aGVyZSBldmVyeXRoaW5nIGFjdHMgYWNjb3JkaW5nIG5vcm1hbCBIVE1MIG1lY2hhbmljcy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKG5ld1Byb3BzLCB1c2VJTExhYmVsUHJvcHMocDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyB9O1xuICAgIH0sIFt1c2VJTExhYmVsLCByb2xlLCBsYWJlbFBvc2l0aW9uXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LFxuICAgICAgICB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsXG4gICAgICAgIGdldExhYmVsRWxlbWVudCxcbiAgICAgICAgZ2V0SW5wdXRFbGVtZW50XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1sYWJlbC5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCB9IGZyb20gXCIuL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VDaGVja2JveExpa2UgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhQ2hlY2tib3goeyBsYWJlbFBvc2l0aW9uLCBjaGVja2VkLCBvbklucHV0LCBkaXNhYmxlZCB9KSB7XG4gICAgY29uc3Qgb25JbnB1dEVuaGFuY2VkID0gKGUpID0+IG9uSW5wdXQ/LihlbmhhbmNlRXZlbnQoZSwgeyBjaGVja2VkOiAhY2hlY2tlZCB9KSk7XG4gICAgY29uc3QgeyBnZXRJbnB1dEVsZW1lbnQsIGdldExhYmVsRWxlbWVudCwgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQgfSA9IHVzZUNoZWNrYm94TGlrZSh7IGxhYmVsUG9zaXRpb24sIHJvbGU6IFwiY2hlY2tib3hcIiwgZGlzYWJsZWQsIG9uSW5wdXQ6IG9uSW5wdXRFbmhhbmNlZCB9KTtcbiAgICBjb25zdCB1c2VDaGVja2JveElucHV0RWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KHsgdGFnIH0pIHtcbiAgICAgICAgY29uc3QgeyBpbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQoeyB0YWcgfSk7XG4gICAgICAgIGNvbnN0IGlzTWl4ZWQgPSAoY2hlY2tlZCA9PSBcIm1peGVkXCIpO1xuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlucHV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICh0YWcgPT09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQuaW5kZXRlcm1pbmF0ZSA9IGlzTWl4ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbaW5wdXRFbGVtZW50LCBpc01peGVkLCB0YWddKTtcbiAgICAgICAgcmV0dXJuIHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9O1xuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKHsgLi4ucDAgfSkge1xuICAgICAgICAgICAgbGV0IHByb3BzID0gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMocDApO1xuICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCA/Pz0gISFjaGVja2VkO1xuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWNoZWNrZWRcIl0gPSBjaGVja2VkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyAhPSBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWcgPT0gXCJpbnB1dFwiKVxuICAgICAgICAgICAgICAgIHByb3BzLnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgIH1cbiAgICB9LCBbY2hlY2tlZCwgbGFiZWxQb3NpdGlvbiwgZGlzYWJsZWRdKTtcbiAgICBjb25zdCB1c2VDaGVja2JveExhYmVsRWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KHsgdGFnIH0pIHtcbiAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50KHsgdGFnIH0pO1xuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzKHsgLi4ucHJvcHMgfSkge1xuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWNoZWNrZWRcIl0gPSBjaGVja2VkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyAhPSBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyhwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICByZXR1cm4geyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIH07XG4gICAgfSwgW3VzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb25dKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VDaGVja2JveElucHV0RWxlbWVudCxcbiAgICAgICAgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWNoZWNrYm94LmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVJhbmRvbUlkIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXJhbmRvbS1pZFwiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1yZWYtZWxlbWVudFwiO1xuaW1wb3J0IHsgdXNlRm9jdXNUcmFwIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWZvY3VzLXRyYXBcIjtcbmltcG9ydCB7IHVzZUdsb2JhbEhhbmRsZXIgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtZXZlbnQtaGFuZGxlclwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2Utc3RhdGVcIjtcbi8qKlxuICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgYSBtb2RhbC1saWtlIHNvZnQtZGlzbWlzcyBpbnRlcmFjdGlvbi5cbiAqXG4gKiBUaGF0IGlzLCBhbnkgY2xpY2tzIG9yIHRhcHMgb3V0c2lkZSBvZiB0aGUgZ2l2ZW4gY29tcG9uZW50LFxuICogb3IgYW55IHRpbWUgdGhlIEVzY2FwZSBrZXkgaXMgcHJlc3NlZCB3aXRoaW4gdGhlIGNvbXBvbmVudCxcbiAqICh3aXRoIHZhcmlvdXMgYnJvd3NlciBvZGRpdGllcyByZWdhcmRpbmcgY2xpY2tzIG9uIGJsYW5rIG9yIGluZXJ0IGFyZWFzIGhhbmRsZWQpXG4gKiB0aGUgY29tcG9uZW50IHdpbGwgcmVxdWVzdCB0byBjbG9zZSBpdHNlbGYuXG4gKlxuICogT2YgY291cnNlLCBpZiB5b3UgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhlIGBvbkNsb3NlYCBmdW5jdGlvbixcbiAqIGl0IHdvbid0IGJlIGEgc29mdCBkaXNtaXNzIGFueW1vcmUuXG4gKlxuICogQHBhcmFtIHBhcmFtMFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNvZnREaXNtaXNzKHsgb25DbG9zZSB9KSB7XG4gICAgY29uc3QgeyBlbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcbiAgICBmdW5jdGlvbiBvbkJhY2tkcm9wQ2xpY2soZSkge1xuICAgICAgICAvLyBCYXNpY2FsbHksIFwid2FzIHRoaXMgZXZlbnQgZmlyZWQgb24gdGhlIHJvb3QtbW9zdCBlbGVtZW50LCBvciBhdCBsZWFzdCBhbiBlbGVtZW50IG5vdCBjb250YWluZWQgYnkgdGhlIG1vZGFsP1wiXG4gICAgICAgIC8vIEVpdGhlciBjb3VsZCBiZSBob3cgdGhlIGJyb3dzZXIgaGFuZGxlcyB0aGVzZSBzb3J0cyBvZiBcImludGVyYWN0aW5nIHdpdGggbm90aGluZ1wiIGV2ZW50cy5cbiAgICAgICAgaWYgKGUudGFyZ2V0ID09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCAhKGVsZW1lbnQgJiYgZS50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKSkge1xuICAgICAgICAgICAgb25DbG9zZShcImJhY2tkcm9wXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNpbmNlIGV2ZXJ5dGhpbmcgZWxzZSBpcyBpbmVydCwgd2UgbGlzdGVuIGZvciBjYXB0dXJlZCBjbGlja3Mgb24gdGhlIHdpbmRvd1xuICAgIC8vICh3ZSBkb24ndCB1c2Ugb25DbGljayBzaW5jZSB0aGF0IGRvZXNuJ3QgZmlyZSB3aGVuIGNsaWNrZWQgb24gZW1wdHkvaW5lcnQgYXJlYXMpXG4gICAgLy8gTm90ZTogV2UgbmVlZCBhICpzZXBhcmF0ZSogdG91Y2ggZXZlbnQgb24gbW9iaWxlIFNhZmFyaSwgYmVjYXVzZVxuICAgIC8vIGl0IGRvZXNuJ3QgbGV0IGNsaWNrIGV2ZW50cyBidWJibGUgb3IgYmUgY2FwdHVyZWQgZnJvbSB0cmFkaXRpb25hbGx5IG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cyxcbiAgICAvLyBidXQgdG91Y2ggZXZlbnRzIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgdXNlR2xvYmFsSGFuZGxlcih3aW5kb3csIFwibW91c2Vkb3duXCIsICFvcGVuID8gbnVsbCA6IG9uQmFja2Ryb3BDbGljaywgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcInRvdWNoc3RhcnRcIiwgIW9wZW4gPyBudWxsIDogb25CYWNrZHJvcENsaWNrLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGUpID0+IHtcbiAgICAgICAgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgICBvbkNsb3NlKFwiZXNjYXBlXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyB1c2VTb2Z0RGlzbWlzc1Byb3BzOiAocHJvcHMpID0+IHVzZU1lcmdlZFByb3BzKCkodXNlUmVmRWxlbWVudFByb3BzKHsgb25LZXlEb3duIH0pLCBwcm9wcykgfTtcbn1cbi8qKlxuICogQSBnZW5lcmljIG1vZGFsIGhvb2ssIHVzZWQgYnkgbW9kYWwgZGlhbG9ncywgYnV0IGNhbiBhbHNvXG4gKiBiZSB1c2VkIGJ5IGFueXRoaW5nIHRoYXQncyBtb2RhbCB3aXRoIGEgYmFja2Ryb3AuXG4gKiBAcGFyYW0gcGFyYW0wXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYU1vZGFsKHsgb3Blbiwgb25DbG9zZSB9KSB7XG4gICAgY29uc3QgW21vZGFsRGVzY3JpYmVkQnlCb2R5LCBzZXRNb2RhbERlc2NyaWJlZEJ5Qm9keV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgdXNlSGlkZVNjcm9sbChvcGVuKTtcbiAgICBjb25zdCB7IGlkOiBtb2RhbElkLCB1c2VSYW5kb21JZFByb3BzOiB1c2VNb2RhbElkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzOiB1c2VNb2RhbFJlZmVyZW5jaW5nSWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1tb2RhbC1cIiB9KTtcbiAgICBjb25zdCB7IGlkOiBib2R5SWQsIHVzZVJhbmRvbUlkUHJvcHM6IHVzZUJvZHlJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlQm9keVJlZmVyZW5jaW5nSWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1tb2RhbC1ib2R5LVwiIH0pO1xuICAgIGNvbnN0IHsgaWQ6IHRpdGxlSWQsIHVzZVJhbmRvbUlkUHJvcHM6IHVzZVRpdGxlSWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVRpdGxlUmVmZXJlbmNpbmdJZFByb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLW1vZGFsLXRpdGxlLVwiIH0pO1xuICAgIGNvbnN0IHsgdXNlU29mdERpc21pc3NQcm9wcyB9ID0gdXNlU29mdERpc21pc3MoeyBvbkNsb3NlIH0pO1xuICAgIGNvbnN0IHVzZU1vZGFsQmFja2Ryb3AgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VNb2RhbEJhY2tkcm9wKCkge1xuICAgICAgICBmdW5jdGlvbiB1c2VNb2RhbEJhY2tkcm9wUHJvcHMocHJvcHMpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHt9LCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdXNlTW9kYWxCYWNrZHJvcFByb3BzIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHVzZU1vZGFsUHJvcHMgPSBmdW5jdGlvbiAoeyBcImFyaWEtbW9kYWxcIjogYXJpYU1vZGFsLCByb2xlLCAuLi5wMCB9KSB7XG4gICAgICAgIGNvbnN0IHsgdXNlRm9jdXNUcmFwUHJvcHMgfSA9IHVzZUZvY3VzVHJhcCh7IHRyYXBBY3RpdmU6IG9wZW4gfSk7XG4gICAgICAgIGNvbnN0IHAxID0gdXNlVGl0bGVSZWZlcmVuY2luZ0lkUHJvcHMoXCJhcmlhLWxhYmVsbGVkYnlcIikocDApO1xuICAgICAgICBjb25zdCBwMiA9IHVzZU1vZGFsSWRQcm9wcyhwMSk7XG4gICAgICAgIGNvbnN0IHBGaW5hbCA9IHVzZUJvZHlSZWZlcmVuY2luZ0lkUHJvcHMoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpKHAyKTtcbiAgICAgICAgcmV0dXJuIHVzZUZvY3VzVHJhcFByb3BzKHVzZU1lcmdlZFByb3BzKCkodXNlU29mdERpc21pc3NQcm9wcyh7IHJvbGU6IFwiZGlhbG9nXCIgfSksIG1vZGFsRGVzY3JpYmVkQnlCb2R5ID8gcEZpbmFsIDogcDIpKTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZU1vZGFsVGl0bGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VNb2RhbFRpdGxlKCkge1xuICAgICAgICBjb25zdCB1c2VNb2RhbFRpdGxlUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VUaXRsZUlkUHJvcHMocHJvcHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyB1c2VNb2RhbFRpdGxlUHJvcHMgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgdXNlTW9kYWxCb2R5ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTW9kYWxCb2R5KHsgZGVzY3JpcHRpdmUgfSkge1xuICAgICAgICBzZXRNb2RhbERlc2NyaWJlZEJ5Qm9keShkZXNjcmlwdGl2ZSk7XG4gICAgICAgIGNvbnN0IHVzZU1vZGFsQm9keVByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlQm9keUlkUHJvcHMocHJvcHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyB1c2VNb2RhbEJvZHlQcm9wcyB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VNb2RhbFByb3BzLFxuICAgICAgICB1c2VNb2RhbFRpdGxlLFxuICAgICAgICB1c2VNb2RhbEJvZHksXG4gICAgICAgIHVzZU1vZGFsQmFja2Ryb3BcbiAgICB9O1xufVxuLyoqXG4gKiBBbGxvd3MgZm9yIGhpZGluZyB0aGUgc2Nyb2xsIGJhciBvZiB0aGUgcm9vdCBIVE1MIGVsZW1lbnRcbiAqIHdpdGhvdXQgc2hpZnRpbmcgdGhlIGxheW91dCBvZiB0aGUgcGFnZSBtb3JlIHRoYW4gYWRkaW5nIGEgZm93IHBpeGVsc1xuICogb2YgcGFkZGluZyB0byB0aGUgcm9vdCBlbGVtZW50IGlmIG5lY2Vzc2FyeS5cbiAqIEBwYXJhbSBoaWRlU2Nyb2xsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VIaWRlU2Nyb2xsKGhpZGVTY3JvbGwpIHtcbiAgICBjb25zdCBbc2Nyb2xsYmFyV2lkdGgsIHNldFNjcm9sbGJhcldpZHRoLCBnZXRTY3JvbGxiYXJXaWR0aF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaGlkZVNjcm9sbCkge1xuICAgICAgICAgICAgbGV0IHdpZHRoV2l0aFNjcm9sbEJhciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZG9jdW1lbnQtc2Nyb2xsLWhpZGRlblwiKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdID0gKCsoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gfHwgXCIwXCIpICsgMSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCB3aWR0aFdpdGhvdXRTY3JvbGxCYXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsYmFyV2lkdGggPSAod2lkdGhXaXRob3V0U2Nyb2xsQmFyIC0gd2lkdGhXaXRoU2Nyb2xsQmFyKTtcbiAgICAgICAgICAgIC8vIEZhaWxzYWZlIC0tIGlmIHRoaXMgbWVhc3VyaW5nIHRyaWNrIGRvZXMgc29tZXRoaW5nIHVuZXhwZWN0ZWQsIGp1c3QgaWdub3JlIGl0XG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFyV2lkdGggPiA4MClcbiAgICAgICAgICAgICAgICBzY3JvbGxiYXJXaWR0aCA9IDA7XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXNjcm9sbGJhci13aWR0aFwiLCBgJHtzY3JvbGxiYXJXaWR0aH1weGApO1xuICAgICAgICAgICAgc2V0U2Nyb2xsYmFyV2lkdGgoc2Nyb2xsYmFyV2lkdGgpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSA9ICgrKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdIHx8IFwiMFwiKSAtIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdID09IFwiMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXNjcm9sbC1oaWRlcnNcIik7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZG9jdW1lbnQtc2Nyb2xsLWhpZGRlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW2hpZGVTY3JvbGxdKTtcbiAgICByZXR1cm4geyBzY3JvbGxiYXJXaWR0aCwgZ2V0U2Nyb2xsYmFyV2lkdGggfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1tb2RhbC5qcy5tYXAiLCJpbXBvcnQgeyB1c2VBcmlhTW9kYWwgfSBmcm9tIFwiLi91c2UtbW9kYWxcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhRGlhbG9nKHsgb3Blbiwgb25DbG9zZSB9KSB7XG4gICAgLy8gVE9ETzogRGlmZmVyZW5jZXMgYmV0d2VlbiBkaWFsb2cgYW5kIG1vZGFsIGdvIGhlcmUsIHByZXN1bWFibHlcbiAgICBjb25zdCB7IHVzZU1vZGFsQmFja2Ryb3AsIHVzZU1vZGFsQm9keSwgdXNlTW9kYWxQcm9wcywgdXNlTW9kYWxUaXRsZSB9ID0gdXNlQXJpYU1vZGFsKHsgb3Blbiwgb25DbG9zZSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VEaWFsb2dQcm9wczogdXNlTW9kYWxQcm9wcyxcbiAgICAgICAgdXNlRGlhbG9nVGl0bGU6IHVzZU1vZGFsVGl0bGUsXG4gICAgICAgIHVzZURpYWxvZ0JvZHk6IHVzZU1vZGFsQm9keSxcbiAgICAgICAgdXNlRGlhbG9nQmFja2Ryb3A6IHVzZU1vZGFsQmFja2Ryb3BcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWRpYWxvZy5qcy5tYXAiLCJpbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50LCB1c2VIYXNGb2N1cyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbGF5b3V0LWVmZmVjdFwiO1xuaW1wb3J0IHsgdXNlTGlzdE5hdmlnYXRpb24gfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbGlzdC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2Utc3RhdGVcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFdmVudERldGFpbCB9IGZyb20gXCIuL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VCdXR0b25MaWtlRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcbmltcG9ydCB7IHVzZUdlbmVyaWNMYWJlbCB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xuaW1wb3J0IHsgdXNlQ2hpbGRGbGFnIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhTGlzdGJveFNpbmdsZSh7IHNlbGVjdGVkSW5kZXgsIG9uU2VsZWN0LCBzZWxlY3Rpb25Nb2RlLCAuLi5hcmdzIH0pIHtcbiAgICBjb25zdCB7IGxhc3RGb2N1c2VkSW5uZXIsIHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzKCk7XG4gICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxJbnB1dCwgdXNlR2VuZXJpY0xhYmVsTGFiZWwsIHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMsIHVzZVJlZmVyZW5jZWRMYWJlbElkUHJvcHMsIGlucHV0RWxlbWVudCB9ID0gdXNlR2VuZXJpY0xhYmVsKHsgbGFiZWxQcmVmaXg6IFwiYXJpYS1saXN0Ym94LWxhYmVsLVwiLCBpbnB1dFByZWZpeDogXCJhcmlhLWxpc3Rib3gtXCIgfSk7XG4gICAgY29uc3QgeyB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCBuYXZpZ2F0ZVRvSW5kZXgsIG1hbmFnZWRDaGlsZHJlbiwgc2V0VGFiYmFibGVJbmRleCwgLi4ubGlzdFJlc3QgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uKHsgLi4uYXJncywgZm9jdXNPbkNoYW5nZTogbGFzdEZvY3VzZWRJbm5lciB9KTtcbiAgICBjb25zdCB7IHVzZUdlbmVyaWNMYWJlbElucHV0UHJvcHMgfSA9IHVzZUdlbmVyaWNMYWJlbElucHV0KCk7XG4gICAgY29uc3Qgc3RhYmxlT25TZWxlY3QgPSB1c2VTdGFibGVDYWxsYmFjayhvblNlbGVjdCA/PyAoKCkgPT4geyB9KSk7XG4gICAgdXNlQ2hpbGRGbGFnKHNlbGVjdGVkSW5kZXgsIG1hbmFnZWRDaGlsZHJlbi5sZW5ndGgsIChpLCBzZWxlY3RlZCkgPT4gbWFuYWdlZENoaWxkcmVuW2ldPy5zZXRTZWxlY3RlZChzZWxlY3RlZCkpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoW10pID0+IHtcbiAgICAgICAgbmF2aWdhdGVUb0luZGV4KHNlbGVjdGVkSW5kZXgpO1xuICAgIH0sIFtzZWxlY3RlZEluZGV4LCBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoXSk7XG4gICAgY29uc3QgY2hpbGRDb3VudCA9IG1hbmFnZWRDaGlsZHJlbi5sZW5ndGg7XG4gICAgY29uc3QgeyBsYXN0QWN0aXZlRWxlbWVudCB9ID0gdXNlQWN0aXZlRWxlbWVudCgpO1xuICAgIGxldCBhbnlSYWRpb3NGb2N1c2VkID0gKCEhaW5wdXRFbGVtZW50Py5jb250YWlucyhsYXN0QWN0aXZlRWxlbWVudCkpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghYW55UmFkaW9zRm9jdXNlZClcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoc2VsZWN0ZWRJbmRleCk7XG4gICAgfSwgW2FueVJhZGlvc0ZvY3VzZWQsIHNlbGVjdGVkSW5kZXgsIHNldFRhYmJhYmxlSW5kZXhdKTtcbiAgICBjb25zdCB1c2VMaXN0Ym94U2luZ2xlSXRlbSA9IHVzZUNhbGxiYWNrKChpbmZvKSA9PiB7XG4gICAgICAgIGNvbnN0IFtzZWxlY3RlZCwgc2V0U2VsZWN0ZWQsIGdldFNlbGVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAgICAgY29uc3QgeyB0YWJiYWJsZSwgdXNlTGlzdE5hdmlnYXRpb25TaWJsaW5nUHJvcHMsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7IHNldFNlbGVjdGVkLCAuLi5pbmZvIH0pO1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xuICAgICAgICBjb25zdCBpbmRleCA9IGluZm8uaW5kZXg7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiB0YWJiYWJsZSAmJiBzZWxlY3Rpb25Nb2RlID09IFwiZm9jdXNcIikge1xuICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyB0YXJnZXQ6IGVsZW1lbnQsIGN1cnJlbnRUYXJnZXQ6IGVsZW1lbnQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogaW5kZXggfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW2VsZW1lbnQsIHRhYmJhYmxlLCBzZWxlY3Rpb25Nb2RlLCBpbmRleF0pO1xuICAgICAgICByZXR1cm4geyB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzLCB0YWJiYWJsZSwgc2VsZWN0ZWQsIGdldFNlbGVjdGVkIH07XG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVJdGVtUHJvcHMocHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0gdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnMoaW5mby50YWcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGluZm8uaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBzdGFibGVPblNlbGVjdD8uKHsgdGFyZ2V0OiBlbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBlbGVtZW50LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IGluZGV4IH0gfSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSwgdW5kZWZpbmVkKSh7fSk7XG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJvcHRpb25cIjtcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1zZXRzaXplXCJdID0gKGNoaWxkQ291bnQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBwcm9wc1tcImFyaWEtcG9zaW5zZXRcIl0gPSAoaW5mby5pbmRleCArIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBwcm9wc1tcImFyaWEtc2VsZWN0ZWRcIl0gPSBzZWxlY3RlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VNZXJnZWRQcm9wcygpKG5ld1Byb3BzLCB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpKSk7XG4gICAgICAgIH1cbiAgICB9LCBbdXNlTGlzdE5hdmlnYXRpb25DaGlsZCwgc2VsZWN0aW9uTW9kZSwgY2hpbGRDb3VudF0pO1xuICAgIGNvbnN0IHVzZUxpc3Rib3hTaW5nbGVMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCgpIHtcbiAgICAgICAgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHMocHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlR2VuZXJpY0xhYmVsTGFiZWxQcm9wcyB9ID0gdXNlR2VuZXJpY0xhYmVsTGFiZWwoKTtcbiAgICAgICAgICAgIHVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHMocHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzIH07XG4gICAgfSwgW3VzZUdlbmVyaWNMYWJlbExhYmVsXSk7XG4gICAgcmV0dXJuIHsgdXNlTGlzdGJveFNpbmdsZUl0ZW0sIHVzZUxpc3Rib3hTaW5nbGVQcm9wcywgdXNlTGlzdGJveFNpbmdsZUxhYmVsLCAuLi5saXN0UmVzdCB9O1xuICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVQcm9wcyhwcm9wcykge1xuICAgICAgICBwcm9wcy5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgICAgIHJldHVybiB1c2VIYXNGb2N1c1Byb3BzKHVzZUdlbmVyaWNMYWJlbElucHV0UHJvcHMocHJvcHMpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbGlzdGJveC1zaW5nbGUuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VIYXNGb2N1cyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1oYXMtZm9jdXNcIjtcbmltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtYWN0aXZlLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IHVzZUxpc3ROYXZpZ2F0aW9uIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxpc3QtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VSYW5kb21JZCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1yYW5kb20taWRcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsLCBlbmhhbmNlRXZlbnQgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlVGltZW91dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VTb2Z0RGlzbWlzcyB9IGZyb20gXCIuL3VzZS1tb2RhbFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFNZW51KHsgY29sbGF0b3IsIGtleU5hdmlnYXRpb24sIG5vVHlwZWFoZWFkLCBub1dyYXAsIHR5cGVhaGVhZFRpbWVvdXQsIC4uLmFyZ3MgfSkge1xuICAgIGNvbnN0IFtmb2N1c1RyYXBBY3RpdmUsIHNldEZvY3VzVHJhcEFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgbGV0IG9uQ2xvc2UgPSBhcmdzLm9uQ2xvc2U7XG4gICAgbGV0IG9uT3BlbiA9IGFyZ3Mub25PcGVuO1xuICAgIGxldCBtZW51YmFyID0gYXJncy5tZW51YmFyO1xuICAgIGxldCBvcGVuID0gKG1lbnViYXIgPyB0cnVlIDogYXJncy5vcGVuKTtcbiAgICBjb25zdCBzdGFibGVPbkNsb3NlID0gdXNlU3RhYmxlQ2FsbGJhY2sob25DbG9zZSA/PyAoKCkgPT4geyB9KSk7XG4gICAgLy8gVE9ETzogSXQncyBhd2t3YXJkIHRoYXQgdGhlIGJ1dHRvbiBmb2N1cyBwcm9wcyBhcmUgb3V0IGhlcmUgd2hlcmUgd2UgZG9uJ3QgaGF2ZSBpdHMgdHlwZSxcbiAgICAvLyBidXQgZm9jdXMgbWFuYWdlbWVudCBpcyBzdXBlciBzZW5zaXRpdmUsIGFuZCBldmVuIHdhaXRpbmcgZm9yIGEgdXNlTGF5b3V0RWZmZWN0IHRvIHN5bmMgc3RhdGUgaGVyZVxuICAgIC8vIHdvdWxkIGJlIHRvbyBsYXRlLCBzbyBpdCB3b3VsZCBsb29rIGxpa2UgdGhlcmUncyBhIG1vbWVudCBiZXR3ZWVuIG1lbnUgZm9jdXMgbG9zdCBhbmQgYnV0dG9uIGZvY3VzIGdhaW5lZFxuICAgIC8vIHdoZXJlIG5vdGhpbmcgaXMgZm9jdXNlZC4gXG4gICAgY29uc3QgeyBmb2N1c2VkSW5uZXI6IG1lbnVIYXNGb2N1cywgdXNlSGFzRm9jdXNQcm9wczogdXNlTWVudUhhc0ZvY3VzUHJvcHMsIH0gPSB1c2VIYXNGb2N1cygpO1xuICAgIGNvbnN0IHsgZm9jdXNlZElubmVyOiBidXR0b25IYXNGb2N1cywgdXNlSGFzRm9jdXNQcm9wczogdXNlQnV0dG9uSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXMoKTtcbiAgICBjb25zdCB7IGFjdGl2ZUVsZW1lbnQsIGxhc3RBY3RpdmVFbGVtZW50LCB3aW5kb3dGb2N1c2VkIH0gPSB1c2VBY3RpdmVFbGVtZW50KCk7XG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW4sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsIHRhYmJhYmxlSW5kZXgsIGZvY3VzU2VsZjogZm9jdXNNZW51IH0gPSB1c2VMaXN0TmF2aWdhdGlvbih7IGNvbGxhdG9yLCBrZXlOYXZpZ2F0aW9uLCBub1R5cGVhaGVhZCwgbm9XcmFwLCB0eXBlYWhlYWRUaW1lb3V0LCBmb2N1c09uQ2hhbmdlOiAobWVudUhhc0ZvY3VzIHx8IGJ1dHRvbkhhc0ZvY3VzKSB9KTtcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUHJvcHM6IHVzZU1lbnVJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlTWVudUlkUmVmZXJlbmNpbmdQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1tZW51LVwiIH0pO1xuICAgIGNvbnN0IFtvcGVuZXJFbGVtZW50LCBzZXRPcGVuZXJFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHsgdXNlU29mdERpc21pc3NQcm9wcyB9ID0gdXNlU29mdERpc21pc3MoeyBvbkNsb3NlOiBzdGFibGVPbkNsb3NlIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldEZvY3VzVHJhcEFjdGl2ZShvcGVuKTtcbiAgICB9LCBbb3Blbl0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChmb2N1c1RyYXBBY3RpdmUpXG4gICAgICAgICAgICBmb2N1c01lbnUoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb3BlbmVyRWxlbWVudD8uZm9jdXMoKTtcbiAgICB9LCBbZm9jdXNUcmFwQWN0aXZlXSk7XG4gICAgLy8gRm9jdXMgbWFuYWdlbWVudCBpcyByZWFsbHkgZmluaWNreSwgYW5kIHRoZXJlJ3MgYWx3YXlzIGdvaW5nIHRvIGJlIFxuICAgIC8vIGFuIGVkZ2UgY2FzZSB3aGVyZSBub3RoaW5nJ3MgZm9jdXNlZCBmb3IgdHdvIGNvbnNlY3V0aXZlIGZyYW1lcyBcbiAgICAvLyBvbiBpT1Mgb3Igd2hhdGV2ZXIsIHdoaWNoIHdvdWxkIGltbWVkaWF0ZWx5IGNsb3NlIHRoZSBtZW51IFxuICAgIC8vIGFueSB0aW1lIGl0J3MgYmVlbiBvcGVuZWQuIFNvIGFueSB0aW1lIGl0ICpsb29rcyogbGlrZSB3ZSBzaG91bGQgY2xvc2UsXG4gICAgLy8gdHJ5IHdhaXRpbmcgMTAwbXMuIElmIGl0J3Mgc3RpbGwgdHJ1ZSB0aGVuLCB0aGVuIHllYWgsIHdlIHNob3VsZCBjbG9zZS5cbiAgICBsZXQgc2hvdWxkQ2xvc2UgPSAoZm9jdXNUcmFwQWN0aXZlICYmIHdpbmRvd0ZvY3VzZWQgJiYgIW1lbnVIYXNGb2N1cyAmJiAhYnV0dG9uSGFzRm9jdXMpO1xuICAgIHVzZVRpbWVvdXQoe1xuICAgICAgICB0aW1lb3V0OiAxMDAsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlPy4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlckluZGV4OiBgJHtzaG91bGRDbG9zZX1gXG4gICAgfSk7XG4gICAgLy8gQSBtZW51IHNlbnRpbmFsIGlzIGEgaGlkZGVuIGJ1dCBmb2N1c2FibGUgZWxlbWVudCB0aGF0IGNvbWVzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGVsZW1lbnRcbiAgICAvLyB0aGF0LCB3aGVuIGFjdGl2YXRlZCBvciBmb2N1c2VkIG92ZXIsIGNsb3NlcyB0aGUgbWVudS5cbiAgICAvLyAoaWYgZm9jdXNlZCB3aXRoaW4gMTAwbXMgb2YgdGhlIG9wZW4gcHJvcCBjaGFuZ2luZywgaW5zdGVhZCBvZlxuICAgIC8vIGNsb3NpbmcgdGhlIG1lbnUsIGZvY3VzaW5nIHRoZSBzZW50aW5lbCBpbW1lZGlhdGVseSBhc2tzIHRoZSBtZW51IHRvIGZvY3VzIGl0c2VsZikuXG4gICAgLy8gVGhpcyBleGlzdHMgYmVjYXVzZSB3aGlsZSBtb3VzZSB1c2VycyBjYW4gY2xpY2sgb3V0IG9mIGEgbWVudVxuICAgIC8vIGFuZCBrZXlib2FyZCB1c2VycyBjYW4gZXNjYXBlIHRvIGNsb3NlIHRoZSBtZW51LFxuICAgIC8vIHNjcmVlbiByZWFkZXJzIGFuZCBvdGhlciBpbnB1dCBtZXRob2RzIHRoYXQgZG9uJ3QgdXNlIHRob3NlIHR3byBiZWNvbWUgc3R1Y2suXG4gICAgY29uc3QgdXNlTWVudVNlbnRpbmVsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBbZmlyc3RTZW50aW5lbElzQWN0aXZlLCBzZXRGaXJzdFNlbnRpbmVsSXNBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgICAgICB1c2VUaW1lb3V0KHsgY2FsbGJhY2s6ICgpID0+IHsgc2V0Rmlyc3RTZW50aW5lbElzQWN0aXZlKG9wZW4pOyB9LCB0aW1lb3V0OiAxMDAsIHRyaWdnZXJJbmRleDogYCR7Zmlyc3RTZW50aW5lbElzQWN0aXZlfWAgfSk7XG4gICAgICAgIGNvbnN0IG9uRm9jdXMgPSBmaXJzdFNlbnRpbmVsSXNBY3RpdmUgPyAoKCkgPT4gc3RhYmxlT25DbG9zZSgpKSA6ICgoKSA9PiBmb2N1c01lbnUoKSk7XG4gICAgICAgIGNvbnN0IG9uQ2xpY2sgPSAoKSA9PiBzdGFibGVPbkNsb3NlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VNZW51U2VudGluZWxQcm9wczogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IG9uRm9jdXMsIG9uQ2xpY2sgfSwgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW29wZW5dKTtcbiAgICBjb25zdCB1c2VNZW51QnV0dG9uID0gdXNlQ2FsbGJhY2soKHsgdGFnIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgc2V0T3BlbmVyRWxlbWVudChlbGVtZW50KTsgfSwgW2VsZW1lbnRdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZU1lbnVCdXR0b25Qcm9wczogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcHMgPSB1c2VSZWZFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IG9uQ2xpY2s6ICgpID0+IHsgcmV0dXJuIG9wZW4gPyBvbkNsb3NlPy4oKSA6IG9uT3Blbj8uKCk7IH0gfSwgdXNlTWVudUlkUmVmZXJlbmNpbmdQcm9wcyhcImFyaWEtY29udHJvbHNcIikodXNlQnV0dG9uSGFzRm9jdXNQcm9wcyhwKSkpKTtcbiAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtaGFzcG9wdXBcIl0gPSBcIm1lbnVcIjtcbiAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtZXhwYW5kZWRcIl0gPSBvcGVuID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtvcGVuLCBvbkNsb3NlLCBvbk9wZW4sIHVzZU1lbnVJZFJlZmVyZW5jaW5nUHJvcHNdKTtcbiAgICBjb25zdCB1c2VNZW51U3VibWVudUl0ZW0gPSB1c2VDYWxsYmFjaygoYXJncykgPT4ge1xuICAgICAgICBjb25zdCB7IHVzZU1lbnVQcm9wcywgdXNlTWVudUJ1dHRvbiB9ID0gdXNlQXJpYU1lbnUoYXJncyk7XG4gICAgICAgIGNvbnN0IHsgdXNlTWVudUJ1dHRvblByb3BzIH0gPSB1c2VNZW51QnV0dG9uKHsgdGFnOiBcImxpXCIgfSk7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHNldE9wZW5lckVsZW1lbnQoZWxlbWVudCk7IH0sIFtlbGVtZW50XSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgZ2V0RWxlbWVudCxcbiAgICAgICAgICAgIHVzZU1lbnVQcm9wcyxcbiAgICAgICAgICAgIHVzZU1lbnVTdWJtZW51SXRlbVByb3BzOiBmdW5jdGlvbiAoeyAuLi5wcm9wcyB9KSB7XG4gICAgICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwibWVudWl0ZW1cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlUmVmRWxlbWVudFByb3BzKHVzZU1lbnVCdXR0b25Qcm9wcyh1c2VNZW51SWRSZWZlcmVuY2luZ1Byb3BzKFwiYXJpYS1jb250cm9sc1wiKShwcm9wcykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgdXNlTWVudUl0ZW0gPSB1c2VDYWxsYmFjaygoYXJncykgPT4ge1xuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZChhcmdzKTtcbiAgICAgICAgLy8gY29uc3QgeyBnZXRTeW5jSGFuZGxlciwgLi4uYXN5bmNJbmZvIH0gPSB1c2VBc3luY0hhbmRsZXI8RT4oKSh7IGNhcHR1cmU6IF8gPT4gdm9pZCAoMCkgfSk7XG4gICAgICAgIC8vIGNvbnN0IG9uQ2xpY2sgPSBnZXRTeW5jSGFuZGxlcihhc3luY0luZm8ucGVuZGluZyA/IG51bGwgOiAoYXJncy5vbkNsaWNrID8/IG51bGwpKTtcbiAgICAgICAgY29uc3Qgb25DbGljayA9IGFyZ3Mub25DbGljaztcbiAgICAgICAgZnVuY3Rpb24gdXNlTWVudUl0ZW1Qcm9wcyh7IC4uLnByb3BzIH0pIHtcbiAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcIm1lbnVpdGVtXCI7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IG9uQ2xpY2sgfSwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHByb3BzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdXNlTWVudUl0ZW1Qcm9wcyB9O1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCB1c2VNZW51SXRlbUNoZWNrYm94ID0gdXNlQ2FsbGJhY2soKGFyZ3MpID0+IHtcbiAgICAgICAgLy9jb25zdCB7IGdldFN5bmNIYW5kbGVyLCAuLi5hc3luY0luZm8gfSA9IHVzZUFzeW5jSGFuZGxlcjxFPigpKHsgY2FwdHVyZTogXyA9PiAhYXJncy5jaGVja2VkIH0pO1xuICAgICAgICAvL2NvbnN0IG9uQ2xpY2sgPSBnZXRTeW5jSGFuZGxlcihhc3luY0luZm8ucGVuZGluZyA/IG51bGwgOiBhcmdzLm9uQ2hhbmdlKTtcbiAgICAgICAgY29uc3Qgb25DbGljayA9IChlKSA9PiBhcmdzLm9uQ2hhbmdlKGVuaGFuY2VFdmVudChlLCB7IGNoZWNrZWQ6ICFhcmdzLmNoZWNrZWQgfSkpO1xuICAgICAgICBmdW5jdGlvbiB1c2VNZW51SXRlbVByb3BzKHsgLi4ucHJvcHMgfSkge1xuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwibWVudWl0ZW1jaGVja2JveFwiO1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkoeyBvbkNsaWNrIH0sIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1c2VNZW51SXRlbVByb3BzIH07XG4gICAgfSwgW10pO1xuICAgIGZ1bmN0aW9uIHVzZU1lbnVQcm9wcyh7IC4uLnByb3BzIH0pIHtcbiAgICAgICAgcHJvcHMucm9sZSA9IFwibWVudVwiO1xuICAgICAgICBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgICAgICAgICAgaWYgKGUua2V5ID09IFwiRXNjYXBlXCIgJiYgb25DbG9zZSkge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXNlTWVudUlkUHJvcHModXNlTWVudUhhc0ZvY3VzUHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IG9uS2V5RG93biB9LCB1c2VTb2Z0RGlzbWlzc1Byb3BzKHByb3BzKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTWVudVByb3BzLFxuICAgICAgICB1c2VNZW51QnV0dG9uLFxuICAgICAgICB1c2VNZW51SXRlbSxcbiAgICAgICAgdXNlTWVudVNlbnRpbmVsLFxuICAgICAgICB1c2VNZW51SXRlbUNoZWNrYm94LFxuICAgICAgICB1c2VNZW51U3VibWVudUl0ZW0sXG4gICAgICAgIGZvY3VzTWVudVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbWVudS5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlQ2hpbGRNYW5hZ2VyIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VMaXN0TmF2aWdhdGlvbiB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlUmFuZG9tSWQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtcmFuZG9tLWlkXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VCdXR0b25MaWtlRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZUhhc0ZvY3VzLCB1c2VMb2dpY2FsRGlyZWN0aW9uLCB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCB9IGZyb20gXCIuL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VDaGlsZEZsYWcgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtY2hpbGQtbWFuYWdlclwiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFUYWJzKHsgc2VsZWN0aW9uTW9kZSwgc2VsZWN0ZWRJbmRleCwgb25TZWxlY3QsIG9yaWVudGF0aW9uOiBsb2dpY2FsT3JpZW50YXRpb24sIC4uLmFyZ3MgfSkge1xuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wczogdXNlVGFiTGlzdEhhc0ZvY3VzUHJvcHMsIGZvY3VzZWRJbm5lcjogdGFiTGlzdEZvY3VzZWQgfSA9IHVzZUhhc0ZvY3VzKCk7XG4gICAgY29uc3QgeyBlbGVtZW50OiBsaXN0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XG4gICAgY29uc3QgeyBnZXRMb2dpY2FsRGlyZWN0aW9uLCBjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uIH0gPSB1c2VMb2dpY2FsRGlyZWN0aW9uKGxpc3RFbGVtZW50KTtcbiAgICBjb25zdCBwaHlzaWNhbE9yaWVudGF0aW9uID0gY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbihsb2dpY2FsT3JpZW50YXRpb24pO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlVGFiTGlzdElkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzOiB1c2VSZWZlcmVuY2VkVGFiTGlzdElkIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLXRhYi1saXN0LVwiIH0pO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlVGFiTGFiZWxJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlUmVmZXJlbmNlZFRhYkxhYmVsSWQgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtdGFiLWxhYmVsLVwiIH0pO1xuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkVGFicywgbmF2aWdhdGVUb0luZGV4LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkIH0gPSB1c2VMaXN0TmF2aWdhdGlvbih7IC4uLmFyZ3MsIGZvY3VzT25DaGFuZ2U6IHVzZVRhYkxpc3RIYXNGb2N1c1Byb3BzLCBrZXlOYXZpZ2F0aW9uOiBsb2dpY2FsT3JpZW50YXRpb24gfSk7XG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRQYW5lbHMsIHVzZU1hbmFnZWRDaGlsZDogdXNlTWFuYWdlZFRhYlBhbmVsIH0gPSB1c2VDaGlsZE1hbmFnZXIoKTtcbiAgICBjb25zdCBzdGFibGVPblNlbGVjdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uU2VsZWN0KTtcbiAgICBjb25zdCBjaGlsZENvdW50ID0gbWFuYWdlZFRhYnMubGVuZ3RoO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG1hbmFnZWRUYWJzKVxuICAgICAgICAgICAgY2hpbGQuc2V0U2VsZWN0aW9uTW9kZShzZWxlY3Rpb25Nb2RlKTtcbiAgICB9LCBbc2VsZWN0aW9uTW9kZV0pO1xuICAgIHVzZUNoaWxkRmxhZyhzZWxlY3RlZEluZGV4LCBtYW5hZ2VkVGFicy5sZW5ndGgsIChpLCBzZWxlY3RlZCkgPT4gbWFuYWdlZFRhYnNbaV0/LnNldFNlbGVjdGVkKHNlbGVjdGVkKSk7XG4gICAgdXNlQ2hpbGRGbGFnKHNlbGVjdGVkSW5kZXgsIG1hbmFnZWRQYW5lbHMubGVuZ3RoLCAoaSwgdmlzaWJsZSkgPT4gbWFuYWdlZFBhbmVsc1tpXT8uc2V0VmlzaWJsZSh2aXNpYmxlKSk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KChbcHJldkNoaWxkQ291bnQsIHByZXZTZWxlY3RlZEluZGV4XSkgPT4ge1xuICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAhPSBudWxsICYmIHNlbGVjdGlvbk1vZGUgPT0gXCJhY3RpdmF0ZVwiKSB7XG4gICAgICAgICAgICBtYW5hZ2VkUGFuZWxzW3NlbGVjdGVkSW5kZXhdPy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfSwgW2NoaWxkQ291bnQsIHNlbGVjdGVkSW5kZXgsIHNlbGVjdGlvbk1vZGVdKTtcbiAgICBjb25zdCBnZXRUYWJMaXN0SXNGb2N1c2VkID0gdXNlU3RhYmxlR2V0dGVyKHRhYkxpc3RGb2N1c2VkKTtcbiAgICBjb25zdCB1c2VUYWIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VUYWIoaW5mbykge1xuICAgICAgICAvL2NvbnN0IFtzZWxlY3RlZFRhYklkLCBzZXRTZWxlY3RlZFRhYklkLCBnZXRTZWxlY3RlZFRhYklkXSA9IHVzZVN0YXRlPHN0cmluZyB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgW3NlbGVjdGlvbk1vZGVMLCBzZXRTZWxlY3Rpb25Nb2RlTF0gPSB1c2VTdGF0ZShzZWxlY3Rpb25Nb2RlKTtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgW3RhYlBhbmVsSWQsIHNldFRhYlBhbmVsSWRdID0gdXNlU3RhdGUodW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VUYWJJZFByb3BzLCBpZDogdGFiSWQsIGdldElkOiBnZXRUYWJJZCB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS10YWItXCIgfSk7XG4gICAgICAgIGNvbnN0IFtzZWxlY3RlZCwgc2V0U2VsZWN0ZWQsIGdldFNlbGVjdGVkXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgICAgICBjb25zdCB7IHRhYmJhYmxlLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsIHVzZUxpc3ROYXZpZ2F0aW9uU2libGluZ1Byb3BzIH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHsgLi4uaW5mbywgc2V0U2VsZWN0ZWQsIHRhYklkLCBzZXRUYWJQYW5lbElkLCBzZXRTZWxlY3Rpb25Nb2RlOiBzZXRTZWxlY3Rpb25Nb2RlTCB9KTtcbiAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VTdGFibGVHZXR0ZXIoaW5mby5pbmRleCk7XG4gICAgICAgIC8vIGNvbnN0IHsgZ2V0U3luY0hhbmRsZXIsIC4uLmFzeW5jSW5mbyB9ID0gdXNlQXN5bmNIYW5kbGVyPEVsZW1lbnQ+KCkoeyBjYXB0dXJlOiAoZTogdW5rbm93bikgPT4gaW5mby5pbmRleCB9KTtcbiAgICAgICAgLy8gY29uc3Qgb25TZWxlY3QgPSBnZXRTeW5jSGFuZGxlcihhc3luY0luZm8ucGVuZGluZz8gbnVsbCA6IChzdGFibGVBc3luY09uU2VsZWN0ID8/IG51bGwpKTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWJiYWJsZSAmJiBzZWxlY3Rpb25Nb2RlTCA9PSBcImZvY3VzXCIpIHtcbiAgICAgICAgICAgICAgICBvblNlbGVjdCh7IHRhcmdldDogZWxlbWVudCwgY3VycmVudFRhcmdldDogZWxlbWVudCwgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBnZXRJbmRleCgpIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt0YWJiYWJsZSwgc2VsZWN0aW9uTW9kZUwsIGVsZW1lbnRdKTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHsgbWFuYWdlZFBhbmVsc1tpbmZvLmluZGV4XT8uc2V0VGFiSWQodGFiSWQpOyB9LCBbdGFiSWQsIGluZm8uaW5kZXhdKTtcbiAgICAgICAgLyp1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKVxuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkVGFiSWQodGFiSWQpO1xuICAgICAgICB9LCBbc2VsZWN0ZWQsIHRhYklkXSkqL1xuICAgICAgICBmdW5jdGlvbiB1c2VUYWJQcm9wcyh7IC4uLnByb3BzIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0gdXNlQnV0dG9uTGlrZUV2ZW50SGFuZGxlcnMoaW5mby50YWcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGluZm8uaW5kZXgpO1xuICAgICAgICAgICAgICAgIG9uU2VsZWN0Py4oZW5oYW5jZUV2ZW50KGUsIHsgc2VsZWN0ZWRJbmRleDogZ2V0SW5kZXgoKSB9KSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSwgdW5kZWZpbmVkKShwcm9wcyk7XG4gICAgICAgICAgICBuZXdQcm9wcy5yb2xlID0gXCJ0YWJcIjtcbiAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1zZWxlY3RlZFwiXSA9IChzZWxlY3RlZCA/PyBmYWxzZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1jb250cm9sc1wiXSA9IHRhYlBhbmVsSWQ7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7fSwgdXNlVGFiSWRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlUmVmRWxlbWVudFByb3BzKG5ld1Byb3BzKSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1c2VUYWJQcm9wcywgc2VsZWN0ZWQgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgdXNlVGFiUGFuZWwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VQYW5lbChpbmZvKSB7XG4gICAgICAgIC8vY29uc3QgW3NlbGVjdGVkVGFiUGFuZWxJZCwgc2V0U2VsZWN0ZWRUYWJQYW5lbElkLCBnZXRTZWxlY3RlZFRhYlBhbmVsSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBbc2hvdWxkRm9jdXMsIHNldFNob3VsZEZvY3VzXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAgICAgY29uc3QgW3RhYklkLCBzZXRUYWJJZF0gPSB1c2VTdGF0ZSh1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkLCBnZXRTZWxlY3RlZF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VQYW5lbElkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzOiB1c2VSZWZlcmVuY2VkUGFuZWxJZCwgaWQ6IHRhYlBhbmVsSWQgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtdGFiLXBhbmVsLVwiIH0pO1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIHVzZU1hbmFnZWRDaGlsZFByb3BzIH0gPSB1c2VNYW5hZ2VkVGFiUGFuZWwoeyAuLi5pbmZvLCB0YWJQYW5lbElkLCBzZXRUYWJJZCwgZm9jdXMsIHNldFZpc2libGU6IHNldFNlbGVjdGVkIH0pO1xuICAgICAgICBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgICAgIGlmIChnZXRUYWJMaXN0SXNGb2N1c2VkKCkpIHtcbiAgICAgICAgICAgICAgICBzZXRTaG91bGRGb2N1cyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNob3VsZEZvY3VzKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudD8uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBzZXRTaG91bGRGb2N1cyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtlbGVtZW50LCBzaG91bGRGb2N1c10pO1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4geyBtYW5hZ2VkVGFic1tpbmZvLmluZGV4XT8uc2V0VGFiUGFuZWxJZCh0YWJQYW5lbElkKTsgfSwgW3RhYlBhbmVsSWQsIGluZm8uaW5kZXhdKTtcbiAgICAgICAgZnVuY3Rpb24gdXNlVGFiUGFuZWxQcm9wcyh7IC4uLnByb3BzIH0pIHtcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1sYWJlbGxlZGJ5XCJdID0gbWFuYWdlZFRhYnNbaW5mby5pbmRleF0/LnRhYklkO1xuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwidGFicGFuZWxcIjtcbiAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID8/PSAtMTsgLy8gTWFrZSBzdXJlIHRoZSB0YWIgcGFuZWwgaXMgdGFiYmFibGUuXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7fSwgdXNlUGFuZWxJZFByb3BzKHVzZU1hbmFnZWRDaGlsZFByb3BzKHByb3BzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHVzZVRhYlBhbmVsUHJvcHMsIHNlbGVjdGVkIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHVzZVRhYnNMaXN0ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVGFiTGlzdCgpIHtcbiAgICAgICAgZnVuY3Rpb24gdXNlVGFiTGlzdFByb3BzKHsgLi4ucHJvcHMgfSkge1xuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwidGFibGlzdFwiO1xuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLW9yaWVudGF0aW9uXCJdID0gcGh5c2ljYWxPcmllbnRhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB1c2VSZWZlcmVuY2VkVGFiTGFiZWxJZChcImFyaWEtbGFiZWxsZWRieVwiKSh1c2VUYWJMaXN0SGFzRm9jdXNQcm9wcyh1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdXNlVGFiTGlzdFByb3BzIH07XG4gICAgfSwgW3BoeXNpY2FsT3JpZW50YXRpb25dKTtcbiAgICBjb25zdCB1c2VUYWJzTGFiZWwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VUYWJzTGFiZWwoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHVzZVRhYnNMYWJlbFByb3BzKHsgLi4ucHJvcHMgfSkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZVRhYkxhYmVsSWRQcm9wcyhwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdXNlVGFic0xhYmVsUHJvcHMgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHsgdXNlVGFiLCB1c2VUYWJQYW5lbCwgdXNlVGFic0xpc3QsIHVzZVRhYnNMYWJlbCB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXRhYnMuanMubWFwIiwiaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCwgdXNlSGFzRm9jdXMsIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlTGlzdE5hdmlnYXRpb24gfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbGlzdC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlQ2hlY2tib3hMaWtlIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XG5pbXBvcnQgeyB1c2VDaGlsZEZsYWcgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtY2hpbGQtbWFuYWdlclwiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFSYWRpb0dyb3VwKHsgbmFtZSwgc2VsZWN0ZWRWYWx1ZSwgb25JbnB1dCB9KSB7XG4gICAgY29uc3QgeyBlbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleCwgZ2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBieU5hbWUgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgICBjb25zdCBzdGFibGVPbklucHV0ID0gdXNlU3RhYmxlQ2FsbGJhY2sob25JbnB1dCk7XG4gICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzLCBsYXN0Rm9jdXNlZElubmVyIH0gPSB1c2VIYXNGb2N1cygpO1xuICAgIGNvbnN0IHsgY3VycmVudFR5cGVhaGVhZCwgbWFuYWdlZENoaWxkcmVuLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCBzZXRUYWJiYWJsZUluZGV4IH0gPSB1c2VMaXN0TmF2aWdhdGlvbih7IGZvY3VzT25DaGFuZ2U6IGxhc3RGb2N1c2VkSW5uZXIgfSk7XG4gICAgY29uc3QgdXNlUmFkaW9Hcm91cFByb3BzID0gdXNlQ2FsbGJhY2soKHsgLi4ucHJvcHMgfSkgPT4ge1xuICAgICAgICBwcm9wcy5yb2xlID0gXCJyYWRpb2dyb3VwXCI7XG4gICAgICAgIHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHModXNlSGFzRm9jdXNQcm9wcyhwcm9wcykpO1xuICAgIH0sIFt1c2VIYXNGb2N1c1Byb3BzLCB1c2VSZWZFbGVtZW50UHJvcHNdKTtcbiAgICB1c2VDaGlsZEZsYWcoc2VsZWN0ZWRJbmRleCwgbWFuYWdlZENoaWxkcmVuLmxlbmd0aCwgKGksIGNoZWNrZWQpID0+IG1hbmFnZWRDaGlsZHJlbltpXT8uc2V0Q2hlY2tlZChjaGVja2VkKSk7XG4gICAgY29uc3QgeyBsYXN0QWN0aXZlRWxlbWVudCB9ID0gdXNlQWN0aXZlRWxlbWVudCgpO1xuICAgIGxldCBhbnlSYWRpb3NGb2N1c2VkID0gKCEhZWxlbWVudD8uY29udGFpbnMobGFzdEFjdGl2ZUVsZW1lbnQpKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWFueVJhZGlvc0ZvY3VzZWQgJiYgc2VsZWN0ZWRJbmRleCAhPSBudWxsKVxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChzZWxlY3RlZEluZGV4KTtcbiAgICB9LCBbYW55UmFkaW9zRm9jdXNlZCwgc2VsZWN0ZWRJbmRleCwgc2V0VGFiYmFibGVJbmRleF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCBvbGRJbmRleCA9IGdldFNlbGVjdGVkSW5kZXgoKTtcbiAgICAgICAgbGV0IG5ld0luZGV4ID0gYnlOYW1lLmN1cnJlbnQuZ2V0KHNlbGVjdGVkVmFsdWUpO1xuICAgICAgICBzZXRTZWxlY3RlZEluZGV4KG5ld0luZGV4KTtcbiAgICB9LCBbc2VsZWN0ZWRWYWx1ZV0pO1xuICAgIGNvbnN0IHVzZVJhZGlvID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQXJpYVJhZGlvKHsgdmFsdWUsIGluZGV4LCB0ZXh0LCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgLi4ucmVzdCB9KSB7XG4gICAgICAgIGNvbnN0IG9uSW5wdXQgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICAgICAgc3RhYmxlT25JbnB1dChlbmhhbmNlRXZlbnQoZSwgeyBzZWxlY3RlZFZhbHVlOiB2YWx1ZSB9KSk7XG4gICAgICAgIH0sIFtzdGFibGVPbklucHV0LCB2YWx1ZSwgaW5kZXhdKTtcbiAgICAgICAgY29uc3QgeyBnZXRJbnB1dEVsZW1lbnQsIGdldExhYmVsRWxlbWVudCwgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQgfSA9IHVzZUNoZWNrYm94TGlrZSh7IGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCBvbklucHV0LCByb2xlOiBcInJhZGlvXCIgfSk7XG4gICAgICAgIC8vY29uc3Qge30gPSB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQoeyAgfSlcbiAgICAgICAgY29uc3QgYnlOYW1lMiA9IGJ5TmFtZS5jdXJyZW50O1xuICAgICAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCghYnlOYW1lMi5oYXModmFsdWUpKTtcbiAgICAgICAgICAgIGJ5TmFtZTIuc2V0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4geyBieU5hbWUyLmRlbGV0ZSh2YWx1ZSk7IH07XG4gICAgICAgIH0sIFt2YWx1ZSwgaW5kZXhdKTtcbiAgICAgICAgY29uc3QgeyB0YWJiYWJsZSwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLCB1c2VMaXN0TmF2aWdhdGlvblNpYmxpbmdQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7IGluZGV4LCBzZXRDaGVja2VkLCB0ZXh0LCAuLi5yZXN0IH0pO1xuICAgICAgICBjb25zdCB1c2VSYWRpb0lucHV0ID0gKHsgdGFnIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZVJhZGlvSW5wdXRQcm9wcyA9IChwcm9wcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0YWcgPT0gXCJpbnB1dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jaGVja2VkID0gY2hlY2tlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1jaGVja2VkXCJdID0gY2hlY2tlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQoeyB0YWcgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh1c2VNZXJnZWRQcm9wcygpKHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcygodXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMoe30pKSksIHByb3BzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1c2VSYWRpb0lucHV0UHJvcHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVzZVJhZGlvTGFiZWwgPSB1c2VDYWxsYmFjaygoeyB0YWcgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXNlUmFkaW9MYWJlbFByb3BzID0gKHByb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50KHsgdGFnIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHt9LCBwcm9wcykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXNlUmFkaW9MYWJlbFByb3BzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50XSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VSYWRpb0lucHV0LFxuICAgICAgICAgICAgdXNlUmFkaW9MYWJlbCxcbiAgICAgICAgfTtcbiAgICB9LCBbYnlOYW1lLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlUmFkaW8sXG4gICAgICAgIHVzZVJhZGlvR3JvdXBQcm9wcyxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxuICAgICAgICBnZXRJbmRleDogdXNlQ2FsbGJhY2soKHZhbHVlKSA9PiB7IHJldHVybiBieU5hbWUuY3VycmVudC5nZXQodmFsdWUpOyB9LCBbYnlOYW1lXSlcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXJhZGlvLWdyb3VwLmpzLm1hcCIsImltcG9ydCB7IHVzZUNoaWxkTWFuYWdlciwgdXNlTWVyZ2VkUHJvcHMsIHVzZVJhbmRvbUlkLCB1c2VSZWZFbGVtZW50LCB1c2VTdGF0ZSwgdXNlVGltZW91dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VDaGlsZEZsYWcgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgZmluZEZpcnN0Rm9jdXNhYmxlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWZvY3VzLXRyYXBcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VUb2FzdHMoe30pIHtcbiAgICAvLyBcIlBvaW50ZXJcIiB0byB3aGF0ZXZlciBpbmRleCB0b2FzdCBpcyBjdXJyZW50bHkgYmVpbmcgc2hvd24uXG4gICAgLy8gRS5nLiBpdCdzIDAgd2hlbiB0aGUgZmlyc3QgdG9hc3QgaXMgc2hvd24sIHRoZW4gd2hlbiBkaXNtaXNzZWQsIGl0IGJlY29tZXMgMS5cbiAgICAvLyBXaGVuIHRoZSBzZWNvbmQgdG9hc3QgaXMgc2hvd24sIGl0IHN0YXlzIGF0IDEgdW50aWwgZGlzbWlzc2VkLCB3aGVuIGl0IHRoZW4gYmVjb21lcyAyLCBldGMuXG4gICAgLy8gQmVjYXVzZSB0b2FzdHMgY2FuIHBvdGVudGlhbGx5IGJlIGRpc21pc3NlZCBvdXQgb2Ygb3JkZXIsIHRoaXMgcmVwcmVzZW50cyB0aGUgXCJvbGRlc3RcIiB0b2FzdCB0aGF0IHN0aWxsIGhhc24ndCBiZWVuIGRpc21pc3NlZCxcbiAgICAvLyBldmVuIGlmIFwieW91bmdlclwiIG9uZXMgaGF2ZS5cbiAgICBjb25zdCBbYWN0aXZlVG9hc3RJbmRleCwgc2V0QWN0aXZlVG9hc3RJbmRleCwgZ2V0QWN0aXZlVG9hc3RJbmRleF0gPSB1c2VTdGF0ZSgtMSk7XG4gICAgY29uc3QgW3BvbGl0ZW5lc3MsIHNldFBvbGl0ZW5lc3NdID0gdXNlU3RhdGUoXCJwb2xpdGVcIik7XG4gICAgY29uc3QgeyBlbGVtZW50LCBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcbiAgICBjb25zdCB7IGluZGljZXNCeUVsZW1lbnQsIG1hbmFnZWRDaGlsZHJlbiwgbW91bnRlZENoaWxkcmVuOiB0b2FzdFF1ZXVlLCB1c2VNYW5hZ2VkQ2hpbGQsIGdldE1vdW50SW5kZXggfSA9IHVzZUNoaWxkTWFuYWdlcigpO1xuICAgIC8vIEFueSB0aW1lIGEgbmV3IHRvYXN0IG1vdW50cywgdXBkYXRlIG91ciBib3R0b21tb3N0VG9hc3RJbmRleCB0byBwb2ludCB0byBpdCBpZiBuZWNlc3NhcnlcbiAgICAvLyAoXCJuZWNlc3NhcnlcIiBqdXN0IG1lYW5pbmcgaWYgaXQncyB0aGUgZmlyc3QgdG9hc3QgZXZlciBvciBhbGwgcHJpb3IgdG9hc3RzIGhhdmUgYmVlbiBkaXNtaXNzZWQpXG4gICAgY29uc3Qgb25BbnlUb2FzdE1vdW50ZWQgPSB1c2VDYWxsYmFjaygoaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IGJvdHRvbSA9IGdldEFjdGl2ZVRvYXN0SW5kZXgoKTtcbiAgICAgICAgd2hpbGUgKGJvdHRvbSA8IHRvYXN0UXVldWUubGVuZ3RoICYmIChib3R0b20gPCAwIHx8IHRvYXN0UXVldWVbYm90dG9tXT8uZGlzbWlzc2VkKSkge1xuICAgICAgICAgICAgKytib3R0b207XG4gICAgICAgIH1cbiAgICAgICAgc2V0QWN0aXZlVG9hc3RJbmRleChib3R0b20pO1xuICAgIH0sIFtzZXRBY3RpdmVUb2FzdEluZGV4XSk7XG4gICAgLy8gQW55IHRpbWUgYSB0b2FzdCBpcyBkaXNtaXNzZWQsIHVwZGF0ZSBvdXIgYm90dG9tbW9zdFRvYXN0SW5kZXggdG8gcG9pbnQgdG8gdGhlIG5leHQgdG9hc3QgaW4gdGhlIHF1ZXVlLCBpZiBvbmUgZXhpc3RzLlxuICAgIGNvbnN0IG9uQW55VG9hc3REaXNtaXNzZWQgPSB1c2VDYWxsYmFjaygoaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IGJvdHRvbSA9IGdldEFjdGl2ZVRvYXN0SW5kZXgoKTtcbiAgICAgICAgd2hpbGUgKGJvdHRvbSA8IHRvYXN0UXVldWUubGVuZ3RoICYmIChib3R0b20gPCAwIHx8IGJvdHRvbSA9PT0gaW5kZXggfHwgdG9hc3RRdWV1ZVtib3R0b21dPy5kaXNtaXNzZWQpKSB7XG4gICAgICAgICAgICArK2JvdHRvbTtcbiAgICAgICAgfVxuICAgICAgICBzZXRBY3RpdmVUb2FzdEluZGV4KGJvdHRvbSk7XG4gICAgICAgIGlmIChnZXRFbGVtZW50KCk/LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgICAgICAgdG9hc3RRdWV1ZVtib3R0b21dPy5mb2N1cygpO1xuICAgIH0sIFtzZXRBY3RpdmVUb2FzdEluZGV4XSk7XG4gICAgLy8gQW55IHRpbWUgdGhlIGluZGV4IHBvaW50aW5nIHRvIHRoZSBjdXJyZW50bHktc2hvd2luZyB0b2FzdCBjaGFuZ2VzLFxuICAgIC8vIHVwZGF0ZSB0aGUgcmVsZXZhbnQgY2hpbGRyZW4gYW5kIGxldCB0aGVtIGtub3cgdGhhdCB0aGV5J3JlIG5vdyBlaXRoZXIgYWN0aXZlIG9yIGRpc21pc3NlZC5cbiAgICB1c2VDaGlsZEZsYWcoYWN0aXZlVG9hc3RJbmRleCwgdG9hc3RRdWV1ZS5sZW5ndGgsICgoaSwgc2V0KSA9PiB7XG4gICAgICAgIGlmIChzZXQpXG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChpIDw9IGdldEFjdGl2ZVRvYXN0SW5kZXgoKSk7XG4gICAgICAgIHRvYXN0UXVldWVbaV0/LnNldFN0YXR1cyhzZXQgPyBcImFjdGl2ZVwiIDogKGkgPCBnZXRBY3RpdmVUb2FzdEluZGV4KCkgPyBcImRpc21pc3NlZFwiIDogXCJwZW5kaW5nXCIpKTtcbiAgICB9KSk7XG4gICAgY29uc3QgdXNlVG9hc3QgPSB1c2VDYWxsYmFjaygoeyBwb2xpdGVuZXNzLCB0aW1lb3V0IH0pID0+IHtcbiAgICAgICAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzLCBnZXRTdGF0dXNdID0gdXNlU3RhdGUoXCJwZW5kaW5nXCIpO1xuICAgICAgICBjb25zdCBkaXNtaXNzZWQgPSAoc3RhdHVzID09PSBcImRpc21pc3NlZFwiKTtcbiAgICAgICAgY29uc3QgZGlzbWlzcyA9IHVzZUNhbGxiYWNrKCgpID0+IHsgc2V0U3RhdHVzKFwiZGlzbWlzc2VkXCIpOyB9LCBbXSk7XG4gICAgICAgIGNvbnN0IHsgcmFuZG9tSWQ6IHRvYXN0SWQgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcInRvYXN0LVwiIH0pO1xuICAgICAgICAvL2NvbnN0IFt0b2FzdElkLCBzZXRUb2FzdElkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoXCJ0b2FzdC1cIikpO1xuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBzZXRQb2xpdGVuZXNzKHBvbGl0ZW5lc3MgPz8gXCJwb2xpdGVcIik7IH0sIFtwb2xpdGVuZXNzXSk7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RGb2N1c2FibGUgPSBmaW5kRmlyc3RGb2N1c2FibGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZmlyc3RGb2N1c2FibGU/LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCB1c2VNYW5hZ2VkQ2hpbGRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlTWFuYWdlZENoaWxkKHsgZGlzbWlzc2VkLCBpbmRleDogdG9hc3RJZCwgc2V0U3RhdHVzLCBmb2N1cyB9KTtcbiAgICAgICAgY29uc3QgaXNBY3RpdmUgPSAoc3RhdHVzID09PSBcImFjdGl2ZVwiKTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIG9uQW55VG9hc3RNb3VudGVkKGdldE1vdW50SW5kZXgodG9hc3RJZCkpO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGlzbWlzc2VkKVxuICAgICAgICAgICAgICAgIG9uQW55VG9hc3REaXNtaXNzZWQoZ2V0TW91bnRJbmRleCh0b2FzdElkKSk7XG4gICAgICAgIH0sIFtkaXNtaXNzZWRdKTtcbiAgICAgICAgdXNlVGltZW91dCh7XG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmUpXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhcImRpc21pc3NlZFwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmlnZ2VySW5kZXg6IGlzQWN0aXZlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgZ2V0U3RhdHVzLFxuICAgICAgICAgICAgZGlzbWlzcyxcbiAgICAgICAgICAgIHVzZVRvYXN0UHJvcHM6IGZ1bmN0aW9uICh7IC4uLnByb3BzIH0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh1c2VNYW5hZ2VkQ2hpbGRQcm9wcyh7fSksIHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgZnVuY3Rpb24gdXNlVG9hc3RDb250YWluZXJQcm9wcyh7IHJvbGUsIFwiYXJpYS1saXZlXCI6IGFyaWFMaXZlLCBcImFyaWEtcmVsZXZhbnRcIjogYXJpYVJlbGV2YW50LCAuLi5wcm9wcyB9KSB7XG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHVzZVJlZkVsZW1lbnRQcm9wcyh7IGNsYXNzOiBcInRvYXN0cy1jb250YWluZXJcIiwgcm9sZTogXCJzdGF0dXNcIiwgXCJhcmlhLWxpdmVcIjogcG9saXRlbmVzcyA/PyBhcmlhTGl2ZSA/PyBcInBvbGl0ZVwiLCBcImFyaWEtcmVsZXZhbnRcIjogYXJpYVJlbGV2YW50ID8/IFwiYWRkaXRpb25zXCIgfSksIHByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdXNlVG9hc3QsIHVzZVRvYXN0Q29udGFpbmVyUHJvcHMgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS10b2FzdHMuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IGZvcndhcmRSZWYsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlVGltZW91dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZEVsZW1lbnRSZWYoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGZvcndhcmRSZWYoY29tcG9uZW50KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VQc2V1ZG9BY3RpdmUoeyBcImRhdGEtcHNldWRvLWFjdGl2ZVwiOiBhY3RpdmUsIC4uLnByb3BzIH0pIHtcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzTmFtZTogY2xzeCgoYWN0aXZlID09IHRydWUgfHwgYWN0aXZlID09IFwidHJ1ZVwiKSAmJiBcImFjdGl2ZVwiKSB9LCBwcm9wcyk7XG59XG5jb25zdCBTcGlubmVyRGVsYXlDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgxMDAwKTtcbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlU3Bpbm5lckRlbGF5KHsgY2hpbGRyZW4sIHRpbWVvdXQgfSkge1xuICAgIHJldHVybiBoKFNwaW5uZXJEZWxheUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRpbWVvdXQgfSwgY2hpbGRyZW4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNwaW5uZXJEZWxheShwZW5kaW5nKSB7XG4gICAgY29uc3QgW3Nob3dTcGlubmVyLCBzZXRTaG93U3Bpbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICAgICAgICBzZXRTaG93U3Bpbm5lcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LCBbcGVuZGluZ10pO1xuICAgIHVzZVRpbWVvdXQoe1xuICAgICAgICB0aW1lb3V0OiB1c2VDb250ZXh0KFNwaW5uZXJEZWxheUNvbnRleHQpLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgc2V0U2hvd1NwaW5uZXIocGVuZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJJbmRleDogcGVuZGluZ1xuICAgIH0pO1xuICAgIHJldHVybiBzaG93U3Bpbm5lcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BzLmpzLm1hcCIsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQXJpYUFjY29yZGlvbiB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IENvbGxhcHNlIH0gZnJvbSBcInByZWFjdC10cmFuc2l0aW9uXCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi4vcHJvcHNcIjtcbmNvbnN0IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5leHBvcnQgY29uc3QgQWNjb3JkaW9uID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQWNjb3JkaW9uKHsgZXhwYW5kZWRJbmRleCwgc2V0RXhwYW5kZWRJbmRleCwgY2hpbGRyZW4sIC4uLnByb3BzIH0sIHJlZikge1xuICAgIGNvbnN0IHsgdXNlQXJpYUFjY29yZGlvblNlY3Rpb24gfSA9IHVzZUFyaWFBY2NvcmRpb24oeyBleHBhbmRlZEluZGV4LCBzZXRFeHBhbmRlZEluZGV4IH0pO1xuICAgIHJldHVybiAoaChcImRpdlwiLCB7IC4uLnVzZU1lcmdlZFByb3BzKCkoeyByZWYsIGNsYXNzTmFtZTogXCJhY2NvcmRpYW5cIiB9LCBwcm9wcykgfSxcbiAgICAgICAgaChVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uIH0sIGNoaWxkcmVuKSkpO1xufSk7XG5leHBvcnQgY29uc3QgQWNjb3JkaW9uU2VjdGlvbiA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEFjY29yZGlvblNlY3Rpb24oeyBpbmRleCwgb3BlbiwgaGVhZGVyLCBoZWFkZXJMZXZlbCwgY2hpbGRyZW4sIFRyYW5zaXRpb24sIC4uLnByb3BzIH0sIHJlZikge1xuICAgIGNvbnN0IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uID0gdXNlQ29udGV4dChVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IHsgZXhwYW5kZWQsIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyLCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHkgfSA9IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uKHsgaW5kZXgsIG9wZW4gfSk7XG4gICAgY29uc3QgeyB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzIH0gPSB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlcih7IHRhZzogXCJidXR0b25cIiB9KTtcbiAgICBjb25zdCB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzIH0gPSB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHkoKTtcbiAgICBUcmFuc2l0aW9uID8/PSBDb2xsYXBzZTtcbiAgICBoZWFkZXJMZXZlbCA/Pz0gMjtcbiAgICBjb25zb2xlLmxvZyhgJHtpbmRleH06ICR7ZXhwYW5kZWQ/LnRvU3RyaW5nKCl9YCk7XG4gICAgY29uc3QgaGVhZGVyQnV0dG9uUHJvcHMgPSB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzKHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3M6IGNsc3goXCJhY2NvcmRpb24tYnV0dG9uXCIsICFleHBhbmRlZCA/IFwiIGNvbGxhcHNlZFwiIDogXCJcIikgfSk7XG4gICAgY29uc3QgaGVhZGVyUHJvcHMgPSAoeyBjbGFzczogXCJhY2NvcmRpb24taGVhZGVyXCIsIGNoaWxkcmVuOiBoKFwiYnV0dG9uXCIsIHsgLi4uaGVhZGVyQnV0dG9uUHJvcHMgfSwgaGVhZGVyKSB9KTtcbiAgICBjb25zdCBoZWFkZXJKc3ggPSBoZWFkZXJMZXZlbCA+PSAxICYmIGhlYWRlckxldmVsIDw9IDYgPyBoKGBoJHtoZWFkZXJMZXZlbH1gLCBoZWFkZXJQcm9wcykgOiBoKFwiZGl2XCIsIHVzZU1lcmdlZFByb3BzKCkoaGVhZGVyUHJvcHMsIHsgcm9sZTogXCJoZWFkaW5nXCIsIFwiYXJpYS1sZXZlbFwiOiBgJHtoZWFkZXJMZXZlbH1gIH0pKTtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyAuLi57IHJlZiwgY2xhc3M6IFwiYWNjb3JkaW9uLWl0ZW1cIiB9IH0sXG4gICAgICAgIGhlYWRlckpzeCxcbiAgICAgICAgaChUcmFuc2l0aW9uLCB7IG9wZW46IGV4cGFuZGVkLCAuLi51c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHByb3BzLCB7IGNsYXNzOiBcIlwiIH0pKSB9LFxuICAgICAgICAgICAgaChcImRpdlwiLCBudWxsLFxuICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJhY2NvcmRpb24tYm9keVwiIH0sIGNoaWxkcmVuKSkpKSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY29yZGlvbi5qcy5tYXAiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmLCB1c2VTcGlubmVyRGVsYXkgfSBmcm9tIFwiLi4vcHJvcHNcIjtcbmltcG9ydCB7IEZhZGUgfSBmcm9tIFwicHJlYWN0LXRyYW5zaXRpb24vZmFkZVwiO1xuaW1wb3J0IHsgU3dhcHBhYmxlIH0gZnJvbSBcInByZWFjdC10cmFuc2l0aW9uXCI7XG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYVByb2dyZXNzQmFyKHsgdGFnLCBtYXgsIHZhbHVlLCB2YWx1ZVRleHQgfSkge1xuICAgIC8vY29uc3QgeyBpbnB1dElkLCBsYWJlbElkLCB1c2VHZW5lcmljTGFiZWxJbnB1dCwgdXNlR2VuZXJpY0xhYmVsTGFiZWwsIHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMsIHVzZVJlZmVyZW5jZWRMYWJlbElkUHJvcHMgfSA9IHVzZUdlbmVyaWNMYWJlbCh7IGlucHV0UHJlZml4OiBcInByb2dyZXNzYmFyLVwiLCBsYWJlbFByZWZpeDogXCJwcm9ncmVzc2Jhci1yZWZlcmVuY2UtXCIgfSk7XG4gICAgY29uc3QgeyBpZDogcHJvZ3Jlc3NCYXJJZCwgZ2V0SWQsIHVzZVJhbmRvbUlkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJwcm9ncmVzc2Jhci1cIiB9KTtcbiAgICBmdW5jdGlvbiB1c2VQcm9ncmVzc1Byb3BzKHsgXCJhcmlhLXZhbHVlbWF4XCI6IGFyaWFWYWx1ZU1heCwgXCJhcmlhLXZhbHVlbm93XCI6IGFyaWFWYWx1ZU5vdywgXCJhcmlhLXZhbHVldGV4dFwiOiBhcmlhVmFsdWVUZXh0LCByb2xlLCAuLi5wIH0pIHtcbiAgICAgICAgY29uc3QgZXh0cmFQcm9wcyA9IHRhZyA9PT0gXCJwcm9ncmVzc1wiID9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICh2YWx1ZSA/PyB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIFwiYXJpYS12YWx1ZW5vd1wiOiB2YWx1ZSA9PSBudWxsID8gdW5kZWZpbmVkIDogYCR7dmFsdWV9YCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiYXJpYS12YWx1ZW1heFwiOiBtYXggPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGAke21heH1gLFxuICAgICAgICAgICAgICAgICAgICBcImFyaWEtdmFsdWV0ZXh0XCI6IHZhbHVlVGV4dCA9PSBudWxsID8gdW5kZWZpbmVkIDogYCR7dmFsdWVUZXh0fWAsXG4gICAgICAgICAgICAgICAgICAgIFwiYXJpYS12YWx1ZW5vd1wiOiB2YWx1ZSA9PSBudWxsID8gdW5kZWZpbmVkIDogYCR7dmFsdWV9YCxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJwcm9ncmVzc2JhclwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHVzZVJhbmRvbUlkUHJvcHModXNlTWVyZ2VkUHJvcHMoKShleHRyYVByb3BzLCBwKSk7XG4gICAgfVxuICAgIGNvbnN0IHVzZVJlZmVyZW5jZWRFbGVtZW50ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlUmVmZXJlbmNlZEVsZW1lbnQoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHVzZVJlZmVyZW5jZWRQcm9wcyhwcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIHVzZVJlZmVyZW5jZWRJZFByb3BzKFwiYXJpYS1jb250cm9sc1wiKShwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdXNlUmVmZXJlbmNlZFByb3BzIH07XG4gICAgfSwgW3VzZVJlZmVyZW5jZWRJZFByb3BzXSk7XG4gICAgcmV0dXJuIHsgdXNlUHJvZ3Jlc3NQcm9wcywgdXNlUmVmZXJlbmNlZEVsZW1lbnQgfTtcbn1cbmV4cG9ydCBjb25zdCBQcm9ncmVzc0FzQ2hpbGRDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuY29uc3QgUHJvZ3Jlc3NNYXhDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuY29uc3QgUHJvZ3Jlc3NWYWx1ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5jb25zdCBQcm9ncmVzc1ZhbHVlVGV4dENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG4vKipcbiAqIEEgcHJvZ3Jlc3MgYmFyIGNhbiBlaXRoZXIgdGFrZSBpdHMgdmFsdWUgJiBtYXggYXJndW1lbnRzIGRpcmVjdGx5LFxuICogb3IgaGF2ZSB0aGVtIHByb3ZpZGVkIGJ5IGEgcGFyZW50IHZpYSB2YXJpb25zIENvbnRleHQgb2JqZWN0cy5cbiAqXG4gKiBQcm9wcyB3aWxsIGJlIHByaW9yaXRpemVkIG92ZXIgY29udGV4dCBpZiBib3RoIGFyZSBnaXZlbi5cbiAqIEBwYXJhbSBwYXJhbTBcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQcm9ncmVzc0xpbmVhcih7IGNvbG9yLCBtYXg6IG1heFByb3AsIHZhbHVlOiB2YWx1ZVByb3AsIHZhbHVlVGV4dDogdmFsdWVUZXh0UHJvcCwgc3RyaXBlZCwgdmFyaWFudCwgLi4ucmVzdCB9KSB7XG4gICAgbGV0IHZhbHVlID0gKHVzZUNvbnRleHQoUHJvZ3Jlc3NWYWx1ZUNvbnRleHQpKTtcbiAgICBsZXQgbWF4ID0gdXNlQ29udGV4dChQcm9ncmVzc01heENvbnRleHQpO1xuICAgIGxldCB2YWx1ZVRleHQgPSB1c2VDb250ZXh0KFByb2dyZXNzVmFsdWVUZXh0Q29udGV4dCk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHZhbHVlID0gdmFsdWVQcm9wO1xuICAgIGlmIChtYXggPT09IHVuZGVmaW5lZClcbiAgICAgICAgbWF4ID0gbWF4UHJvcDtcbiAgICBpZiAodmFsdWVUZXh0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHZhbHVlVGV4dCA9IHZhbHVlVGV4dFByb3A7XG4gICAgY29uc3QgcHJvdmlkZVBhcmVudFdpdGhIb29rID0gdXNlQ29udGV4dChQcm9ncmVzc0FzQ2hpbGRDb250ZXh0KTtcbiAgICBjb25zdCB7IHVzZVByb2dyZXNzUHJvcHMsIHVzZVJlZmVyZW5jZWRFbGVtZW50IH0gPSB1c2VBcmlhUHJvZ3Jlc3NCYXIoeyB2YWx1ZSwgdmFsdWVUZXh0LCBtYXgsIHRhZzogXCJwcm9ncmVzc1wiIH0pO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHByb3ZpZGVQYXJlbnRXaXRoSG9vaz8uKHVzZVJlZmVyZW5jZWRFbGVtZW50KTsgfSwgW3VzZVJlZmVyZW5jZWRFbGVtZW50LCBwcm92aWRlUGFyZW50V2l0aEhvb2tdKTtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyAuLi51c2VNZXJnZWRQcm9wcygpKHsgY2xhc3NOYW1lOiBjbHN4KFwicHJvZ3Jlc3NcIiwgYGJnLSR7Y29sb3IgPz8gXCJwcmltYXJ5XCJ9YCkgfSwgcmVzdCkgfSxcbiAgICAgICAgaChcInByb2dyZXNzXCIsIHsgLi4udXNlUHJvZ3Jlc3NQcm9wcyh7IGNsYXNzTmFtZTogXCJwcm9ncmVzcy1iYXJcIiB9KSB9KSkpO1xufVxuLy8gOilcbmNvbnN0IFIgPSAoKG5ldyBEYXRlKCkpLmdldERhdGUoKSAlIDIpO1xuZnVuY3Rpb24gQ2hlY2soKSB7XG4gICAgcmV0dXJuIChoKFwiaVwiLCB7IGNsYXNzOiBcImJpIGJpLWNoZWNrIHRleHQtc3VjY2Vzc1wiIH0pKTtcbn1cbmZ1bmN0aW9uIENyb3NzKCkge1xuICAgIHJldHVybiAoaChcImlcIiwgeyBjbGFzczogXCJiaSBiaS14IHRleHQtd2FybmluZ1wiIH0pKTtcbn1cbmV4cG9ydCBjb25zdCBQcm9ncmVzc0NpcmN1bGFyID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gKHsgbW9kZSwgY29sb3JGaWxsLCBjaGlsZHJlblBvc2l0aW9uLCBjaGlsZHJlbiwgY29sb3IsIC4uLnAgfSwgcmVmKSB7XG4gICAgY29uc3QgcHJvdmlkZVBhcmVudFdpdGhIb29rID0gdXNlQ29udGV4dChQcm9ncmVzc0FzQ2hpbGRDb250ZXh0KTtcbiAgICBjb25zdCB7IHVzZVByb2dyZXNzUHJvcHMsIHVzZVJlZmVyZW5jZWRFbGVtZW50IH0gPSB1c2VBcmlhUHJvZ3Jlc3NCYXIoeyB2YWx1ZTogbnVsbCwgdmFsdWVUZXh0OiB1bmRlZmluZWQsIG1heDogdW5kZWZpbmVkLCB0YWc6IFwiZGl2XCIgfSk7XG4gICAgLy91c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBwcm92aWRlUGFyZW50V2l0aEhvb2s/Lih1c2VSZWZlcmVuY2VkRWxlbWVudCkgfSwgW3VzZVJlZmVyZW5jZWRFbGVtZW50LCBwcm92aWRlUGFyZW50V2l0aEhvb2tdKVxuICAgIGNvbnN0IHsgdXNlUmVmZXJlbmNlZFByb3BzIH0gPSB1c2VSZWZlcmVuY2VkRWxlbWVudCgpO1xuICAgIGNvbnN0IHNob3dTcGlubmVyID0gdXNlU3Bpbm5lckRlbGF5KG1vZGUgPT09IFwicGVuZGluZ1wiKTtcbiAgICAvL2NvbnN0IFtzcGlubmVyU2hvd0NvdW50LCBzZXRTcGlubmVyU2hvd0NvdW50XSA9IHVzZVN0YXRlKDApO1xuICAgIC8vdXNlRWZmZWN0KCgpID0+IHsgc2V0U3Bpbm5lclNob3dDb3VudChzID0+ICsrcykgfSwgW3Nob3dTcGlubmVyXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHsgc2V0U2hvd25TdGF0dXNMb25nRW5vdWdoKGZhbHNlKTsgfSwgW21vZGVdKTtcbiAgICBjb25zdCBbc2hvd25TdGF0dXNMb25nRW5vdWdoLCBzZXRTaG93blN0YXR1c0xvbmdFbm91Z2hdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHVzZVRpbWVvdXQoe1xuICAgICAgICBjYWxsYmFjazogKCkgPT4geyBpZiAobW9kZSA9PSBcImZhaWxlZFwiIHx8IChtb2RlID09IFwic3VjY2VlZGVkXCIpKVxuICAgICAgICAgICAgc2V0U2hvd25TdGF0dXNMb25nRW5vdWdoKHRydWUpOyB9LFxuICAgICAgICB0aW1lb3V0OiAxMDAwLFxuICAgICAgICB0cmlnZ2VySW5kZXg6IG1vZGVcbiAgICB9KTtcbiAgICBjb25zdCBwcm9ncmVzc0VsZW1lbnQgPSAoaChcImRpdlwiLCB7IC4uLnVzZU1lcmdlZFByb3BzKCkodXNlUHJvZ3Jlc3NQcm9wcyh7IHJlZiwgY2xhc3NOYW1lOiBjbHN4KFwiY2lyY3VsYXItcHJvZ3Jlc3MtY29udGFpbmVyXCIpIH0pLCBwKSB9LFxuICAgICAgICBoKFN3YXBwYWJsZSwgbnVsbCxcbiAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2lyY3VsYXItcHJvZ3Jlc3Mtc3dhcHBhYmxlXCIgfSxcbiAgICAgICAgICAgICAgICBoKEZhZGUsIHsgb3BlbjogbW9kZSA9PT0gXCJwZW5kaW5nXCIgJiYgc2hvd1NwaW5uZXIgfSxcbiAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeChcImNpcmN1bGFyLXByb2dyZXNzXCIsIGBjaXJjdWxhci1wcm9ncmVzcy0ke2NvbG9yID8/IFwicHJpbWFyeVwifWAsIGNvbG9yRmlsbCA9PSBcImZvcmVncm91bmRcIiAmJiBcImludmVyc2UtZmlsbFwiLCBjb2xvckZpbGwgPT09IFwiZm9yZWdyb3VuZC1vbmx5XCIgJiYgXCJuby1maWxsXCIpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCBudWxsKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCBudWxsKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCBudWxsKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCBudWxsKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCBudWxsKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCBudWxsKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCBudWxsKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCBudWxsKSkpKSxcbiAgICAgICAgICAgICAgICBoKEZhZGUsIHsgb3BlbjogIXNob3duU3RhdHVzTG9uZ0Vub3VnaCAmJiBtb2RlID09PSBcInN1Y2NlZWRlZFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoQ2hlY2ssIG51bGwpKSksXG4gICAgICAgICAgICAgICAgaChGYWRlLCB7IG9wZW46ICFzaG93blN0YXR1c0xvbmdFbm91Z2ggJiYgbW9kZSA9PT0gXCJmYWlsZWRcIiB9LFxuICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBoKENyb3NzLCBudWxsKSkpKSkpKTtcbiAgICBjaGlsZHJlblBvc2l0aW9uID8/PSBcImFmdGVyXCI7XG4gICAgcmV0dXJuIChoKEZyYWdtZW50LCBudWxsLFxuICAgICAgICBjaGlsZHJlblBvc2l0aW9uID09IFwiYmVmb3JlXCIgJiYgcHJvZ3Jlc3NFbGVtZW50LFxuICAgICAgICBjaGlsZHJlbiAmJiBjcmVhdGVFbGVtZW50KGNoaWxkcmVuLnR5cGUsIHVzZU1lcmdlZFByb3BzKCkoeyBjaGlsZHJlbjogY2hpbGRyZW5Qb3NpdGlvbiA9PT0gXCJjaGlsZFwiID8gcHJvZ3Jlc3NFbGVtZW50IDogdW5kZWZpbmVkLCByZWY6IGNoaWxkcmVuLnJlZiB9LCB1c2VSZWZlcmVuY2VkUHJvcHMoY2hpbGRyZW4ucHJvcHMpKSksXG4gICAgICAgIGNoaWxkcmVuUG9zaXRpb24gPT0gXCJhZnRlclwiICYmIHByb2dyZXNzRWxlbWVudCkpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5lYXIuanMubWFwIiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmNvbnN0IERlZmF1bHRGaWxsU3R5bGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcImZpbGxcIik7XG5jb25zdCBEZWZhdWx0Q29sb3JTdHlsZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KFwicHJpbWFyeVwiKTtcbmNvbnN0IERlZmF1bHRTaXplQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoXCJtZFwiKTtcbmNvbnN0IERlZmF1bHREaXNhYmxlZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KGZhbHNlKTtcbmV4cG9ydCBjb25zdCBQcm92aWRlRGVmYXVsdEJ1dHRvbkZpbGwgPSBtZW1vKGZ1bmN0aW9uIFByb3ZpZGVEZWZhdWx0QnV0dG9uRmlsbCh7IHZhbHVlLCBjaGlsZHJlbiB9KSB7IHJldHVybiBoKERlZmF1bHRGaWxsU3R5bGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSB9LCBjaGlsZHJlbik7IH0pO1xuZXhwb3J0IGNvbnN0IFByb3ZpZGVEZWZhdWx0QnV0dG9uQ29sb3IgPSBtZW1vKGZ1bmN0aW9uIFByb3ZpZGVEZWZhdWx0QnV0dG9uQ29sb3IoeyB2YWx1ZSwgY2hpbGRyZW4gfSkgeyByZXR1cm4gaChEZWZhdWx0Q29sb3JTdHlsZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHZhbHVlIH0sIGNoaWxkcmVuKTsgfSk7XG5leHBvcnQgY29uc3QgUHJvdmlkZURlZmF1bHRCdXR0b25TaXplID0gbWVtbyhmdW5jdGlvbiBQcm92aWRlRGVmYXVsdEJ1dHRvblNpemUoeyB2YWx1ZSwgY2hpbGRyZW4gfSkgeyByZXR1cm4gaChEZWZhdWx0U2l6ZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHZhbHVlIH0sIGNoaWxkcmVuKTsgfSk7XG5leHBvcnQgY29uc3QgUHJvdmlkZURlZmF1bHRCdXR0b25EaXNhYmxlZCA9IG1lbW8oZnVuY3Rpb24gUHJvdmlkZURlZmF1bHRCdXR0b25EaXNhYmxlZCh7IHZhbHVlLCBjaGlsZHJlbiB9KSB7IHJldHVybiBoKERlZmF1bHREaXNhYmxlZENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHZhbHVlIH0sIGNoaWxkcmVuKTsgfSk7XG5leHBvcnQgZnVuY3Rpb24gdXNlQnV0dG9uRmlsbFZhcmlhbnQocHJvdmlkZWRWYWx1ZSkge1xuICAgIGNvbnN0IGRlZmF1bHRGaWxsID0gdXNlQ29udGV4dChEZWZhdWx0RmlsbFN0eWxlQ29udGV4dCk7XG4gICAgcmV0dXJuIHByb3ZpZGVkVmFsdWUgPz8gZGVmYXVsdEZpbGw7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlQnV0dG9uQ29sb3JWYXJpYW50KHByb3ZpZGVkVmFsdWUpIHtcbiAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSB1c2VDb250ZXh0KERlZmF1bHRDb2xvclN0eWxlQ29udGV4dCk7XG4gICAgcmV0dXJuIHByb3ZpZGVkVmFsdWUgPz8gZGVmYXVsdENvbG9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJ1dHRvblNpemUocHJvdmlkZWRWYWx1ZSkge1xuICAgIGNvbnN0IGRlZmF1bHRTaXplID0gdXNlQ29udGV4dChEZWZhdWx0U2l6ZUNvbnRleHQpO1xuICAgIHJldHVybiBwcm92aWRlZFZhbHVlID8/IGRlZmF1bHRTaXplO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJ1dHRvbkRpc2FibGVkKHByb3ZpZGVkVmFsdWUpIHtcbiAgICBjb25zdCBkZWZhdWx0RGlzYWJsZWQgPSB1c2VDb250ZXh0KERlZmF1bHREaXNhYmxlZENvbnRleHQpO1xuICAgIHJldHVybiBwcm92aWRlZFZhbHVlID8/IGRlZmF1bHREaXNhYmxlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VCdXR0b25TdHlsZXMocCkge1xuICAgIGxldCB7IGNvbG9yVmFyaWFudCwgc2l6ZSwgZmlsbFZhcmlhbnQsIGRpc2FibGVkIH0gPSBwO1xuICAgIGNvbG9yVmFyaWFudCA9IHVzZUJ1dHRvbkNvbG9yVmFyaWFudChjb2xvclZhcmlhbnQpO1xuICAgIHNpemUgPSB1c2VCdXR0b25TaXplKHNpemUpO1xuICAgIGZpbGxWYXJpYW50ID0gdXNlQnV0dG9uRmlsbFZhcmlhbnQoZmlsbFZhcmlhbnQpO1xuICAgIGRpc2FibGVkID0gdXNlQnV0dG9uRGlzYWJsZWQoZGlzYWJsZWQpO1xuICAgIGNvbnN0IHVzZUJ1dHRvblN0eWxlc1Byb3BzID0gKHByb3BzKSA9PiB1c2VNZXJnZWRQcm9wcygpKHsgXCJhcmlhLWRpc2FibGVkXCI6IGRpc2FibGVkID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQsIGNsYXNzTmFtZTogY2xzeChkaXNhYmxlZCAmJiBcImRpc2FibGVkXCIsIFwiYnRuXCIsIGBidG4tJHtmaWxsVmFyaWFudCA9PSBcIm91dGxpbmVcIiA/IGBvdXRsaW5lLWAgOiBgYH0ke2NvbG9yVmFyaWFudH1gLCBgYnRuLSR7c2l6ZX1gLCBkaXNhYmxlZCAmJiBcImRpc2FibGVkXCIpIH0sIHByb3BzKTtcbiAgICByZXR1cm4geyBjb2xvclZhcmlhbnQsIHNpemUsIGZpbGxWYXJpYW50LCBkaXNhYmxlZCwgdXNlQnV0dG9uU3R5bGVzUHJvcHMgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRzLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VBcmlhQnV0dG9uIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWJ1dHRvblwiO1xuaW1wb3J0IHsgdXNlQXN5bmNIYW5kbGVyIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgUHJvZ3Jlc3NDaXJjdWxhciB9IGZyb20gXCIuLi9wcm9ncmVzc1wiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUJ1dHRvblN0eWxlcyB9IGZyb20gXCIuL2RlZmF1bHRzXCI7XG5mdW5jdGlvbiBCdXR0b25SKHAsIHJlZikge1xuICAgIGlmIChwLnRhZz8udG9Mb3dlckNhc2UoKSA9PT0gXCJhXCIpXG4gICAgICAgIHJldHVybiBoKEFuY2hvckJ1dHRvbiwgeyByZWY6IHJlZiwgLi4ucCB9KTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBoKEJ1dHRvbkJ1dHRvbiwgeyByZWY6IHJlZiwgLi4ucCB9KTtcbn1cbmNvbnN0IEFuY2hvckJ1dHRvbiA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEFuY2hvckJ1dHRvbihwLCByZWYpIHtcbiAgICBsZXQgeyBjb2xvclZhcmlhbnQsIHNpemUsIGZpbGxWYXJpYW50LCBkaXNhYmxlZCwgLi4ucHJvcHMgfSA9IHA7XG4gICAgY29uc3QgeyB1c2VBcmlhQnV0dG9uUHJvcHMgfSA9IHVzZUFyaWFCdXR0b24oeyB0YWc6IFwiYVwiIH0pO1xuICAgIGNvbnN0IGJ1dHRvblN0eWxlSW5mbyA9IHVzZUJ1dHRvblN0eWxlcyh7IGNvbG9yVmFyaWFudCwgc2l6ZSwgZmlsbFZhcmlhbnQsIGRpc2FibGVkIH0pO1xuICAgIGRpc2FibGVkID0gYnV0dG9uU3R5bGVJbmZvLmRpc2FibGVkO1xuICAgIGNvbG9yVmFyaWFudCA9IGJ1dHRvblN0eWxlSW5mby5jb2xvclZhcmlhbnQ7XG4gICAgc2l6ZSA9IGJ1dHRvblN0eWxlSW5mby5zaXplO1xuICAgIGZpbGxWYXJpYW50ID0gYnV0dG9uU3R5bGVJbmZvLmZpbGxWYXJpYW50O1xuICAgIGNvbnN0IHVzZUJ1dHRvblN0eWxlc1Byb3BzID0gYnV0dG9uU3R5bGVJbmZvLnVzZUJ1dHRvblN0eWxlc1Byb3BzO1xuICAgIHJldHVybiBoKFwiYVwiLCB7IC4uLnVzZUFyaWFCdXR0b25Qcm9wcyh1c2VCdXR0b25TdHlsZXNQcm9wcyh7IC4uLnByb3BzLCByZWYgfSkpIH0pO1xufSk7XG5jb25zdCBCdXR0b25CdXR0b24gPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBCdXR0b25CdXR0b24ocCwgcmVmKSB7XG4gICAgbGV0IHsgY29sb3JWYXJpYW50LCBzaXplLCBmaWxsVmFyaWFudCwgZGlzYWJsZWQsIGRlYm91bmNlLCBzaG93QXN5bmNTdWNjZXNzLCBvbkNsaWNrOiBvbkNsaWNrQXN5bmMsIC4uLnByb3BzIH0gPSBwO1xuICAgIGNvbnN0IHsgZ2V0U3luY0hhbmRsZXIsIHBlbmRpbmcsIHNldHRsZUNvdW50LCBoYXNFcnJvciB9ID0gdXNlQXN5bmNIYW5kbGVyKCkoeyBkZWJvdW5jZSwgY2FwdHVyZTogdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gdW5kZWZpbmVkOyB9LCBbXSkgfSk7XG4gICAgZGlzYWJsZWQgfHw9IHBlbmRpbmc7XG4gICAgY29uc3QgeyB1c2VBcmlhQnV0dG9uUHJvcHMgfSA9IHVzZUFyaWFCdXR0b24oeyB0YWc6IFwiYnV0dG9uXCIgfSk7XG4gICAgY29uc3QgYnV0dG9uU3R5bGVJbmZvID0gdXNlQnV0dG9uU3R5bGVzKHsgY29sb3JWYXJpYW50LCBzaXplLCBmaWxsVmFyaWFudCwgZGlzYWJsZWQgfSk7XG4gICAgZGlzYWJsZWQgPSBidXR0b25TdHlsZUluZm8uZGlzYWJsZWQ7XG4gICAgY29sb3JWYXJpYW50ID0gYnV0dG9uU3R5bGVJbmZvLmNvbG9yVmFyaWFudDtcbiAgICBzaXplID0gYnV0dG9uU3R5bGVJbmZvLnNpemU7XG4gICAgZmlsbFZhcmlhbnQgPSBidXR0b25TdHlsZUluZm8uZmlsbFZhcmlhbnQ7XG4gICAgY29uc3QgdXNlQnV0dG9uU3R5bGVzUHJvcHMgPSBidXR0b25TdHlsZUluZm8udXNlQnV0dG9uU3R5bGVzUHJvcHM7XG4gICAgY29uc3Qgb25DbGljayA9IGdldFN5bmNIYW5kbGVyKHBlbmRpbmcgPyBudWxsIDogb25DbGlja0FzeW5jKTtcbiAgICByZXR1cm4gKGgoUHJvZ3Jlc3NDaXJjdWxhciwgeyBtb2RlOiBoYXNFcnJvciA/IFwiZmFpbGVkXCIgOiBwZW5kaW5nID8gXCJwZW5kaW5nXCIgOiAoc2V0dGxlQ291bnQgJiYgc2hvd0FzeW5jU3VjY2VzcykgPyBcInN1Y2NlZWRlZFwiIDogbnVsbCwgY2hpbGRyZW5Qb3NpdGlvbjogXCJjaGlsZFwiLCBjb2xvcjogY29sb3JWYXJpYW50ID09PSBcImxpbmtcIiA/IFwicHJpbWFyeVwiIDogY29sb3JWYXJpYW50LCBjb2xvckZpbGw6IGZpbGxWYXJpYW50ID09IFwiZmlsbFwiID8gXCJmb3JlZ3JvdW5kXCIgOiBcImJhY2tncm91bmRcIiB9LFxuICAgICAgICBoKFwiYnV0dG9uXCIsIHsgLi4udXNlQXJpYUJ1dHRvblByb3BzKHVzZUJ1dHRvblN0eWxlc1Byb3BzKHsgLi4ucHJvcHMsIG9uQ2xpY2ssIHJlZiB9KSkgfSkpKTtcbn0pO1xuZXhwb3J0IGNvbnN0IEJ1dHRvbiA9IGZvcndhcmRFbGVtZW50UmVmKEJ1dHRvblIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLmpzLm1hcCIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VBcmlhQnV0dG9uIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHMvdXNlLWJ1dHRvblwiO1xuaW1wb3J0IHsgdXNlQXN5bmNIYW5kbGVyLCB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlQnV0dG9uU3R5bGVzIH0gZnJvbSBcIi4vZGVmYXVsdHNcIjtcbmV4cG9ydCBjb25zdCBUb2dnbGVCdXR0b24gPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBUb2dnbGVCdXR0b24ocCwgcmVmKSB7XG4gICAgbGV0IHsgY29sb3JWYXJpYW50LCBzaXplLCBkaXNhYmxlZCwgcHJlc3NlZCwgZGVib3VuY2UsIG9uQ2xpY2s6IG9uQ2xpY2tBc3luYywgLi4ucHJvcHMgfSA9IHA7XG4gICAgY29uc3QgZmlsbFZhcmlhbnQgPSBwcmVzc2VkID8gXCJmaWxsXCIgOiBcIm91dGxpbmVcIjtcbiAgICBjb25zdCBnZXRQcmVzc2VkID0gdXNlU3RhYmxlR2V0dGVyKHByZXNzZWQpO1xuICAgIGNvbnN0IHsgZ2V0U3luY0hhbmRsZXIsIHBlbmRpbmcgfSA9IHVzZUFzeW5jSGFuZGxlcigpKHsgZGVib3VuY2UsIGNhcHR1cmU6IHVzZUNhbGxiYWNrKCgpID0+IHsgcmV0dXJuICFnZXRQcmVzc2VkKCk7IH0sIFtdKSB9KTtcbiAgICBkaXNhYmxlZCB8fD0gcGVuZGluZztcbiAgICBjb25zdCB7IHVzZUFyaWFCdXR0b25Qcm9wcyB9ID0gdXNlQXJpYUJ1dHRvbih7IHRhZzogXCJidXR0b25cIiwgcHJlc3NlZCB9KTtcbiAgICBjb25zdCBidXR0b25TdHlsZUluZm8gPSB1c2VCdXR0b25TdHlsZXMoeyBjb2xvclZhcmlhbnQsIHNpemUsIGZpbGxWYXJpYW50LCBkaXNhYmxlZCB9KTtcbiAgICBkaXNhYmxlZCA9IGJ1dHRvblN0eWxlSW5mby5kaXNhYmxlZDtcbiAgICBjb2xvclZhcmlhbnQgPSBidXR0b25TdHlsZUluZm8uY29sb3JWYXJpYW50O1xuICAgIHNpemUgPSBidXR0b25TdHlsZUluZm8uc2l6ZTtcbiAgICBjb25zdCB1c2VCdXR0b25TdHlsZXNQcm9wcyA9IGJ1dHRvblN0eWxlSW5mby51c2VCdXR0b25TdHlsZXNQcm9wcztcbiAgICBjb25zdCBvbkNsaWNrID0gZ2V0U3luY0hhbmRsZXIocGVuZGluZyA/IG51bGwgOiBvbkNsaWNrQXN5bmMpO1xuICAgIHJldHVybiBoKFwiYnV0dG9uXCIsIHsgLi4udXNlQXJpYUJ1dHRvblByb3BzKHVzZUJ1dHRvblN0eWxlc1Byb3BzKHsgLi4ucHJvcHMsIG9uQ2xpY2ssIHJlZiB9KSkgfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvZ2dsZS1idXR0b24uanMubWFwIiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VIYXNGb2N1cywgdXNlTGlzdE5hdmlnYXRpb24sIHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VCdXR0b25Db2xvclZhcmlhbnQsIHVzZUJ1dHRvbkRpc2FibGVkLCB1c2VCdXR0b25GaWxsVmFyaWFudCwgdXNlQnV0dG9uU2l6ZSB9IGZyb20gXCIuL2RlZmF1bHRzXCI7XG5pbXBvcnQgeyBQcm92aWRlRGVmYXVsdEJ1dHRvbkNvbG9yLCBQcm92aWRlRGVmYXVsdEJ1dHRvblNpemUsIFByb3ZpZGVEZWZhdWx0QnV0dG9uRGlzYWJsZWQsIFByb3ZpZGVEZWZhdWx0QnV0dG9uRmlsbCB9IGZyb20gXCIuL2RlZmF1bHRzXCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tIFwiLi9idXR0b25cIjtcbmltcG9ydCB7IFRvZ2dsZUJ1dHRvbiB9IGZyb20gXCIuL3RvZ2dsZS1idXR0b25cIjtcbmV4cG9ydCBjb25zdCBVc2VCdXR0b25Hcm91cENoaWxkID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydCBjb25zdCBCdXR0b25Hcm91cCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEJ1dHRvbkdyb3VwKHAsIHJlZikge1xuICAgIGNvbnN0IHsgbGFzdEZvY3VzZWRJbm5lciwgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXMoKTtcbiAgICBjb25zdCB7IGluZGljZXNCeUVsZW1lbnQsIG1hbmFnZWRDaGlsZHJlbiwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCwgbmF2aWdhdGVUb0luZGV4LCBjaGlsZENvdW50IH0gPSB1c2VMaXN0TmF2aWdhdGlvbih7IGZvY3VzT25DaGFuZ2U6IGxhc3RGb2N1c2VkSW5uZXIgfSk7XG4gICAgLy8gU3R5bGluZyBwcm9wc1xuICAgIGxldCB7IGNvbG9yVmFyaWFudCwgZmlsbFZhcmlhbnQsIHNpemUsIGRpc2FibGVkLCBzZWxlY3RlZEluZGV4LCAuLi5wMyB9ID0gcDtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAhPSBudWxsKVxuICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KHNlbGVjdGVkSW5kZXgpO1xuICAgIH0sIFtzZWxlY3RlZEluZGV4XSk7XG4gICAgLy8gQnVpbGQgbmV3IERPTSBwcm9wcyB0byBtZXJnZSBiYXNlZCBvZmYgdGhlIHN0eWxpbmcgcHJvcHNcbiAgICBjb2xvclZhcmlhbnQgPSB1c2VCdXR0b25Db2xvclZhcmlhbnQoY29sb3JWYXJpYW50KTtcbiAgICBzaXplID0gdXNlQnV0dG9uU2l6ZShzaXplKTtcbiAgICBmaWxsVmFyaWFudCA9IHVzZUJ1dHRvbkZpbGxWYXJpYW50KGZpbGxWYXJpYW50KTtcbiAgICBkaXNhYmxlZCA9IHVzZUJ1dHRvbkRpc2FibGVkKGRpc2FibGVkKTtcbiAgICBjb25zdCBuZXdEb21Qcm9wcyA9IHsgcmVmLCByb2xlOiBcImdyb3VwXCIsIGRpc2FibGVkLCBjbGFzc05hbWU6IGNsc3goXCJidG4tZ3JvdXBcIikgfTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcHMsIGZvcndhcmRlZCBvbnRvIHRoZSBET01cbiAgICBjb25zdCBkb21Qcm9wcyA9IHVzZUhhc0ZvY3VzUHJvcHModXNlTWVyZ2VkUHJvcHMoKShuZXdEb21Qcm9wcywgcDMpKTtcbiAgICBkb21Qcm9wc1tcImRhdGEtY2hpbGQtY291bnRcIl0gPSBgJHtjaGlsZENvdW50fWA7XG4gICAgcmV0dXJuIChoKFVzZUJ1dHRvbkdyb3VwQ2hpbGQuUHJvdmlkZXIsIHsgdmFsdWU6IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQgfSxcbiAgICAgICAgaChQcm92aWRlRGVmYXVsdEJ1dHRvbkNvbG9yLCB7IHZhbHVlOiBjb2xvclZhcmlhbnQgfSxcbiAgICAgICAgICAgIGgoUHJvdmlkZURlZmF1bHRCdXR0b25GaWxsLCB7IHZhbHVlOiBmaWxsVmFyaWFudCB9LFxuICAgICAgICAgICAgICAgIGgoUHJvdmlkZURlZmF1bHRCdXR0b25TaXplLCB7IHZhbHVlOiBzaXplIH0sXG4gICAgICAgICAgICAgICAgICAgIGgoUHJvdmlkZURlZmF1bHRCdXR0b25EaXNhYmxlZCwgeyB2YWx1ZTogZGlzYWJsZWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi5kb21Qcm9wcyB9KSkpKSkpKTtcbn0pO1xuZnVuY3Rpb24gQnV0dG9uR3JvdXBDaGlsZDEoeyBpbmRleCwgLi4uYnV0dG9uUHJvcHMgfSwgcmVmKSB7XG4gICAgLy8gVGhpcyBpcyBtb3JlLW9yLWxlc3MgZm9yY2VkIHRvIGJlIGEgc2VwYXJhdGUgY29tcG9uZW50IGJlY2F1c2Ugb2YgdGhlIGluZGV4IHByb3AuXG4gICAgLy8gSXQgd291bGQgYmUgcmVhbGx5IG5pY2UgdG8gZmluZCBhIHdheSB0byBtYWtlIHRoYXQgaW1wbGljaXQgYmFzZWQgb24gRE9NIGxvY2F0aW9uLFxuICAgIC8vIHNwZWNpZmljYWxseSBmb3Igc21hbGwgdGhpbmdzIGxpa2UgYnV0dG9uIGdyb3Vwcy4uLlxuICAgIGNvbnN0IHVzZUJ1dHRvbkdyb3VwQ2hpbGQgPSB1c2VDb250ZXh0KFVzZUJ1dHRvbkdyb3VwQ2hpbGQpO1xuICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcywgdXNlTGlzdE5hdmlnYXRpb25TaWJsaW5nUHJvcHMgfSA9IHVzZUJ1dHRvbkdyb3VwQ2hpbGQoeyBpbmRleCwgdGV4dDogbnVsbCB9KTtcbiAgICAvLyBUT0RPOiBJdCdzIGtpbmRhIGZyYWdpbGUgaGVyZSBob3cgdGhlIHN5bmMgb25DbGljayBvZiBsaXN0TmF2aWdhdGlvbiBcbiAgICAvLyBhbmQgdGhlIGFzeW5jIG9uQ2xpY2sgb2YgYnV0dG9uIGFyZSBtaXhpbmcuXG4gICAgY29uc3QgcCA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh7IHJlZiwgLi4uYnV0dG9uUHJvcHMgfSk7XG4gICAgaWYgKHAucHJlc3NlZCAhPSBudWxsKVxuICAgICAgICByZXR1cm4gaChUb2dnbGVCdXR0b24sIHsgLi4ucCB9KTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBoKEJ1dHRvbiwgeyAuLi5wIH0pO1xufVxuZXhwb3J0IGNvbnN0IEJ1dHRvbkdyb3VwQ2hpbGQgPSBmb3J3YXJkRWxlbWVudFJlZihCdXR0b25Hcm91cENoaWxkMSk7XG4oKSA9PiB7XG4gICAgaChCdXR0b25Hcm91cENoaWxkLCB7IGluZGV4OiAwLCBwcmVzc2VkOiB0cnVlLCBvbkNsaWNrOiBiID0+IHsgfSB9KTtcbiAgICBoKEJ1dHRvbkdyb3VwQ2hpbGQsIHsgaW5kZXg6IDAsIHRhZzogXCJhXCIsIGhyZWY6IFwiIFwiIH0pO1xuICAgIGgoQnV0dG9uR3JvdXBDaGlsZCwgeyBpbmRleDogMCwgb25DbGljazogKG4sIGUpID0+IHsgfSB9KTtcbiAgICBoKEJ1dHRvbkdyb3VwQ2hpbGQsIHsgdGFnOiBcImJ1dHRvblwiLCBpbmRleDogMCB9KTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGgoQnV0dG9uR3JvdXBDaGlsZCwgeyB0YWc6IFwiYnV0dG9uXCIgfSk7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBoKEJ1dHRvbkdyb3VwQ2hpbGQsIHsgdGFnOiBcImJ1dHRvblwiLCBpbmRleDogMCwgcHJlc3NlZDogdHJ1ZSwgb25DbGljazogYiA9PiB7IH0gfSk7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBoKEJ1dHRvbkdyb3VwQ2hpbGQsIHsgdGFnOiBcImFcIiwgaW5kZXg6IDAsIHByZXNzZWQ6IHRydWUsIG9uQ2xpY2s6IGIgPT4geyB9IH0pO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaChCdXR0b25Hcm91cENoaWxkLCB7IHRhZzogXCJhXCIsIGluZGV4OiAwLCBvbkNsaWNrOiBiID0+IHsgfSB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24tZ3JvdXAuanMubWFwIiwiaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1yYW5kb20taWRcIjtcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5jb25zdCBiYXNlSWQgPSBnZW5lcmF0ZVJhbmRvbUlkKFwicmVuZGVyLXBvcnRhbC1jb250YWluZXItXCIpO1xuZXhwb3J0IGZ1bmN0aW9uIEJvZHlQb3J0YWwoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgaWQgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgW3BvcnRhbEVsZW1lbnQsIHNldFBvcnRhbEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGlkLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWQuY3VycmVudCA9IGdlbmVyYXRlUmFuZG9tSWQoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYmFzZUlkKTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBjb250YWluZXIuaWQgPSBiYXNlSWQ7XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJib2R5LXBvcnRhbC1jb250YWluZXJcIjtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkLmN1cnJlbnQpO1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImJvZHktcG9ydGFsXCI7XG4gICAgICAgICAgICBlbGVtZW50LmlkID0gaWQuY3VycmVudDtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRQb3J0YWxFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgfSwgW10pO1xuICAgIGlmIChwb3J0YWxFbGVtZW50KVxuICAgICAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBwb3J0YWxFbGVtZW50KTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgQm9keVBvcnRhbCB9IGZyb20gXCIuLi9wb3J0YWxcIjtcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VBcmlhRGlhbG9nIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHNcIjtcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyBGYWRlIH0gZnJvbSBcInByZWFjdC10cmFuc2l0aW9uL2ZhZGVcIjtcbmltcG9ydCBcIndpY2ctaW5lcnRcIjtcbmV4cG9ydCBjb25zdCBEaWFsb2cgPSBmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBEaWFsb2coeyBvbkNsb3NlLCBvcGVuLCBkZXNjcmlwdGl2ZSwgdGl0bGUsIGZvb3RlciwgVHJhbnNpdGlvbiwgY2hpbGRyZW4sIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgY29uc3QgeyB1c2VEaWFsb2dCYWNrZHJvcCwgdXNlRGlhbG9nQm9keSwgdXNlRGlhbG9nUHJvcHMsIHVzZURpYWxvZ1RpdGxlIH0gPSB1c2VBcmlhRGlhbG9nKHsgb3Blbiwgb25DbG9zZSB9KTtcbiAgICBjb25zdCB7IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9ID0gdXNlRGlhbG9nQmFja2Ryb3AoKTtcbiAgICBjb25zdCB7IHVzZU1vZGFsQm9keVByb3BzLCB9ID0gdXNlRGlhbG9nQm9keSh7IGRlc2NyaXB0aXZlIH0pO1xuICAgIGNvbnN0IHsgdXNlTW9kYWxUaXRsZVByb3BzIH0gPSB1c2VEaWFsb2dUaXRsZSgpO1xuICAgIHJldHVybiAoaChCb2R5UG9ydGFsLCBudWxsLFxuICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3M6IFwibW9kYWwtcG9ydGFsLWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICBoKEZhZGUsIHsgb3Blbjogb3BlbiB9LFxuICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VNb2RhbEJhY2tkcm9wUHJvcHMoeyBjbGFzczogXCJtb2RhbC1iYWNrZHJvcCAgYmFja2Ryb3AtZmlsdGVyLXRyYW5zaXRpb25cIiwgb25Qb2ludGVyVXA6ICgpID0+IG9uQ2xvc2UoXCJiYWNrZHJvcFwiKSB9KSB9KSksXG4gICAgICAgICAgICBoKFRyYW5zaXRpb24sIHsgLi4ueyByZWYsIG9wZW4sIC4uLnJlc3QgfSB9LFxuICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VEaWFsb2dQcm9wcyh7IGNsYXNzOiBcIm1vZGFsLWRpYWxvZyBtb2RhbC1kaWFsb2ctc2Nyb2xsYWJsZVwiIH0pIH0sXG4gICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJtb2RhbC1jb250ZW50IFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSAhPSBudWxsICYmIGgoXCJkaXZcIiwgeyAuLi51c2VNb2RhbFRpdGxlUHJvcHMoeyBjbGFzczogXCJtb2RhbC1oZWFkZXJcIiB9KSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoXCJoMVwiLCB7IGNsYXNzOiBcIm1vZGFsLXRpdGxlXCIgfSwgdGl0bGUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VNb2RhbEJvZHlQcm9wcyh7IGNsYXNzOiBcIm1vZGFsLWJvZHlcIiB9KSB9LCBjaGlsZHJlbiksXG4gICAgICAgICAgICAgICAgICAgICAgICBmb290ZXIgIT0gbnVsbCAmJiBoKFwiZGl2XCIsIHsgY2xhc3M6IFwibW9kYWwtZm9vdGVyXCIgfSwgZm9vdGVyKSkpKSkpKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlhbG9nLmpzLm1hcCIsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQXJpYUxpc3Rib3hTaW5nbGUgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0c1wiO1xuaW1wb3J0IHsgRXZlbnREZXRhaWwgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlQXN5bmNIYW5kbGVyLCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlUHNldWRvQWN0aXZlIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5leHBvcnQgY29uc3QgVXNlTGlzdGJveFNpbmdsZUl0ZW1Db250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydCBmdW5jdGlvbiBMaXN0U2luZ2xlKHByb3BzLCByZWYpIHtcbiAgICBjb25zdCB7IG9uU2VsZWN0OiBvblNlbGVjdEFzeW5jLCBzZWxlY3RlZEluZGV4LCBzZWxlY3Rpb25Nb2RlLCBjb2xsYXRvciwga2V5TmF2aWdhdGlvbiwgbm9UeXBlYWhlYWQsIG5vV3JhcCwgdHlwZWFoZWFkVGltZW91dCwgdGFnLCBzZWxlY3QsIC4uLmRvbVByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IGdldFN5bmNIYW5kbGVyIH0gPSB1c2VBc3luY0hhbmRsZXIoKSh7IGNhcHR1cmU6IChlKSA9PiBlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZEluZGV4IH0pO1xuICAgIGNvbnN0IG9uU2VsZWN0ID0gZ2V0U3luY0hhbmRsZXIob25TZWxlY3RBc3luYyk7XG4gICAgY29uc3QgeyB1c2VMaXN0Ym94U2luZ2xlSXRlbSwgdXNlTGlzdGJveFNpbmdsZUxhYmVsLCB1c2VMaXN0Ym94U2luZ2xlUHJvcHMgfSA9IHVzZUFyaWFMaXN0Ym94U2luZ2xlKHsgb25TZWxlY3QsIHNlbGVjdGVkSW5kZXgsIHNlbGVjdGlvbk1vZGUsIHR5cGVhaGVhZFRpbWVvdXQsIG5vV3JhcCwgbm9UeXBlYWhlYWQsIGtleU5hdmlnYXRpb24sIGNvbGxhdG9yIH0pO1xuICAgIHJldHVybiBoKFVzZUxpc3Rib3hTaW5nbGVJdGVtQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlTGlzdGJveFNpbmdsZUl0ZW0gfSwgaCh0YWcsIHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzczogXCJsaXN0LWdyb3VwXCIsIHJlZiB9LCB1c2VMaXN0Ym94U2luZ2xlUHJvcHMoZG9tUHJvcHMpKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIExpc3RJdGVtU2luZ2xlKHByb3BzLCByZWYpIHtcbiAgICBjb25zdCB1c2VMaXN0SXRlbVNpbmdsZSA9IHVzZUNvbnRleHQoVXNlTGlzdGJveFNpbmdsZUl0ZW1Db250ZXh0KTtcbiAgICBjb25zdCB7IGluZGV4LCAuLi5kb21Qcm9wcyB9ID0geyAuLi5wcm9wcywgcmVmIH07XG4gICAgY29uc3QgW3RleHQsIHNldFRleHRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQoKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgIHNldFRleHQoZWxlbWVudC5pbm5lclRleHQpO1xuICAgIH0sIFtlbGVtZW50XSk7XG4gICAgY29uc3QgeyBnZXRTZWxlY3RlZCwgdGFiYmFibGUsIHNlbGVjdGVkLCB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzIH0gPSB1c2VMaXN0SXRlbVNpbmdsZSh7IGluZGV4LCB0ZXh0LCB0YWc6IFwibGlcIiB9KTtcbiAgICByZXR1cm4gaChcImxpXCIsIHsgLi4udXNlUHNldWRvQWN0aXZlKHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzczogY2xzeChcImxpc3QtZ3JvdXAtaXRlbVwiLCBcImxpc3QtZ3JvdXAtaXRlbS1hY3Rpb25cIiwgc2VsZWN0ZWQgJiYgXCJhY3RpdmVcIikgfSwgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyh1c2VSZWZFbGVtZW50UHJvcHMoZG9tUHJvcHMpKSkpIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlzdC1zaW5nbGUuanMubWFwIiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IGgsIGNyZWF0ZUNvbnRleHQsIGNsb25lRWxlbWVudCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUFyaWFUYWJzIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHNcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHMvcHJvcHNcIjtcbmltcG9ydCB7IHVzZUFzeW5jSGFuZGxlciB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IFN3YXBwYWJsZSB9IGZyb20gXCJwcmVhY3QtdHJhbnNpdGlvblwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmNvbnN0IFVzZVRhYkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgVXNlVGFiUGFuZWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydCBmdW5jdGlvbiBUYWJzKHsgb25TZWxlY3Q6IG9uU2VsZWN0QXN5bmMsIG9yaWVudGF0aW9uLCBzZWxlY3RlZEluZGV4LCBzZWxlY3Rpb25Nb2RlLCB0YWcsIGNoaWxkcmVuLCB2aXN1YWxWYXJpYW50LCAuLi5wcm9wcyB9KSB7XG4gICAgY29uc3QgY2FwdHVyZSA9IChlKSA9PiB7IHJldHVybiBlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZEluZGV4OyB9O1xuICAgIG9yaWVudGF0aW9uID8/PSBcImlubGluZVwiO1xuICAgIGNvbnN0IHsgZ2V0U3luY0hhbmRsZXIgfSA9IHVzZUFzeW5jSGFuZGxlcigpKHsgY2FwdHVyZTogY2FwdHVyZSB9KTtcbiAgICBjb25zdCBvblNlbGVjdCA9IGdldFN5bmNIYW5kbGVyKG9uU2VsZWN0QXN5bmMpO1xuICAgIGNvbnN0IHsgdXNlVGFiLCB1c2VUYWJQYW5lbCwgdXNlVGFic0xhYmVsLCB1c2VUYWJzTGlzdCB9ID0gdXNlQXJpYVRhYnMoeyBvblNlbGVjdCwgc2VsZWN0ZWRJbmRleCwgc2VsZWN0aW9uTW9kZSwgb3JpZW50YXRpb24gfSk7XG4gICAgY29uc3QgeyB1c2VUYWJMaXN0UHJvcHMgfSA9IHVzZVRhYnNMaXN0KCk7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IGNsc3goXCJ0YWJzLWNvbnRhaW5lclwiLCBgdGFicy1vcmllbnRhdGlvbi0ke29yaWVudGF0aW9ufWApIH0sXG4gICAgICAgIGgoVXNlVGFiQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlVGFiIH0sIGNsb25lRWxlbWVudChjaGlsZHJlblswXSwgdXNlVGFiTGlzdFByb3BzKHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzc05hbWU6IGNsc3goXCJuYXZcIiwgdmlzdWFsVmFyaWFudCA9PSBcInBpbGxzXCIgPyBcIm5hdi1waWxsc1wiIDogXCJuYXYtdGFic1wiKSB9LCB7IC4uLnByb3BzIH0pKSwgY2hpbGRyZW5bMF0ucHJvcHMuY2hpbGRyZW4pKSxcbiAgICAgICAgaChVc2VUYWJQYW5lbENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHVzZVRhYlBhbmVsIH0sXG4gICAgICAgICAgICBoKFN3YXBwYWJsZSwgbnVsbCxcbiAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3M6IFwidGFiLWNvbnRlbnRcIiB9LCBjaGlsZHJlbi5zbGljZSgxKSkpKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIFRhYih7IGluZGV4LCBjaGlsZHJlbiwgLi4ucHJvcHMgfSkge1xuICAgIGNvbnN0IHVzZVRhYkNvbnRleHQgPSB1c2VDb250ZXh0KFVzZVRhYkNvbnRleHQpO1xuICAgIGNvbnN0IHsgdXNlVGFiUHJvcHMsIHNlbGVjdGVkIH0gPSB1c2VUYWJDb250ZXh0KHsgaW5kZXgsIHRleHQ6IG51bGwsIHRhZzogXCJidXR0b25cIiB9KTtcbiAgICByZXR1cm4gaChcImxpXCIsIHsgY2xhc3NOYW1lOiBcIm5hdi1pdGVtXCIsIHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSxcbiAgICAgICAgaChcImJ1dHRvblwiLCB7IC4uLnVzZVRhYlByb3BzKHVzZU1lcmdlZFByb3BzKCkoeyBjbGFzczogY2xzeChgbmF2LWxpbmtgLCBzZWxlY3RlZCAmJiBgYWN0aXZlYCkgfSwgcHJvcHMpKSB9LCBjaGlsZHJlbikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIFRhYlBhbmVsKHsgaW5kZXgsIGNoaWxkcmVuLCBUcmFuc2l0aW9uLCAuLi5yZXN0IH0pIHtcbiAgICBjb25zdCB1c2VUYWJQYW5lbCA9IHVzZUNvbnRleHQoVXNlVGFiUGFuZWxDb250ZXh0KTtcbiAgICBjb25zdCB7IHVzZVRhYlBhbmVsUHJvcHMsIHNlbGVjdGVkIH0gPSB1c2VUYWJQYW5lbCh7IGluZGV4IH0pO1xuICAgIHJldHVybiBoKFRyYW5zaXRpb24sIHVzZVRhYlBhbmVsUHJvcHMoeyBjbGFzczogXCJcIiwgb3Blbjogc2VsZWN0ZWQsIGNoaWxkcmVuLCAuLi5yZXN0IH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYnMuanMubWFwIixudWxsLG51bGwsIlwidXNlIHN0cmljdFwiO1xuZ2xvYmFsVGhpcy5wcm9jZXNzID8/PSB7fTtcbmdsb2JhbFRoaXMucHJvY2Vzcy5lbnYgPz89IHt9O1xuZ2xvYmFsVGhpcy5wcm9jZXNzLmVudi5OT0RFX0VOViA/Pz0gXCJkZXZlbG9wbWVudFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLWNvbmZpZy5qcy5tYXAiLCJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTsiLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07IiwiaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufSIsImltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnQpICYmIGluY2x1ZGVTY2FsZSkge1xuICAgIC8vIEZhbGxiYWNrIHRvIDEgaW4gY2FzZSBib3RoIHZhbHVlcyBhcmUgYDBgXG4gICAgc2NhbGVYID0gcmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgICBzY2FsZVkgPSByZWN0LmhlaWdodCAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiByb3VuZChyZWN0LndpZHRoIC8gc2NhbGVYKSxcbiAgICBoZWlnaHQ6IHJvdW5kKHJlY3QuaGVpZ2h0IC8gc2NhbGVZKSxcbiAgICB0b3A6IHJvdW5kKHJlY3QudG9wIC8gc2NhbGVZKSxcbiAgICByaWdodDogcm91bmQocmVjdC5yaWdodCAvIHNjYWxlWCksXG4gICAgYm90dG9tOiByb3VuZChyZWN0LmJvdHRvbSAvIHNjYWxlWSksXG4gICAgbGVmdDogcm91bmQocmVjdC5sZWZ0IC8gc2NhbGVYKSxcbiAgICB4OiByb3VuZChyZWN0LmxlZnQgLyBzY2FsZVgpLFxuICAgIHk6IHJvdW5kKHJlY3QudG9wIC8gc2NhbGVZKVxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcblxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGVsc2UgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59IiwiaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tIFwiLi9pc1RhYmxlRWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbi8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xuXG5cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIHZhciBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMTtcbiAgdmFyIGlzSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSAhPT0gLTE7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XG4gICAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG5cbiAgICBpZiAoY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IGNzcy5jb250YWluID09PSAncGFpbnQnIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8IGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicgfHwgaXNGaXJlZm94ICYmIGNzcy5maWx0ZXIgJiYgY3NzLmZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufSIsImV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7IiwiaW1wb3J0IHsgbWF4IGFzIG1hdGhNYXgsIG1pbiBhcyBtYXRoTWluIH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gbWF0aE1heChtaW4sIG1hdGhNaW4odmFsdWUsIG1heCkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCBwYWRkaW5nT2JqZWN0KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcbiAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gaGFzaE1hcDtcbiAgfSwge30pO1xufSIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi4vZG9tLXV0aWxzL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB3aXRoaW4gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuLi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcIjtcbmltcG9ydCB7IGxlZnQsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdG9wLCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCAobm90IGFuIFNWR0VsZW1lbnQpLicsICdUbyB1c2UgYW4gU1ZHIGFycm93LCB3cmFwIGl0IGluIGFuIEhUTUxFbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIGFzJywgJ3RoZSBhcnJvdy4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLCAnZWxlbWVudC4nXS5qb2luKCcgJykpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn07IiwiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQocm91bmQoeCAqIGRwcikgLyBkcHIpIHx8IDAsXG4gICAgeTogcm91bmQocm91bmQoeSAqIGRwcikgLyBkcHIpIHx8IDBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cztcblxuICB2YXIgX3JlZjMgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUihvZmZzZXRzKSA6IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMob2Zmc2V0cykgOiBvZmZzZXRzLFxuICAgICAgX3JlZjMkeCA9IF9yZWYzLngsXG4gICAgICB4ID0gX3JlZjMkeCA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJHgsXG4gICAgICBfcmVmMyR5ID0gX3JlZjMueSxcbiAgICAgIHkgPSBfcmVmMyR5ID09PSB2b2lkIDAgPyAwIDogX3JlZjMkeTtcblxuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCkge1xuICAgICAgc2lkZVkgPSBib3R0b207IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gICAgICB5IC09IG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCkge1xuICAgICAgc2lkZVggPSByaWdodDsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgICAgIHggLT0gb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF0gLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPCAyID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY0KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY0LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY0Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gZ2V0Q29tcHV0ZWRTdHlsZShzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCAnJztcblxuICAgIGlmIChhZGFwdGl2ZSAmJiBbJ3RyYW5zZm9ybScsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5zb21lKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25Qcm9wZXJ0eS5pbmRleE9mKHByb3BlcnR5KSA+PSAwO1xuICAgIH0pKSB7XG4gICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZycsICdDU1MgcHJvcGVydGllczogXCJ0cmFuc2Zvcm1cIiwgXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIi4nLCAnXFxuXFxuJywgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsICdmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1MnLCAndHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nJywgJ29wYWNpdHkgb3IgYmFja2dyb3VuZC1jb2xvciBmb3IgZXhhbXBsZS4nLCAnXFxuXFxuJywgJ1dlIHJlY29tbWVuZCB1c2luZyB0aGUgcG9wcGVyIGVsZW1lbnQgYXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBpbm5lcicsICdlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvblxuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgZm46IGNvbXB1dGVTdHlsZXMsXG4gIGRhdGE6IHt9XG59OyIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcbiAgICAgIHNjcm9sbCA9IF9vcHRpb25zJHNjcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHNjcm9sbCxcbiAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XG4gIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgaWYgKHNjcm9sbCkge1xuICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIGRhdGE6IHt9XG59OyIsInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsInZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7IC8vIE5COiBUaGlzIGlzbid0IHN1cHBvcnRlZCBvbiBpT1MgPD0gMTIuIElmIHRoZSBrZXlib2FyZCBpcyBvcGVuLCB0aGUgcG9wcGVyXG4gIC8vIGNhbiBiZSBvYnNjdXJlZCB1bmRlcm5lYXRoIGl0LlxuICAvLyBBbHNvLCBgaHRtbC5jbGllbnRIZWlnaHRgIGFkZHMgdGhlIGJvdHRvbSBiYXIgaGVpZ2h0IGluIFNhZmFyaSBpT1MsIGV2ZW5cbiAgLy8gaWYgaXQgaXNuJ3Qgb3Blbiwgc28gaWYgdGhpcyBpc24ndCBhdmFpbGFibGUsIHRoZSBwb3BwZXIgd2lsbCBiZSBkZXRlY3RlZFxuICAvLyB0byBvdmVyZmxvdyB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gdG9vIGVhcmx5LlxuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0OyAvLyBVc2VzIExheW91dCBWaWV3cG9ydCAobGlrZSBDaHJvbWU7IFNhZmFyaSBkb2VzIG5vdCBjdXJyZW50bHkpXG4gICAgLy8gSW4gQ2hyb21lLCBpdCByZXR1cm5zIGEgdmFsdWUgdmVyeSBjbG9zZSB0byAwICgrLy0pIGJ1dCBjb250YWlucyByb3VuZGluZ1xuICAgIC8vIGVycm9ycyBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgbnVtYmVycywgc28gd2UgbmVlZCB0byBjaGVjayBwcmVjaXNpb24uXG4gICAgLy8gU2FmYXJpIHJldHVybnMgYSBudW1iZXIgPD0gMCwgdXN1YWxseSA8IC0xIHdoZW4gcGluY2gtem9vbWVkXG4gICAgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZmFpbHMgaW4gbW9iaWxlIGVtdWxhdGlvbiBtb2RlIGluIENocm9tZS5cbiAgICAvLyBNYXRoLmFicyh3aW4uaW5uZXJXaWR0aCAvIHZpc3VhbFZpZXdwb3J0LnNjYWxlIC0gdmlzdWFsVmlld3BvcnQud2lkdGgpIDxcbiAgICAvLyAwLjAwMVxuICAgIC8vIEZhbGxiYWNrIGhlcmU6IFwiTm90IFNhZmFyaVwiIHVzZXJBZ2VudFxuXG4gICAgaWYgKCEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IHsgbWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59IiwiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufSIsImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSkgOiBpc0hUTUxFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcbiAgdmFyIG9mZnNldHM7XG5cbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSByaWdodDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldENsaXBwaW5nUmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBjbGlwcGluZ1BhcmVudHMsIHJlZmVyZW5jZSwgcG9wcGVyLCBib3R0b20sIHRvcCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi9leHBhbmRUb0hhc2hNYXAuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gc3RhdGUucGxhY2VtZW50IDogX29wdGlvbnMkcGxhY2VtZW50LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcmVmZXJlbmNlRWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlRWxlbWVudCk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59IiwiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFRoZSBgYWxsb3dlZEF1dG9QbGFjZW1lbnRzYCBvcHRpb24gZGlkIG5vdCBhbGxvdyBhbnknLCAncGxhY2VtZW50cy4gRW5zdXJlIHRoZSBgcGxhY2VtZW50YCBvcHRpb24gbWF0Y2hlcyB0aGUgdmFyaWF0aW9uJywgJ29mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuJywgJ0ZvciBleGFtcGxlLCBcImF1dG9cIiBjYW5ub3QgYmUgdXNlZCB0byBhbGxvdyBcImJvdHRvbS1zdGFydFwiLicsICdVc2UgXCJhdXRvLXN0YXJ0XCIgaW5zdGVhZC4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyIsImltcG9ydCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVcbn07IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59OyIsImltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcIjtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgc3RhcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRBbHRBeGlzIGZyb20gXCIuLi91dGlscy9nZXRBbHRBeGlzLmpzXCI7XG5pbXBvcnQgd2l0aGluIGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgZGF0YSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hlY2tNYWluQXhpcyB8fCBjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgdmFyIG1pbiA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcbiAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcblxuICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG5cbiAgICB2YXIgYXJyb3dMZW4gPSB3aXRoaW4oMCwgcmVmZXJlbmNlUmVjdFtsZW5dLCBhcnJvd1JlY3RbbGVuXSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gdGV0aGVyT2Zmc2V0VmFsdWUgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIHRldGhlck9mZnNldFZhbHVlO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyB0ZXRoZXJPZmZzZXRWYWx1ZSA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgdGV0aGVyT2Zmc2V0VmFsdWU7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdW21haW5BeGlzXSA6IDA7XG4gICAgdmFyIHRldGhlck1pbiA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gbWF0aE1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgICAgcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICB2YXIgX21haW5TaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IHRvcCA6IGxlZnQ7XG5cbiAgICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1hdGhNaW4oX21pbiwgdGV0aGVyTWluKSA6IF9taW4sIF9vZmZzZXQsIHRldGhlciA/IG1hdGhNYXgoX21heCwgdGV0aGVyTWF4KSA6IF9tYXgpO1xuXG4gICAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59IiwiaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEhUTUxFbGVtZW50U2Nyb2xsIGZyb20gXCIuL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gXCIuL2dldE5vZGVTY3JvbGwuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDE7XG59IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnRJc1NjYWxlZCk7XG4gIHZhciBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufSIsImltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICB2YXIgcGVuZGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0KHN0cikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gW10uY29uY2F0KGFyZ3MpLnJlZHVjZShmdW5jdGlvbiAocCwgYykge1xuICAgIHJldHVybiBwLnJlcGxhY2UoLyVzLywgYyk7XG4gIH0sIHN0cik7XG59IiwiaW1wb3J0IGZvcm1hdCBmcm9tIFwiLi9mb3JtYXQuanNcIjtcbmltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG52YXIgSU5WQUxJRF9NT0RJRklFUl9FUlJPUiA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiBwcm92aWRlZCBhbiBpbnZhbGlkICVzIHByb3BlcnR5LCBleHBlY3RlZCAlcyBidXQgZ290ICVzJztcbnZhciBNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcmVxdWlyZXMgXCIlc1wiLCBidXQgXCIlc1wiIG1vZGlmaWVyIGlzIG5vdCBhdmFpbGFibGUnO1xudmFyIFZBTElEX1BST1BFUlRJRVMgPSBbJ25hbWUnLCAnZW5hYmxlZCcsICdwaGFzZScsICdmbicsICdlZmZlY3QnLCAncmVxdWlyZXMnLCAnb3B0aW9ucyddO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmFsaWRhdGVNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIE9iamVjdC5rZXlzKG1vZGlmaWVyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIFN0cmluZyhtb2RpZmllci5uYW1lKSwgJ1wibmFtZVwiJywgJ1wic3RyaW5nXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5uYW1lKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZW5hYmxlZCc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5lbmFibGVkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcImVuYWJsZWRcIicsICdcImJvb2xlYW5cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmVuYWJsZWQpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncGhhc2UnOlxuICAgICAgICAgIGlmIChtb2RpZmllclBoYXNlcy5pbmRleE9mKG1vZGlmaWVyLnBoYXNlKSA8IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcInBoYXNlXCInLCBcImVpdGhlciBcIiArIG1vZGlmaWVyUGhhc2VzLmpvaW4oJywgJyksIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLnBoYXNlKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm4nOlxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIuZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcImZuXCInLCAnXCJmdW5jdGlvblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZm4pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlZmZlY3QnOlxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIuZWZmZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJlZmZlY3RcIicsICdcImZ1bmN0aW9uXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5mbikgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JlcXVpcmVzJzpcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kaWZpZXIucmVxdWlyZXMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJyZXF1aXJlc1wiJywgJ1wiYXJyYXlcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLnJlcXVpcmVzKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmVxdWlyZXNJZkV4aXN0cyc6XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJyZXF1aXJlc0lmRXhpc3RzXCInLCAnXCJhcnJheVwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cykgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ29wdGlvbnMnOlxuICAgICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQb3BwZXJKUzogYW4gaW52YWxpZCBwcm9wZXJ0eSBoYXMgYmVlbiBwcm92aWRlZCB0byB0aGUgXFxcIlwiICsgbW9kaWZpZXIubmFtZSArIFwiXFxcIiBtb2RpZmllciwgdmFsaWQgcHJvcGVydGllcyBhcmUgXCIgKyBWQUxJRF9QUk9QRVJUSUVTLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxcIlwiICsgcyArIFwiXFxcIlwiO1xuICAgICAgICAgIH0pLmpvaW4oJywgJykgKyBcIjsgYnV0IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgcHJvdmlkZWQuXCIpO1xuICAgICAgfVxuXG4gICAgICBtb2RpZmllci5yZXF1aXJlcyAmJiBtb2RpZmllci5yZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1aXJlbWVudCkge1xuICAgICAgICBpZiAobW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgIHJldHVybiBtb2QubmFtZSA9PT0gcmVxdWlyZW1lbnQ7XG4gICAgICAgIH0pID09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IsIFN0cmluZyhtb2RpZmllci5uYW1lKSwgcmVxdWlyZW1lbnQsIHJlcXVpcmVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1bmlxdWVCeShhcnIsIGZuKSB7XG4gIHZhciBpZGVudGlmaWVycyA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgaWRlbnRpZmllciA9IGZuKGl0ZW0pO1xuXG4gICAgaWYgKCFpZGVudGlmaWVycy5oYXMoaWRlbnRpZmllcikpIHtcbiAgICAgIGlkZW50aWZpZXJzLmFkZChpZGVudGlmaWVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXG4gICAgfSkgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgb3JkZXJNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvb3JkZXJNb2RpZmllcnMuanNcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwiLi91dGlscy9kZWJvdW5jZS5qc1wiO1xuaW1wb3J0IHZhbGlkYXRlTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgdW5pcXVlQnkgZnJvbSBcIi4vdXRpbHMvdW5pcXVlQnkuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBtZXJnZUJ5TmFtZSBmcm9tIFwiLi91dGlscy9tZXJnZUJ5TmFtZS5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuL2VudW1zLmpzXCI7XG52YXIgSU5WQUxJRF9FTEVNRU5UX0VSUk9SID0gJ1BvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50Lic7XG52YXIgSU5GSU5JVEVfTE9PUF9FUlJPUiA9ICdQb3BwZXI6IEFuIGluZmluaXRlIGxvb3AgaW4gdGhlIG1vZGlmaWVycyBjeWNsZSBoYXMgYmVlbiBkZXRlY3RlZCEgVGhlIGN5Y2xlIGhhcyBiZWVuIGludGVycnVwdGVkIHRvIHByZXZlbnQgYSBicm93c2VyIGNyYXNoLic7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pOyAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbW9kaWZpZXJzIHNvIHRoYXQgdGhlIGNvbnN1bWVyIHdpbGwgZ2V0IHdhcm5lZFxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1vZGlmaWVycyBpcyBpbnZhbGlkIGZvciBhbnkgcmVhc29uXG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSB1bmlxdWVCeShbXS5jb25jYXQob3JkZXJlZE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpO1xuXG4gICAgICAgICAgaWYgKGdldEJhc2VQbGFjZW1lbnQoc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICAgICAgICB2YXIgZmxpcE1vZGlmaWVyID0gc3RhdGUub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSAnZmxpcCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFmbGlwTW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsICdwcmVzZW50IGFuZCBlbmFibGVkIHRvIHdvcmsuJ10uam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBvcHBlciksXG4gICAgICAgICAgICAgIG1hcmdpblRvcCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5SaWdodCxcbiAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luTGVmdDsgLy8gV2Ugbm8gbG9uZ2VyIHRha2UgaW50byBhY2NvdW50IGBtYXJnaW5zYCBvbiB0aGUgcG9wcGVyLCBhbmQgaXQgY2FuXG4gICAgICAgICAgLy8gY2F1c2UgYnVncyB3aXRoIHBvc2l0aW9uaW5nLCBzbyB3ZSdsbCB3YXJuIHRoZSBjb25zdW1lclxuXG5cbiAgICAgICAgICBpZiAoW21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdF0uc29tZShmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXJnaW4pO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgJ2JldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50IG9yIGJvdW5kYXJ5LicsICdUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzJywgJ3RoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgJywgJ21vZGlmaWVycy4nXS5qb2luKCcgJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9fZGVidWdfbG9vcHNfXyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgX19kZWJ1Z19sb29wc19fICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChfX2RlYnVnX2xvb3BzX18gPiAxMDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTkZJTklURV9MT09QX0VSUk9SKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgICAgICBfcmVmMyRvcHRpb25zID0gX3JlZjMub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmMyRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuZXhwb3J0IHZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgZGV0ZWN0T3ZlcmZsb3cgfTsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyIsImltcG9ydCBcIi4vcG9wcGVyLWNvbmZpZ1wiO1xuaW1wb3J0IHsgY3JlYXRlUG9wcGVyIH0gZnJvbSBcIkBwb3BwZXJqcy9jb3JlXCI7XG5pbXBvcnQgeyB1c2VHbG9iYWxIYW5kbGVyLCB1c2VMb2dpY2FsRGlyZWN0aW9uLCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgdXNlU3RhdGUsIHVzZVRpbWVvdXQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VQb3BwZXJBcGkoeyB1cGRhdGluZywgcG9zaXRpb24sIHNraWRkaW5nLCBkaXN0YW5jZSwgcGFkZGluZ1RvcCwgcGFkZGluZ0JvdHRvbSwgcGFkZGluZ0xlZnQsIHBhZGRpbmdSaWdodCB9KSB7XG4gICAgY29uc3QgW3BvcHBlckluc3RhbmNlLCBzZXRQb3BwZXJJbnN0YW5jZSwgZ2V0UG9wcGVySW5zdGFuY2VdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW3VzZWRQbGFjZW1lbnQsIHNldFVzZWRQbGFjZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgeyBlbGVtZW50OiBzb3VyY2VFbGVtZW50LCBnZXRFbGVtZW50OiBnZXRTb3VyY2VFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZVNvdXJjZUVsZW1lbnRSZWZQcm9wcyB9ID0gdXNlUmVmRWxlbWVudCgpO1xuICAgIGNvbnN0IHsgZWxlbWVudDogcG9wcGVyRWxlbWVudCwgZ2V0RWxlbWVudDogZ2V0UG9wcGVyRWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VQb3BwZXJFbGVtZW50UmVmUHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQoKTtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGFycm93RWxlbWVudCwgZ2V0RWxlbWVudDogZ2V0QXJyb3dFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUFycm93RWxlbWVudFJlZlByb3BzIH0gPSB1c2VSZWZFbGVtZW50KCk7XG4gICAgY29uc3QgW3NvdXJjZVN0eWxlLCBzZXRTb3VyY2VTdHlsZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbc291cmNlQXR0cmlidXRlcywgc2V0U291cmNlQXR0cmlidXRlc10gPSB1c2VTdGF0ZSh7fSk7XG4gICAgY29uc3QgW3BvcHBlclN0eWxlLCBzZXRQb3BwZXJTdHlsZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbcG9wcGVyQXR0cmlidXRlcywgc2V0UG9wcGVyQXR0cmlidXRlc10gPSB1c2VTdGF0ZSh7fSk7XG4gICAgY29uc3QgW2Fycm93U3R5bGUsIHNldEFycm93U3R5bGVdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2Fycm93QXR0cmlidXRlcywgc2V0QXJyb3dBdHRyaWJ1dGVzXSA9IHVzZVN0YXRlKHt9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodXBkYXRpbmcpIHtcbiAgICAgICAgICAgIGxldCByYWZIYW5kbGUgPSAwO1xuICAgICAgICAgICAgZnVuY3Rpb24gcmFmKCkge1xuICAgICAgICAgICAgICAgIGxldCBwID0gKChjbG9zZWQgPyBQcm9taXNlLnJlc29sdmUoKSA6IGdldFBvcHBlckluc3RhbmNlKCk/LnVwZGF0ZSgpKSA/PyBQcm9taXNlLnJlc29sdmUoKSk7XG4gICAgICAgICAgICAgICAgcC50aGVuKF8gPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYWZIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSGFuZGxlKTtcbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUtdGhyZWFkZWQgbGFuZ3VhZ2VzIGFyZSBuaWNlIHNvbWV0aW1lcy5cbiAgICAgICAgICAgICAgICByYWZIYW5kbGUgPSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFt1cGRhdGluZ10pO1xuICAgIGNvbnN0IHVwZGF0ZVN0YXRlTW9kaWZpZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IG1vZGlmaWVyID0ge1xuICAgICAgICAgICAgbmFtZTogXCJ1cGRhdGVTdGF0ZVwiLFxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHBoYXNlOiBcIndyaXRlXCIsXG4gICAgICAgICAgICBmbjogKHsgc3RhdGUsIG9wdGlvbnMsIG5hbWUsIGluc3RhbmNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdXNlZFBsYWNlbWVudCA9IHN0YXRlLnBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAodXNlZFBsYWNlbWVudC5pbmNsdWRlcyhcIi1cIikpXG4gICAgICAgICAgICAgICAgICAgIHVzZWRQbGFjZW1lbnQgPSB1c2VkUGxhY2VtZW50LnN1YnN0cigwLCB1c2VkUGxhY2VtZW50LmluZGV4T2YoXCItXCIpKTtcbiAgICAgICAgICAgICAgICBzZXRVc2VkUGxhY2VtZW50KHVzZWRQbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdHlsZXMucmVmZXJlbmNlKVxuICAgICAgICAgICAgICAgICAgICBzZXRTb3VyY2VTdHlsZShzdGF0ZS5zdHlsZXMucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYXR0cmlidXRlcy5yZWZlcmVuY2UpXG4gICAgICAgICAgICAgICAgICAgIHNldFNvdXJjZUF0dHJpYnV0ZXMoc3RhdGUuYXR0cmlidXRlcy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdHlsZXMucG9wcGVyKVxuICAgICAgICAgICAgICAgICAgICBzZXRQb3BwZXJTdHlsZShzdGF0ZS5zdHlsZXMucG9wcGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIpXG4gICAgICAgICAgICAgICAgICAgIHNldFBvcHBlckF0dHJpYnV0ZXMoc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdHlsZXMuYXJyb3cpXG4gICAgICAgICAgICAgICAgICAgIHNldEFycm93U3R5bGUoc3RhdGUuc3R5bGVzLmFycm93KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYXR0cmlidXRlcy5hcnJvdylcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJyb3dBdHRyaWJ1dGVzKHN0YXRlLmF0dHJpYnV0ZXMuYXJyb3cpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJjb21wdXRlU3R5bGVzXCIsIFwiZmxpcFwiXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbW9kaWZpZXI7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHsgY29udmVydEVsZW1lbnRTaXplLCBnZXRMb2dpY2FsRGlyZWN0aW9uIH0gPSB1c2VMb2dpY2FsRGlyZWN0aW9uKHNvdXJjZUVsZW1lbnQpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzb3VyY2VFbGVtZW50ICYmIHBvcHBlckVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uRmlyc3RVcGRhdGUgPSAoKSA9PiB7IH07XG4gICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgIGxldCBwbGFjZW1lbnQgPSBsb2dpY2FsVG9QbGFjZW1lbnQoZ2V0TG9naWNhbERpcmVjdGlvbigpLCBwb3NpdGlvbik7XG4gICAgICAgICAgICBzZXRQb3BwZXJJbnN0YW5jZShjcmVhdGVQb3BwZXIoc291cmNlRWxlbWVudCwgcG9wcGVyRWxlbWVudCwge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiZmxpcFwiLCBvcHRpb25zOiB7fSB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwicHJldmVudE92ZXJmbG93XCIsIG9wdGlvbnM6IHsgcGFkZGluZzogeyBib3R0b206IHBhZGRpbmdCb3R0b20sIHRvcDogcGFkZGluZ1RvcCwgbGVmdDogcGFkZGluZ0xlZnQsIHJpZ2h0OiBwYWRkaW5nUmlnaHQgfSB9IH0sXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0YXRlTW9kaWZpZXIsXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJywgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcImFwcGx5U3R5bGVzXCIsIGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgXSwgb25GaXJzdFVwZGF0ZSwgcGxhY2VtZW50LCBzdHJhdGVneVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSwgW3NvdXJjZUVsZW1lbnQsIHBvcHBlckVsZW1lbnQsIHBvc2l0aW9uLCBza2lkZGluZywgZGlzdGFuY2UsIHBhZGRpbmdUb3AsIHBhZGRpbmdCb3R0b20sIHBhZGRpbmdMZWZ0LCBwYWRkaW5nUmlnaHRdKTtcbiAgICBmdW5jdGlvbiB1c2VQb3BwZXJTb3VyY2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHVzZVBvcHBlclNvdXJjZVByb3BzKHByb3BzKSB7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB7IC4uLnNvdXJjZVN0eWxlIH07XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKShzb3VyY2VBdHRyaWJ1dGVzLCB1c2VNZXJnZWRQcm9wcygpKHsgc3R5bGUgfSwgdXNlU291cmNlRWxlbWVudFJlZlByb3BzKHByb3BzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHVzZVBvcHBlclNvdXJjZVByb3BzIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVBvcHBlclBvcHVwKHsgb3BlbiB9KSB7XG4gICAgICAgIGZ1bmN0aW9uIHVzZVBvcHBlclBvcHVwUHJvcHMocHJvcHMpIHtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHsgLi4ucG9wcGVyU3R5bGUsIHBvaW50ZXJFdmVudHM6IG9wZW4gPyB1bmRlZmluZWQgOiBcIm5vbmVcIiB9O1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKCkocG9wcGVyQXR0cmlidXRlcywgdXNlTWVyZ2VkUHJvcHMoKSh7IHN0eWxlIH0sIHVzZVBvcHBlckVsZW1lbnRSZWZQcm9wcyhwcm9wcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1c2VQb3BwZXJQb3B1cFByb3BzIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVBvcHBlckFycm93KCkge1xuICAgICAgICBmdW5jdGlvbiB1c2VQb3BwZXJBcnJvd1Byb3BzKHByb3BzKSB7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB7IC4uLmFycm93U3R5bGUgfTtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcygpKHBvcHBlckF0dHJpYnV0ZXMsIHVzZU1lcmdlZFByb3BzKCkoeyBzdHlsZSB9LCB1c2VBcnJvd0VsZW1lbnRSZWZQcm9wcyhwcm9wcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1c2VQb3BwZXJBcnJvd1Byb3BzIH07XG4gICAgfVxuICAgIHJldHVybiB7IHVzZVBvcHBlclNvdXJjZSwgdXNlUG9wcGVyUG9wdXAsIHVzZVBvcHBlckFycm93LCB1c2VkUGxhY2VtZW50LCBnZXRMb2dpY2FsRGlyZWN0aW9uIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGxhY2VtZW50VG9Mb2dpY2FsKGxvZ2ljYWxEaXJlY3Rpb24sIHBsYWNlbWVudCkge1xuICAgIGNvbnN0IHsgYmxvY2tEaXJlY3Rpb24sIGJsb2NrT3JpZW50YXRpb24sIGlubGluZURpcmVjdGlvbiwgaW5saW5lT3JpZW50YXRpb24gfSA9IGxvZ2ljYWxEaXJlY3Rpb247XG4gICAgbGV0IGxvZ2ljYWw7XG4gICAgc3dpdGNoIChgJHtpbmxpbmVEaXJlY3Rpb259LSR7YmxvY2tEaXJlY3Rpb259LCR7cGxhY2VtZW50fWApIHtcbiAgICAgICAgLy8gVGhlcmUncyBhIHBhdHRlcm4sIGFuZCBpdCBjb3VsZCBiZSBjb2RlZCBhcyBhIHBhdHRlcm5cbiAgICAgICAgY2FzZSBcImx0ci10dGIsdG9wXCI6XG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1zdGFydFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsdHItYnR0LGJvdHRvbVwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stc3RhcnRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicnRsLXR0Yix0b3BcIjpcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLXN0YXJ0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJ0bC1idHQsYm90dG9tXCI6XG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1zdGFydFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0dGItbHRyLGxlZnRcIjpcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLXN0YXJ0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJ0dC1sdHIscmlnaHRcIjpcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLXN0YXJ0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInR0Yi1ydGwsbGVmdFwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stc3RhcnRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYnR0LXJ0bCxyaWdodFwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stc3RhcnRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibHRyLXR0Yixib3R0b21cIjpcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLWVuZFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJydGwtdHRiLGJvdHRvbVwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stZW5kXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImx0ci1idHQsdG9wXCI6XG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1lbmRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicnRsLWJ0dCx0b3BcIjpcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImJsb2NrLWVuZFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0dGItbHRyLHJpZ2h0XCI6XG4gICAgICAgICAgICBsb2dpY2FsID0gXCJibG9jay1lbmRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidHRiLXJ0bCxyaWdodFwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stZW5kXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJ0dC1sdHIsbGVmdFwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stZW5kXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJ0dC1ydGwsbGVmdFwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiYmxvY2stZW5kXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInR0Yi1sdHIsdG9wXCI6XG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtc3RhcnRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidHRiLXJ0bCx0b3BcIjpcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1zdGFydFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJidHQtbHRyLGJvdHRvbVwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLXN0YXJ0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJ0dC1ydGwsYm90dG9tXCI6XG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtc3RhcnRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibHRyLXR0YixsZWZ0XCI6XG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtc3RhcnRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicnRsLXR0YixsZWZ0XCI6XG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtc3RhcnRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibHRyLWJ0dCxyaWdodFwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLXN0YXJ0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJ0bC1idHQscmlnaHRcIjpcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1zdGFydFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0dGItbHRyLGJvdHRvbVwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLWVuZFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0dGItcnRsLGJvdHRvbVwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLWVuZFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJidHQtbHRyLHRvcFwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLWVuZFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJidHQtcnRsLHRvcFwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLWVuZFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsdHItdHRiLHJpZ2h0XCI6XG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtZW5kXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJ0bC10dGIscmlnaHRcIjpcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBcImlubGluZS1lbmRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibHRyLWJ0dCxsZWZ0XCI6XG4gICAgICAgICAgICBsb2dpY2FsID0gXCJpbmxpbmUtZW5kXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJ0bC1idHQsbGVmdFwiOlxuICAgICAgICAgICAgbG9naWNhbCA9IFwiaW5saW5lLWVuZFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFNob3VsZG4ndCBoYXBwZW4sIGJ1dCBoZXJlIGZvciB0eXBlIGNvcnJlY3RuZXNzLlxuICAgICAgICBjYXNlIFwidHRiLXR0Yixib3R0b21cIjpcbiAgICAgICAgY2FzZSBcInR0Yi10dGIsdG9wXCI6XG4gICAgICAgIGNhc2UgXCJidHQtYnR0LGJvdHRvbVwiOlxuICAgICAgICBjYXNlIFwiYnR0LWJ0dCx0b3BcIjpcbiAgICAgICAgY2FzZSBcImx0ci1sdHIsYm90dG9tXCI6XG4gICAgICAgIGNhc2UgXCJsdHItbHRyLHRvcFwiOlxuICAgICAgICBjYXNlIFwicnRsLXJ0bCxib3R0b21cIjpcbiAgICAgICAgY2FzZSBcInJ0bC1ydGwsdG9wXCI6XG4gICAgICAgIGNhc2UgXCJ0dGItYnR0LGJvdHRvbVwiOlxuICAgICAgICBjYXNlIFwiYnR0LXR0Yix0b3BcIjpcbiAgICAgICAgY2FzZSBcImJ0dC10dGIsYm90dG9tXCI6XG4gICAgICAgIGNhc2UgXCJ0dGItYnR0LHRvcFwiOlxuICAgICAgICBjYXNlIFwibHRyLXJ0bCxib3R0b21cIjpcbiAgICAgICAgY2FzZSBcInJ0bC1sdHIsdG9wXCI6XG4gICAgICAgIGNhc2UgXCJydGwtbHRyLGJvdHRvbVwiOlxuICAgICAgICBjYXNlIFwibHRyLXJ0bCx0b3BcIjpcbiAgICAgICAgY2FzZSBcInR0Yi10dGIscmlnaHRcIjpcbiAgICAgICAgY2FzZSBcInR0Yi10dGIsbGVmdFwiOlxuICAgICAgICBjYXNlIFwiYnR0LWJ0dCxyaWdodFwiOlxuICAgICAgICBjYXNlIFwiYnR0LWJ0dCxsZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJsdHItbHRyLHJpZ2h0XCI6XG4gICAgICAgIGNhc2UgXCJsdHItbHRyLGxlZnRcIjpcbiAgICAgICAgY2FzZSBcInJ0bC1ydGwscmlnaHRcIjpcbiAgICAgICAgY2FzZSBcInJ0bC1ydGwsbGVmdFwiOlxuICAgICAgICBjYXNlIFwidHRiLWJ0dCxyaWdodFwiOlxuICAgICAgICBjYXNlIFwiYnR0LXR0YixsZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJidHQtdHRiLHJpZ2h0XCI6XG4gICAgICAgIGNhc2UgXCJ0dGItYnR0LGxlZnRcIjpcbiAgICAgICAgY2FzZSBcImx0ci1ydGwscmlnaHRcIjpcbiAgICAgICAgY2FzZSBcInJ0bC1sdHIsbGVmdFwiOlxuICAgICAgICBjYXNlIFwicnRsLWx0cixyaWdodFwiOlxuICAgICAgICBjYXNlIFwibHRyLXJ0bCxsZWZ0XCI6XG4gICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgIGxvZ2ljYWwgPSBsb2dpY2FsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBsb2dpY2FsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxvZ2ljYWxUb1BsYWNlbWVudChsb2dpY2FsRGlyZWN0aW9uLCBwb3NpdGlvbikge1xuICAgIGxldCBwbGFjZW1lbnQ7XG4gICAgY29uc3QgeyBibG9ja0RpcmVjdGlvbiwgYmxvY2tPcmllbnRhdGlvbiwgaW5saW5lRGlyZWN0aW9uLCBpbmxpbmVPcmllbnRhdGlvbiB9ID0gbG9naWNhbERpcmVjdGlvbjtcbiAgICBpZiAocG9zaXRpb24gPT09IFwiYmxvY2stc3RhcnRcIiB8fCBwb3NpdGlvbiA9PSBcImJsb2NrLWVuZFwiKSB7XG4gICAgICAgIHN3aXRjaCAoYCR7cG9zaXRpb259LSR7YmxvY2tEaXJlY3Rpb259YCkge1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrLXN0YXJ0LXR0YlwiOlxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwidG9wXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stZW5kLWJ0dFwiOlxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwidG9wXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stc3RhcnQtYnR0XCI6XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJib3R0b21cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1lbmQtdHRiXCI6XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJib3R0b21cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1zdGFydC1sdHJcIjpcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1lbmQtcnRsXCI6XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stZW5kLWx0clwiOlxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1zdGFydC1ydGxcIjpcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcInJpZ2h0XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwiYm90dG9tXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoYCR7cG9zaXRpb259LSR7aW5saW5lRGlyZWN0aW9ufWApIHtcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtc3RhcnQtbHRyXCI6XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLWVuZC1ydGxcIjpcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtZW5kLWx0clwiOlxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtc3RhcnQtcnRsXCI6XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJyaWdodFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImlubGluZS1zdGFydC10dGJcIjpcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBcInRvcFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImlubGluZS1lbmQtYnR0XCI6XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gXCJ0b3BcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtZW5kLXR0YlwiOlxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwiYm90dG9tXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLXN0YXJ0LWJ0dFwiOlxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwiYm90dG9tXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGxhY2VtZW50O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNob3VsZFVwZGF0ZVBvcHBlcihvcGVuLCBlbGVtZW50U2l6ZSkge1xuICAgIC8vIFNpbmNlIHNjcm9sbCBldmVudHMgYXJlIGFzeW5jaHJvbm91cywgZXNwZWNpYWxseSBvbiBpT1MgZGV2aWNlcyxcbiAgICAvLyBqdXN0IG1hbnVhbGx5IGFkanVzdCB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlciBmb3IgYSBiaXRcbiAgICAvLyBhbnkgdGltZSBiYXNpY2FsbHkgYW55IHVzZXIgaW50ZXJhY3Rpb24gaGFwcGVucy5cbiAgICBjb25zdCBbdXBkYXRpbmdGb3JBQml0LCBzZXRVcGRhdGluZ0ZvckFCaXRdID0gdXNlU3RhdGUoMCk7XG4gICAgdXNlVGltZW91dCh7IGNhbGxiYWNrOiAoKSA9PiB7IHNldFVwZGF0aW5nRm9yQUJpdCgwKTsgfSwgdGltZW91dDogMTAwLCB0cmlnZ2VySW5kZXg6IHVwZGF0aW5nRm9yQUJpdCB9KTtcbiAgICBsZXQgb25JbnRlcmFjdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHsgc2V0VXBkYXRpbmdGb3JBQml0KHUgPT4gKyt1KTsgfSwgW2Nsb3NlZF0pO1xuICAgIGlmICghb3BlbilcbiAgICAgICAgb25JbnRlcmFjdGlvbiA9IG51bGw7XG4gICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJrZXlkb3duXCIsIG9uSW50ZXJhY3Rpb24sIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJzY3JvbGxcIiwgb25JbnRlcmFjdGlvbiwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pO1xuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcInBvaW50ZXJtb3ZlXCIsIG9uSW50ZXJhY3Rpb24sIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJjbGlja1wiLCBvbkludGVyYWN0aW9uLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSk7XG4gICAgdXNlR2xvYmFsSGFuZGxlcih3aW5kb3csIFwicmVzaXplXCIsIG9uSW50ZXJhY3Rpb24sIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4geyBvbkludGVyYWN0aW9uPy4oKTsgfSwgT2JqZWN0LnZhbHVlcyhlbGVtZW50U2l6ZSA/PyB7fSkpO1xuICAgIHJldHVybiB7IHNob3VsZFVwZGF0ZTogISF1cGRhdGluZ0ZvckFCaXQsIG9uSW50ZXJhY3Rpb24gfTtcbn1cbi8qKlxuICogSGFuZGxlIHRoZSBlLmcuIHpvb21PcmlnaW5EeW5hbWljIHByb3BzLCB0byB0dXJuIHRoZW0gaW50byB6b29tT3JpZ2luSW5saW5lIG9yIHpvb21PcmlnaW5CbG9jayBhcyBhcHByb3ByaWF0ZS5cbiAqIFRPRE86IFJpZ2h0IG5vdywgYWxsICpEeW5hbWljIHByb3BzIGFyZSBqdXN0IGhhbmRsZWQgYXMgMSAtIHByb3AuIFNvbWUgcHJvYmFibHkgbmVlZCB0byBiZSAtMSAqIHByb3AgdGhvdWdoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZml4UHJvcHMobG9naWNhbERpcmVjdGlvbiwgcmVxdWVzdGVkUGxhY2VtZW50LCB1c2VkUGxhY2VtZW50LCBwcm9wcykge1xuICAgIGxldCBsb2dpY2FsU25ha2UgPSBwbGFjZW1lbnRUb0xvZ2ljYWwobG9naWNhbERpcmVjdGlvbiwgdXNlZFBsYWNlbWVudCk7XG4gICAgbGV0IHByb3BBeGlzO1xuICAgIGxldCByZXZlcnNlO1xuICAgIHN3aXRjaCAobG9naWNhbFNuYWtlKSB7XG4gICAgICAgIGNhc2UgXCJibG9jay1zdGFydFwiOlxuICAgICAgICAgICAgcHJvcEF4aXMgPSBcIkJsb2NrXCI7XG4gICAgICAgICAgICByZXZlcnNlID0gKHJlcXVlc3RlZFBsYWNlbWVudCA9PSBcImJsb2NrLWVuZFwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmxvY2stZW5kXCI6XG4gICAgICAgICAgICBwcm9wQXhpcyA9IFwiQmxvY2tcIjtcbiAgICAgICAgICAgIHJldmVyc2UgPSAocmVxdWVzdGVkUGxhY2VtZW50ID09IFwiYmxvY2stc3RhcnRcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlubGluZS1zdGFydFwiOlxuICAgICAgICAgICAgcHJvcEF4aXMgPSBcIklubGluZVwiO1xuICAgICAgICAgICAgcmV2ZXJzZSA9IChyZXF1ZXN0ZWRQbGFjZW1lbnQgPT0gXCJpbmxpbmUtZW5kXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbmxpbmUtZW5kXCI6XG4gICAgICAgICAgICBwcm9wQXhpcyA9IFwiSW5saW5lXCI7XG4gICAgICAgICAgICByZXZlcnNlID0gKHJlcXVlc3RlZFBsYWNlbWVudCA9PSBcImlubGluZS1zdGFydFwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgbmV3UHJvcHMgPSB7IC4uLnByb3BzIH07XG4gICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BOYW1lLmVuZHNXaXRoKFwiRHluYW1pY1wiKSAmJiB0eXBlb2YgcHJvcHNbcHJvcE5hbWVdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBsZXQgbmV3UHJvcE5hbWUgPSBgJHtwcm9wTmFtZS5zdWJzdHIoMCwgcHJvcE5hbWUuaW5kZXhPZihcIkR5bmFtaWNcIikpfSR7cHJvcEF4aXN9YDtcbiAgICAgICAgICAgIG5ld1Byb3BzW25ld1Byb3BOYW1lXSA9ICghcmV2ZXJzZSA/IG5ld1Byb3BzW3Byb3BOYW1lXSA6IDEgLSBuZXdQcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICAgICAgZGVsZXRlIG5ld1Byb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3UHJvcHM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXItYXBpLmpzLm1hcCIsImltcG9ydCB7IGNsb25lRWxlbWVudCwgY3JlYXRlQ29udGV4dCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VBcmlhTWVudSB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzXCI7XG5pbXBvcnQgeyB1c2VFbGVtZW50U2l6ZSwgdXNlTWVyZ2VkUHJvcHMsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBCb2R5UG9ydGFsIH0gZnJvbSBcIi4uL3BvcnRhbFwiO1xuaW1wb3J0IHsgZml4UHJvcHMsIHVzZVBvcHBlckFwaSwgdXNlU2hvdWxkVXBkYXRlUG9wcGVyIH0gZnJvbSBcIi4vcG9wcGVyLWFwaVwiO1xuZnVuY3Rpb24gZm9vKHBsYWNlbWVudCwgcHJvcHMpIHtcbn1cbmNvbnN0IE9uQ2xvc2VDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuY29uc3QgVXNlTWVudUl0ZW1Db250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydCBmdW5jdGlvbiBNZW51KHsgYW5jaG9yLCBhbmNob3JUYWcsIGNoaWxkcmVuLCB0YWcsIFRyYW5zaXRpb24sIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBvbkNsb3NlID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0T3BlbihmYWxzZSksIFtdKTtcbiAgICBjb25zdCBvbk9wZW4gPSAoKSA9PiBzZXRPcGVuKHRydWUpO1xuICAgIGNvbnN0IHsgdXNlRWxlbWVudFNpemVQcm9wcywgZWxlbWVudFNpemUgfSA9IHVzZUVsZW1lbnRTaXplKCk7XG4gICAgY29uc3QgeyBzaG91bGRVcGRhdGU6IHVwZGF0aW5nRm9yQUJpdCwgb25JbnRlcmFjdGlvbiB9ID0gdXNlU2hvdWxkVXBkYXRlUG9wcGVyKG9wZW4sIGVsZW1lbnRTaXplKTtcbiAgICBjb25zdCB7IHVzZVBvcHBlckFycm93LCB1c2VQb3BwZXJQb3B1cCwgdXNlUG9wcGVyU291cmNlLCB1c2VkUGxhY2VtZW50LCBnZXRMb2dpY2FsRGlyZWN0aW9uIH0gPSB1c2VQb3BwZXJBcGkoeyBwb3NpdGlvbjogXCJibG9jay1lbmRcIiwgdXBkYXRpbmc6IHVwZGF0aW5nRm9yQUJpdCB9KTtcbiAgICBjb25zdCB7IHVzZU1lbnVCdXR0b24sIHVzZU1lbnVJdGVtLCB1c2VNZW51SXRlbUNoZWNrYm94LCB1c2VNZW51UHJvcHMsIHVzZU1lbnVTdWJtZW51SXRlbSwgZm9jdXNNZW51IH0gPSB1c2VBcmlhTWVudSh7IG9wZW4sIG9uQ2xvc2UsIG9uT3BlbiB9KTtcbiAgICBjb25zdCB7IHVzZU1lbnVCdXR0b25Qcm9wcyB9ID0gdXNlTWVudUJ1dHRvbih7IHRhZzogYW5jaG9yVGFnID8/IFwiYnV0dG9uXCIgfSk7XG4gICAgY29uc3QgeyB1c2VQb3BwZXJTb3VyY2VQcm9wcyB9ID0gdXNlUG9wcGVyU291cmNlKCk7XG4gICAgY29uc3QgeyB1c2VQb3BwZXJQb3B1cFByb3BzIH0gPSB1c2VQb3BwZXJQb3B1cCh7IG9wZW4gfSk7XG4gICAgY29uc3QgeyB1c2VQb3BwZXJBcnJvd1Byb3BzIH0gPSB1c2VQb3BwZXJBcnJvdygpO1xuICAgIC8qY29uc3QgW3NlbnRpbmVsRm9jdXNlZCwgc2V0U2VudGluZWxGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICB1c2VUaW1lb3V0KHsgY2FsbGJhY2s6ICgpID0+IHsgaWYgKHNlbnRpbmVsRm9jdXNlZCkgb25DbG9zZSgpOyBzZXRTZW50aW5lbEZvY3VzZWQoZmFsc2UpOyB9LCB0aW1lb3V0OiAxMDAwLCB0cmlnZ2VySW5kZXg6IHNlbnRpbmVsRm9jdXNlZC50b1N0cmluZygpIH0pKi9cbiAgICBjb25zdCBbZmlyc3RTZW50aW5lbElzQWN0aXZlLCBzZXRGaXJzdFNlbnRpbmVsSXNBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHVzZVRpbWVvdXQoeyBjYWxsYmFjazogKCkgPT4geyBzZXRGaXJzdFNlbnRpbmVsSXNBY3RpdmUob3Blbik7IH0sIHRpbWVvdXQ6IDEwMCwgdHJpZ2dlckluZGV4OiBgJHtmaXJzdFNlbnRpbmVsSXNBY3RpdmV9YCB9KTtcbiAgICBjb25zdCBtZW51Q2hpbGRyZW4gPSAoaChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgaChcImRpdlwiLCB7IC4uLnVzZVBvcHBlckFycm93UHJvcHMoe30pIH0pLFxuICAgICAgICBoKFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBcInZpc3VhbGx5LWhpZGRlblwiLCBvbkZvY3VzOiAhZmlyc3RTZW50aW5lbElzQWN0aXZlID8gKCkgPT4gZm9jdXNNZW51KCkgOiAoKSA9PiBvbkNsb3NlKCksIG9uQ2xpY2s6IG9uQ2xvc2UgfSwgXCJDbG9zZSBtZW51XCIpLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogXCJ2aXN1YWxseS1oaWRkZW5cIiwgb25Gb2N1czogb25DbG9zZSwgb25DbGljazogb25DbG9zZSB9LCBcIkNsb3NlIG1lbnVcIikpKTtcbiAgICBjb25zdCBsb2dpY2FsRGlyZWN0aW9uID0gZ2V0TG9naWNhbERpcmVjdGlvbigpO1xuICAgIGlmIChsb2dpY2FsRGlyZWN0aW9uICYmIHVzZWRQbGFjZW1lbnQpXG4gICAgICAgIHJlc3QgPSBmaXhQcm9wcyhsb2dpY2FsRGlyZWN0aW9uLCBcImJsb2NrLWVuZFwiLCB1c2VkUGxhY2VtZW50LCByZXN0KTtcbiAgICByZXR1cm4gKGgoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGgoT25DbG9zZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IG9uQ2xvc2UgfSxcbiAgICAgICAgICAgIGgoVXNlTWVudUl0ZW1Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VNZW51SXRlbSB9LFxuICAgICAgICAgICAgICAgIGNsb25lRWxlbWVudChhbmNob3IsIHVzZU1lcmdlZFByb3BzKCkodXNlRWxlbWVudFNpemVQcm9wcyh7IHJlZjogYW5jaG9yLnJlZiwgY2xhc3M6IGBkcm9wZG93bi10b2dnbGUgJHtvcGVuID8gXCJhY3RpdmVcIiA6IFwiXCJ9YCB9KSwgdXNlUG9wcGVyU291cmNlUHJvcHModXNlTWVudUJ1dHRvblByb3BzKGFuY2hvci5wcm9wcykpKSksXG4gICAgICAgICAgICAgICAgaChCb2R5UG9ydGFsLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlUG9wcGVyUG9wdXBQcm9wcyh7IGNsYXNzOiBcImRyb3Bkb3duLW1lbnUtcG9wcGVyXCIgfSkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoVHJhbnNpdGlvbiwgeyAuLi51c2VNZW51UHJvcHMocmVzdCksIG9wZW46IG9wZW4sIG9uVHJhbnNpdGlvblVwZGF0ZTogb25JbnRlcmFjdGlvbiwgZXhpdFZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIG51bGwsIGgodGFnLCB7IGNoaWxkcmVuOiBtZW51Q2hpbGRyZW4sIGNsYXNzTmFtZTogXCJkcm9wZG93bi1tZW51XCIgfSkpKSkpKSkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBNZW51SXRlbSh7IGNoaWxkcmVuLCBpbmRleCwgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgdXNlTWVudUl0ZW0gPSB1c2VDb250ZXh0KFVzZU1lbnVJdGVtQ29udGV4dCk7XG4gICAgY29uc3QgW3RleHQsIHNldFRleHRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQoKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgIHNldFRleHQoZWxlbWVudC5pbm5lclRleHQpO1xuICAgIH0sIFtlbGVtZW50XSk7XG4gICAgY29uc3QgeyB1c2VNZW51SXRlbVByb3BzIH0gPSB1c2VNZW51SXRlbSh7IGluZGV4LCB0ZXh0IH0pO1xuICAgIHJldHVybiAoaChcImxpXCIsIG51bGwsXG4gICAgICAgIGgoXCJidXR0b25cIiwgeyAuLi51c2VNZW51SXRlbVByb3BzKHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VNZXJnZWRQcm9wcygpKHJlc3QsIHsgY2xhc3M6IFwiZHJvcGRvd24taXRlbVwiIH0pKSkgfSwgY2hpbGRyZW4pKSk7XG59XG5mdW5jdGlvbiBmbGlwVHJhbnNpdGlvbkNvbXBvbmVudChpbnB1dCwgeyBpbmxpbmUsIGJsb2NrIH0pIHtcbiAgICBsZXQgb3V0cHV0ID0geyAuLi5pbnB1dCB9O1xuICAgIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gb3V0cHV0KSB7XG4gICAgICAgIGlmIChvdXRwdXRbYCR7cHJvcE5hbWV9RmxpcHNgXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGwgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgaXNJbmxpbmUgPSBsLmluY2x1ZGVzKFwiaW5saW5lXCIpO1xuICAgICAgICAgICAgY29uc3QgaXNCbG9jayA9IGwuaW5jbHVkZXMoXCJibG9ja1wiKTtcbiAgICAgICAgICAgIGlmICgoaXNJbmxpbmUgJiYgaW5saW5lKSB8fCAoaXNCbG9jayAmJiBibG9jaykpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3V0cHV0W2Ake3Byb3BOYW1lfUZsaXBzYF07XG4gICAgICAgICAgICAgICAgb3V0cHV0W3Byb3BOYW1lXSA9IC1pbnB1dFtwcm9wTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbnUuanMubWFwIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlUmFuZG9tSWQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtcmFuZG9tLWlkXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlRm9jdXNUcmFwIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWZvY3VzLXRyYXBcIjtcbmltcG9ydCB7IEJvZHlQb3J0YWwgfSBmcm9tIFwiLi4vcG9ydGFsXCI7XG5pbXBvcnQgeyBGYWRlIH0gZnJvbSBcInByZWFjdC10cmFuc2l0aW9uL2ZhZGVcIjtcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gXCIuLi9idXR0b25cIjtcbmltcG9ydCB7IHVzZUdsb2JhbEhhbmRsZXIgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFPZmZjYW52YXMoeyBvcGVuLCBvbkNsb3NlIH0pIHtcbiAgICBjb25zdCBbb2ZmY2FudmFzRGVzY3JpYmVkQnlCb2R5LCBzZXRPZmZjYW52YXNEZXNjcmliZWRCeUJvZHldID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgaWQ6IG9mZmNhbnZhc0lkLCB1c2VSYW5kb21JZFByb3BzOiB1c2VPZmZjYW52YXNJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlT2ZmY2FudmFzUmVmZXJlbmNpbmdJZFByb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLW9mZmNhbnZhcy1cIiB9KTtcbiAgICBjb25zdCB7IGlkOiBib2R5SWQsIHVzZVJhbmRvbUlkUHJvcHM6IHVzZUJvZHlJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlQm9keVJlZmVyZW5jaW5nSWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1vZmZjYW52YXMtYm9keS1cIiB9KTtcbiAgICBjb25zdCB7IGlkOiB0aXRsZUlkLCB1c2VSYW5kb21JZFByb3BzOiB1c2VUaXRsZUlkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzOiB1c2VUaXRsZVJlZmVyZW5jaW5nSWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1vZmZjYW52YXMtdGl0bGUtXCIgfSk7XG4gICAgdXNlR2xvYmFsSGFuZGxlcih3aW5kb3csIFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICAgIGlmICghKG9mZmNhbnZhc0lkICYmIGUudGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvZmZjYW52YXNJZCk/LmNvbnRhaW5zKGUudGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIG9uQ2xvc2UoXCJiYWNrZHJvcFwiKTtcbiAgICAgICAgfVxuICAgIH0sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICBjb25zdCBvbktleURvd24gPSAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgIG9uQ2xvc2UoXCJlc2NhcGVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVzZU9mZmNhbnZhc0JhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvL2NvbnN0IG9uQ2xpY2s6IGguSlNYLkV2ZW50SGFuZGxlcjxoLkpTWC5UYXJnZXRlZEV2ZW50PEJhY2tkcm9wRWxlbWVudD4+ID0gZSA9PiBvbkNsb3NlKFwiZXNjYXBlXCIpO1xuICAgICAgICBmdW5jdGlvbiB1c2VPZmZjYW52YXNCYWNrZHJvcFByb3BzKHByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoKSh7fSwgcHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHVzZU9mZmNhbnZhc0JhY2tkcm9wUHJvcHMgfTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZU9mZmNhbnZhc1Byb3BzID0gZnVuY3Rpb24gKHsgXCJhcmlhLW1vZGFsXCI6IGFyaWFNb2RhbCwgcm9sZSwgLi4ucDAgfSkge1xuICAgICAgICBjb25zdCB7IHVzZUZvY3VzVHJhcFByb3BzIH0gPSB1c2VGb2N1c1RyYXAoeyB0cmFwQWN0aXZlOiBvcGVuIH0pO1xuICAgICAgICBjb25zdCBwMSA9IHVzZVRpdGxlUmVmZXJlbmNpbmdJZFByb3BzKFwiYXJpYS1sYWJlbGxlZGJ5XCIpKHAwKTtcbiAgICAgICAgY29uc3QgcDIgPSB1c2VPZmZjYW52YXNJZFByb3BzKHAxKTtcbiAgICAgICAgY29uc3QgcEZpbmFsID0gdXNlQm9keVJlZmVyZW5jaW5nSWRQcm9wcyhcImFyaWEtZGVzY3JpYmVkYnlcIikocDIpO1xuICAgICAgICByZXR1cm4gdXNlRm9jdXNUcmFwUHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IHJvbGU6IFwib2ZmY2FudmFzXCIsIG9uS2V5RG93biB9LCBvZmZjYW52YXNEZXNjcmliZWRCeUJvZHkgPyBwRmluYWwgOiBwMikpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdXNlT2ZmY2FudmFzVGl0bGUoKSB7XG4gICAgICAgIGNvbnN0IHVzZU9mZmNhbnZhc1RpdGxlUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VUaXRsZUlkUHJvcHMocHJvcHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyB1c2VPZmZjYW52YXNUaXRsZVByb3BzIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZU9mZmNhbnZhc0JvZHkoeyBkZXNjcmlwdGl2ZSB9KSB7XG4gICAgICAgIHNldE9mZmNhbnZhc0Rlc2NyaWJlZEJ5Qm9keShkZXNjcmlwdGl2ZSk7XG4gICAgICAgIGNvbnN0IHVzZU9mZmNhbnZhc0JvZHlQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIHVzZUJvZHlJZFByb3BzKHByb3BzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgdXNlT2ZmY2FudmFzQm9keVByb3BzIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZU9mZmNhbnZhc1Byb3BzLFxuICAgICAgICB1c2VPZmZjYW52YXNUaXRsZSxcbiAgICAgICAgdXNlT2ZmY2FudmFzQm9keSxcbiAgICAgICAgdXNlT2ZmY2FudmFzQmFja2Ryb3BcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIE9mZmNhbnZhcyh7IG9uQ2xvc2UsIG9wZW4sIGRlc2NyaXB0aXZlLCB0aXRsZSwgZm9vdGVyLCBUcmFuc2l0aW9uLCBjaGlsZHJlbiwgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgeyB1c2VPZmZjYW52YXNCYWNrZHJvcCwgdXNlT2ZmY2FudmFzQm9keSwgdXNlT2ZmY2FudmFzUHJvcHMsIHVzZU9mZmNhbnZhc1RpdGxlIH0gPSB1c2VBcmlhT2ZmY2FudmFzKHsgb3Blbiwgb25DbG9zZSB9KTtcbiAgICBjb25zdCB7IHVzZU9mZmNhbnZhc0JhY2tkcm9wUHJvcHMgfSA9IHVzZU9mZmNhbnZhc0JhY2tkcm9wKCk7XG4gICAgY29uc3QgeyB1c2VPZmZjYW52YXNCb2R5UHJvcHMsIH0gPSB1c2VPZmZjYW52YXNCb2R5KHsgZGVzY3JpcHRpdmUgfSk7XG4gICAgY29uc3QgeyB1c2VPZmZjYW52YXNUaXRsZVByb3BzIH0gPSB1c2VPZmZjYW52YXNUaXRsZSgpO1xuICAgIHJldHVybiAoaChCb2R5UG9ydGFsLCBudWxsLFxuICAgICAgICBoKFwiZGl2XCIsIG51bGwsXG4gICAgICAgICAgICBoKEZhZGUsIHsgb3Blbjogb3BlbiB9LFxuICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VPZmZjYW52YXNCYWNrZHJvcFByb3BzKHsgY2xhc3M6IFwib2ZmY2FudmFzLWJhY2tkcm9wIGJhY2tkcm9wLWZpbHRlci10cmFuc2l0aW9uXCIgfSkgfSkpLFxuICAgICAgICAgICAgaChUcmFuc2l0aW9uLCB7IC4uLnsgb3BlbiwgLi4ucmVzdCB9IH0sXG4gICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IC4uLnVzZU9mZmNhbnZhc1Byb3BzKHsgY2xhc3M6IFwib2ZmY2FudmFzIG9mZmNhbnZhcy1zdGFydFwiLCB0YWJpbmRleDogLTEgfSkgfSxcbiAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzOiBcIm9mZmNhbnZhcy1oZWFkZXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaChcImg1XCIsIHsgLi4udXNlT2ZmY2FudmFzVGl0bGVQcm9wcyh7IGNsYXNzOiBcIm9mZmNhbnZhcy10aXRsZVwiIH0pIH0sIFwiT2ZmY2FudmFzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaChCdXR0b24sIHsgdGFnOiBcImJ1dHRvblwiLCBjbGFzczogXCJidG4tY2xvc2UgdGV4dC1yZXNldFwiLCBcImFyaWEtbGFiZWxcIjogXCJDbG9zZVwiLCBvbkNsaWNrOiAoKSA9PiBvbkNsb3NlKFwiZXNjYXBlXCIpIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IC4uLnVzZU9mZmNhbnZhc0JvZHlQcm9wcyh7IGNsYXNzOiBcIm9mZmNhbnZhcy1ib2R5XCIgfSkgfSwgXCJDb250ZW50IGZvciB0aGUgb2ZmY2FudmFzIGdvZXMgaGVyZS5Zb3UgY2FuIHBsYWNlIGp1c3QgYWJvdXQgYW55IEJvb3RzdHJhcCBjb21wb25lbnQgb3IgY3VzdG9tIGVsZW1lbnRzIGhlcmUuXCIpKSkpKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZmZjYW52YXMuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuZXhwb3J0IGNvbnN0IEluSW5wdXRHcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0KGZhbHNlKTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnB1dENhcHR1cmVzKHR5cGUpIHtcbiAgICBjb25zdCBjYXB0dXJlID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyO1xuICAgICAgICB9XG4gICAgfSwgW3R5cGVdKTtcbiAgICBjb25zdCB1bmNhcHR1cmUgPSB1c2VDYWxsYmFjaygodmFsdWUpID0+IHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgICAgICAgfVxuICAgIH0sIFt0eXBlXSk7XG4gICAgcmV0dXJuIHsgY2FwdHVyZSwgdW5jYXB0dXJlIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wcy5qcy5tYXAiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VBcmlhQ2hlY2tib3gsIHVzZUNoZWNrYm94R3JvdXAgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0c1wiO1xuaW1wb3J0IHsgRXZlbnREZXRhaWwgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlQXN5bmNIYW5kbGVyLCB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEluSW5wdXRHcm91cENvbnRleHQgfSBmcm9tIFwiLi9wcm9wc1wiO1xuZnVuY3Rpb24gY2FwdHVyZShlKSB7XG4gICAgcmV0dXJuIGVbRXZlbnREZXRhaWxdLmNoZWNrZWQ7XG59XG4vKipcbiAqIFRPRE86IFdoZW4gaW5zaWRlIGFuIElucHV0R3JvdXAsIENoZWNrYm94ZXMgZG9uJ3QgZm9yd2FyZCBhbnkgcHJvcGVydGllcyBvciByZWZzIGJlY2F1c2UgdGhlcmUncyBubyBvbmUgRE9NIGVsZW1lbnQgdG8gYXR0YWNoIHRvLlxuICpcbiAqIFByb2JhYmx5IG5lZWQgc2VwYXJhdGUgYGlucHV0UmVmYCAmIGBsYWJlbFJlZmAgcHJvcGVydGllcyBmb3IgdGhhdCxcbiAqIGJ1dCBnaXZlbiB0aGVyZSdzIGFsc28gbm8gZWFzeSB3YXkgdG8gZm9yd2FyZCBwcm9wcyB0byBqdXN0IHRoZW0gYSBzb2x1dGlvbiBsaWtlIHRoYXQgZmVlbHMgaW5jb21wbGV0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENoZWNrYm94KHsgY2hlY2tlZCwgZGlzYWJsZWQsIG9uSW5wdXQ6IG9uSW5wdXRBc3luYywgbGFiZWwsIGxhYmVsUG9zaXRpb24sIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgbGFiZWxQb3NpdGlvbiA/Pz0gXCJlbmRcIjtcbiAgICBjb25zdCB7IGdldFN5bmNIYW5kbGVyLCBwZW5kaW5nIH0gPSB1c2VBc3luY0hhbmRsZXIoKSh7IGNhcHR1cmUgfSk7XG4gICAgY29uc3Qgb25JbnB1dCA9IGdldFN5bmNIYW5kbGVyKG9uSW5wdXRBc3luYyk7XG4gICAgY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQgfSA9IHVzZUFyaWFDaGVja2JveCh7IGNoZWNrZWQ6IGNoZWNrZWQgPT09IFwiaW5kZXRlcm1pbmF0ZVwiID8gXCJtaXhlZFwiIDogY2hlY2tlZCwgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlLCBvbklucHV0LCBsYWJlbFBvc2l0aW9uOiBcInNlcGFyYXRlXCIgfSk7XG4gICAgY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveElucHV0RWxlbWVudCh7IHRhZzogXCJpbnB1dFwiIH0pO1xuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoeyB0YWc6IFwibGFiZWxcIiB9KTtcbiAgICBjb25zdCBpbklucHV0R3JvdXAgPSB1c2VDb250ZXh0KEluSW5wdXRHcm91cENvbnRleHQpO1xuICAgIGxldCBzdHJpbmdMYWJlbCA9IGAke2xhYmVsfWA7XG4gICAgaWYgKGxhYmVsICE9IG51bGwgJiYgbGFiZWxQb3NpdGlvbiA9PT0gXCJoaWRkZW5cIiAmJiAhW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiXS5pbmNsdWRlcyh0eXBlb2YgbGFiZWwpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEhpZGRlbiBsYWJlbHMgcmVxdWlyZSBhIHN0cmluZy1iYXNlZCBsYWJlbCBmb3IgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlLmApO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSBoKE9wdGlvbmFsbHlJbnB1dEdyb3VwLCBudWxsLFxuICAgICAgICBoKFwiaW5wdXRcIiwgeyAuLi51c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKHsgdHlwZTogXCJjaGVja2JveFwiLCBjbGFzc05hbWU6IGNsc3goXCJmb3JtLWNoZWNrLWlucHV0XCIsIGluSW5wdXRHcm91cCAmJiBcIm10LTBcIiksIFwiYXJpYS1sYWJlbFwiOiBsYWJlbFBvc2l0aW9uID09PSBcImhpZGRlblwiID8gc3RyaW5nTGFiZWwgOiB1bmRlZmluZWQgfSkgfSkpO1xuICAgIGNvbnN0IGxhYmVsRWxlbWVudCA9IGgoRnJhZ21lbnQsIG51bGwsIGxhYmVsICE9IG51bGwgJiYgaChPcHRpb25hbGx5SW5wdXRHcm91cCwgbnVsbCxcbiAgICAgICAgaChcImxhYmVsXCIsIHsgLi4udXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyh7IGNsYXNzTmFtZTogXCJmb3JtLWNoZWNrLWxhYmVsXCIsIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSkgfSwgbGFiZWwpKSk7XG4gICAgY29uc3QgcmV0ID0gKGgoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGxhYmVsUG9zaXRpb24gPT0gXCJzdGFydFwiICYmIGxhYmVsRWxlbWVudCxcbiAgICAgICAgaW5wdXRFbGVtZW50LFxuICAgICAgICBsYWJlbFBvc2l0aW9uID09IFwiZW5kXCIgJiYgbGFiZWxFbGVtZW50KSk7XG4gICAgaWYgKCFpbklucHV0R3JvdXApXG4gICAgICAgIHJldHVybiBoKFwiZGl2XCIsIHsgLi4udXNlTWVyZ2VkUHJvcHMoKShyZXN0LCB7IHJlZiwgY2xhc3M6IFwiZm9ybS1jaGVja1wiIH0pIH0sIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IENoZWNrYm94R3JvdXBQYXJlbnRDaGVja2JveFByb3BzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydCBmdW5jdGlvbiBDaGVja2JveEdyb3VwKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHsgcGVyY2VudENoZWNrZWQsIHNlbGZJc0NoZWNrZWQsIG9uQ2hlY2tib3hHcm91cElucHV0LCB1c2VDaGVja2JveEdyb3VwQ2hlY2tib3hQcm9wcywgdXNlQ2hlY2tib3hHcm91cENoaWxkIH0gPSB1c2VDaGVja2JveEdyb3VwKHt9KTtcbiAgICByZXR1cm4gKGgoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGgoQ2hlY2tib3hHcm91cFBhcmVudENoZWNrYm94UHJvcHNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VDaGVja2JveEdyb3VwQ2hlY2tib3hQcm9wcyB9LFxuICAgICAgICAgICAgaChDaGVja2JveCwgeyBjbGFzc05hbWU6IFwiY2hlY2tib3gtZ3JvdXAtcGFyZW50XCIsIGNoZWNrZWQ6IHNlbGZJc0NoZWNrZWQsIG9uSW5wdXQ6IHVzZUNhbGxiYWNrKChjaGVja2VkLCBlKSA9PiB7IG9uQ2hlY2tib3hHcm91cElucHV0KGUpOyB9LCBbb25DaGVja2JveEdyb3VwSW5wdXRdKSB9KSksXG4gICAgICAgIGgoQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlQ2hlY2tib3hHcm91cENoaWxkIH0sIGNoaWxkcmVuKSkpO1xufVxuZnVuY3Rpb24gT3B0aW9uYWxseUlucHV0R3JvdXAoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgaW5JbnB1dEdyb3VwID0gdXNlQ29udGV4dChJbklucHV0R3JvdXBDb250ZXh0KTtcbiAgICBpZiAoIWluSW5wdXRHcm91cClcbiAgICAgICAgcmV0dXJuIGgoRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbiAgICByZXR1cm4gaChcImRpdlwiLCB7IGNsYXNzOiBcImlucHV0LWdyb3VwLXRleHRcIiB9LCBjaGlsZHJlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnB1dC1jaGVjay5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBGcmFnbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcInByZWFjdC1hcmlhLXdpZGdldHMvcHJvcHNcIjtcbmltcG9ydCB7IHVzZUdlbmVyaWNMYWJlbCB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1sYWJlbFwiO1xuaW1wb3J0IHsgdXNlQXJpYVJhZGlvR3JvdXAgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtcmFkaW8tZ3JvdXBcIjtcbmltcG9ydCB7IHVzZUFzeW5jSGFuZGxlciwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2hpbGRGbGFnIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTcGlubmVyRGVsYXkgfSBmcm9tIFwiLi4vcHJvcHNcIjtcbmltcG9ydCB7IFByb2dyZXNzQ2lyY3VsYXIgfSBmcm9tIFwiLi4vcHJvZ3Jlc3NcIjtcbmltcG9ydCB7IEluSW5wdXRHcm91cENvbnRleHQgfSBmcm9tIFwiLi9wcm9wc1wiO1xuY29uc3QgUmFkaW9Hcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuZXhwb3J0IGZ1bmN0aW9uIFJhZGlvR3JvdXAoeyBjaGlsZHJlbiwgbmFtZSwgc2VsZWN0ZWRWYWx1ZSwgbGFiZWwsIGxhYmVsUG9zaXRpb24sIG9uSW5wdXQ6IG9uSW5wdXRBc3luYyB9KSB7XG4gICAgY29uc3QgeyBnZXRTeW5jSGFuZGxlciwgcGVuZGluZywgaGFzRXJyb3IsIHNldHRsZUNvdW50LCBjdXJyZW50Q2FwdHVyZSB9ID0gdXNlQXN5bmNIYW5kbGVyKCkoeyBjYXB0dXJlOiAoZSkgPT4gZVtFdmVudERldGFpbF0uc2VsZWN0ZWRWYWx1ZSB9KTtcbiAgICBjb25zdCBvbklucHV0ID0gZ2V0U3luY0hhbmRsZXIob25JbnB1dEFzeW5jKTtcbiAgICBjb25zdCB7IHVzZVJhZGlvLCB1c2VSYWRpb0dyb3VwUHJvcHMsIG1hbmFnZWRDaGlsZHJlbiwgZ2V0SW5kZXggfSA9IHVzZUFyaWFSYWRpb0dyb3VwKHsgbmFtZSwgc2VsZWN0ZWRWYWx1ZTogY3VycmVudENhcHR1cmUgPz8gc2VsZWN0ZWRWYWx1ZSwgb25JbnB1dDogb25JbnB1dCB9KTtcbiAgICBsZXQgc3RyaW5nTGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgaWYgKGxhYmVsICE9IG51bGwgJiYgIVtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0uaW5jbHVkZXModHlwZW9mIGxhYmVsKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSGlkZGVuIGxhYmVscyByZXF1aXJlIGEgc3RyaW5nLWJhc2VkIGxhYmVsIGZvciB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJpbmdMYWJlbCA9IGAke2xhYmVsfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IGdldEluZGV4KGN1cnJlbnRDYXB0dXJlID8/IHNlbGVjdGVkVmFsdWUpO1xuICAgIC8vY29uc3QgY2FwdHVyZWRJbmRleCA9IGdldEluZGV4KGN1cnJlbnRDYXB0dXJlISk7XG4gICAgdXNlQ2hpbGRGbGFnKHNlbGVjdGVkSW5kZXgsIG1hbmFnZWRDaGlsZHJlbi5sZW5ndGgsIChpbmRleCwgaXNTZWxlY3RlZCkgPT4gbWFuYWdlZENoaWxkcmVuW2luZGV4XS5zZXRBc3luY1N0YXRlKGlzU2VsZWN0ZWQgPyAoaGFzRXJyb3IgPyBcImZhaWxlZFwiIDogcGVuZGluZyA/IFwicGVuZGluZ1wiIDogXCJzdWNjZWVkZWRcIikgOiBudWxsKSk7XG4gICAgLy8gdXNlQ2hpbGRGbGFnKHBlbmRpbmcgPyBjYXB0dXJlZEluZGV4IDogbnVsbCwgbWFuYWdlZENoaWxkcmVuLmxlbmd0aCwgdXNlQ2FsbGJhY2soKGluZGV4LCBpc0NhcHR1cmVkKSA9PiBtYW5hZ2VkQ2hpbGRyZW5baW5kZXhdLnNldFBlbmRpbmcoaXNDYXB0dXJlZD8gXCJpblwiIDogZmFsc2UpLCBbXSkpO1xuICAgIGNvbnN0IHsgdXNlR2VuZXJpY0xhYmVsTGFiZWwsIHVzZUdlbmVyaWNMYWJlbElucHV0IH0gPSB1c2VHZW5lcmljTGFiZWwoeyBpbnB1dFByZWZpeDogXCJhcmlhLXJhZGlvZ3JvdXBcIiwgbGFiZWxQcmVmaXg6IFwiYXJpYS1yYWRpb2dyb3VwLWxhYmVsXCIsIGJhY2t1cFRleHQ6IHN0cmluZ0xhYmVsIH0pO1xuICAgIGNvbnN0IHsgdXNlR2VuZXJpY0xhYmVsSW5wdXRQcm9wcyB9ID0gdXNlR2VuZXJpY0xhYmVsSW5wdXQoKTtcbiAgICBjb25zdCB7IHVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUdlbmVyaWNMYWJlbExhYmVsKCk7XG4gICAgbGV0IGxhYmVsSnN4ID0gaChcImRpdlwiLCB7IC4uLnVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHMoe30pIH0pO1xuICAgIGxldCBncm91cEpzeCA9IChoKFwiZGl2XCIsIHsgLi4udXNlR2VuZXJpY0xhYmVsSW5wdXRQcm9wcyh1c2VSYWRpb0dyb3VwUHJvcHMoeyBcImFyaWEtbGFiZWxcIjogbGFiZWxQb3NpdGlvbiA9PT0gXCJoaWRkZW5cIiA/IHN0cmluZ0xhYmVsIDogdW5kZWZpbmVkIH0pKSB9LCBjaGlsZHJlbikpO1xuICAgIHJldHVybiAoaChSYWRpb0dyb3VwQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlUmFkaW8gfSxcbiAgICAgICAgbGFiZWxQb3NpdGlvbiA9PSBcInN0YXJ0XCIgJiYgbGFiZWxKc3gsXG4gICAgICAgIGdyb3VwSnN4LFxuICAgICAgICBsYWJlbFBvc2l0aW9uID09IFwiZW5kXCIgJiYgbGFiZWxKc3gpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBSYWRpbyh7IGRpc2FibGVkLCBsYWJlbCwgaW5kZXgsIHZhbHVlLCBsYWJlbFBvc2l0aW9uIH0pIHtcbiAgICBjb25zdCB1c2VBcmlhUmFkaW8gPSB1c2VDb250ZXh0KFJhZGlvR3JvdXBDb250ZXh0KTtcbiAgICBsYWJlbFBvc2l0aW9uID8/PSBcImVuZFwiO1xuICAgIGNvbnN0IHRleHQgPSBudWxsO1xuICAgIGNvbnN0IFthc3luY1N0YXRlLCBzZXRBc3luY1N0YXRlXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHsgdXNlUmFkaW9JbnB1dCwgdXNlUmFkaW9MYWJlbCB9ID0gdXNlQXJpYVJhZGlvKHsgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlLCBsYWJlbFBvc2l0aW9uOiBcInNlcGFyYXRlXCIsIGluZGV4LCB0ZXh0LCB2YWx1ZSwgc2V0QXN5bmNTdGF0ZSB9KTtcbiAgICBjb25zdCB7IHVzZVJhZGlvSW5wdXRQcm9wcyB9ID0gdXNlUmFkaW9JbnB1dCh7IHRhZzogXCJpbnB1dFwiIH0pO1xuICAgIGNvbnN0IHsgdXNlUmFkaW9MYWJlbFByb3BzIH0gPSB1c2VSYWRpb0xhYmVsKHsgdGFnOiBcImxhYmVsXCIgfSk7XG4gICAgY29uc3Qgc2hvd1NwaW5uZXIgPSB1c2VTcGlubmVyRGVsYXkoYXN5bmNTdGF0ZSA9PT0gXCJwZW5kaW5nXCIpO1xuICAgIGNvbnN0IGluSW5wdXRHcm91cCA9IHVzZUNvbnRleHQoSW5JbnB1dEdyb3VwQ29udGV4dCk7XG4gICAgbGFiZWwgPz89IHZhbHVlO1xuICAgIGxldCBzdHJpbmdMYWJlbCA9IGAke2xhYmVsfWA7XG4gICAgaWYgKGxhYmVsICE9IG51bGwgJiYgbGFiZWxQb3NpdGlvbiA9PT0gXCJoaWRkZW5cIiAmJiAhW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiXS5pbmNsdWRlcyh0eXBlb2YgbGFiZWwpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEhpZGRlbiBsYWJlbHMgcmVxdWlyZSBhIHN0cmluZy1iYXNlZCBsYWJlbCBmb3IgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlLmApO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSBoKE9wdGlvbmFsbHlJbnB1dEdyb3VwLCBudWxsLFxuICAgICAgICBoKFByb2dyZXNzQ2lyY3VsYXIsIHsgY2hpbGRyZW5Qb3NpdGlvbjogXCJhZnRlclwiLCBjb2xvckZpbGw6IFwiZm9yZWdyb3VuZC1vbmx5XCIsIG1vZGU6IGFzeW5jU3RhdGUsIGNvbG9yOiBcImluZm9cIiB9LFxuICAgICAgICAgICAgaChcImlucHV0XCIsIHsgLi4udXNlUmFkaW9JbnB1dFByb3BzKHsgdHlwZTogXCJyYWRpb1wiLCBjbGFzc05hbWU6IFwiZm9ybS1jaGVjay1pbnB1dFwiLCBcImFyaWEtbGFiZWxcIjogbGFiZWxQb3NpdGlvbiA9PT0gXCJoaWRkZW5cIiA/IHN0cmluZ0xhYmVsIDogdW5kZWZpbmVkIH0pIH0pKSk7XG4gICAgY29uc3QgbGFiZWxFbGVtZW50ID0gaChGcmFnbWVudCwgbnVsbCwgbGFiZWwgIT0gbnVsbCAmJiBoKE9wdGlvbmFsbHlJbnB1dEdyb3VwLCBudWxsLFxuICAgICAgICBoKFwibGFiZWxcIiwgeyAuLi51c2VSYWRpb0xhYmVsUHJvcHMoeyBjbGFzc05hbWU6IFwiZm9ybS1jaGVjay1sYWJlbFwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0pIH0sIGxhYmVsKSkpO1xuICAgIGNvbnN0IHJldCA9IChoKEZyYWdtZW50LCBudWxsLFxuICAgICAgICBsYWJlbFBvc2l0aW9uID09IFwic3RhcnRcIiAmJiBsYWJlbEVsZW1lbnQsXG4gICAgICAgIGlucHV0RWxlbWVudCxcbiAgICAgICAgbGFiZWxQb3NpdGlvbiA9PSBcImVuZFwiICYmIGxhYmVsRWxlbWVudCkpO1xuICAgIGlmICghaW5JbnB1dEdyb3VwKVxuICAgICAgICByZXR1cm4gaChcImRpdlwiLCB7IGNsYXNzOiBcImZvcm0tY2hlY2tcIiB9LCByZXQpO1xuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBPcHRpb25hbGx5SW5wdXRHcm91cCh7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCBpbklucHV0R3JvdXAgPSB1c2VDb250ZXh0KEluSW5wdXRHcm91cENvbnRleHQpO1xuICAgIGlmICghaW5JbnB1dEdyb3VwKVxuICAgICAgICByZXR1cm4gaChGcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xuICAgIHJldHVybiBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaW5wdXQtZ3JvdXAtdGV4dFwiIH0sIGNoaWxkcmVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0LXJhZGlvLmpzLm1hcCIsImltcG9ydCB7IEJvZHlQb3J0YWwgfSBmcm9tIFwiLi4vcG9ydGFsXCI7XG5pbXBvcnQgeyBjbG9uZUVsZW1lbnQsIGgsIEZyYWdtZW50IH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQXJpYVRvb2x0aXAgfSBmcm9tIFwicHJlYWN0LWFyaWEtd2lkZ2V0cy91c2UtdG9vbHRpcFwiO1xuaW1wb3J0IHsgdXNlRWxlbWVudFNpemUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtZWxlbWVudC1zaXplXCI7XG5pbXBvcnQgeyBmaXhQcm9wcywgdXNlUG9wcGVyQXBpLCB1c2VTaG91bGRVcGRhdGVQb3BwZXIgfSBmcm9tIFwiLi4vbWVudS9wb3BwZXItYXBpXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmV4cG9ydCBmdW5jdGlvbiBUb29sdGlwKHsgY2hpbGRyZW4sIHBvc2l0aW9uLCB0b29sdGlwLCBUcmFuc2l0aW9uLCBtb3VzZW92ZXJEZWxheSwgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgeyBnZXRJc09wZW4sIGlzT3BlbiwgdXNlVG9vbHRpcCwgdXNlVG9vbHRpcFRyaWdnZXIgfSA9IHVzZUFyaWFUb29sdGlwKHsgbW91c2VvdmVyRGVsYXkgfSk7XG4gICAgY29uc3QgeyB1c2VFbGVtZW50U2l6ZVByb3BzLCBlbGVtZW50U2l6ZSB9ID0gdXNlRWxlbWVudFNpemUoKTtcbiAgICBsZXQgY2xvbmVhYmxlO1xuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGNoaWxkcmVuID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBjaGlsZHJlbiA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgY2hpbGRyZW4gPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgY2xvbmVhYmxlID0gaChcInNwYW5cIiwgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICBjbG9uZWFibGUgPSBoKFwic3BhblwiLCBudWxsLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjbG9uZWFibGUgPSBjaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3QgeyB1c2VUb29sdGlwUHJvcHMgfSA9IHVzZVRvb2x0aXAoKTtcbiAgICBjb25zdCB7IHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMgfSA9IHVzZVRvb2x0aXBUcmlnZ2VyKCk7XG4gICAgY29uc3QgeyBzaG91bGRVcGRhdGUsIG9uSW50ZXJhY3Rpb24gfSA9IHVzZVNob3VsZFVwZGF0ZVBvcHBlcihpc09wZW4sIGVsZW1lbnRTaXplKTtcbiAgICBjb25zdCB7IGdldExvZ2ljYWxEaXJlY3Rpb24sIHVzZVBvcHBlckFycm93LCB1c2VQb3BwZXJQb3B1cCwgdXNlUG9wcGVyU291cmNlLCB1c2VkUGxhY2VtZW50IH0gPSB1c2VQb3BwZXJBcGkoeyB1cGRhdGluZzogc2hvdWxkVXBkYXRlLCBwb3NpdGlvbiwgfSk7XG4gICAgY29uc3QgeyB1c2VQb3BwZXJQb3B1cFByb3BzIH0gPSB1c2VQb3BwZXJQb3B1cCh7IG9wZW46IGlzT3BlbiB9KTtcbiAgICBjb25zdCB7IHVzZVBvcHBlckFycm93UHJvcHMgfSA9IHVzZVBvcHBlckFycm93KCk7XG4gICAgY29uc3QgeyB1c2VQb3BwZXJTb3VyY2VQcm9wcyB9ID0gdXNlUG9wcGVyU291cmNlKCk7XG4gICAgY29uc3QgbG9naWNhbERpcmVjdGlvbiA9IGdldExvZ2ljYWxEaXJlY3Rpb24oKTtcbiAgICBpZiAobG9naWNhbERpcmVjdGlvbiAmJiB1c2VkUGxhY2VtZW50KVxuICAgICAgICByZXN0ID0gZml4UHJvcHMobG9naWNhbERpcmVjdGlvbiwgXCJibG9jay1lbmRcIiwgdXNlZFBsYWNlbWVudCwgcmVzdCk7XG4gICAgLy8gVE9ETzogSXQncyByZXF1aXJlZCBmb3IgdGhpcyB0byBiZSBleGl0VmlzaWJpbGl0eT1cImhpZGRlblwiIGZvciB0cmFuc2Zvcm1zIHRvIHdvcms/XG4gICAgLy8gUHJvYmFibHkgYW4gaXNzdWUgaW4gdGhlIFRyYW5zaXRpb24gZWxlbWVudCBpdHNlbGYgYmVjYXVzZSBpdCdzIG5vdCBicm93c2VyLXNwZWNpZmljIGJ1dCBpdCdzIGEgbGl0dGxlIHdlaXJkXG4gICAgcmV0dXJuIGgoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGNsb25lRWxlbWVudChjbG9uZWFibGUsIHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHModXNlRWxlbWVudFNpemVQcm9wcyh1c2VQb3BwZXJTb3VyY2VQcm9wcyh7fSkpKSksXG4gICAgICAgIGgoQm9keVBvcnRhbCwgbnVsbCxcbiAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VQb3BwZXJQb3B1cFByb3BzKHsgY2xhc3M6IFwidG9vbHRpcC13cmFwcGVyXCIgfSkgfSxcbiAgICAgICAgICAgICAgICBoKFRyYW5zaXRpb24sIHsgLi4ucmVzdCwgb3BlbjogaXNPcGVuLCBvblRyYW5zaXRpb25VcGRhdGU6IG9uSW50ZXJhY3Rpb24sIGV4aXRWaXNpYmlsaXR5OiBcImhpZGRlblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VUb29sdGlwUHJvcHModXNlTWVyZ2VkUHJvcHMoKSh7IGNsYXNzOiBcInRvb2x0aXAgc2hvd1wiLCByb2xlOiBcInRvb2x0aXBcIiB9LCB7fSkpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlUG9wcGVyQXJyb3dQcm9wcyh7IGNsYXNzOiBcInRvb2x0aXAtYXJyb3dcIiB9KSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJ0b29sdGlwLWlubmVyXCIgfSwgdG9vbHRpcCkpKSkpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvb2x0aXAuanMubWFwIiwiaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSBcIi4uL2J1dHRvbi9idXR0b25cIjtcbmltcG9ydCB7IEJvZHlQb3J0YWwgfSBmcm9tIFwiLi4vcG9ydGFsXCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBGcmFnbWVudCwgaCwgY2xvbmVFbGVtZW50IH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1yYW5kb20taWRcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBTbGlkZUZhZGUgfSBmcm9tIFwicHJlYWN0LXRyYW5zaXRpb25cIjtcbmltcG9ydCB7IHVzZVRvYXN0cyB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzXCI7XG5jb25zdCBQdXNoVG9hc3RDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IERlZmF1bHRUb2FzdFRpbWVvdXQgPSBjcmVhdGVDb250ZXh0KDUwMDApO1xuZXhwb3J0IGZ1bmN0aW9uIFRvYXN0c1Byb3ZpZGVyKHsgY2hpbGRyZW4sIGRlZmF1bHRUaW1lb3V0IH0pIHtcbiAgICBjb25zdCBbcHVzaFRvYXN0LCBzZXRQdXNoVG9hc3RdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgcmV0dXJuIChoKEZyYWdtZW50LCBudWxsLFxuICAgICAgICBoKERlZmF1bHRUb2FzdFRpbWVvdXQuUHJvdmlkZXIsIHsgdmFsdWU6IGRlZmF1bHRUaW1lb3V0ID8/IDUwMDAgfSxcbiAgICAgICAgICAgIGgoVG9hc3RzUHJvdmlkZXJIZWxwZXIsIHsgc2V0UHVzaFRvYXN0OiBzZXRQdXNoVG9hc3QgfSksXG4gICAgICAgICAgICBwdXNoVG9hc3QgJiYgaChQdXNoVG9hc3RDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwdXNoVG9hc3QgfSwgY2hpbGRyZW4pKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVB1c2hUb2FzdCgpIHtcbiAgICBjb25zdCBwdXNoVG9hc3QgPSB1c2VDb250ZXh0KFB1c2hUb2FzdENvbnRleHQpO1xuICAgIHJldHVybiBwdXNoVG9hc3Q7XG59XG4vLyBFeHRyYWN0ZWQgdG8gYSBzZXBhcmF0ZSBjb21wb25lbnQgdG8gYXZvaWQgcmVyZW5kZXJpbmcgYWxsIG5vbi10b2FzdCBjaGlsZHJlblxuZnVuY3Rpb24gVG9hc3RzUHJvdmlkZXJIZWxwZXIoeyBzZXRQdXNoVG9hc3QgfSkge1xuICAgIGNvbnN0IFtjaGlsZHJlbiwgc2V0Q2hpbGRyZW5dID0gdXNlU3RhdGUoW10pO1xuICAgIGNvbnN0IHB1c2hUb2FzdCA9IHVzZUNhbGxiYWNrKCh0b2FzdCkgPT4geyBjb25zdCByYW5kb21LZXkgPSBnZW5lcmF0ZVJhbmRvbUlkKCk7IHNldENoaWxkcmVuKHByZXYgPT4gKFsuLi5wcmV2LCBjbG9uZUVsZW1lbnQodG9hc3QsIHsga2V5OiByYW5kb21LZXkgfSldKSk7IH0sIFtdKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBzZXRQdXNoVG9hc3QoXyA9PiBwdXNoVG9hc3QpOyB9LCBbcHVzaFRvYXN0XSk7XG4gICAgcmV0dXJuIChoKEJvZHlQb3J0YWwsIG51bGwsXG4gICAgICAgIGgoVG9hc3RzQ29udGFpbmVyQ2hpbGRyZW5Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjaGlsZHJlbiB9LFxuICAgICAgICAgICAgaChUb2FzdHNDb250YWluZXIsIG51bGwpKSkpO1xufVxuY29uc3QgVG9hc3RzQ29udGFpbmVyQ2hpbGRyZW5Db250ZXh0ID0gY3JlYXRlQ29udGV4dChbXSk7XG5jb25zdCBVc2VUb2FzdENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gVG9hc3RzQ29udGFpbmVyKHByb3BzKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB1c2VDb250ZXh0KFRvYXN0c0NvbnRhaW5lckNoaWxkcmVuQ29udGV4dCk7XG4gICAgY29uc3QgeyB1c2VUb2FzdCwgdXNlVG9hc3RDb250YWluZXJQcm9wcyB9ID0gdXNlVG9hc3RzKHByb3BzKTtcbiAgICByZXR1cm4gKGgoVXNlVG9hc3RDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1c2VUb2FzdCB9LFxuICAgICAgICBoKFwiZGl2XCIsIHsgLi4udXNlVG9hc3RDb250YWluZXJQcm9wcyhwcm9wcykgfSwgY2hpbGRyZW4pKSk7XG59XG5jb25zdCBUb2FzdERpc21pc3NDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydCBmdW5jdGlvbiBUb2FzdCh7IHRpbWVvdXQsIHBvbGl0ZW5lc3MsIGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCB1c2VUb2FzdCA9IHVzZUNvbnRleHQoVXNlVG9hc3RDb250ZXh0KTtcbiAgICBjb25zdCBkZWZhdWx0VGltZW91dCA9IHVzZUNvbnRleHQoRGVmYXVsdFRvYXN0VGltZW91dCk7XG4gICAgY29uc3QgeyB1c2VUb2FzdFByb3BzLCBkaXNtaXNzLCBzdGF0dXMgfSA9IHVzZVRvYXN0KHsgdGltZW91dDogdGltZW91dCA/PyBkZWZhdWx0VGltZW91dCwgcG9saXRlbmVzcyB9KTtcbiAgICByZXR1cm4gKGgoVG9hc3REaXNtaXNzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGlzbWlzcyB9LFxuICAgICAgICBoKFNsaWRlRmFkZSwgeyBvcGVuOiBzdGF0dXMgIT0gXCJkaXNtaXNzZWRcIiwgc2xpZGVUYXJnZXRJbmxpbmU6IDEsIGFuaW1hdGVPbk1vdW50OiB0cnVlLCBleGl0VmlzaWJpbGl0eTogXCJyZW1vdmVkXCIgfSxcbiAgICAgICAgICAgIGgoXCJkaXZcIiwgeyAuLi51c2VUb2FzdFByb3BzKHsgY2xhc3M6IFwidG9hc3Qgc2hvd1wiLCByb2xlOiBcImFsZXJ0XCIsIFwiYXJpYS1hdG9taWNcIjogXCJ0cnVlXCIgfSkgfSxcbiAgICAgICAgICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiZC1mbGV4XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzOiBcInRvYXN0LWJvZHlcIiB9LCBjaGlsZHJlbiksXG4gICAgICAgICAgICAgICAgICAgIGgoQnV0dG9uLCB7IGNsYXNzOiBcImJ0bi1jbG9zZSBtZS0yIG0tYXV0b1wiLCBcImFyaWEtbGFiZWxcIjogXCJDbG9zZVwiLCBvbkNsaWNrOiBkaXNtaXNzIH0pKSkpKSk7XG59XG4vKlxuZXhwb3J0IGZ1bmN0aW9uIFRvYXN0SGVhZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4gfSkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0b2FzdC1oZWFkZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZS1hdXRvXCI+XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8QnV0dG9uIGNsYXNzPVwiYnRuLWNsb3NlXCIgYXJpYS1sYWJlbD1cIkNsb3NlXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufSovXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2FzdC5qcy5tYXAiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi4vcHJvcHNcIjtcbmltcG9ydCB7IEluSW5wdXRHcm91cENvbnRleHQgfSBmcm9tIFwiLi9wcm9wc1wiO1xuLyoqXG4gKiBBbiBJbnB1dEdyb3VwLCB0aGF0IHB1dHMgYW4gSW5wdXQgYW5kIGl0cyBMYWJlbCB0b2dldGhlciwgdmlzdWFsbHksIGludG8gb25lIGNvbXBvbmVudC5cbiAqXG4gKiBBbGwgSW5wdXQtdHlwZSBjb21wb25lbnRzIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHdoZW4gdGhleSdyZSBpbiBhbiBJbnB1dEdyb3VwIGFuZCByZW5kZXIgZGlmZmVyZW50IGFjY29yZGluZ2x5LlxuICovXG5leHBvcnQgY29uc3QgSW5wdXRHcm91cCA9IGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIElucHV0R3JvdXAoeyBjaGlsZHJlbiwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyAuLi51c2VNZXJnZWRQcm9wcygpKHsgY2xhc3M6IFwiaW5wdXQtZ3JvdXBcIiwgcmVmIH0sIHJlc3QpIH0sXG4gICAgICAgIGgoSW5JbnB1dEdyb3VwQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdHJ1ZSB9LCBjaGlsZHJlbikpKTtcbn0pO1xuLyoqXG4gKiBOb3QgZ2VuZXJhbGx5IG5lZWRlZCwgc2luY2UgbW9zdCBpbnB1dCBjb21wb25lbnRzIGNvbWUgd2l0aCBsYWJlbHMgdGhhdCBkbyB0aGlzIGZvciB5b3UuXG4gKlxuICogVGhhdCBiZWluZyBzYWlkLCBpZiB5b3UganVzdCBuZWVkIGEgc3RhdGljIGJsb2NrIG9mIHRleHQgbm90IGhvb2tlZCB1cCB0byBhbnkgaW5wdXQgZWxlbWVudCwgdGhpcyBpcyB5b3VyIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IElucHV0R3JvdXBUZXh0ID0gZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gSW5wdXRHcm91cFRleHQoeyBjaGlsZHJlbiwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICByZXR1cm4gaChcInNwYW5cIiwgeyAuLi51c2VNZXJnZWRQcm9wcygpKHsgY2xhc3M6IFwiaW5wdXQtZ3JvdXAtdGV4dFwiLCByZWYgfSwgcmVzdCkgfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0LWdyb3VwLmpzLm1hcCIsImltcG9ydCB7IEZyYWdtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlSW5wdXRMYWJlbCB9IGZyb20gXCJwcmVhY3QtYXJpYS13aWRnZXRzL3VzZS1sYWJlbFwiO1xuaW1wb3J0IHsgdXNlQXN5bmNIYW5kbGVyLCB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgUHJvZ3Jlc3NDaXJjdWxhciB9IGZyb20gXCIuLi9wcm9ncmVzc1wiO1xuaW1wb3J0IHsgSW5JbnB1dEdyb3VwQ29udGV4dCwgdXNlSW5wdXRDYXB0dXJlcyB9IGZyb20gXCIuL3Byb3BzXCI7XG5pbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xuZXhwb3J0IGZ1bmN0aW9uIElucHV0KHsgdHlwZSwgdmFsdWUsIG9uSW5wdXQ6IG9uSW5wdXRBc3luYywgLi4ucHJvcHMgfSkge1xuICAgIGNvbnN0IHsgY2FwdHVyZSwgdW5jYXB0dXJlIH0gPSB1c2VJbnB1dENhcHR1cmVzKHR5cGUpO1xuICAgIGNvbnN0IHsgZ2V0U3luY0hhbmRsZXIsIGN1cnJlbnRDYXB0dXJlLCBwZW5kaW5nLCBoYXNFcnJvciwgc2V0dGxlQ291bnQsIC4uLmFzeW5jSW5mbyB9ID0gdXNlQXN5bmNIYW5kbGVyKCkoeyBjYXB0dXJlIH0pO1xuICAgIGNvbnN0IG9uSW5wdXQgPSBnZXRTeW5jSGFuZGxlcihvbklucHV0QXN5bmMpO1xuICAgIHJldHVybiAoaChQcm9ncmVzc0NpcmN1bGFyLCB7IG1vZGU6IGhhc0Vycm9yID8gXCJmYWlsZWRcIiA6IHBlbmRpbmcgPyBcInBlbmRpbmdcIiA6IHNldHRsZUNvdW50ID8gXCJzdWNjZWVkZWRcIiA6IG51bGwsIGNoaWxkcmVuUG9zaXRpb246IFwiYWZ0ZXJcIiwgY29sb3I6IFwiaW5mb1wiIH0sXG4gICAgICAgIGgoXCJpbnB1dFwiLCB7IC4uLnVzZU1lcmdlZFByb3BzKCkocHJvcHMsIHsgY2xhc3M6IGNsc3goYGZvcm0tY29udHJvbGAsIHBlbmRpbmcgJiYgXCJ3aXRoLWVuZC1pY29uXCIpLCB0eXBlLCB2YWx1ZTogY3VycmVudENhcHR1cmUgPz8gdW5jYXB0dXJlKHZhbHVlKSwgb25JbnB1dCB9KSB9KSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIExhYmVsbGVkSW5wdXQoeyBsYWJlbCwgbGFiZWxQb3NpdGlvbiwgLi4ucHJvcHMgfSkge1xuICAgIGxhYmVsUG9zaXRpb24gPz89IFwic3RhcnRcIjtcbiAgICBjb25zdCB7IGlucHV0SWQsIGxhYmVsSWQsIHVzZUlucHV0TGFiZWxJbnB1dCwgdXNlSW5wdXRMYWJlbExhYmVsIH0gPSB1c2VJbnB1dExhYmVsKHsgaW5wdXRQcmVmaXg6IFwiaW5wdXQtXCIsIGxhYmVsUHJlZml4OiBcImlucHV0LWxhYmVsLVwiIH0pO1xuICAgIGNvbnN0IHsgdXNlSW5wdXRMYWJlbElucHV0UHJvcHMgfSA9IHVzZUlucHV0TGFiZWxJbnB1dCgpO1xuICAgIGNvbnN0IHsgdXNlSW5wdXRMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUlucHV0TGFiZWxMYWJlbCh7IHRhZzogXCJsYWJlbFwiIH0pO1xuICAgIGNvbnN0IGlzSW5JbnB1dEdyb3VwID0gdXNlQ29udGV4dChJbklucHV0R3JvdXBDb250ZXh0KTtcbiAgICBjb25zdCBsYWJlbEpzeCA9IGgoXCJsYWJlbFwiLCB7IC4uLnVzZUlucHV0TGFiZWxMYWJlbFByb3BzKHsgY2xhc3M6IGlzSW5JbnB1dEdyb3VwID8gXCJpbnB1dC1ncm91cC10ZXh0XCIgOiBsYWJlbFBvc2l0aW9uICE9IFwiZmxvYXRpbmdcIiA/IFwiZm9ybS1sYWJlbFwiIDogXCJcIiB9KSB9LCBsYWJlbCk7XG4gICAgY29uc3QgaW5wdXRKc3ggPSBoKElucHV0LCB7IC4uLnVzZUlucHV0TGFiZWxJbnB1dFByb3BzKHByb3BzKSB9KTtcbiAgICBjb25zdCBpbnB1dFdpdGhMYWJlbCA9IChoKEZyYWdtZW50LCBudWxsLFxuICAgICAgICBsYWJlbFBvc2l0aW9uID09PSBcInN0YXJ0XCIgJiYgbGFiZWxKc3gsXG4gICAgICAgIGlucHV0SnN4LFxuICAgICAgICAobGFiZWxQb3NpdGlvbiA9PT0gXCJlbmRcIiB8fCBsYWJlbFBvc2l0aW9uID09IFwiZmxvYXRpbmdcIikgJiYgbGFiZWxKc3gpKTtcbiAgICBpZiAobGFiZWxQb3NpdGlvbiAhPT0gXCJmbG9hdGluZ1wiKVxuICAgICAgICByZXR1cm4gaW5wdXRXaXRoTGFiZWw7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gaChcImRpdlwiLCB7IGNsYXNzOiBcImZvcm0tZmxvYXRpbmdcIiB9LCBpbnB1dEpzeCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnB1dC10ZXh0LmpzLm1hcCIsbnVsbF0sIm5hbWVzIjpbIl9fYXNzaWduIiwiT2JqZWN0IiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsInYiLCJvcCIsIlR5cGVFcnJvciIsInBvcCIsInB1c2giLCJFTVBUWV9PQkoiLCJFTVBUWV9BUlIiLCJJU19OT05fRElNRU5TSU9OQUwiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50Q29tcG9uZW50IiwicHJldlJhZiIsImN1cnJlbnRIb29rIiwiYWZ0ZXJQYWludEVmZmVjdHMiLCJvbGRCZWZvcmVEaWZmIiwib3B0aW9ucyIsIm9sZEJlZm9yZVJlbmRlciIsIm9sZEFmdGVyRGlmZiIsImRpZmZlZCIsIm9sZENvbW1pdCIsIm9sZEJlZm9yZVVubW91bnQiLCJ1bm1vdW50IiwiZ2V0SG9va1N0YXRlIiwiaW5kZXgiLCJ0eXBlIiwiaG9va3MiLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInVzZVJlZHVjZXIiLCJpbnZva2VPclJldHVybiIsInJlZHVjZXIiLCJpbml0IiwiaG9va1N0YXRlIiwiX3JlZHVjZXIiLCJ1bmRlZmluZWQiLCJuZXh0VmFsdWUiLCJhY3Rpb24iLCJzZXRTdGF0ZSIsInVzZUVmZmVjdCIsImNhbGxiYWNrIiwiYXJncyIsInN0YXRlIiwiYXJnc0NoYW5nZWQiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCJpbml0aWFsVmFsdWUiLCJ1c2VNZW1vIiwiY3VycmVudCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJyZWYiLCJjcmVhdGVIYW5kbGUiLCJjb25jYXQiLCJmYWN0b3J5IiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwiY29udGV4dCIsInByb3ZpZGVyIiwic3ViIiwicHJvcHMiLCJmbHVzaEFmdGVyUGFpbnRFZmZlY3RzIiwiZm9yRWFjaCIsImNvbXBvbmVudCIsImludm9rZUNsZWFudXAiLCJpbnZva2VFZmZlY3QiLCJ2bm9kZSIsImMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyYWYiLCJjbGVhclRpbWVvdXQiLCJ0aW1lb3V0IiwiSEFTX1JBRiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsInByZXZpb3VzQ29tcG9uZW50IiwiY29tbWl0UXVldWUiLCJzb21lIiwiZmlsdGVyIiwiY2IiLCJob29rIiwiY29tcCIsIm9sZEFyZ3MiLCJuZXdBcmdzIiwiYXJnIiwidXNlU3RhdGVQIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwidG9WYWwiLCJtaXgiLCJrIiwic3RyIiwiQXJyYXkiLCJpc0FycmF5IiwidG1wIiwieCIsInVzZUxheW91dEVmZmVjdE5hdGl2ZSIsImNhbmRpZGF0ZVNlbGVjdG9ycyIsIm1hdGNoZXMiLCJFbGVtZW50IiwiaXNJbnB1dCIsIm5vZGUiLCJpc0hpZGRlbklucHV0IiwiaXNEZXRhaWxzV2l0aFN1bW1hcnkiLCJyIiwiY2hpbGQiLCJpc0hpZGRlbiIsImdldENvbXB1dGVkU3R5bGUiLCJpc0RpcmVjdFN1bW1hcnkiLCJub2RlVW5kZXJEZXRhaWxzIiwiZGlzcGxheUNoZWNrIiwid2lkdGgiLCJoZWlnaHQiLCJpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlIiwiZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IiLCJpc0ZvY3VzYWJsZSIsImdsb2JhbCIsInRoaXMiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIndpbmRvdyIsInNsaWNlIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmciLCJqb2luIiwiSW5lcnRSb290Iiwicm9vdEVsZW1lbnQiLCJpbmVydE1hbmFnZXIiLCJfaW5lcnRNYW5hZ2VyIiwiX3Jvb3RFbGVtZW50IiwiX21hbmFnZWROb2RlcyIsIlNldCIsImhhc0F0dHJpYnV0ZSIsIl9zYXZlZEFyaWFIaWRkZW4iLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSIsIl9vYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJfb25NdXRhdGlvbiIsImJpbmQiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJkZXN0cnVjdG9yIiwiZGlzY29ubmVjdCIsInJlbW92ZUF0dHJpYnV0ZSIsImluZXJ0Tm9kZSIsIl91bm1hbmFnZU5vZGUiLCJzdGFydE5vZGUiLCJfdGhpczIiLCJjb21wb3NlZFRyZWVXYWxrIiwiX3Zpc2l0Tm9kZSIsImFjdGl2ZUVsZW1lbnQiLCJkb2N1bWVudCIsImNvbnRhaW5zIiwicm9vdCIsIm5vZGVUeXBlIiwiTm9kZSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUiLCJwYXJlbnROb2RlIiwiYmx1ciIsImZvY3VzIiwiRUxFTUVOVF9OT0RFIiwiZWxlbWVudCIsIl9hZG9wdEluZXJ0Um9vdCIsIl9tYW5hZ2VOb2RlIiwicmVnaXN0ZXIiLCJhZGQiLCJkZXJlZ2lzdGVyIiwiX3VubWFuYWdlU3VidHJlZSIsIl90aGlzMyIsImluZXJ0U3Vicm9vdCIsImdldEluZXJ0Um9vdCIsInNldEluZXJ0IiwibWFuYWdlZE5vZGVzIiwic2F2ZWRJbmVydE5vZGUiLCJyZWNvcmRzIiwic2VsZiIsInJlY29yZCIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJhdHRyaWJ1dGVOYW1lIiwibWFuYWdlZE5vZGUiLCJnZXQiLCJzZXQiLCJhcmlhSGlkZGVuIiwiSW5lcnROb2RlIiwiaW5lcnRSb290IiwiX25vZGUiLCJfb3ZlcnJvZGVGb2N1c01ldGhvZCIsIl9pbmVydFJvb3RzIiwiX3NhdmVkVGFiSW5kZXgiLCJfZGVzdHJveWVkIiwiZW5zdXJlVW50YWJiYWJsZSIsIl90aHJvd0lmRGVzdHJveWVkIiwiZGVzdHJveWVkIiwiRXJyb3IiLCJ0YWJJbmRleCIsImhhc1NhdmVkVGFiSW5kZXgiLCJhZGRJbmVydFJvb3QiLCJyZW1vdmVJbmVydFJvb3QiLCJzaXplIiwiSW5lcnRNYW5hZ2VyIiwiX2RvY3VtZW50IiwiTWFwIiwiX3dhdGNoRm9ySW5lcnQiLCJhZGRJbmVydFN0eWxlIiwiaGVhZCIsImRvY3VtZW50RWxlbWVudCIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiX29uRG9jdW1lbnRMb2FkZWQiLCJpbmVydCIsImhhcyIsInBhcmVudCIsIl9pbmVydFJvb3QiLCJpbmVydEVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImluZXJ0RWxlbWVudCIsIl90aGlzIiwidW5zaGlmdCIsInNoYWRvd1Jvb3RBbmNlc3RvciIsInNoYWRvd1Jvb3QiLCJsb2NhbE5hbWUiLCJjb250ZW50IiwiZGlzdHJpYnV0ZWROb2RlcyIsImdldERpc3RyaWJ1dGVkTm9kZXMiLCJzbG90IiwiX2Rpc3RyaWJ1dGVkTm9kZXMiLCJhc3NpZ25lZE5vZGVzIiwiZmxhdHRlbiIsIl9pIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicXVlcnlTZWxlY3RvciIsInN0eWxlIiwidGV4dENvbnRlbnQiLCJhcHBlbmRDaGlsZCIsIm9iaiIsInNoYWxsb3dEaWZmZXJzIiwiYSIsImIiLCJmb3J3YXJkRWxlbWVudFJlZiIsImZvcndhcmRSZWYiLCJjbG9uZUVsZW1lbnQiLCJoIiwiY3JlYXRlQ29udGV4dCIsIm1lbW8iLCJjcmVhdGVQb3J0YWwiLCJ0b3AiLCJib3R0b20iLCJyaWdodCIsImxlZnQiLCJhdXRvIiwiYmFzZVBsYWNlbWVudHMiLCJzdGFydCIsImVuZCIsImNsaXBwaW5nUGFyZW50cyIsInZpZXdwb3J0IiwicG9wcGVyIiwicmVmZXJlbmNlIiwidmFyaWF0aW9uUGxhY2VtZW50cyIsInJlZHVjZSIsImFjYyIsInBsYWNlbWVudCIsInBsYWNlbWVudHMiLCJiZWZvcmVSZWFkIiwicmVhZCIsImFmdGVyUmVhZCIsImJlZm9yZU1haW4iLCJtYWluIiwiYWZ0ZXJNYWluIiwiYmVmb3JlV3JpdGUiLCJ3cml0ZSIsImFmdGVyV3JpdGUiLCJtb2RpZmllclBoYXNlcyIsImdldE5vZGVOYW1lIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImdldFdpbmRvdyIsInRvU3RyaW5nIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNFbGVtZW50IiwiT3duRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJhcHBseVN0eWxlcyIsIl9yZWYiLCJrZXlzIiwiZWxlbWVudHMiLCJuYW1lIiwic3R5bGVzIiwiZWZmZWN0IiwiX3JlZjIiLCJpbml0aWFsU3R5bGVzIiwicG9zaXRpb24iLCJzdHJhdGVneSIsIm1hcmdpbiIsImFycm93Iiwic3R5bGVQcm9wZXJ0aWVzIiwicHJvcGVydHkiLCJhdHRyaWJ1dGUiLCJlbmFibGVkIiwicGhhc2UiLCJmbiIsInJlcXVpcmVzIiwiZ2V0QmFzZVBsYWNlbWVudCIsInNwbGl0Iiwicm91bmQiLCJNYXRoIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaW5jbHVkZVNjYWxlIiwicmVjdCIsInNjYWxlWCIsInNjYWxlWSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiZ2V0TGF5b3V0UmVjdCIsImNsaWVudFJlY3QiLCJhYnMiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsImlzU2FtZU5vZGUiLCJob3N0IiwiaXNUYWJsZUVsZW1lbnQiLCJpbmRleE9mIiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiZ2V0UGFyZW50Tm9kZSIsImFzc2lnbmVkU2xvdCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJvZmZzZXRQYXJlbnQiLCJnZXRDb250YWluaW5nQmxvY2siLCJpc0ZpcmVmb3giLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiZWxlbWVudENzcyIsImN1cnJlbnROb2RlIiwiY3NzIiwidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiLCJjb250YWluIiwid2lsbENoYW5nZSIsImdldE9mZnNldFBhcmVudCIsImdldE1haW5BeGlzRnJvbVBsYWNlbWVudCIsIm1heCIsIm1pbiIsIndpdGhpbiIsIm1hdGhNYXgiLCJtYXRoTWluIiwiZ2V0RnJlc2hTaWRlT2JqZWN0IiwibWVyZ2VQYWRkaW5nT2JqZWN0IiwicGFkZGluZ09iamVjdCIsImV4cGFuZFRvSGFzaE1hcCIsImhhc2hNYXAiLCJ0b1BhZGRpbmdPYmplY3QiLCJwYWRkaW5nIiwicmVjdHMiLCJfc3RhdGUkbW9kaWZpZXJzRGF0YSQiLCJhcnJvd0VsZW1lbnQiLCJwb3BwZXJPZmZzZXRzIiwibW9kaWZpZXJzRGF0YSIsImJhc2VQbGFjZW1lbnQiLCJheGlzIiwiaXNWZXJ0aWNhbCIsImxlbiIsImFycm93UmVjdCIsIm1pblByb3AiLCJtYXhQcm9wIiwiZW5kRGlmZiIsInN0YXJ0RGlmZiIsImFycm93T2Zmc2V0UGFyZW50IiwiY2xpZW50U2l6ZSIsImNsaWVudEhlaWdodCIsImNsaWVudFdpZHRoIiwiY2VudGVyVG9SZWZlcmVuY2UiLCJjZW50ZXIiLCJvZmZzZXQiLCJheGlzUHJvcCIsImNlbnRlck9mZnNldCIsIl9vcHRpb25zJGVsZW1lbnQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjb25zb2xlIiwiZXJyb3IiLCJyZXF1aXJlc0lmRXhpc3RzIiwidW5zZXRTaWRlcyIsInJvdW5kT2Zmc2V0c0J5RFBSIiwid2luIiwiZHByIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIm1hcFRvU3R5bGVzIiwiX09iamVjdCRhc3NpZ24yIiwicG9wcGVyUmVjdCIsIm9mZnNldHMiLCJncHVBY2NlbGVyYXRpb24iLCJhZGFwdGl2ZSIsInJvdW5kT2Zmc2V0cyIsIl9yZWYzIiwiX3JlZjMkeCIsIl9yZWYzJHkiLCJoYXNYIiwiaGFzWSIsInNpZGVYIiwic2lkZVkiLCJoZWlnaHRQcm9wIiwid2lkdGhQcm9wIiwiY29tbW9uU3R5bGVzIiwiX09iamVjdCRhc3NpZ24iLCJjb21wdXRlU3R5bGVzIiwiX3JlZjQiLCJfb3B0aW9ucyRncHVBY2NlbGVyYXQiLCJfb3B0aW9ucyRhZGFwdGl2ZSIsIl9vcHRpb25zJHJvdW5kT2Zmc2V0cyIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsIndhcm4iLCJkYXRhIiwicGFzc2l2ZSIsIl9vcHRpb25zJHNjcm9sbCIsInNjcm9sbCIsIl9vcHRpb25zJHJlc2l6ZSIsInJlc2l6ZSIsInNjcm9sbFBhcmVudHMiLCJzY3JvbGxQYXJlbnQiLCJ1cGRhdGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFzaCIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwicmVwbGFjZSIsIm1hdGNoZWQiLCJnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCIsImdldFdpbmRvd1Njcm9sbCIsInNjcm9sbExlZnQiLCJwYWdlWE9mZnNldCIsInNjcm9sbFRvcCIsInBhZ2VZT2Zmc2V0IiwiZ2V0V2luZG93U2Nyb2xsQmFyWCIsImdldFZpZXdwb3J0UmVjdCIsImh0bWwiLCJ2aXN1YWxWaWV3cG9ydCIsInRlc3QiLCJnZXREb2N1bWVudFJlY3QiLCJfZWxlbWVudCRvd25lckRvY3VtZW4iLCJ3aW5TY3JvbGwiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImRpcmVjdGlvbiIsImlzU2Nyb2xsUGFyZW50IiwiX2dldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImdldFNjcm9sbFBhcmVudCIsImxpc3RTY3JvbGxQYXJlbnRzIiwibGlzdCIsImlzQm9keSIsInVwZGF0ZWRMaXN0IiwicmVjdFRvQ2xpZW50UmVjdCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsImdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlIiwiY2xpcHBpbmdQYXJlbnQiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJjYW5Fc2NhcGVDbGlwcGluZyIsImNsaXBwZXJFbGVtZW50IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJtYWluQ2xpcHBpbmdQYXJlbnRzIiwiZmlyc3RDbGlwcGluZ1BhcmVudCIsImNsaXBwaW5nUmVjdCIsImFjY1JlY3QiLCJnZXRWYXJpYXRpb24iLCJjb21wdXRlT2Zmc2V0cyIsInZhcmlhdGlvbiIsImNvbW1vblgiLCJjb21tb25ZIiwibWFpbkF4aXMiLCJkZXRlY3RPdmVyZmxvdyIsIl9vcHRpb25zIiwiX29wdGlvbnMkcGxhY2VtZW50IiwiX29wdGlvbnMkYm91bmRhcnkiLCJfb3B0aW9ucyRyb290Qm91bmRhcnkiLCJfb3B0aW9ucyRlbGVtZW50Q29udGUiLCJlbGVtZW50Q29udGV4dCIsIl9vcHRpb25zJGFsdEJvdW5kYXJ5IiwiYWx0Qm91bmRhcnkiLCJfb3B0aW9ucyRwYWRkaW5nIiwiYWx0Q29udGV4dCIsInJlZmVyZW5jZUVsZW1lbnQiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJjb250ZXh0RWxlbWVudCIsInJlZmVyZW5jZUNsaWVudFJlY3QiLCJwb3BwZXJDbGllbnRSZWN0IiwiZWxlbWVudENsaWVudFJlY3QiLCJvdmVyZmxvd09mZnNldHMiLCJvZmZzZXREYXRhIiwibXVsdGlwbHkiLCJjb21wdXRlQXV0b1BsYWNlbWVudCIsImZsaXBWYXJpYXRpb25zIiwiX29wdGlvbnMkYWxsb3dlZEF1dG9QIiwiYWxsb3dlZEF1dG9QbGFjZW1lbnRzIiwiYWxsUGxhY2VtZW50cyIsImFsbG93ZWRQbGFjZW1lbnRzIiwib3ZlcmZsb3dzIiwic29ydCIsImdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJmbGlwIiwiX3NraXAiLCJfb3B0aW9ucyRtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJfb3B0aW9ucyRhbHRBeGlzIiwiYWx0QXhpcyIsImNoZWNrQWx0QXhpcyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrUGxhY2VtZW50cyIsIl9vcHRpb25zJGZsaXBWYXJpYXRpbyIsInByZWZlcnJlZFBsYWNlbWVudCIsImlzQmFzZVBsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJfYmFzZVBsYWNlbWVudCIsImlzU3RhcnRWYXJpYXRpb24iLCJtYWluVmFyaWF0aW9uU2lkZSIsImFsdFZhcmlhdGlvblNpZGUiLCJjaGVja3MiLCJldmVyeSIsImNoZWNrIiwibnVtYmVyT2ZDaGVja3MiLCJfbG9vcCIsImZpdHRpbmdQbGFjZW1lbnQiLCJmaW5kIiwiX3JldCIsInJlc2V0IiwiZ2V0U2lkZU9mZnNldHMiLCJwcmV2ZW50ZWRPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic2lkZSIsImhpZGUiLCJwcmV2ZW50T3ZlcmZsb3ciLCJyZWZlcmVuY2VPdmVyZmxvdyIsInBvcHBlckFsdE92ZXJmbG93IiwicmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzIiwicG9wcGVyRXNjYXBlT2Zmc2V0cyIsImlzUmVmZXJlbmNlSGlkZGVuIiwiaGFzUG9wcGVyRXNjYXBlZCIsImRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZIiwiaW52ZXJ0RGlzdGFuY2UiLCJza2lkZGluZyIsImRpc3RhbmNlIiwiX29wdGlvbnMkb2Zmc2V0IiwiX2RhdGEkc3RhdGUkcGxhY2VtZW50IiwiZ2V0QWx0QXhpcyIsIl9vcHRpb25zJHRldGhlciIsInRldGhlciIsIl9vcHRpb25zJHRldGhlck9mZnNldCIsInRldGhlck9mZnNldCIsInRldGhlck9mZnNldFZhbHVlIiwibWFpblNpZGUiLCJhbHRTaWRlIiwiYWRkaXRpdmUiLCJtaW5MZW4iLCJtYXhMZW4iLCJhcnJvd1BhZGRpbmdPYmplY3QiLCJhcnJvd1BhZGRpbmdNaW4iLCJhcnJvd1BhZGRpbmdNYXgiLCJhcnJvd0xlbiIsIm1pbk9mZnNldCIsIm1heE9mZnNldCIsImNsaWVudE9mZnNldCIsIm9mZnNldE1vZGlmaWVyVmFsdWUiLCJ0ZXRoZXJNaW4iLCJ0ZXRoZXJNYXgiLCJwcmV2ZW50ZWRPZmZzZXQiLCJfbWFpblNpZGUiLCJfYWx0U2lkZSIsIl9vZmZzZXQiLCJfbWluIiwiX21heCIsIl9wcmV2ZW50ZWRPZmZzZXQiLCJnZXRIVE1MRWxlbWVudFNjcm9sbCIsImdldE5vZGVTY3JvbGwiLCJpc0VsZW1lbnRTY2FsZWQiLCJnZXRDb21wb3NpdGVSZWN0IiwiZWxlbWVudE9yVmlydHVhbEVsZW1lbnQiLCJpc0ZpeGVkIiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsIm9yZGVyIiwibW9kaWZpZXJzIiwibWFwIiwidmlzaXRlZCIsIm1vZGlmaWVyIiwiZGVwIiwiZGVwTW9kaWZpZXIiLCJvcmRlck1vZGlmaWVycyIsIm9yZGVyZWRNb2RpZmllcnMiLCJkZWJvdW5jZSIsInBlbmRpbmciLCJmb3JtYXQiLCJfbGVuIiwiX2tleSIsIklOVkFMSURfTU9ESUZJRVJfRVJST1IiLCJNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IiLCJWQUxJRF9QUk9QRVJUSUVTIiwidmFsaWRhdGVNb2RpZmllcnMiLCJTdHJpbmciLCJyZXF1aXJlbWVudCIsIm1vZCIsInVuaXF1ZUJ5IiwiYXJyIiwiaWRlbnRpZmllcnMiLCJpdGVtIiwiaWRlbnRpZmllciIsIm1lcmdlQnlOYW1lIiwibWVyZ2VkIiwiZXhpc3RpbmciLCJJTlZBTElEX0VMRU1FTlRfRVJST1IiLCJJTkZJTklURV9MT09QX0VSUk9SIiwiREVGQVVMVF9PUFRJT05TIiwiYXJlVmFsaWRFbGVtZW50cyIsInBvcHBlckdlbmVyYXRvciIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGVQb3BwZXIiLCJlZmZlY3RDbGVhbnVwRm5zIiwiaXNEZXN0cm95ZWQiLCJzZXRPcHRpb25zIiwiY2xlYW51cE1vZGlmaWVyRWZmZWN0cyIsIm0iLCJmbGlwTW9kaWZpZXIiLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpbkxlZnQiLCJwYXJzZUZsb2F0IiwicnVuTW9kaWZpZXJFZmZlY3RzIiwiZm9yY2VVcGRhdGUiLCJfc3RhdGUkZWxlbWVudHMiLCJfX2RlYnVnX2xvb3BzX18iLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUyIiwiZGVzdHJveSIsIm9uRmlyc3RVcGRhdGUiLCJfcmVmMyRvcHRpb25zIiwiY2xlYW51cEZuIiwibm9vcEZuIiwiZXZlbnRMaXN0ZW5lcnMiLCJPcHRpb25hbGx5SW5wdXRHcm91cCIsInJlbmRlciJdLCJtYXBwaW5ncyI6Ijs7O0lBQUE7SUFDQTtBQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQWtCTyxJQUFJQSxRQUFRLEdBQUcsWUFBVztJQUM3QkEsRUFBQUEsUUFBUSxHQUFHQyxNQUFNLENBQUNDLE1BQVAsSUFBaUIsU0FBU0YsUUFBVCxDQUFrQkcsQ0FBbEIsRUFBcUI7SUFDN0MsU0FBSyxJQUFJQyxDQUFKLEVBQU9DLENBQUMsR0FBRyxDQUFYLEVBQWNDLENBQUMsR0FBR0MsU0FBUyxDQUFDQyxNQUFqQyxFQUF5Q0gsQ0FBQyxHQUFHQyxDQUE3QyxFQUFnREQsQ0FBQyxFQUFqRCxFQUFxRDtJQUNqREQsTUFBQUEsQ0FBQyxHQUFHRyxTQUFTLENBQUNGLENBQUQsQ0FBYjs7SUFDQSxXQUFLLElBQUlJLENBQVQsSUFBY0wsQ0FBZDtJQUFpQixZ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
