@use "../variables.scss" as *;
@use "sass:color";
@use "sass:map";
@use "sass:string";

@forward "../variables.scss";

.btn-group {
  &.wrap {
    flex-wrap: wrap;
  }
}

// Make the buttons' text move up and down as the shadows imply
.btn {
  position: relative;
  touch-action: manipulation;
  position: relative;
  contain: content;
  height: calc(1.5em + (#{$btn-padding-y} * 2) + 2px);

  transition: $btn-transition, text-shadow 0.15s ease-in-out;

  &:not(.disabled):not(:disabled):not(.pending) {
    cursor: pointer;
  }
  &.pending {
    cursor: progress;
    pointer-events: auto;
  }

  & > .circular-progress-container {
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
  }

  // Checked buttons don't always have their text offset,
  // just when they're actively being pressed.
  /*.btn-check:checked + &,.btn-check:active + &,*/
  &:active,
  &.active {
    // Fix some default Bootstrap styles not applying all the box-shadows we want
    // Box shadows should always appear when active.
    @each $color, $value in $theme-colors {
      &.btn-#{$color} {
        @include box-shadow($btn-active-box-shadow, 0 0 0 0 rgba(mix($value, $value, 15%), 0.5));
      }
      &.btn-outline-#{$color} {
        @include box-shadow($btn-active-box-shadow, 0 0 0 0 rgba($value, 0.5));
      }
    }

    // Handle the "text depression" effect
    // It should happen when we're active *and* have focus.
    // (TODO: iOS is *really* reluctant to focus buttons.
    // The pending class acts the same as :focus for now to "fix" that,
    // at least for async buttons, but it would be nice to remove that
    // and just have :focus apply the relevant styles without also .pending,
    // which should normally apply the box shadow but NOT the text shadow.)
    &:focus,
    &:active:not(:focus):not(.toggle-button),
    &.active:not(:focus):not(.toggle-button),
    &.pending {
      padding-bottom: $btn-padding-y * 0.5;
      padding-top: $btn-padding-y + $btn-padding-y * 0.5;
      text-shadow: 0 0 0 $black;
    }

    &:focus, &.pending:focus {
      @each $color, $value in $theme-colors {
        &.btn-#{$color} {
          @include box-shadow($btn-active-box-shadow, 0 0 0 $btn-focus-width rgba(mix($value, $value, 15%), 0.5));
        }
        &.btn-outline-#{$color} {
          @include box-shadow($btn-active-box-shadow, 0 0 0 $btn-focus-width rgba($value, 0.5));
        }
      }
    }

    &:not(:focus).pending {
      @each $color, $value in $theme-colors {
        &.btn-#{$color} {
          @include box-shadow($btn-active-box-shadow, 0 0 0 0 rgba(mix($value, $value, 15%), 0.5));
        }
        &.btn-outline-#{$color} {
          @include box-shadow($btn-active-box-shadow, 0 0 0 0 rgba($value, 0.5));
        }
      }
    }

    // We don't offset the text when the button isn't actively focused
    // (it's a little distracting if it's in a row with other buttons)
    // so as a compromise, there's a small shadow to make it appear to float.
    //
    // Do this any time we're active *but not* focused.
    &:not(:focus):not(.pending).active,
    &:not(:focus):not(.pending).active.toggle-button {
      --text-shadow-color: rgb(0 0 0 / 35%);
      text-shadow: 0em 0.2em 0.25em var(--text-shadow-color), 0.05em 0.15em 0.25em var(--text-shadow-color),
        -0.05em 0.15em 0.25em var(--text-shadow-color);
    }
  }
}
.btn-lg {
  height: calc(1.5em + (#{$btn-padding-y-lg} * 2) + 2px);
  /*.btn-check:checked + &,.btn-check:active + &,*/
  &:active,
  &.active {
    &:not(.toggle-button),
    &:focus,
    &.pending {
      padding-bottom: $btn-padding-y-lg * 0.5;
      padding-top: $btn-padding-y-lg + $btn-padding-y-lg * 0.5;
      text-shadow: 0 0 0 $black;
    }
  }
  &:not(:focus):not(.active):not(.pending) {
    text-shadow: 0em 0.2em 0.25em $black, 0.05em 0.15em 0.25em $black, -0.05em 0.15em 0.25em $black;
  }
}
.btn-sm {
  height: calc(1.5em + (#{$btn-padding-y-sm} * 2) + 2px);
  /*.btn-check:checked + &,.btn-check:active + &,*/
  &:active,
  &.active {
    &:not(.toggle-button),
    &:focus,
    &.pending {
      padding-bottom: $btn-padding-y-sm * 0.5;
      padding-top: $btn-padding-y-sm + $btn-padding-y-sm * 0.5;
      text-shadow: 0 0 0 $black;
    }
  }
  &:not(:focus):not(.pending).active {
    text-shadow: 0em 0.2em 0.25em $black, 0.05em 0.15em 0.25em $black, -0.05em 0.15em 0.25em $black;
  }
}

@each $color, $value in $theme-colors {
  .btn-outline-#{$color} {
    // Make outline button styles a bit less flashy
    @include button-outline-variant(
      $color: $value,
      $color-hover: $value,
      $active-background: color.change($value, $alpha: 0.125),
      $active-border: color.change($value, $alpha: 0.25),
      $active-color: $value
    );

    // Make sure all colors are visible on the default body background
    // (Especially a problem for dark themes)
    $contrast-ratio: contrast-ratio($body-bg, $value);
    @if $contrast-ratio <= $min-contrast-ratio {
      // We need to know if we should shade (darken) or tint (lighten)
      // the color in order to increase its contrast against the background.
      $tinted-ratio: contrast-ratio($body-bg, tint-color($value, 50%));
      $shaded-ratio: contrast-ratio($body-bg, shade-color($value, 50%));

      // Not impossible that there's no valid contrast ratio for a given BG I guess.
      // Also just to be safe.
      $loop-prevention: 10;

      @while $loop-prevention >= 0 and $contrast-ratio <= $min-contrast-ratio {
        @if $tinted-ratio > $shaded-ratio {
          $value: tint-color($value, 10%);
        } @else {
          $value: shade-color($value, 10%);
        }
        $contrast-ratio: contrast-ratio($body-bg, $value);
        $loop-prevention: $loop-prevention - 1;
      }

      color: $value;

      // Adjust these colors because either
      // * They're over a translucent colored background
      // * Their opacity has been lowered
      &:hover,
      &:focus,
      &.active,
      &:active,
      &:disabled,
      &.disabled {
        @if $tinted-ratio > $shaded-ratio {
          color: tint-color($value, 20%);
        } @else {
          color: shade-color($value, 20%);
        }
      }
    }

    &:focus,
    &.active {
      border-color: color.change($value, $alpha: 0.4);
      background-color: color.change($value, $alpha: 0.25);
    }
  }
}

@media (prefers-reduced-motion) {
  .btn {
    .btn-check:checked + &,
    .btn-check:active + &,
    &:active,
    &.active {
      padding-bottom: $btn-padding-y;
      padding-top: $btn-padding-y;
      &.list-group-item {
        padding-bottom: $btn-padding-y;
        padding-top: $btn-padding-y;
      }
    }
  }
  .btn-lg {
    .btn-check:checked + &,
    .btn-check:active + &,
    &:active,
    &.active {
      padding-bottom: $btn-padding-y-lg;
      padding-top: $btn-padding-y-lg;
    }
  }
  .btn-sm {
    .btn-check:checked + &,
    .btn-check:active + &,
    &:active,
    &.active {
      padding-bottom: $btn-padding-y-sm;
      padding-top: $btn-padding-y-sm;
    }
  }
}
