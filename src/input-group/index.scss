@use "../variables.scss" as *;
@use "sass:color";
@use "sass:map";
@use "sass:string";

@forward "../variables.scss";

.input-group-text.form-switch {
  // Shrink the usual padding to make switches fill the same space as a checkbox or radio
  padding-left: 0.25em;
  padding-right: 0.25em;

  & > .form-check-input {
    margin-inline-start: 0;
  }
}

.form-check:not(.input-group-text).form-switch {
  padding-left: $form-check-padding-start;
}

.input-group-text {
  position: relative;
}

.form-check-input + .circular-progress-container {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
}

.input-group-text > .form-check-input {
  margin-top: 0;
}

.form-control.with-end-icon {
  padding-inline-end: 1.8em;
}

.form-control + .circular-progress-container {
  position: absolute;
  right: 0.5em;
  top: 0;
  bottom: 0;
  align-items: center;
  z-index: 5;
}

.form-check-label,
.form-check-input {
  touch-action: manipulation;

  // TODO: Would prefer to just cancel any selection events so that manual selection could still occur, but preventDefault on click/dblclick doesn't work.
  user-select: none;
}

.form-check-input.disabled.form-check-input:disabled,
.form-check-label.disabled {
  opacity: $form-check-label-disabled-opacity;

  &:not(.pending) {
    cursor: default;
  }
}

.form-check-input.pending,
.form-check-label.pending {
  cursor: progress;
}

.form-check-input:not(.disabled).form-check-input:not(:disabled),
.form-check-label:not(.disabled) {
  cursor: pointer;
}

:not(.input-group) > .form-control + .circular-progress-container {
  align-items: flex-end;
  inset-block-end: 0.6em;
}

.form-check {
  position: relative;

  &.form-switch > .form-check-input:not(:checked) + .circular-progress-container {
    inset-inline-start: -1.1em;
  }

  & > .circular-progress-container {
    justify-content: flex-start;
    inset-inline-start: -0.1em;
  }
}
